var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { S as SvelteComponent, i as init, s as safe_not_equal, l as create_slot, a as assign, p as element, q as space, v as attr, ai as null_to_empty, O as toggle_class, N as set_attributes, y as insert, z as append, A as listen, a9 as stop_propagation, B as prevent_default, P as action_destroyer, u as update_slot_base, n as get_all_dirty_from_scope, o as get_slot_changes, g as get_spread_update, t as transition_in, d as transition_out, C as detach, L as run_all, f as compute_rest_props, M as createEventDispatcher, k as exclude_internal_props, Q as bubble, H as group_outros, I as check_outros, U as empty, a7 as update_keyed_each, a8 as outro_and_destroy_block, c as create_component, m as mount_component, e as destroy_component, r as text, G as set_data, x as set_style, J as compute_slots, Y as onMount, V as binding_callbacks, j as component_subscribe, E as noop, K as subscribe$1, b as get_spread_object, ae as get_store_value, F as destroy_each, ah as tick, D as is_function, af as svg_element, a5 as select_option, h as getContext, a0 as onDestroy, ad as globals, ak as set_svg_attributes, a3 as to_number, a6 as select_value, a4 as add_render_callback, a1 as set_input_value, $ as construct_svelte_component, W as bind, X as add_flush_callback } from "./index.21aef151.js";
import { b0 as Params, h as register, f as TYPES, b1 as Types, e as createFieldStore, s as base, T as TXT, m as route, a8 as sanitize, y as types, a7 as ParsedPropertyName } from "./json-parser.f519fd70.js";
function clickOutside$1(node) {
  const handleClick = (event) => {
    if (!node.contains(event.target)) {
      node.dispatchEvent(new CustomEvent("outclick"));
    }
  };
  document.addEventListener("click", handleClick, true);
  return {
    destroy() {
      document.removeEventListener("click", handleClick, true);
    }
  };
}
function keypressEscape$1(node) {
  const handleKey = (event) => {
    if (event.key == "Escape") {
      node.dispatchEvent(new CustomEvent("escape"));
    }
  };
  document.body.addEventListener("keydown", handleKey, true);
  return {
    destroy() {
      document.body.removeEventListener("keydown", handleKey, true);
    }
  };
}
function tooltip$1(node, { placement } = { placement: "auto" }) {
  let tooltipInstance = new bootstrap.Tooltip(node, {
    placement,
    fallbackPlacements: []
  });
  return {
    destroy() {
      if (tooltipInstance) {
        tooltipInstance.dispose();
      }
    }
  };
}
var MenuItem_svelte_svelte_type_style_lang = "";
const get_bottom_slot_changes$4 = (dirty) => ({});
const get_bottom_slot_context$4 = (ctx) => ({});
const get_right_slot_changes = (dirty) => ({});
const get_right_slot_context = (ctx) => ({});
const get_icon_slot_changes$6 = (dirty) => ({});
const get_icon_slot_context$6 = (ctx) => ({});
function create_fragment$1l(ctx) {
  let li;
  let a;
  let div;
  let t0;
  let t1;
  let div_class_value;
  let t2;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = ctx[12].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[11], get_icon_slot_context$6);
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  const right_slot_template = ctx[12].right;
  const right_slot = create_slot(right_slot_template, ctx, ctx[11], get_right_slot_context);
  const bottom_slot_template = ctx[12].bottom;
  const bottom_slot = create_slot(bottom_slot_template, ctx, ctx[11], get_bottom_slot_context$4);
  let li_levels = [{ title: ctx[6] }, ctx[10]];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      div = element("div");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (right_slot)
        right_slot.c();
      t2 = space();
      if (bottom_slot)
        bottom_slot.c();
      attr(div, "class", div_class_value = null_to_empty(ctx[8]) + " svelte-t5jfpe");
      attr(a, "role", "button");
      attr(a, "class", "dropdown-item svelte-t5jfpe");
      attr(a, "href", ctx[2]);
      attr(a, "style", ctx[5]);
      attr(a, "target", ctx[3]);
      attr(a, "rel", ctx[4]);
      toggle_class(a, "active", ctx[0]);
      toggle_class(a, "focused", ctx[7] && !ctx[0]);
      toggle_class(a, "disabled", ctx[1]);
      set_attributes(li, li_data);
      toggle_class(li, "svelte-t5jfpe", true);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, div);
      if (icon_slot) {
        icon_slot.m(div, null);
      }
      append(div, t0);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t1);
      if (right_slot) {
        right_slot.m(div, null);
      }
      append(a, t2);
      if (bottom_slot) {
        bottom_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(a, "click", ctx[9]),
          listen(li, "hover", stop_propagation(prevent_default(ctx[13]))),
          action_destroyer(tooltip$1.call(null, li))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(icon_slot_template, ctx2[11], dirty, get_icon_slot_changes$6),
            get_icon_slot_context$6
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      if (right_slot) {
        if (right_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(right_slot_template, ctx2[11], dirty, get_right_slot_changes),
            get_right_slot_context
          );
        }
      }
      if (!current || dirty & 256 && div_class_value !== (div_class_value = null_to_empty(ctx2[8]) + " svelte-t5jfpe")) {
        attr(div, "class", div_class_value);
      }
      if (bottom_slot) {
        if (bottom_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            bottom_slot,
            bottom_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(bottom_slot_template, ctx2[11], dirty, get_bottom_slot_changes$4),
            get_bottom_slot_context$4
          );
        }
      }
      if (!current || dirty & 4) {
        attr(a, "href", ctx2[2]);
      }
      if (!current || dirty & 32) {
        attr(a, "style", ctx2[5]);
      }
      if (!current || dirty & 8) {
        attr(a, "target", ctx2[3]);
      }
      if (!current || dirty & 16) {
        attr(a, "rel", ctx2[4]);
      }
      if (!current || dirty & 1) {
        toggle_class(a, "active", ctx2[0]);
      }
      if (!current || dirty & 129) {
        toggle_class(a, "focused", ctx2[7] && !ctx2[0]);
      }
      if (!current || dirty & 2) {
        toggle_class(a, "disabled", ctx2[1]);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & 64) && { title: ctx2[6] },
        dirty & 1024 && ctx2[10]
      ]));
      toggle_class(li, "svelte-t5jfpe", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      transition_in(right_slot, local);
      transition_in(bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      transition_out(right_slot, local);
      transition_out(bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (right_slot)
        right_slot.d(detaching);
      if (bottom_slot)
        bottom_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1l($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "selected",
    "disabled",
    "href",
    "target",
    "rel",
    "menuItemStyle",
    "title",
    "focused",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { selected = false } = $$props;
  let { disabled = false } = $$props;
  let { href = "#" } = $$props;
  let { target = "" } = $$props;
  let { rel = "" } = $$props;
  let { menuItemStyle = "" } = $$props;
  let { title = "" } = $$props;
  let { focused = false } = $$props;
  let { class: clazz = "" } = $$props;
  const dispatch = createEventDispatcher();
  function onClick(e) {
    if (href === "#" || disabled) {
      e.preventDefault();
    }
    if (!disabled) {
      dispatch("click", e);
    }
  }
  function hover_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("target" in $$new_props)
      $$invalidate(3, target = $$new_props.target);
    if ("rel" in $$new_props)
      $$invalidate(4, rel = $$new_props.rel);
    if ("menuItemStyle" in $$new_props)
      $$invalidate(5, menuItemStyle = $$new_props.menuItemStyle);
    if ("title" in $$new_props)
      $$invalidate(6, title = $$new_props.title);
    if ("focused" in $$new_props)
      $$invalidate(7, focused = $$new_props.focused);
    if ("class" in $$new_props)
      $$invalidate(8, clazz = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  return [
    selected,
    disabled,
    href,
    target,
    rel,
    menuItemStyle,
    title,
    focused,
    clazz,
    onClick,
    $$restProps,
    $$scope,
    slots,
    hover_handler
  ];
}
class MenuItem$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {
      selected: 0,
      disabled: 1,
      href: 2,
      target: 3,
      rel: 4,
      menuItemStyle: 5,
      title: 6,
      focused: 7,
      class: 8
    });
  }
}
const get_bottom_slot_changes$3 = (dirty) => ({});
const get_bottom_slot_context$3 = (ctx) => ({});
function get_each_context$e(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
const get_item_right_slot_changes$1 = (dirty) => ({ item: dirty & 2 });
const get_item_right_slot_context$1 = (ctx) => ({ slot: "right", item: ctx[16] });
const get_item_icon_slot_changes$1 = (dirty) => ({ item: dirty & 2 });
const get_item_icon_slot_context$1 = (ctx) => ({ slot: "icon", item: ctx[16] });
const get_item_bottom_slot_changes$1 = (dirty) => ({ item: dirty & 2 });
const get_item_bottom_slot_context$1 = (ctx) => ({ slot: "bottom", item: ctx[16] });
const get_main_slot_changes = (dirty) => ({});
const get_main_slot_context = (ctx) => ({});
const get_top_slot_changes$4 = (dirty) => ({});
const get_top_slot_context$4 = (ctx) => ({});
function create_if_block$G(ctx) {
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let current;
  const top_slot_template = ctx[11].top;
  const top_slot = create_slot(top_slot_template, ctx, ctx[14], get_top_slot_context$4);
  const if_block_creators = [create_if_block_1$n, create_else_block$m];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[8])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const bottom_slot_template = ctx[11].bottom;
  const bottom_slot = create_slot(bottom_slot_template, ctx, ctx[14], get_bottom_slot_context$3);
  return {
    c() {
      if (top_slot)
        top_slot.c();
      t0 = space();
      if_block.c();
      t1 = space();
      if (bottom_slot)
        bottom_slot.c();
    },
    m(target, anchor) {
      if (top_slot) {
        top_slot.m(target, anchor);
      }
      insert(target, t0, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t1, anchor);
      if (bottom_slot) {
        bottom_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (top_slot) {
        if (top_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            top_slot,
            top_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(top_slot_template, ctx2[14], dirty, get_top_slot_changes$4),
            get_top_slot_context$4
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t1.parentNode, t1);
      }
      if (bottom_slot) {
        if (bottom_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            bottom_slot,
            bottom_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(bottom_slot_template, ctx2[14], dirty, get_bottom_slot_changes$3),
            get_bottom_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(top_slot, local);
      transition_in(if_block);
      transition_in(bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(top_slot, local);
      transition_out(if_block);
      transition_out(bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (top_slot)
        top_slot.d(detaching);
      if (detaching)
        detach(t0);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t1);
      if (bottom_slot)
        bottom_slot.d(detaching);
    }
  };
}
function create_else_block$m(ctx) {
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let if_block = ctx[2] && create_if_block_2$c(ctx);
  let each_value = ctx[1];
  const get_key = (ctx2) => ctx2[16].id;
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$e(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$e(key, child_ctx));
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 17027) {
        each_value = ctx2[1];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$e, each_1_anchor, get_each_context$e);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$n(ctx) {
  let current;
  const main_slot_template = ctx[11].main;
  const main_slot = create_slot(main_slot_template, ctx, ctx[14], get_main_slot_context);
  return {
    c() {
      if (main_slot)
        main_slot.c();
    },
    m(target, anchor) {
      if (main_slot) {
        main_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (main_slot) {
        if (main_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            main_slot,
            main_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(main_slot_template, ctx2[14], dirty, get_main_slot_changes),
            get_main_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(main_slot, local);
      current = true;
    },
    o(local) {
      transition_out(main_slot, local);
      current = false;
    },
    d(detaching) {
      if (main_slot)
        main_slot.d(detaching);
    }
  };
}
function create_if_block_2$c(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem$1({
    props: {
      selected: !ctx[0],
      $$slots: { default: [create_default_slot_1$l] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[12]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 1)
        menuitem_changes.selected = !ctx2[0];
      if (dirty & 16416) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_1$l(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[5]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$y(ctx) {
  let span;
  let t0_value = ctx[16].name + "";
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      attr(span, "class", "flex-1");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[16].name + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
    }
  };
}
function create_right_slot(ctx) {
  let current;
  const item_right_slot_template = ctx[11]["item-right"];
  const item_right_slot = create_slot(item_right_slot_template, ctx, ctx[14], get_item_right_slot_context$1);
  return {
    c() {
      if (item_right_slot)
        item_right_slot.c();
    },
    m(target, anchor) {
      if (item_right_slot) {
        item_right_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (item_right_slot) {
        if (item_right_slot.p && (!current || dirty & 16386)) {
          update_slot_base(
            item_right_slot,
            item_right_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(item_right_slot_template, ctx2[14], dirty, get_item_right_slot_changes$1),
            get_item_right_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(item_right_slot, local);
      current = true;
    },
    o(local) {
      transition_out(item_right_slot, local);
      current = false;
    },
    d(detaching) {
      if (item_right_slot)
        item_right_slot.d(detaching);
    }
  };
}
function create_icon_slot$4(ctx) {
  let current;
  const item_icon_slot_template = ctx[11]["item-icon"];
  const item_icon_slot = create_slot(item_icon_slot_template, ctx, ctx[14], get_item_icon_slot_context$1);
  return {
    c() {
      if (item_icon_slot)
        item_icon_slot.c();
    },
    m(target, anchor) {
      if (item_icon_slot) {
        item_icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (item_icon_slot) {
        if (item_icon_slot.p && (!current || dirty & 16386)) {
          update_slot_base(
            item_icon_slot,
            item_icon_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(item_icon_slot_template, ctx2[14], dirty, get_item_icon_slot_changes$1),
            get_item_icon_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(item_icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(item_icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (item_icon_slot)
        item_icon_slot.d(detaching);
    }
  };
}
function create_bottom_slot$3(ctx) {
  let current;
  const item_bottom_slot_template = ctx[11]["item-bottom"];
  const item_bottom_slot = create_slot(item_bottom_slot_template, ctx, ctx[14], get_item_bottom_slot_context$1);
  return {
    c() {
      if (item_bottom_slot)
        item_bottom_slot.c();
    },
    m(target, anchor) {
      if (item_bottom_slot) {
        item_bottom_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (item_bottom_slot) {
        if (item_bottom_slot.p && (!current || dirty & 16386)) {
          update_slot_base(
            item_bottom_slot,
            item_bottom_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(item_bottom_slot_template, ctx2[14], dirty, get_item_bottom_slot_changes$1),
            get_item_bottom_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(item_bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(item_bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (item_bottom_slot)
        item_bottom_slot.d(detaching);
    }
  };
}
function create_each_block$e(key_1, ctx) {
  let first;
  let menuitem;
  let current;
  function click_handler_1(...args) {
    return ctx[13](ctx[16], ...args);
  }
  menuitem = new MenuItem$1({
    props: {
      selected: ctx[0] == ctx[16].id,
      focused: ctx[7] == ctx[16].id,
      disabled: ctx[16].disabled,
      title: ctx[16].title,
      class: "d-flex align-items-center",
      $$slots: {
        bottom: [create_bottom_slot$3],
        icon: [create_icon_slot$4],
        right: [create_right_slot],
        default: [create_default_slot$y]
      },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", click_handler_1);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(menuitem.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 3)
        menuitem_changes.selected = ctx[0] == ctx[16].id;
      if (dirty & 130)
        menuitem_changes.focused = ctx[7] == ctx[16].id;
      if (dirty & 2)
        menuitem_changes.disabled = ctx[16].disabled;
      if (dirty & 2)
        menuitem_changes.title = ctx[16].title;
      if (dirty & 16386) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(menuitem, detaching);
    }
  };
}
function create_fragment$1k(ctx) {
  let ul;
  let ul_class_value;
  let current;
  let if_block = ctx[6] && create_if_block$G(ctx);
  return {
    c() {
      ul = element("ul");
      if (if_block)
        if_block.c();
      attr(ul, "class", ul_class_value = "dropdown-menu min-w-[200px] " + ctx[3]);
      attr(ul, "style", ctx[4]);
      toggle_class(ul, "show", ctx[6]);
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      if (if_block)
        if_block.m(ul, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$G(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(ul, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 8 && ul_class_value !== (ul_class_value = "dropdown-menu min-w-[200px] " + ctx2[3])) {
        attr(ul, "class", ul_class_value);
      }
      if (!current || dirty & 16) {
        attr(ul, "style", ctx2[4]);
      }
      if (!current || dirty & 72) {
        toggle_class(ul, "show", ctx2[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$1k($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id = null } = $$props;
  let { items = [] } = $$props;
  let { allowNull = true } = $$props;
  let { dropDownClass = "" } = $$props;
  let { dropDownStyle = "" } = $$props;
  let { toggle = true } = $$props;
  let { defaultActionLabel = "<None>" } = $$props;
  let { show = false } = $$props;
  let { focusedId = null } = $$props;
  const dispatch = createEventDispatcher();
  let { hasMainSlot = true } = $$props;
  function onSelect(_id) {
    dispatch("select", _id);
  }
  const click_handler2 = (e) => onSelect(null);
  const click_handler_1 = (item, e) => {
    if (item.disabled) {
      e.stopPropagation();
      return;
    }
    onSelect(item.id);
  };
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("items" in $$props2)
      $$invalidate(1, items = $$props2.items);
    if ("allowNull" in $$props2)
      $$invalidate(2, allowNull = $$props2.allowNull);
    if ("dropDownClass" in $$props2)
      $$invalidate(3, dropDownClass = $$props2.dropDownClass);
    if ("dropDownStyle" in $$props2)
      $$invalidate(4, dropDownStyle = $$props2.dropDownStyle);
    if ("toggle" in $$props2)
      $$invalidate(10, toggle = $$props2.toggle);
    if ("defaultActionLabel" in $$props2)
      $$invalidate(5, defaultActionLabel = $$props2.defaultActionLabel);
    if ("show" in $$props2)
      $$invalidate(6, show = $$props2.show);
    if ("focusedId" in $$props2)
      $$invalidate(7, focusedId = $$props2.focusedId);
    if ("hasMainSlot" in $$props2)
      $$invalidate(8, hasMainSlot = $$props2.hasMainSlot);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  return [
    id,
    items,
    allowNull,
    dropDownClass,
    dropDownStyle,
    defaultActionLabel,
    show,
    focusedId,
    hasMainSlot,
    onSelect,
    toggle,
    slots,
    click_handler2,
    click_handler_1,
    $$scope
  ];
}
class MenuList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {
      id: 0,
      items: 1,
      allowNull: 2,
      dropDownClass: 3,
      dropDownStyle: 4,
      toggle: 10,
      defaultActionLabel: 5,
      show: 6,
      focusedId: 7,
      hasMainSlot: 8
    });
  }
}
const get_top_slot_changes$3 = (dirty) => ({});
const get_top_slot_context$3 = (ctx) => ({ slot: "top", close: ctx[19] });
const get_default_slot_changes$1 = (dirty) => ({});
const get_default_slot_context$1 = (ctx) => ({ slot: "main" });
const get_item_right_slot_changes = (dirty) => ({ item: dirty[1] & 4 });
const get_item_right_slot_context = (ctx) => ({
  slot: "item-right",
  item: ctx[33]
});
const get_bottom_slot_changes$2 = (dirty) => ({});
const get_bottom_slot_context$2 = (ctx) => ({ slot: "bottom" });
const get_item_icon_slot_changes = (dirty) => ({ item: dirty[1] & 4 });
const get_item_icon_slot_context = (ctx) => ({
  slot: "item-icon",
  item: ctx[33]
});
const get_item_bottom_slot_changes = (dirty) => ({ item: dirty[1] & 4 });
const get_item_bottom_slot_context = (ctx) => ({
  slot: "item-bottom",
  item: ctx[33]
});
const get_action_slot_changes$1 = (dirty) => ({});
const get_action_slot_context$1 = (ctx) => ({
  onClick: ctx[18],
  slot: "main"
});
const get_label_slot_changes$7 = (dirty) => ({});
const get_label_slot_context$7 = (ctx) => ({ slot: "main" });
const get_label_pre_slot_changes$2 = (dirty) => ({});
const get_label_pre_slot_context$2 = (ctx) => ({ slot: "main" });
const get_icon_slot_changes$5 = (dirty) => ({});
const get_icon_slot_context$5 = (ctx) => ({ slot: "main" });
function create_else_block$l(ctx) {
  let current;
  const action_slot_template = ctx[25].action;
  const action_slot = create_slot(action_slot_template, ctx, ctx[27], get_action_slot_context$1);
  return {
    c() {
      if (action_slot)
        action_slot.c();
    },
    m(target, anchor) {
      if (action_slot) {
        action_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (action_slot) {
        if (action_slot.p && (!current || dirty[0] & 134217728)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(action_slot_template, ctx2[27], dirty, get_action_slot_changes$1),
            get_action_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(action_slot, local);
      current = true;
    },
    o(local) {
      transition_out(action_slot, local);
      current = false;
    },
    d(detaching) {
      if (action_slot)
        action_slot.d(detaching);
    }
  };
}
function create_if_block$F(ctx) {
  let a;
  let t0;
  let t1;
  let a_class_value;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = ctx[25].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[27], get_icon_slot_context$5);
  let if_block = ctx[13] && create_if_block_1$m(ctx);
  const label_slot_template = ctx[25].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[27], get_label_slot_context$7);
  const label_slot_or_fallback = label_slot || fallback_block$4(ctx);
  let a_levels = [
    { href: "#" },
    {
      class: a_class_value = "px-2 gap-2 " + ctx[5]
    },
    ctx[22]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  return {
    c() {
      a = element("a");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      set_attributes(a, a_data);
      toggle_class(a, "show", ctx[1]);
      toggle_class(a, "dropdown-toggle", ctx[12]);
      toggle_class(a, "border-danger", ctx[14]);
      toggle_class(a, "disabled", ctx[11]);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (icon_slot) {
        icon_slot.m(a, null);
      }
      append(a, t0);
      if (if_block)
        if_block.m(a, null);
      append(a, t1);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[18]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[0] & 134217728)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(icon_slot_template, ctx2[27], dirty, get_icon_slot_changes$5),
            get_icon_slot_context$5
          );
        }
      }
      if (ctx2[13]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 8192) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$m(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(a, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (label_slot) {
        if (label_slot.p && (!current || dirty[0] & 134217728)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(label_slot_template, ctx2[27], dirty, get_label_slot_changes$7),
            get_label_slot_context$7
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & 131072)) {
          label_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { href: "#" },
        (!current || dirty[0] & 32 && a_class_value !== (a_class_value = "px-2 gap-2 " + ctx2[5])) && { class: a_class_value },
        dirty[0] & 4194304 && ctx2[22]
      ]));
      toggle_class(a, "show", ctx2[1]);
      toggle_class(a, "dropdown-toggle", ctx2[12]);
      toggle_class(a, "border-danger", ctx2[14]);
      toggle_class(a, "disabled", ctx2[11]);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(if_block);
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(if_block);
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (icon_slot)
        icon_slot.d(detaching);
      if (if_block)
        if_block.d();
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$m(ctx) {
  let current;
  const label_pre_slot_template = ctx[25]["label-pre"];
  const label_pre_slot = create_slot(label_pre_slot_template, ctx, ctx[27], get_label_pre_slot_context$2);
  return {
    c() {
      if (label_pre_slot)
        label_pre_slot.c();
    },
    m(target, anchor) {
      if (label_pre_slot) {
        label_pre_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_pre_slot) {
        if (label_pre_slot.p && (!current || dirty[0] & 134217728)) {
          update_slot_base(
            label_pre_slot,
            label_pre_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(label_pre_slot_template, ctx2[27], dirty, get_label_pre_slot_changes$2),
            get_label_pre_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_pre_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_pre_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_pre_slot)
        label_pre_slot.d(detaching);
    }
  };
}
function fallback_block$4(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[17]);
      attr(span, "class", "flex-1");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 131072)
        set_data(t, ctx2[17]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_top_slot$3(ctx) {
  let current;
  const top_slot_template = ctx[25].top;
  const top_slot = create_slot(top_slot_template, ctx, ctx[27], get_top_slot_context$3);
  return {
    c() {
      if (top_slot)
        top_slot.c();
    },
    m(target, anchor) {
      if (top_slot) {
        top_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (top_slot) {
        if (top_slot.p && (!current || dirty[0] & 134217728)) {
          update_slot_base(
            top_slot,
            top_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(top_slot_template, ctx2[27], dirty, get_top_slot_changes$3),
            get_top_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(top_slot, local);
      current = true;
    },
    o(local) {
      transition_out(top_slot, local);
      current = false;
    },
    d(detaching) {
      if (top_slot)
        top_slot.d(detaching);
    }
  };
}
function create_main_slot(ctx) {
  let current;
  const default_slot_template = ctx[25].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[27], get_default_slot_context$1);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(default_slot_template, ctx2[27], dirty, get_default_slot_changes$1),
            get_default_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_item_right_slot(ctx) {
  let current;
  const item_right_slot_template = ctx[25]["item-right"];
  const item_right_slot = create_slot(item_right_slot_template, ctx, ctx[27], get_item_right_slot_context);
  return {
    c() {
      if (item_right_slot)
        item_right_slot.c();
    },
    m(target, anchor) {
      if (item_right_slot) {
        item_right_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (item_right_slot) {
        if (item_right_slot.p && (!current || dirty[0] & 134217728 | dirty[1] & 4)) {
          update_slot_base(
            item_right_slot,
            item_right_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(item_right_slot_template, ctx2[27], dirty, get_item_right_slot_changes),
            get_item_right_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(item_right_slot, local);
      current = true;
    },
    o(local) {
      transition_out(item_right_slot, local);
      current = false;
    },
    d(detaching) {
      if (item_right_slot)
        item_right_slot.d(detaching);
    }
  };
}
function create_bottom_slot$2(ctx) {
  let current;
  const bottom_slot_template = ctx[25].bottom;
  const bottom_slot = create_slot(bottom_slot_template, ctx, ctx[27], get_bottom_slot_context$2);
  return {
    c() {
      if (bottom_slot)
        bottom_slot.c();
    },
    m(target, anchor) {
      if (bottom_slot) {
        bottom_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (bottom_slot) {
        if (bottom_slot.p && (!current || dirty[0] & 134217728)) {
          update_slot_base(
            bottom_slot,
            bottom_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(bottom_slot_template, ctx2[27], dirty, get_bottom_slot_changes$2),
            get_bottom_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (bottom_slot)
        bottom_slot.d(detaching);
    }
  };
}
function create_item_icon_slot(ctx) {
  let current;
  const item_icon_slot_template = ctx[25]["item-icon"];
  const item_icon_slot = create_slot(item_icon_slot_template, ctx, ctx[27], get_item_icon_slot_context);
  return {
    c() {
      if (item_icon_slot)
        item_icon_slot.c();
    },
    m(target, anchor) {
      if (item_icon_slot) {
        item_icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (item_icon_slot) {
        if (item_icon_slot.p && (!current || dirty[0] & 134217728 | dirty[1] & 4)) {
          update_slot_base(
            item_icon_slot,
            item_icon_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(item_icon_slot_template, ctx2[27], dirty, get_item_icon_slot_changes),
            get_item_icon_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(item_icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(item_icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (item_icon_slot)
        item_icon_slot.d(detaching);
    }
  };
}
function create_item_bottom_slot(ctx) {
  let current;
  const item_bottom_slot_template = ctx[25]["item-bottom"];
  const item_bottom_slot = create_slot(item_bottom_slot_template, ctx, ctx[27], get_item_bottom_slot_context);
  return {
    c() {
      if (item_bottom_slot)
        item_bottom_slot.c();
    },
    m(target, anchor) {
      if (item_bottom_slot) {
        item_bottom_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (item_bottom_slot) {
        if (item_bottom_slot.p && (!current || dirty[0] & 134217728 | dirty[1] & 4)) {
          update_slot_base(
            item_bottom_slot,
            item_bottom_slot_template,
            ctx2,
            ctx2[27],
            !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(item_bottom_slot_template, ctx2[27], dirty, get_item_bottom_slot_changes),
            get_item_bottom_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(item_bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(item_bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (item_bottom_slot)
        item_bottom_slot.d(detaching);
    }
  };
}
function create_fragment$1j(ctx) {
  let div1;
  let current_block_type_index;
  let if_block;
  let t0;
  let div0;
  let t1;
  let menulist;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$F, create_else_block$l];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[21].action)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  menulist = new MenuList({
    props: {
      id: ctx[0],
      items: ctx[2],
      allowNull: ctx[3],
      dropDownClass: ctx[6],
      dropDownStyle: ctx[7],
      toggle: ctx[8],
      defaultActionLabel: ctx[10],
      show: ctx[1],
      hasMainSlot: !!ctx[21].default,
      $$slots: {
        "item-bottom": [
          create_item_bottom_slot,
          ({ item }) => ({ 33: item }),
          ({ item }) => [0, item ? 4 : 0]
        ],
        "item-icon": [
          create_item_icon_slot,
          ({ item }) => ({ 33: item }),
          ({ item }) => [0, item ? 4 : 0]
        ],
        bottom: [create_bottom_slot$2],
        "item-right": [
          create_item_right_slot,
          ({ item }) => ({ 33: item }),
          ({ item }) => [0, item ? 4 : 0]
        ],
        main: [create_main_slot],
        top: [create_top_slot$3]
      },
      $$scope: { ctx }
    }
  });
  menulist.$on("select", ctx[20]);
  menulist.$on("close", ctx[19]);
  return {
    c() {
      div1 = element("div");
      if_block.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      create_component(menulist.$$.fragment);
      set_style(div0, "position", "absolute");
      set_style(div0, "inset", "0");
      set_style(div0, "pointer-events", "none");
      attr(div1, "class", div1_class_value = "dropdown " + ctx[15]);
      attr(div1, "style", ctx[4]);
      attr(div1, "title", ctx[9]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if_blocks[current_block_type_index].m(div1, null);
      append(div1, t0);
      append(div1, div0);
      ctx[26](div0);
      append(div1, t1);
      mount_component(menulist, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(clickOutside$1.call(null, div1)),
          action_destroyer(keypressEscape$1.call(null, div1)),
          listen(div1, "outclick", ctx[19]),
          listen(div1, "escape", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, t0);
      }
      const menulist_changes = {};
      if (dirty[0] & 1)
        menulist_changes.id = ctx2[0];
      if (dirty[0] & 4)
        menulist_changes.items = ctx2[2];
      if (dirty[0] & 8)
        menulist_changes.allowNull = ctx2[3];
      if (dirty[0] & 64)
        menulist_changes.dropDownClass = ctx2[6];
      if (dirty[0] & 128)
        menulist_changes.dropDownStyle = ctx2[7];
      if (dirty[0] & 256)
        menulist_changes.toggle = ctx2[8];
      if (dirty[0] & 1024)
        menulist_changes.defaultActionLabel = ctx2[10];
      if (dirty[0] & 2)
        menulist_changes.show = ctx2[1];
      if (dirty[0] & 2097152)
        menulist_changes.hasMainSlot = !!ctx2[21].default;
      if (dirty[0] & 134217728 | dirty[1] & 4) {
        menulist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menulist.$set(menulist_changes);
      if (!current || dirty[0] & 32768 && div1_class_value !== (div1_class_value = "dropdown " + ctx2[15])) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & 16) {
        attr(div1, "style", ctx2[4]);
      }
      if (!current || dirty[0] & 512) {
        attr(div1, "title", ctx2[9]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(menulist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(menulist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      ctx[26](null);
      destroy_component(menulist);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1j($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "id",
    "items",
    "allowNull",
    "style",
    "actionClass",
    "dropDownClass",
    "dropDownStyle",
    "toggle",
    "title",
    "defaultActionLabel",
    "disabled",
    "showToggleButton",
    "show",
    "placement",
    "showLabelPrefix",
    "strategy",
    "showError",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { id = null } = $$props;
  let { items = [] } = $$props;
  let { allowNull = true } = $$props;
  let { style = "" } = $$props;
  let { actionClass = "" } = $$props;
  let { dropDownClass = "" } = $$props;
  let { dropDownStyle = "" } = $$props;
  let { toggle = true } = $$props;
  let { title = "" } = $$props;
  let { defaultActionLabel = "<None>" } = $$props;
  let { disabled = false } = $$props;
  let { showToggleButton = true } = $$props;
  let { show = false } = $$props;
  let { placement = "bottom-start" } = $$props;
  let { showLabelPrefix = true } = $$props;
  let { strategy = "absolute" } = $$props;
  let { showError = false } = $$props;
  let { class: clazz = "" } = $$props;
  let actionEl;
  let dd;
  let dispatch = createEventDispatcher();
  let selectedItem;
  selectedItem = getSelectedItem();
  let label;
  onMount(() => {
    dd = new bootstrap.Dropdown(
      actionEl,
      {
        popperConfig: (defaultBsConfig) => {
          if (placement) {
            return { ...defaultBsConfig, placement, strategy };
          }
          return defaultBsConfig;
        }
      }
    );
    return () => {
      dd.dispose();
    };
  });
  function getLabel() {
    return !id ? defaultActionLabel : (selectedItem == null ? void 0 : selectedItem.name) || "<NA>";
  }
  function getSelectedItem() {
    let item = items == null ? void 0 : items.find((item2) => item2.id === id);
    if (item) {
      return item;
    }
    if (id && (selectedItem == null ? void 0 : selectedItem.id) == id) {
      return selectedItem;
    }
  }
  function onClick() {
    if (disabled) {
      $$invalidate(1, show = false);
      dd.hide();
      return;
    }
    $$invalidate(1, show = !show);
    if (show) {
      dd.show();
    } else {
      dd.hide();
    }
    dispatch(show ? "open" : "close");
  }
  function close2() {
    if (!show)
      return;
    dd.hide();
    $$invalidate(1, show = false);
    dispatch("close");
  }
  function onSelect(e) {
    $$invalidate(0, id = e.detail);
    dispatch("select", id);
    close2();
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      actionEl = $$value;
      $$invalidate(16, actionEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("items" in $$new_props)
      $$invalidate(2, items = $$new_props.items);
    if ("allowNull" in $$new_props)
      $$invalidate(3, allowNull = $$new_props.allowNull);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("actionClass" in $$new_props)
      $$invalidate(5, actionClass = $$new_props.actionClass);
    if ("dropDownClass" in $$new_props)
      $$invalidate(6, dropDownClass = $$new_props.dropDownClass);
    if ("dropDownStyle" in $$new_props)
      $$invalidate(7, dropDownStyle = $$new_props.dropDownStyle);
    if ("toggle" in $$new_props)
      $$invalidate(8, toggle = $$new_props.toggle);
    if ("title" in $$new_props)
      $$invalidate(9, title = $$new_props.title);
    if ("defaultActionLabel" in $$new_props)
      $$invalidate(10, defaultActionLabel = $$new_props.defaultActionLabel);
    if ("disabled" in $$new_props)
      $$invalidate(11, disabled = $$new_props.disabled);
    if ("showToggleButton" in $$new_props)
      $$invalidate(12, showToggleButton = $$new_props.showToggleButton);
    if ("show" in $$new_props)
      $$invalidate(1, show = $$new_props.show);
    if ("placement" in $$new_props)
      $$invalidate(23, placement = $$new_props.placement);
    if ("showLabelPrefix" in $$new_props)
      $$invalidate(13, showLabelPrefix = $$new_props.showLabelPrefix);
    if ("strategy" in $$new_props)
      $$invalidate(24, strategy = $$new_props.strategy);
    if ("showError" in $$new_props)
      $$invalidate(14, showError = $$new_props.showError);
    if ("class" in $$new_props)
      $$invalidate(15, clazz = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 5) {
      selectedItem = getSelectedItem();
    }
    if ($$self.$$.dirty[0] & 5) {
      $$invalidate(17, label = getLabel());
    }
  };
  return [
    id,
    show,
    items,
    allowNull,
    style,
    actionClass,
    dropDownClass,
    dropDownStyle,
    toggle,
    title,
    defaultActionLabel,
    disabled,
    showToggleButton,
    showLabelPrefix,
    showError,
    clazz,
    actionEl,
    label,
    onClick,
    close2,
    onSelect,
    $$slots,
    $$restProps,
    placement,
    strategy,
    slots,
    div0_binding,
    $$scope
  ];
}
class Menu$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$1j,
      create_fragment$1j,
      safe_not_equal,
      {
        id: 0,
        items: 2,
        allowNull: 3,
        style: 4,
        actionClass: 5,
        dropDownClass: 6,
        dropDownStyle: 7,
        toggle: 8,
        title: 9,
        defaultActionLabel: 10,
        disabled: 11,
        showToggleButton: 12,
        show: 1,
        placement: 23,
        showLabelPrefix: 13,
        strategy: 24,
        showError: 14,
        class: 15
      },
      null,
      [-1, -1]
    );
  }
}
const get_error_slot_changes$2 = (dirty) => ({
  showError: dirty & 64,
  inputClasses: dirty & 4,
  inputProps: dirty & 8
});
const get_error_slot_context$2 = (ctx) => ({
  action: ctx[11],
  showError: ctx[6],
  inputClasses: "x-input-edit-padding " + ctx[8] + " " + ctx[2],
  inputProps: ctx[3]
});
const get_default_slot_changes = (dirty) => ({
  showError: dirty & 64,
  inputClasses: dirty & 4,
  inputProps: dirty & 8
});
const get_default_slot_context = (ctx) => ({
  action: ctx[11],
  showError: ctx[6],
  inputClasses: "x-input-edit-padding " + ctx[8] + " " + ctx[2],
  inputProps: ctx[3]
});
function fallback_block_1$2(ctx) {
  let input;
  let input_class_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: ctx[1] },
    { style: "z-index: 0;" },
    {
      class: input_class_value = "x-input-edit-padding " + ctx[8] + " " + ctx[2]
    },
    ctx[3]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  return {
    c() {
      input = element("input");
      set_attributes(input, input_data);
      toggle_class(input, "is-invalid", ctx[6]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus)
        input.focus();
      ctx[20](input);
      if (!mounted) {
        dispose = [
          listen(input, "beforeinput", ctx[15]),
          listen(input, "blur", ctx[16]),
          listen(input, "change", ctx[17]),
          listen(input, "input", ctx[18]),
          listen(input, "focus", ctx[19]),
          action_destroyer(ctx[11].call(null, input))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & 2 && { type: ctx2[1] },
        { style: "z-index: 0;" },
        dirty & 4 && input_class_value !== (input_class_value = "x-input-edit-padding " + ctx2[8] + " " + ctx2[2]) && { class: input_class_value },
        dirty & 8 && ctx2[3]
      ]));
      toggle_class(input, "is-invalid", ctx2[6]);
    },
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$E(ctx) {
  let current;
  const error_slot_template = ctx[14].error;
  const error_slot = create_slot(error_slot_template, ctx, ctx[13], get_error_slot_context$2);
  const error_slot_or_fallback = error_slot || fallback_block$3(ctx);
  return {
    c() {
      if (error_slot_or_fallback)
        error_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (error_slot_or_fallback) {
        error_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (error_slot) {
        if (error_slot.p && (!current || dirty & 8268)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(error_slot_template, ctx2[13], dirty, get_error_slot_changes$2),
            get_error_slot_context$2
          );
        }
      } else {
        if (error_slot_or_fallback && error_slot_or_fallback.p && (!current || dirty & 128)) {
          error_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(error_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(error_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (error_slot_or_fallback)
        error_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block$3(ctx) {
  let div;
  let t_value = ctx[7].message + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "invalid-tooltip");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 128 && t_value !== (t_value = ctx2[7].message + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1i(ctx) {
  let div;
  let t;
  let div_class_value;
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], get_default_slot_context);
  const default_slot_or_fallback = default_slot || fallback_block_1$2(ctx);
  let if_block = ctx[6] && create_if_block$E(ctx);
  return {
    c() {
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", div_class_value = ctx[4] + " position-relative border-0 has-validation");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8268)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, get_default_slot_changes),
            get_default_slot_context
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 110)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$E(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 16 && div_class_value !== (div_class_value = ctx2[4] + " position-relative border-0 has-validation")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$1i($$self, $$props, $$invalidate) {
  let $field, $$unsubscribe_field = noop, $$subscribe_field = () => ($$unsubscribe_field(), $$unsubscribe_field = subscribe$1(field, ($$value) => $$invalidate(21, $field = $$value)), field);
  let $showError;
  let $error;
  $$self.$$.on_destroy.push(() => $$unsubscribe_field());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { field } = $$props;
  $$subscribe_field();
  let { formatOptions = {} } = $$props;
  let { inputType = "text" } = $$props;
  let { inputClasses = "" } = $$props;
  let { inputProps = {} } = $$props;
  const defaultInputClass = field.def.type === "boolean" ? "form-check-input" : "form-control";
  const { format, deformat } = field.typeDef;
  const { error, showError } = field;
  component_subscribe($$self, error, (value) => $$invalidate(7, $error = value));
  component_subscribe($$self, showError, (value) => $$invalidate(6, $showError = value));
  let { class: clazz = "" } = $$props;
  let inputEl;
  function set(formattedValue, options = formatOptions) {
    try {
      const parsedValue = deformat(formattedValue, options);
      field.set(parsedValue);
    } catch (e) {
      field.error.set({ message: e.message });
    }
  }
  function get() {
    return format($field, formatOptions);
  }
  function action(el) {
    let inputChanged = false;
    const _unsubscribe = field.subscribe((_2) => {
      if (inputChanged) {
        inputChanged = false;
        return;
      }
      el.value = get();
    });
    function onInput(e) {
      inputChanged = true;
      if (inputType === "checkbox") {
        set(e.target.checked);
      } else {
        set(e.target.value);
      }
    }
    function onTouch(e) {
      field.setTouched(true);
    }
    el.addEventListener("input", onInput);
    el.addEventListener("beforeinput", onTouch, { once: true });
    el.addEventListener("focusout", onTouch, { once: true });
    return {
      destroy: () => {
        el.removeEventListener("input", onInput);
        el.removeEventListener("beforeinput", onTouch);
        el.removeEventListener("focusout", onTouch);
        _unsubscribe();
      }
    };
  }
  function beforeinput_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(5, inputEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$subscribe_field($$invalidate(0, field = $$props2.field));
    if ("formatOptions" in $$props2)
      $$invalidate(12, formatOptions = $$props2.formatOptions);
    if ("inputType" in $$props2)
      $$invalidate(1, inputType = $$props2.inputType);
    if ("inputClasses" in $$props2)
      $$invalidate(2, inputClasses = $$props2.inputClasses);
    if ("inputProps" in $$props2)
      $$invalidate(3, inputProps = $$props2.inputProps);
    if ("class" in $$props2)
      $$invalidate(4, clazz = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      if (inputEl) {
        $$invalidate(0, field.el = inputEl, field);
      }
    }
  };
  return [
    field,
    inputType,
    inputClasses,
    inputProps,
    clazz,
    inputEl,
    $showError,
    $error,
    defaultInputClass,
    error,
    showError,
    action,
    formatOptions,
    $$scope,
    slots,
    beforeinput_handler,
    blur_handler,
    change_handler,
    input_handler,
    focus_handler,
    input_binding
  ];
}
class FieldWrapper extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {
      field: 0,
      formatOptions: 12,
      inputType: 1,
      inputClasses: 2,
      inputProps: 3,
      class: 4
    });
  }
}
function create_if_block$D(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element("p");
      t = text(ctx[2]);
      attr(p, "class", "help");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_fragment$1h(ctx) {
  let fieldwrapper;
  let t;
  let if_block_anchor;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[1],
      inputType: ctx[5],
      inputClasses: ctx[0],
      class: ctx[3],
      inputProps: ctx[4]
    }
  });
  fieldwrapper.$on("beforeinput", ctx[6]);
  fieldwrapper.$on("blur", ctx[7]);
  fieldwrapper.$on("change", ctx[8]);
  fieldwrapper.$on("input", ctx[9]);
  fieldwrapper.$on("focus", ctx[10]);
  let if_block = !!ctx[2] && create_if_block$D(ctx);
  return {
    c() {
      create_component(fieldwrapper.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(fieldwrapper, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 2)
        fieldwrapper_changes.field = ctx2[1];
      if (dirty & 1)
        fieldwrapper_changes.inputClasses = ctx2[0];
      if (dirty & 8)
        fieldwrapper_changes.class = ctx2[3];
      if (dirty & 16)
        fieldwrapper_changes.inputProps = ctx2[4];
      fieldwrapper.$set(fieldwrapper_changes);
      if (!!ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$D(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldwrapper, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1h($$self, $$props, $$invalidate) {
  let inputProps;
  const omit_props_names = ["inputClasses", "field", "help", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { inputClasses = "" } = $$props;
  let { field } = $$props;
  let { help = "" } = $$props;
  const inputType = getInputType();
  let { class: clazz } = $$props;
  function getInputType() {
    if (field.def.type === "secret")
      return "password";
    else if (field.def.type === "boolean")
      return "checkbox";
    else if (field.def.type === "int" || field.def.type === "float" || field.def.type === "ranged:int")
      return "number";
    else
      return "text";
  }
  function beforeinput_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("inputClasses" in $$new_props)
      $$invalidate(0, inputClasses = $$new_props.inputClasses);
    if ("field" in $$new_props)
      $$invalidate(1, field = $$new_props.field);
    if ("help" in $$new_props)
      $$invalidate(2, help = $$new_props.help);
    if ("class" in $$new_props)
      $$invalidate(3, clazz = $$new_props.class);
  };
  $$self.$$.update = () => {
    $$invalidate(4, inputProps = field.def.type === "boolean" ? { ...$$restProps, checked: field.get() } : $$restProps);
  };
  return [
    inputClasses,
    field,
    help,
    clazz,
    inputProps,
    inputType,
    beforeinput_handler,
    blur_handler,
    change_handler,
    input_handler,
    focus_handler
  ];
}
class InputEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {
      inputClasses: 0,
      field: 1,
      help: 2,
      class: 3
    });
  }
}
function create_fragment$1g(ctx) {
  let li;
  let t;
  return {
    c() {
      li = element("li");
      t = text(ctx[0]);
      attr(li, "class", "dropdown-header ttu");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function instance$1g($$self, $$props, $$invalidate) {
  let { name } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
  };
  return [name];
}
class MenuHeaderItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1g, create_fragment$1g, safe_not_equal, { name: 0 });
  }
}
function create_default_slot$x(ctx) {
  let div1;
  let span;
  let input;
  let t0;
  let div0;
  let t1_value = (ctx[2].label || ctx[2].name) + "";
  let t1;
  return {
    c() {
      div1 = element("div");
      span = element("span");
      input = element("input");
      t0 = space();
      div0 = element("div");
      t1 = text(t1_value);
      attr(input, "type", "checkbox");
      set_style(input, "vertical-align", "top");
      set_style(input, "margin", "0 4px");
      input.checked = ctx[1];
      attr(span, "class", "pa1 pb0");
      attr(div0, "class", "ml1");
      attr(div1, "class", "flex");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span);
      append(span, input);
      append(div1, t0);
      append(div1, div0);
      append(div0, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        input.checked = ctx2[1];
      }
      if (dirty & 4 && t1_value !== (t1_value = (ctx2[2].label || ctx2[2].name) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_fragment$1f(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot$x] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[3]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menuitem_changes = {};
      if (dirty & 22) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function instance$1f($$self, $$props, $$invalidate) {
  let $item, $$unsubscribe_item = noop, $$subscribe_item = () => ($$unsubscribe_item(), $$unsubscribe_item = subscribe$1(item, ($$value) => $$invalidate(2, $item = $$value)), item);
  $$self.$$.on_destroy.push(() => $$unsubscribe_item());
  let { item } = $$props;
  $$subscribe_item();
  let { checked = false } = $$props;
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$subscribe_item($$invalidate(0, item = $$props2.item));
    if ("checked" in $$props2)
      $$invalidate(1, checked = $$props2.checked);
  };
  return [item, checked, $item, click_handler2];
}
class CheckableMenuItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1f, create_fragment$1f, safe_not_equal, { item: 0, checked: 1 });
  }
}
const get_bottom_slot_changes$1 = (dirty) => ({});
const get_bottom_slot_context$1 = (ctx) => ({});
function get_each_context$d(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  child_ctx[20] = i;
  return child_ctx;
}
const get_top_slot_changes$2 = (dirty) => ({});
const get_top_slot_context$2 = (ctx) => ({});
const get_icon_slot_changes$4 = (dirty) => ({});
const get_icon_slot_context$4 = (ctx) => ({ slot: "icon" });
const get_label_slot_changes$6 = (dirty) => ({});
const get_label_slot_context$6 = (ctx) => ({ slot: "label" });
function create_if_block_1$l(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem$1({
    props: {
      selected: false,
      $$slots: { default: [create_default_slot_1$k] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[11]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 32768) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_1$k(ctx) {
  let t;
  return {
    c() {
      t = text("None (Default)");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$C(ctx) {
  let menuheaderitem;
  let current;
  menuheaderitem = new MenuHeaderItem({
    props: {
      name: ctx[4](ctx[18])
    }
  });
  return {
    c() {
      create_component(menuheaderitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuheaderitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuheaderitem_changes = {};
      if (dirty & 17)
        menuheaderitem_changes.name = ctx2[4](ctx2[18]);
      menuheaderitem.$set(menuheaderitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuheaderitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuheaderitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuheaderitem, detaching);
    }
  };
}
function create_key_block$1(ctx) {
  let checkablemenuitem;
  let current;
  function click_handler_1(...args) {
    return ctx[12](ctx[18], ...args);
  }
  checkablemenuitem = new CheckableMenuItem({
    props: {
      item: ctx[18],
      checked: ctx[1].includes(ctx[3](ctx[18]).id)
    }
  });
  checkablemenuitem.$on("click", click_handler_1);
  return {
    c() {
      create_component(checkablemenuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkablemenuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const checkablemenuitem_changes = {};
      if (dirty & 1)
        checkablemenuitem_changes.item = ctx[18];
      if (dirty & 11)
        checkablemenuitem_changes.checked = ctx[1].includes(ctx[3](ctx[18]).id);
      checkablemenuitem.$set(checkablemenuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkablemenuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkablemenuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkablemenuitem, detaching);
    }
  };
}
function create_each_block$d(ctx) {
  let show_if = ctx[8](ctx[18], ctx[20]);
  let t;
  let previous_key = ctx[1];
  let key_block_anchor;
  let current;
  let if_block = show_if && create_if_block$C(ctx);
  let key_block = create_key_block$1(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = ctx2[8](ctx2[18], ctx2[20]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$C(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 2 && safe_not_equal(previous_key, previous_key = ctx2[1])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_default_slot$w(ctx) {
  let t0;
  let t1;
  let t2;
  let current;
  const top_slot_template = ctx[10].top;
  const top_slot = create_slot(top_slot_template, ctx, ctx[15], get_top_slot_context$2);
  let if_block = ctx[2] && create_if_block_1$l(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const bottom_slot_template = ctx[10].bottom;
  const bottom_slot = create_slot(bottom_slot_template, ctx, ctx[15], get_bottom_slot_context$1);
  return {
    c() {
      if (top_slot)
        top_slot.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (bottom_slot)
        bottom_slot.c();
    },
    m(target, anchor) {
      if (top_slot) {
        top_slot.m(target, anchor);
      }
      insert(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, t2, anchor);
      if (bottom_slot) {
        bottom_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (top_slot) {
        if (top_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            top_slot,
            top_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(top_slot_template, ctx2[15], dirty, get_top_slot_changes$2),
            get_top_slot_context$2
          );
        }
      }
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$l(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 347) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$d(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$d(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (bottom_slot) {
        if (bottom_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            bottom_slot,
            bottom_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(bottom_slot_template, ctx2[15], dirty, get_bottom_slot_changes$1),
            get_bottom_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(top_slot, local);
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(top_slot, local);
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (top_slot)
        top_slot.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t1);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t2);
      if (bottom_slot)
        bottom_slot.d(detaching);
    }
  };
}
function create_icon_slot$3(ctx) {
  let current;
  const icon_slot_template = ctx[10].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[15], get_icon_slot_context$4);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(icon_slot_template, ctx2[15], dirty, get_icon_slot_changes$4),
            get_icon_slot_context$4
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_label_slot$h(ctx) {
  let current;
  const label_slot_template = ctx[10].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[15], get_label_slot_context$6);
  return {
    c() {
      if (label_slot)
        label_slot.c();
    },
    m(target, anchor) {
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[15],
            !current ? get_all_dirty_from_scope(ctx2[15]) : get_slot_changes(label_slot_template, ctx2[15], dirty, get_label_slot_changes$6),
            get_label_slot_context$6
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_fragment$1e(ctx) {
  let menu;
  let current;
  const menu_spread_levels = [
    {
      actionClass: "d-flex btn btn-default btn-sm items-center dropdown-toggle " + ctx[5]
    },
    { allowNull: ctx[2] },
    { toggle: false },
    ctx[9]
  ];
  let menu_props = {
    $$slots: {
      label: [create_label_slot$h],
      icon: [create_icon_slot$3],
      default: [create_default_slot$w]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < menu_spread_levels.length; i += 1) {
    menu_props = assign(menu_props, menu_spread_levels[i]);
  }
  menu = new Menu$1({ props: menu_props });
  menu.$on("close", ctx[13]);
  menu.$on("open", ctx[14]);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = dirty & 548 ? get_spread_update(menu_spread_levels, [
        dirty & 32 && {
          actionClass: "d-flex btn btn-default btn-sm items-center dropdown-toggle " + ctx2[5]
        },
        dirty & 4 && { allowNull: ctx2[2] },
        menu_spread_levels[2],
        dirty & 512 && get_spread_object(ctx2[9])
      ]) : {};
      if (dirty & 32799) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$1e($$self, $$props, $$invalidate) {
  const omit_props_names = ["ids", "items", "allowNull", "get", "getSectionName", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { ids = [] } = $$props;
  let { items } = $$props;
  let { allowNull = true } = $$props;
  let { get = get_store_value } = $$props;
  let { getSectionName: getSectionName2 = () => {
    return null;
  } } = $$props;
  let { class: clazz = "" } = $$props;
  let dispatch = createEventDispatcher();
  let lastSectionName;
  function onClickItem(_id) {
    let checked = ids.includes(_id);
    onSelect(checked ? _.without(ids, _id) : [...ids, _id]);
  }
  function onSelect(_ids) {
    $$invalidate(1, ids = _ids);
    $$invalidate(0, items);
    dispatch("change", ids);
  }
  function shouldCreateSectionHeader(item, i) {
    if (i === 0) {
      lastSectionName = void 0;
    }
    const currentSectionName = getSectionName2(item);
    if (!currentSectionName) {
      return false;
    }
    if (lastSectionName === currentSectionName) {
      return false;
    } else {
      lastSectionName = currentSectionName;
      return true;
    }
  }
  const click_handler2 = (e) => onSelect([]);
  const click_handler_1 = (item, e) => onClickItem(get(item).id);
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  function open_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("ids" in $$new_props)
      $$invalidate(1, ids = $$new_props.ids);
    if ("items" in $$new_props)
      $$invalidate(0, items = $$new_props.items);
    if ("allowNull" in $$new_props)
      $$invalidate(2, allowNull = $$new_props.allowNull);
    if ("get" in $$new_props)
      $$invalidate(3, get = $$new_props.get);
    if ("getSectionName" in $$new_props)
      $$invalidate(4, getSectionName2 = $$new_props.getSectionName);
    if ("class" in $$new_props)
      $$invalidate(5, clazz = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      lastSectionName = void 0;
    }
  };
  return [
    items,
    ids,
    allowNull,
    get,
    getSectionName2,
    clazz,
    onClickItem,
    onSelect,
    shouldCreateSectionHeader,
    $$restProps,
    slots,
    click_handler2,
    click_handler_1,
    close_handler,
    open_handler,
    $$scope
  ];
}
class MultiSelectMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {
      ids: 1,
      items: 0,
      allowNull: 2,
      get: 3,
      getSectionName: 4,
      class: 5
    });
  }
}
function portal(el, target = "body") {
  let targetEl;
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetEl = document.querySelector(target);
      if (targetEl === null) {
        await tick();
        targetEl = document.querySelector(target);
      }
      if (targetEl === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetEl = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    targetEl.appendChild(el);
    el.hidden = false;
  }
  function destroy() {
    if (el.parentNode) {
      el.parentNode.removeChild(el);
    }
  }
  update(target);
  return { update, destroy };
}
function create_if_block$B(ctx) {
  let div;
  let t;
  let div_class_value;
  return {
    c() {
      div = element("div");
      t = text(ctx[0]);
      attr(div, "class", div_class_value = "text-center " + ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
      if (dirty & 2 && div_class_value !== (div_class_value = "text-center " + ctx2[1])) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1d(ctx) {
  let div1;
  let div0;
  let div1_class_value;
  let t;
  let if_block_anchor;
  let if_block = ctx[0] && create_if_block$B(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div0, "class", "xindeterminate");
      attr(div1, "class", div1_class_value = "xprogress " + ctx[3]);
      attr(div1, "style", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & 8 && div1_class_value !== (div1_class_value = "xprogress " + ctx2[3])) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & 4) {
        attr(div1, "style", ctx2[2]);
      }
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$B(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1d($$self, $$props, $$invalidate) {
  let { message = void 0 } = $$props;
  let { messageClass = "" } = $$props;
  let { style = "" } = $$props;
  let { class: clazz = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("message" in $$props2)
      $$invalidate(0, message = $$props2.message);
    if ("messageClass" in $$props2)
      $$invalidate(1, messageClass = $$props2.messageClass);
    if ("style" in $$props2)
      $$invalidate(2, style = $$props2.style);
    if ("class" in $$props2)
      $$invalidate(3, clazz = $$props2.class);
  };
  return [message, messageClass, style, clazz];
}
class Loader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {
      message: 0,
      messageClass: 1,
      style: 2,
      class: 3
    });
  }
}
var ParamsForm_svelte_svelte_type_style_lang = "";
function get_each_context$c(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_if_block_1$k(ctx) {
  let h4;
  return {
    c() {
      h4 = element("h4");
      h4.textContent = "Input Fields";
      attr(h4, "class", "span-full-row svelte-4nha8s");
    },
    m(target, anchor) {
      insert(target, h4, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(h4);
    }
  };
}
function create_if_block$A(ctx) {
  let i;
  let i_title_value;
  return {
    c() {
      i = element("i");
      attr(i, "class", "fa fa-info-circle");
      set_style(i, "font-size", "12px");
      attr(i, "title", i_title_value = ctx[0].fields[ctx[8]].def.spec.note);
    },
    m(target, anchor) {
      insert(target, i, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && i_title_value !== (i_title_value = ctx2[0].fields[ctx2[8]].def.spec.note)) {
        attr(i, "title", i_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(i);
    }
  };
}
function create_each_block$c(ctx) {
  let div;
  let label;
  let t0_value = formatParamName(ctx[8]) + "";
  let t0;
  let t1;
  let label_for_value;
  let label_class_value;
  let t2;
  let inputedit;
  let t3;
  let current;
  let if_block = ctx[0].fields[ctx[8]].def.spec.note && create_if_block$A(ctx);
  const inputedit_spread_levels = [
    { class: "col-auto" },
    {
      field: ctx[0].fields[ctx[8]]
    },
    {
      placeholder: ctx[0].fields[ctx[8]].def.spec.note
    },
    ctx[4]
  ];
  function change_handler() {
    return ctx[6](ctx[8]);
  }
  let inputedit_props = {};
  for (let i = 0; i < inputedit_spread_levels.length; i += 1) {
    inputedit_props = assign(inputedit_props, inputedit_spread_levels[i]);
  }
  inputedit = new InputEdit({ props: inputedit_props });
  inputedit.$on("change", change_handler);
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(inputedit.$$.fragment);
      t3 = space();
      attr(label, "for", label_for_value = ctx[8]);
      set_style(label, "flex-basis", "30%");
      set_style(label, "word-break", "break-all");
      attr(label, "class", label_class_value = "form-label col-auto text-capitalize " + ctx[2] + " svelte-4nha8s");
      attr(div, "class", "form-group row span-full-row grid svelte-4nha8s");
      set_style(div, "grid-template-columns", "subgrid");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      append(label, t1);
      if (if_block)
        if_block.m(label, null);
      append(div, t2);
      mount_component(inputedit, div, null);
      append(div, t3);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = formatParamName(ctx[8]) + ""))
        set_data(t0, t0_value);
      if (ctx[0].fields[ctx[8]].def.spec.note) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$A(ctx);
          if_block.c();
          if_block.m(label, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 1 && label_for_value !== (label_for_value = ctx[8])) {
        attr(label, "for", label_for_value);
      }
      if (!current || dirty & 4 && label_class_value !== (label_class_value = "form-label col-auto text-capitalize " + ctx[2] + " svelte-4nha8s")) {
        attr(label, "class", label_class_value);
      }
      const inputedit_changes = dirty & 17 ? get_spread_update(inputedit_spread_levels, [
        inputedit_spread_levels[0],
        dirty & 1 && {
          field: ctx[0].fields[ctx[8]]
        },
        dirty & 1 && {
          placeholder: ctx[0].fields[ctx[8]].def.spec.note
        },
        dirty & 16 && get_spread_object(ctx[4])
      ]) : {};
      inputedit.$set(inputedit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      destroy_component(inputedit);
    }
  };
}
function create_fragment$1c(ctx) {
  let form;
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block_1$k();
  let each_value = Object.keys(ctx[0].fields);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      form = element("form");
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(form, "class", "params grid grid-template row-gap-2 mt-1 svelte-4nha8s");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      if (if_block)
        if_block.m(form, null);
      append(form, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(form, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen(form, "submit", prevent_default(ctx[5]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$k();
          if_block.c();
          if_block.m(form, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 29) {
        each_value = Object.keys(ctx2[0].fields);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$c(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$c(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(form, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function formatParamName(name) {
  return name.replace(/([a-zA-Z])(\d)|(\d)([a-zA-Z])|_/g, "$1$3 $2$4");
}
function instance$1c($$self, $$props, $$invalidate) {
  const omit_props_names = ["paramsFormModel", "showHeader", "paramLabelClass"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  const dispatch = createEventDispatcher();
  let { paramsFormModel } = $$props;
  let { showHeader = true } = $$props;
  let { paramLabelClass = "" } = $$props;
  function updateField(field) {
    dispatch("change", field);
  }
  function submit_handler(event) {
    bubble.call(this, $$self, event);
  }
  const change_handler = (name) => updateField(paramsFormModel.fields[name]);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("paramsFormModel" in $$new_props)
      $$invalidate(0, paramsFormModel = $$new_props.paramsFormModel);
    if ("showHeader" in $$new_props)
      $$invalidate(1, showHeader = $$new_props.showHeader);
    if ("paramLabelClass" in $$new_props)
      $$invalidate(2, paramLabelClass = $$new_props.paramLabelClass);
  };
  return [
    paramsFormModel,
    showHeader,
    paramLabelClass,
    updateField,
    $$restProps,
    submit_handler,
    change_handler
  ];
}
class ParamsForm extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {
      paramsFormModel: 0,
      showHeader: 1,
      paramLabelClass: 2
    });
  }
}
function create_else_block$k(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "No params required";
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block$z(ctx) {
  let div;
  let paramsform;
  let current;
  paramsform = new ParamsForm({
    props: {
      paramsFormModel: ctx[0],
      showHeader: false,
      paramLabelClass: ctx[1]
    }
  });
  paramsform.$on("change", ctx[3]);
  return {
    c() {
      div = element("div");
      create_component(paramsform.$$.fragment);
      attr(div, "class", "row-gap-2 p-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(paramsform, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const paramsform_changes = {};
      if (dirty & 1)
        paramsform_changes.paramsFormModel = ctx2[0];
      if (dirty & 2)
        paramsform_changes.paramLabelClass = ctx2[1];
      paramsform.$set(paramsform_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(paramsform.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(paramsform.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(paramsform);
    }
  };
}
function create_fragment$1b(ctx) {
  let div;
  let show_if;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block$z, create_else_block$k];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 1)
      show_if = null;
    if (show_if == null)
      show_if = !!(ctx2[0] && Object.keys(ctx2[0].fields).length);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", div_class_value = "bg-white px-1 " + ctx[2]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "bg-white px-1 " + ctx2[2])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function setupParams(params, fields) {
  if (!(params == null ? void 0 : params.length)) {
    return;
  }
  const fieldParams = fields || {};
  const paramsSpec = params.map((spec) => {
    if (fieldParams.hasOwnProperty(spec.name)) {
      return { ...spec, default: fieldParams[spec.name] };
    }
    return spec;
  });
  let paramsFormModel = new Params(paramsSpec);
  paramsFormModel.updateValues(paramsSpec);
  paramsFormModel.setTouched();
  return paramsFormModel;
}
function instance$1b($$self, $$props, $$invalidate) {
  let { fields } = $$props;
  let { spec } = $$props;
  let { paramsFormModel } = $$props;
  let { updatedFields } = $$props;
  let { paramLabelClass } = $$props;
  let { onUpdate = (a, b) => {
  } } = $$props;
  let { wrapperClass = "" } = $$props;
  function onChangeParams() {
    const params = paramsFormModel.toJSON();
    onUpdate(params, updatedFields);
  }
  $$self.$$set = ($$props2) => {
    if ("fields" in $$props2)
      $$invalidate(4, fields = $$props2.fields);
    if ("spec" in $$props2)
      $$invalidate(5, spec = $$props2.spec);
    if ("paramsFormModel" in $$props2)
      $$invalidate(0, paramsFormModel = $$props2.paramsFormModel);
    if ("updatedFields" in $$props2)
      $$invalidate(6, updatedFields = $$props2.updatedFields);
    if ("paramLabelClass" in $$props2)
      $$invalidate(1, paramLabelClass = $$props2.paramLabelClass);
    if ("onUpdate" in $$props2)
      $$invalidate(7, onUpdate = $$props2.onUpdate);
    if ("wrapperClass" in $$props2)
      $$invalidate(2, wrapperClass = $$props2.wrapperClass);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 49) {
      !paramsFormModel && $$invalidate(0, paramsFormModel = setupParams(spec == null ? void 0 : spec.params, fields));
    }
  };
  return [
    paramsFormModel,
    paramLabelClass,
    wrapperClass,
    onChangeParams,
    fields,
    spec,
    updatedFields,
    onUpdate
  ];
}
class ParamsEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {
      fields: 4,
      spec: 5,
      paramsFormModel: 0,
      updatedFields: 6,
      paramLabelClass: 1,
      onUpdate: 7,
      wrapperClass: 2
    });
  }
}
const get_tvi_meta_expanded_view_slot_changes = (dirty) => ({ node: dirty & 1 });
const get_tvi_meta_expanded_view_slot_context = (ctx) => ({ node: ctx[0] });
const get_tvi_right_content_slot_changes = (dirty) => ({ node: dirty & 1 });
const get_tvi_right_content_slot_context = (ctx) => ({ node: ctx[0] });
const get_label_edit_slot_changes$2 = (dirty) => ({});
const get_label_edit_slot_context$2 = (ctx) => ({
  closeLabelEditor: ctx[13],
  handleKeyDownEventForLabelEditor: ctx[12]
});
const get_tvi_label_slot_changes = (dirty) => ({});
const get_tvi_label_slot_context = (ctx) => ({});
const get_tvi_icon_slot_changes = (dirty) => ({});
const get_tvi_icon_slot_context = (ctx) => ({});
const get_tvi_checkbox_slot_changes = (dirty) => ({});
const get_tvi_checkbox_slot_context = (ctx) => ({});
const get_tvi_expandable_slot_changes = (dirty) => ({});
const get_tvi_expandable_slot_context = (ctx) => ({});
function create_else_block$j(ctx) {
  let current;
  const label_edit_slot_template = ctx[17]["label-edit"];
  const label_edit_slot = create_slot(label_edit_slot_template, ctx, ctx[16], get_label_edit_slot_context$2);
  const label_edit_slot_or_fallback = label_edit_slot || fallback_block_2$1(ctx);
  return {
    c() {
      if (label_edit_slot_or_fallback)
        label_edit_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (label_edit_slot_or_fallback) {
        label_edit_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_edit_slot) {
        if (label_edit_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            label_edit_slot,
            label_edit_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(label_edit_slot_template, ctx2[16], dirty, get_label_edit_slot_changes$2),
            get_label_edit_slot_context$2
          );
        }
      } else {
        if (label_edit_slot_or_fallback && label_edit_slot_or_fallback.p && (!current || dirty & 80)) {
          label_edit_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_edit_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(label_edit_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (label_edit_slot_or_fallback)
        label_edit_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block_2$b(ctx) {
  let div;
  let show_if_1 = ctx[4].isExpandable();
  let t0;
  let show_if = ctx[4].isCheckable();
  let t1;
  let t2;
  let a;
  let current;
  let mounted;
  let dispose;
  let if_block0 = show_if_1 && create_if_block_5$4(ctx);
  let if_block1 = show_if && create_if_block_4$6(ctx);
  let if_block2 = ctx[1] && create_if_block_3$8(ctx);
  const tvi_label_slot_template = ctx[17]["tvi-label"];
  const tvi_label_slot = create_slot(tvi_label_slot_template, ctx, ctx[16], get_tvi_label_slot_context);
  const tvi_label_slot_or_fallback = tvi_label_slot || fallback_block_1$1(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      a = element("a");
      if (tvi_label_slot_or_fallback)
        tvi_label_slot_or_fallback.c();
      attr(div, "class", "tv-caret");
      attr(a, "class", "tv-label");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t2, anchor);
      insert(target, a, anchor);
      if (tvi_label_slot_or_fallback) {
        tvi_label_slot_or_fallback.m(a, null);
      }
      ctx[19](a);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[10]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        show_if_1 = ctx2[4].isExpandable();
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & 16)
        show_if = ctx2[4].isCheckable();
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_3$8(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (tvi_label_slot) {
        if (tvi_label_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tvi_label_slot,
            tvi_label_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tvi_label_slot_template, ctx2[16], dirty, get_tvi_label_slot_changes),
            get_tvi_label_slot_context
          );
        }
      } else {
        if (tvi_label_slot_or_fallback && tvi_label_slot_or_fallback.p && (!current || dirty & 16)) {
          tvi_label_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(tvi_label_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(tvi_label_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(a);
      if (tvi_label_slot_or_fallback)
        tvi_label_slot_or_fallback.d(detaching);
      ctx[19](null);
      mounted = false;
      dispose();
    }
  };
}
function fallback_block_2$1(ctx) {
  let input;
  let input_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "class", "tv-label-editor w-100");
      input.value = input_value_value = ctx[4].label;
      input.autofocus = true;
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.focus();
      if (!mounted) {
        dispose = [
          listen(input, "blur", ctx[20]),
          listen(input, "keydown", ctx[21])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16 && input_value_value !== (input_value_value = ctx2[4].label) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_5$4(ctx) {
  let current;
  const tvi_expandable_slot_template = ctx[17]["tvi-expandable"];
  const tvi_expandable_slot = create_slot(tvi_expandable_slot_template, ctx, ctx[16], get_tvi_expandable_slot_context);
  return {
    c() {
      if (tvi_expandable_slot)
        tvi_expandable_slot.c();
    },
    m(target, anchor) {
      if (tvi_expandable_slot) {
        tvi_expandable_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tvi_expandable_slot) {
        if (tvi_expandable_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tvi_expandable_slot,
            tvi_expandable_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tvi_expandable_slot_template, ctx2[16], dirty, get_tvi_expandable_slot_changes),
            get_tvi_expandable_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tvi_expandable_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tvi_expandable_slot, local);
      current = false;
    },
    d(detaching) {
      if (tvi_expandable_slot)
        tvi_expandable_slot.d(detaching);
    }
  };
}
function create_if_block_4$6(ctx) {
  let div;
  let current;
  const tvi_checkbox_slot_template = ctx[17]["tvi-checkbox"];
  const tvi_checkbox_slot = create_slot(tvi_checkbox_slot_template, ctx, ctx[16], get_tvi_checkbox_slot_context);
  return {
    c() {
      div = element("div");
      if (tvi_checkbox_slot)
        tvi_checkbox_slot.c();
      attr(div, "class", "tv-checkbox");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (tvi_checkbox_slot) {
        tvi_checkbox_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tvi_checkbox_slot) {
        if (tvi_checkbox_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tvi_checkbox_slot,
            tvi_checkbox_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tvi_checkbox_slot_template, ctx2[16], dirty, get_tvi_checkbox_slot_changes),
            get_tvi_checkbox_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tvi_checkbox_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tvi_checkbox_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (tvi_checkbox_slot)
        tvi_checkbox_slot.d(detaching);
    }
  };
}
function create_if_block_3$8(ctx) {
  let div;
  let current;
  const tvi_icon_slot_template = ctx[17]["tvi-icon"];
  const tvi_icon_slot = create_slot(tvi_icon_slot_template, ctx, ctx[16], get_tvi_icon_slot_context);
  return {
    c() {
      div = element("div");
      if (tvi_icon_slot)
        tvi_icon_slot.c();
      attr(div, "class", "tv-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (tvi_icon_slot) {
        tvi_icon_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tvi_icon_slot) {
        if (tvi_icon_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tvi_icon_slot,
            tvi_icon_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tvi_icon_slot_template, ctx2[16], dirty, get_tvi_icon_slot_changes),
            get_tvi_icon_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tvi_icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tvi_icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (tvi_icon_slot)
        tvi_icon_slot.d(detaching);
    }
  };
}
function fallback_block_1$1(ctx) {
  let t_value = ctx[4].label + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = ctx2[4].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$j(ctx) {
  let div;
  let current;
  const tvi_right_content_slot_template = ctx[17]["tvi-right-content"];
  const tvi_right_content_slot = create_slot(tvi_right_content_slot_template, ctx, ctx[16], get_tvi_right_content_slot_context);
  return {
    c() {
      div = element("div");
      if (tvi_right_content_slot)
        tvi_right_content_slot.c();
      attr(div, "class", "tv-key-meta tv-flex tv-flex-row tv-flex-wrap tv-tree-item " + ctx[9]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (tvi_right_content_slot) {
        tvi_right_content_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tvi_right_content_slot) {
        if (tvi_right_content_slot.p && (!current || dirty & 65537)) {
          update_slot_base(
            tvi_right_content_slot,
            tvi_right_content_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tvi_right_content_slot_template, ctx2[16], dirty, get_tvi_right_content_slot_changes),
            get_tvi_right_content_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tvi_right_content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tvi_right_content_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (tvi_right_content_slot)
        tvi_right_content_slot.d(detaching);
    }
  };
}
function create_if_block$y(ctx) {
  let div1;
  let div0;
  let t;
  let current;
  let mounted;
  let dispose;
  const tvi_meta_expanded_view_slot_template = ctx[17]["tvi-meta-expanded-view"];
  const tvi_meta_expanded_view_slot = create_slot(tvi_meta_expanded_view_slot_template, ctx, ctx[16], get_tvi_meta_expanded_view_slot_context);
  const tvi_meta_expanded_view_slot_or_fallback = tvi_meta_expanded_view_slot || fallback_block$2();
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      if (tvi_meta_expanded_view_slot_or_fallback)
        tvi_meta_expanded_view_slot_or_fallback.c();
      attr(div0, "class", "tv-icon");
      attr(div1, "class", "tv-flex");
      set_style(div1, "padding-left", ctx[8] - 3 + "px");
      attr(div1, "tabindex", "0");
      attr(div1, "role", "button");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t);
      if (tvi_meta_expanded_view_slot_or_fallback) {
        tvi_meta_expanded_view_slot_or_fallback.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div1, "keydown", stop_propagation(ctx[18]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (tvi_meta_expanded_view_slot) {
        if (tvi_meta_expanded_view_slot.p && (!current || dirty & 65537)) {
          update_slot_base(
            tvi_meta_expanded_view_slot,
            tvi_meta_expanded_view_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tvi_meta_expanded_view_slot_template, ctx2[16], dirty, get_tvi_meta_expanded_view_slot_changes),
            get_tvi_meta_expanded_view_slot_context
          );
        }
      }
      if (!current || dirty & 256) {
        set_style(div1, "padding-left", ctx2[8] - 3 + "px");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tvi_meta_expanded_view_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(tvi_meta_expanded_view_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (tvi_meta_expanded_view_slot_or_fallback)
        tvi_meta_expanded_view_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function fallback_block$2(ctx) {
  let t;
  return {
    c() {
      t = text("Default Meta Expanded View");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$1a(ctx) {
  let div2;
  let div1;
  let div0;
  let current_block_type_index;
  let if_block0;
  let div0_aria_selected_value;
  let div0_disabled_value;
  let t0;
  let t1;
  let action_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_2$b, create_else_block$j];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[6])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[2] && create_if_block_1$j(ctx);
  let if_block2 = ctx[5] && create_if_block$y(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "tv-key tv-flex tv-flex-row " + ctx[9]);
      attr(div0, "tabindex", "-1");
      attr(div0, "role", "treeitem");
      attr(div0, "aria-selected", div0_aria_selected_value = ctx[4].selected);
      attr(div0, "disabled", div0_disabled_value = ctx[4].isDisabled());
      set_style(div0, "padding-left", ctx[6] ? "initial" : `${ctx[8]}px`);
      attr(div1, "class", "tv-flex");
      attr(div2, "class", "tv-flex tv-container w-full tv-tree-item");
      attr(div2, "role", "row");
      set_style(div2, "flex-direction", "column");
      toggle_class(div2, "tv-hover-select", ctx[4].selected);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append(div2, t1);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "dblclick", ctx[22]),
          action_destroyer(action_action = ctx[3].call(null, div2, ctx[4]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, null);
      }
      if (!current || dirty & 16 && div0_aria_selected_value !== (div0_aria_selected_value = ctx2[4].selected)) {
        attr(div0, "aria-selected", div0_aria_selected_value);
      }
      if (!current || dirty & 16 && div0_disabled_value !== (div0_disabled_value = ctx2[4].isDisabled())) {
        attr(div0, "disabled", div0_disabled_value);
      }
      if (dirty & 320) {
        set_style(div0, "padding-left", ctx2[6] ? "initial" : `${ctx2[8]}px`);
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$j(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[5]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$y(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (action_action && is_function(action_action.update) && dirty & 16)
        action_action.update.call(null, ctx2[4]);
      if (!current || dirty & 16) {
        toggle_class(div2, "tv-hover-select", ctx2[4].selected);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function getSizeClass(size) {
  if (size === "medium") {
    return "tv-md";
  } else if (size === "small") {
    return "tv-sm";
  } else if (size === "large" || !size) {
    return "tv-lg";
  }
}
function instance$1a($$self, $$props, $$invalidate) {
  let indentPadding;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(4, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  let { node } = $$props;
  $$subscribe_node();
  let { showIcon = true } = $$props;
  let { size = "medium" } = $$props;
  let { showMeta = true } = $$props;
  let { action } = $$props;
  let { showRoot } = $$props;
  let showExpandedMetaView = false;
  let showLabelEditor = false;
  let sizeClass = getSizeClass(size);
  let elAction;
  function onClick(e) {
    dispatch("click", { e, node });
  }
  function handleDoubleClick() {
    if (!node.isLabelEditable()) {
      return;
    }
    $$invalidate(6, showLabelEditor = true);
  }
  function handleKeyDownEventForLabelEditor(e) {
    if (e.key === "Enter" || e.key === "Tab") {
      closeLabelEditor();
      node.editLabel(e.target.value);
    } else if (e.key === "Escape") {
      closeLabelEditor();
    }
  }
  function closeLabelEditor() {
    $$invalidate(6, showLabelEditor = false);
  }
  function setFocus(selected) {
    if (selected) {
      elAction == null ? void 0 : elAction.focus();
    }
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elAction = $$value;
      $$invalidate(7, elAction);
    });
  }
  const blur_handler = (e) => $$invalidate(6, showLabelEditor = false);
  const keydown_handler_1 = (e) => handleKeyDownEventForLabelEditor(e);
  const dblclick_handler = () => handleDoubleClick();
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("showIcon" in $$props2)
      $$invalidate(1, showIcon = $$props2.showIcon);
    if ("size" in $$props2)
      $$invalidate(14, size = $$props2.size);
    if ("showMeta" in $$props2)
      $$invalidate(2, showMeta = $$props2.showMeta);
    if ("action" in $$props2)
      $$invalidate(3, action = $$props2.action);
    if ("showRoot" in $$props2)
      $$invalidate(15, showRoot = $$props2.showRoot);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $$invalidate(5, showExpandedMetaView = $node._showExpandedMetaView);
    }
    if ($$self.$$.dirty & 32784) {
      $$invalidate(8, indentPadding = ($node.getNodeLevel() - (showRoot ? 0 : 1)) * 16 - 4);
    }
    if ($$self.$$.dirty & 16) {
      setFocus($node.selected);
    }
  };
  return [
    node,
    showIcon,
    showMeta,
    action,
    $node,
    showExpandedMetaView,
    showLabelEditor,
    elAction,
    indentPadding,
    sizeClass,
    onClick,
    handleDoubleClick,
    handleKeyDownEventForLabelEditor,
    closeLabelEditor,
    size,
    showRoot,
    $$scope,
    slots,
    keydown_handler,
    a_binding,
    blur_handler,
    keydown_handler_1,
    dblclick_handler
  ];
}
class TreeViewItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {
      node: 0,
      showIcon: 1,
      size: 14,
      showMeta: 2,
      action: 3,
      showRoot: 15
    });
  }
}
function get_each_context$b(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
const get_expandable_slot_changes_1 = (dirty) => ({ node: dirty & 32 });
const get_expandable_slot_context_1 = (ctx) => ({
  slot: "expandable",
  node: ctx[5]
});
const get_checkbox_slot_changes_1 = (dirty) => ({ node: dirty & 32 });
const get_checkbox_slot_context_1 = (ctx) => ({ slot: "checkbox", node: ctx[5] });
const get_icon_slot_changes_1 = (dirty) => ({ node: dirty & 32 });
const get_icon_slot_context_1 = (ctx) => ({ slot: "icon", node: ctx[5] });
const get_label_slot_changes_1 = (dirty) => ({ node: dirty & 32 });
const get_label_slot_context_1 = (ctx) => ({ slot: "label", node: ctx[5] });
const get_label_edit_slot_changes_1 = (dirty) => ({
  node: dirty & 32,
  closeLabelEditor: dirty & 524288,
  handleKeyDownEventForLabelEditor: dirty & 262144
});
const get_label_edit_slot_context_1 = (ctx) => ({
  slot: "label-edit",
  node: ctx[5],
  closeLabelEditor: ctx[19],
  handleKeyDownEventForLabelEditor: ctx[18]
});
const get_right_content_slot_changes_1 = (dirty) => ({ node: dirty & 32 });
const get_right_content_slot_context_1 = (ctx) => ({
  slot: "right-content",
  node: ctx[5]
});
const get_meta_expanded_view_slot_changes_1 = (dirty) => ({ node: dirty & 32 });
const get_meta_expanded_view_slot_context_1 = (ctx) => ({
  slot: "meta-expanded-view",
  node: ctx[5]
});
const get_expandable_slot_changes$1 = (dirty) => ({ node: dirty & 64 });
const get_expandable_slot_context$1 = (ctx) => ({
  slot: "tvi-expandable",
  node: ctx[6]
});
const get_checkbox_slot_changes$1 = (dirty) => ({ node: dirty & 64 });
const get_checkbox_slot_context$1 = (ctx) => ({
  slot: "tvi-checkbox",
  node: ctx[6]
});
const get_icon_slot_changes$3 = (dirty) => ({ node: dirty & 64 });
const get_icon_slot_context$3 = (ctx) => ({ slot: "tvi-icon", node: ctx[6] });
const get_label_slot_changes$5 = (dirty) => ({ node: dirty & 64 });
const get_label_slot_context$5 = (ctx) => ({
  slot: "tvi-label",
  node: ctx[6]
});
const get_label_edit_slot_changes$1 = (dirty) => ({
  node: dirty & 64,
  closeLabelEditor: dirty & 524288,
  handleKeyDownEventForLabelEditor: dirty & 262144
});
const get_label_edit_slot_context$1 = (ctx) => ({
  slot: "label-edit",
  node: ctx[6],
  closeLabelEditor: ctx[19],
  handleKeyDownEventForLabelEditor: ctx[18]
});
const get_right_content_slot_changes = (dirty) => ({ node: dirty & 32 });
const get_right_content_slot_context = (ctx) => ({
  slot: "tvi-right-content",
  node: ctx[5]
});
const get_meta_expanded_view_slot_changes$1 = (dirty) => ({ node: dirty & 32 });
const get_meta_expanded_view_slot_context$1 = (ctx) => ({
  slot: "tvi-meta-expanded-view",
  node: ctx[5]
});
function create_if_block_2$a(ctx) {
  let treeviewitem;
  let current;
  treeviewitem = new TreeViewItem({
    props: {
      node: ctx[6],
      showIcon: ctx[1],
      size: ctx[4],
      action: ctx[0],
      showMeta: ctx[3],
      showRoot: ctx[2],
      $$slots: {
        "tvi-meta-expanded-view": [
          create_tvi_meta_expanded_view_slot,
          ({ node }) => ({ 5: node }),
          ({ node }) => node ? 32 : 0
        ],
        "tvi-right-content": [
          create_tvi_right_content_slot,
          ({ node }) => ({ 5: node }),
          ({ node }) => node ? 32 : 0
        ],
        "label-edit": [
          create_label_edit_slot_1,
          ({ handleKeyDownEventForLabelEditor, closeLabelEditor }) => ({
            18: handleKeyDownEventForLabelEditor,
            19: closeLabelEditor
          }),
          ({ handleKeyDownEventForLabelEditor, closeLabelEditor }) => (handleKeyDownEventForLabelEditor ? 262144 : 0) | (closeLabelEditor ? 524288 : 0)
        ],
        "tvi-label": [create_tvi_label_slot],
        "tvi-icon": [create_tvi_icon_slot],
        "tvi-checkbox": [create_tvi_checkbox_slot],
        "tvi-expandable": [create_tvi_expandable_slot]
      },
      $$scope: { ctx }
    }
  });
  treeviewitem.$on("click", ctx[11]);
  return {
    c() {
      create_component(treeviewitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeviewitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeviewitem_changes = {};
      if (dirty & 64)
        treeviewitem_changes.node = ctx2[6];
      if (dirty & 2)
        treeviewitem_changes.showIcon = ctx2[1];
      if (dirty & 16)
        treeviewitem_changes.size = ctx2[4];
      if (dirty & 1)
        treeviewitem_changes.action = ctx2[0];
      if (dirty & 8)
        treeviewitem_changes.showMeta = ctx2[3];
      if (dirty & 4)
        treeviewitem_changes.showRoot = ctx2[2];
      if (dirty & 794720) {
        treeviewitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeviewitem.$set(treeviewitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeviewitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeviewitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeviewitem, detaching);
    }
  };
}
function create_tvi_expandable_slot(ctx) {
  let current;
  const expandable_slot_template = ctx[10].expandable;
  const expandable_slot = create_slot(expandable_slot_template, ctx, ctx[13], get_expandable_slot_context$1);
  return {
    c() {
      if (expandable_slot)
        expandable_slot.c();
    },
    m(target, anchor) {
      if (expandable_slot) {
        expandable_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (expandable_slot) {
        if (expandable_slot.p && (!current || dirty & 8256)) {
          update_slot_base(
            expandable_slot,
            expandable_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(expandable_slot_template, ctx2[13], dirty, get_expandable_slot_changes$1),
            get_expandable_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable_slot, local);
      current = true;
    },
    o(local) {
      transition_out(expandable_slot, local);
      current = false;
    },
    d(detaching) {
      if (expandable_slot)
        expandable_slot.d(detaching);
    }
  };
}
function create_tvi_checkbox_slot(ctx) {
  let current;
  const checkbox_slot_template = ctx[10].checkbox;
  const checkbox_slot = create_slot(checkbox_slot_template, ctx, ctx[13], get_checkbox_slot_context$1);
  return {
    c() {
      if (checkbox_slot)
        checkbox_slot.c();
    },
    m(target, anchor) {
      if (checkbox_slot) {
        checkbox_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (checkbox_slot) {
        if (checkbox_slot.p && (!current || dirty & 8256)) {
          update_slot_base(
            checkbox_slot,
            checkbox_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(checkbox_slot_template, ctx2[13], dirty, get_checkbox_slot_changes$1),
            get_checkbox_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox_slot, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox_slot, local);
      current = false;
    },
    d(detaching) {
      if (checkbox_slot)
        checkbox_slot.d(detaching);
    }
  };
}
function create_tvi_icon_slot(ctx) {
  let current;
  const icon_slot_template = ctx[10].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[13], get_icon_slot_context$3);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 8256)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(icon_slot_template, ctx2[13], dirty, get_icon_slot_changes$3),
            get_icon_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_tvi_label_slot(ctx) {
  let current;
  const label_slot_template = ctx[10].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[13], get_label_slot_context$5);
  return {
    c() {
      if (label_slot)
        label_slot.c();
    },
    m(target, anchor) {
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 8256)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(label_slot_template, ctx2[13], dirty, get_label_slot_changes$5),
            get_label_slot_context$5
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_label_edit_slot_1(ctx) {
  let current;
  const label_edit_slot_template = ctx[10]["label-edit"];
  const label_edit_slot = create_slot(label_edit_slot_template, ctx, ctx[13], get_label_edit_slot_context$1);
  return {
    c() {
      if (label_edit_slot)
        label_edit_slot.c();
    },
    m(target, anchor) {
      if (label_edit_slot) {
        label_edit_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_edit_slot) {
        if (label_edit_slot.p && (!current || dirty & 794688)) {
          update_slot_base(
            label_edit_slot,
            label_edit_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(label_edit_slot_template, ctx2[13], dirty, get_label_edit_slot_changes$1),
            get_label_edit_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_edit_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_edit_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_edit_slot)
        label_edit_slot.d(detaching);
    }
  };
}
function create_tvi_right_content_slot(ctx) {
  let current;
  const right_content_slot_template = ctx[10]["right-content"];
  const right_content_slot = create_slot(right_content_slot_template, ctx, ctx[13], get_right_content_slot_context);
  return {
    c() {
      if (right_content_slot)
        right_content_slot.c();
    },
    m(target, anchor) {
      if (right_content_slot) {
        right_content_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (right_content_slot) {
        if (right_content_slot.p && (!current || dirty & 8224)) {
          update_slot_base(
            right_content_slot,
            right_content_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(right_content_slot_template, ctx2[13], dirty, get_right_content_slot_changes),
            get_right_content_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(right_content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(right_content_slot, local);
      current = false;
    },
    d(detaching) {
      if (right_content_slot)
        right_content_slot.d(detaching);
    }
  };
}
function create_tvi_meta_expanded_view_slot(ctx) {
  let current;
  const meta_expanded_view_slot_template = ctx[10]["meta-expanded-view"];
  const meta_expanded_view_slot = create_slot(meta_expanded_view_slot_template, ctx, ctx[13], get_meta_expanded_view_slot_context$1);
  return {
    c() {
      if (meta_expanded_view_slot)
        meta_expanded_view_slot.c();
    },
    m(target, anchor) {
      if (meta_expanded_view_slot) {
        meta_expanded_view_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (meta_expanded_view_slot) {
        if (meta_expanded_view_slot.p && (!current || dirty & 8224)) {
          update_slot_base(
            meta_expanded_view_slot,
            meta_expanded_view_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(meta_expanded_view_slot_template, ctx2[13], dirty, get_meta_expanded_view_slot_changes$1),
            get_meta_expanded_view_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(meta_expanded_view_slot, local);
      current = true;
    },
    o(local) {
      transition_out(meta_expanded_view_slot, local);
      current = false;
    },
    d(detaching) {
      if (meta_expanded_view_slot)
        meta_expanded_view_slot.d(detaching);
    }
  };
}
function create_if_block$x(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$i, create_else_block$i];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[8])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$i(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[7];
  const get_key = (ctx2) => ctx2[15].id;
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$b(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$b(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 794815) {
        each_value = ctx2[7];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$b, each_1_anchor, get_each_context$b);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$i(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text("Loading...");
      set_style(div, "padding-left", "calc(" + (ctx[6].getNodeLevel() + 1) + "*16px - 4px)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 64) {
        set_style(div, "padding-left", "calc(" + (ctx2[6].getNodeLevel() + 1) + "*16px - 4px)");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_expandable_slot$1(ctx) {
  let current;
  const expandable_slot_template = ctx[10].expandable;
  const expandable_slot = create_slot(expandable_slot_template, ctx, ctx[13], get_expandable_slot_context_1);
  return {
    c() {
      if (expandable_slot)
        expandable_slot.c();
    },
    m(target, anchor) {
      if (expandable_slot) {
        expandable_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (expandable_slot) {
        if (expandable_slot.p && (!current || dirty & 8224)) {
          update_slot_base(
            expandable_slot,
            expandable_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(expandable_slot_template, ctx2[13], dirty, get_expandable_slot_changes_1),
            get_expandable_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable_slot, local);
      current = true;
    },
    o(local) {
      transition_out(expandable_slot, local);
      current = false;
    },
    d(detaching) {
      if (expandable_slot)
        expandable_slot.d(detaching);
    }
  };
}
function create_checkbox_slot$1(ctx) {
  let current;
  const checkbox_slot_template = ctx[10].checkbox;
  const checkbox_slot = create_slot(checkbox_slot_template, ctx, ctx[13], get_checkbox_slot_context_1);
  return {
    c() {
      if (checkbox_slot)
        checkbox_slot.c();
    },
    m(target, anchor) {
      if (checkbox_slot) {
        checkbox_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (checkbox_slot) {
        if (checkbox_slot.p && (!current || dirty & 8224)) {
          update_slot_base(
            checkbox_slot,
            checkbox_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(checkbox_slot_template, ctx2[13], dirty, get_checkbox_slot_changes_1),
            get_checkbox_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox_slot, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox_slot, local);
      current = false;
    },
    d(detaching) {
      if (checkbox_slot)
        checkbox_slot.d(detaching);
    }
  };
}
function create_icon_slot$2(ctx) {
  let current;
  const icon_slot_template = ctx[10].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[13], get_icon_slot_context_1);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 8224)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(icon_slot_template, ctx2[13], dirty, get_icon_slot_changes_1),
            get_icon_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_label_slot$g(ctx) {
  let current;
  const label_slot_template = ctx[10].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[13], get_label_slot_context_1);
  return {
    c() {
      if (label_slot)
        label_slot.c();
    },
    m(target, anchor) {
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 8224)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(label_slot_template, ctx2[13], dirty, get_label_slot_changes_1),
            get_label_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_label_edit_slot$1(ctx) {
  let current;
  const label_edit_slot_template = ctx[10]["label-edit"];
  const label_edit_slot = create_slot(label_edit_slot_template, ctx, ctx[13], get_label_edit_slot_context_1);
  return {
    c() {
      if (label_edit_slot)
        label_edit_slot.c();
    },
    m(target, anchor) {
      if (label_edit_slot) {
        label_edit_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_edit_slot) {
        if (label_edit_slot.p && (!current || dirty & 794656)) {
          update_slot_base(
            label_edit_slot,
            label_edit_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(label_edit_slot_template, ctx2[13], dirty, get_label_edit_slot_changes_1),
            get_label_edit_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_edit_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_edit_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_edit_slot)
        label_edit_slot.d(detaching);
    }
  };
}
function create_right_content_slot$1(ctx) {
  let current;
  const right_content_slot_template = ctx[10]["right-content"];
  const right_content_slot = create_slot(right_content_slot_template, ctx, ctx[13], get_right_content_slot_context_1);
  return {
    c() {
      if (right_content_slot)
        right_content_slot.c();
    },
    m(target, anchor) {
      if (right_content_slot) {
        right_content_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (right_content_slot) {
        if (right_content_slot.p && (!current || dirty & 8224)) {
          update_slot_base(
            right_content_slot,
            right_content_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(right_content_slot_template, ctx2[13], dirty, get_right_content_slot_changes_1),
            get_right_content_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(right_content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(right_content_slot, local);
      current = false;
    },
    d(detaching) {
      if (right_content_slot)
        right_content_slot.d(detaching);
    }
  };
}
function create_meta_expanded_view_slot$1(ctx) {
  let current;
  const meta_expanded_view_slot_template = ctx[10]["meta-expanded-view"];
  const meta_expanded_view_slot = create_slot(meta_expanded_view_slot_template, ctx, ctx[13], get_meta_expanded_view_slot_context_1);
  return {
    c() {
      if (meta_expanded_view_slot)
        meta_expanded_view_slot.c();
    },
    m(target, anchor) {
      if (meta_expanded_view_slot) {
        meta_expanded_view_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (meta_expanded_view_slot) {
        if (meta_expanded_view_slot.p && (!current || dirty & 8224)) {
          update_slot_base(
            meta_expanded_view_slot,
            meta_expanded_view_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(meta_expanded_view_slot_template, ctx2[13], dirty, get_meta_expanded_view_slot_changes_1),
            get_meta_expanded_view_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(meta_expanded_view_slot, local);
      current = true;
    },
    o(local) {
      transition_out(meta_expanded_view_slot, local);
      current = false;
    },
    d(detaching) {
      if (meta_expanded_view_slot)
        meta_expanded_view_slot.d(detaching);
    }
  };
}
function create_each_block$b(key_1, ctx) {
  let first;
  let treenode;
  let current;
  treenode = new TreeNode({
    props: {
      node: ctx[15],
      showIcon: ctx[1],
      size: ctx[4],
      action: ctx[0],
      showMeta: ctx[3],
      showRoot: ctx[2],
      $$slots: {
        "meta-expanded-view": [
          create_meta_expanded_view_slot$1,
          ({ node }) => ({ 5: node }),
          ({ node }) => node ? 32 : 0
        ],
        "right-content": [
          create_right_content_slot$1,
          ({ node }) => ({ 5: node }),
          ({ node }) => node ? 32 : 0
        ],
        "label-edit": [
          create_label_edit_slot$1,
          ({ handleKeyDownEventForLabelEditor, closeLabelEditor, node }) => ({
            18: handleKeyDownEventForLabelEditor,
            19: closeLabelEditor,
            5: node
          }),
          ({ handleKeyDownEventForLabelEditor, closeLabelEditor, node }) => (handleKeyDownEventForLabelEditor ? 262144 : 0) | (closeLabelEditor ? 524288 : 0) | (node ? 32 : 0)
        ],
        label: [
          create_label_slot$g,
          ({ node }) => ({ 5: node }),
          ({ node }) => node ? 32 : 0
        ],
        icon: [
          create_icon_slot$2,
          ({ node }) => ({ 5: node }),
          ({ node }) => node ? 32 : 0
        ],
        checkbox: [
          create_checkbox_slot$1,
          ({ node }) => ({ 5: node }),
          ({ node }) => node ? 32 : 0
        ],
        expandable: [
          create_expandable_slot$1,
          ({ node }) => ({ 5: node }),
          ({ node }) => node ? 32 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  treenode.$on("click", ctx[12]);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(treenode.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(treenode, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const treenode_changes = {};
      if (dirty & 128)
        treenode_changes.node = ctx[15];
      if (dirty & 2)
        treenode_changes.showIcon = ctx[1];
      if (dirty & 16)
        treenode_changes.size = ctx[4];
      if (dirty & 1)
        treenode_changes.action = ctx[0];
      if (dirty & 8)
        treenode_changes.showMeta = ctx[3];
      if (dirty & 4)
        treenode_changes.showRoot = ctx[2];
      if (dirty & 794656) {
        treenode_changes.$$scope = { dirty, ctx };
      }
      treenode.$set(treenode_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treenode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treenode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(treenode, detaching);
    }
  };
}
function create_fragment$19(ctx) {
  let t;
  let show_if = ctx[6].isExpanded();
  let if_block1_anchor;
  let current;
  let if_block0 = (ctx[9] && ctx[2] || !ctx[9]) && create_if_block_2$a(ctx);
  let if_block1 = show_if && create_if_block$x(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[9] && ctx2[2] || !ctx2[9]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 516) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$a(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & 64)
        show_if = ctx2[6].isExpanded();
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$x(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$19($$self, $$props, $$invalidate) {
  let _root;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(6, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { action } = $$props;
  let { showIcon } = $$props;
  let { showRoot = true } = $$props;
  let { showMeta = true } = $$props;
  let { size = "medium" } = $$props;
  let children = [];
  let loading = false;
  async function getChildren(node2) {
    if (node2.isExpanded()) {
      if (children.length === 0) {
        $$invalidate(8, loading = true);
      }
      $$invalidate(7, children = await node2.getChildren());
      $$invalidate(8, loading = false);
    } else {
      $$invalidate(7, children = []);
    }
  }
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(5, node = $$props2.node));
    if ("action" in $$props2)
      $$invalidate(0, action = $$props2.action);
    if ("showIcon" in $$props2)
      $$invalidate(1, showIcon = $$props2.showIcon);
    if ("showRoot" in $$props2)
      $$invalidate(2, showRoot = $$props2.showRoot);
    if ("showMeta" in $$props2)
      $$invalidate(3, showMeta = $$props2.showMeta);
    if ("size" in $$props2)
      $$invalidate(4, size = $$props2.size);
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      $$invalidate(9, _root = $node.isRoot());
    }
    if ($$self.$$.dirty & 64) {
      getChildren($node);
    }
  };
  return [
    action,
    showIcon,
    showRoot,
    showMeta,
    size,
    node,
    $node,
    children,
    loading,
    _root,
    slots,
    click_handler2,
    click_handler_1,
    $$scope
  ];
}
class TreeNode extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$19, create_fragment$19, safe_not_equal, {
      node: 5,
      action: 0,
      showIcon: 1,
      showRoot: 2,
      showMeta: 3,
      size: 4
    });
  }
}
function create_fragment$18(ctx) {
  let svg;
  let path;
  let svg_style_value;
  let mounted;
  let dispose;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z");
      attr(path, "clip-rule", "evenodd");
      attr(svg, "class", ctx[3]);
      attr(svg, "style", svg_style_value = "transition: transform 100ms; " + ctx[2]);
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "fill", "currentColor");
      set_style(svg, "transform", ctx[0] ? "rotate(90deg)" : "");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      if (!mounted) {
        dispose = listen(svg, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 8) {
        attr(svg, "class", ctx2[3]);
      }
      if (dirty & 4 && svg_style_value !== (svg_style_value = "transition: transform 100ms; " + ctx2[2])) {
        attr(svg, "style", svg_style_value);
      }
      const style_changed = dirty & 4;
      if (style_changed || dirty & 5) {
        set_style(svg, "transform", ctx2[0] ? "rotate(90deg)" : "");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
      mounted = false;
      dispose();
    }
  };
}
function instance$18($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(5, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  const dispatch = createEventDispatcher();
  let { node } = $$props;
  $$subscribe_node();
  let { expanded } = $$props;
  let { style = "" } = $$props;
  let { class: clazz = "" } = $$props;
  function click() {
    $$invalidate(0, expanded = !expanded);
    if (node) {
      node.setExpanded(expanded);
    }
    dispatch("expanded", { expanded, node });
  }
  const click_handler2 = (e) => click();
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(1, node = $$props2.node));
    if ("expanded" in $$props2)
      $$invalidate(0, expanded = $$props2.expanded);
    if ("style" in $$props2)
      $$invalidate(2, style = $$props2.style);
    if ("class" in $$props2)
      $$invalidate(3, clazz = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 34) {
      node && $$invalidate(0, expanded = $node.isExpanded());
    }
  };
  return [expanded, node, style, clazz, click, $node, click_handler2];
}
class Expandable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$18, create_fragment$18, safe_not_equal, { node: 1, expanded: 0, style: 2, class: 3 });
  }
}
Object.freeze({
  none: "none",
  single: "single",
  multi: "multi"
});
const CheckState = Object.freeze({
  none: "none",
  indeterminate: "indeterminate",
  selected: "selected"
});
function create_fragment$17(ctx) {
  let input_1;
  let mounted;
  let dispose;
  return {
    c() {
      input_1 = element("input");
      attr(input_1, "class", "");
      input_1.checked = ctx[2];
      attr(input_1, "type", "checkbox");
      attr(input_1, "tabindex", "-1");
      input_1.disabled = ctx[0];
    },
    m(target, anchor) {
      insert(target, input_1, anchor);
      ctx[5](input_1);
      if (!mounted) {
        dispose = listen(input_1, "click", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        input_1.checked = ctx2[2];
      }
      if (dirty & 1) {
        input_1.disabled = ctx2[0];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(input_1);
      ctx[5](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$17($$self, $$props, $$invalidate) {
  let checked;
  let { disabled = false } = $$props;
  let { node } = $$props;
  let input;
  const dispatch = createEventDispatcher();
  onMount(() => {
    $$invalidate(1, input.indeterminate = node.checkState === CheckState.indeterminate, input);
  });
  function click(e) {
    $$invalidate(2, checked = !checked);
    $$invalidate(4, node.checkState = checked ? CheckState.selected : CheckState.none, node);
    dispatch("checked", { checked, node });
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(1, input), $$invalidate(4, node);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(0, disabled = $$props2.disabled);
    if ("node" in $$props2)
      $$invalidate(4, node = $$props2.node);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $$invalidate(2, checked = node.checkState === CheckState.none ? false : true);
    }
    if ($$self.$$.dirty & 18) {
      if (input) {
        $$invalidate(1, input.indeterminate = node.checkState === CheckState.indeterminate, input);
      }
    }
  };
  return [disabled, input, checked, click, node, input_1_binding];
}
class Checkbox extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$17, create_fragment$17, safe_not_equal, { disabled: 0, node: 4 });
  }
}
function classes(...classArray) {
  if (!classArray)
    return "";
  return classArray.filter((cls) => !!cls).join(" ");
}
const get_expandable_slot_changes = (dirty) => ({ node: dirty & 524288 });
const get_expandable_slot_context = (ctx) => ({ node: ctx[19] });
const get_checkbox_slot_changes = (dirty) => ({ node: dirty & 524288 });
const get_checkbox_slot_context = (ctx) => ({ node: ctx[19] });
const get_icon_slot_changes$2 = (dirty) => ({ node: dirty & 524288 });
const get_icon_slot_context$2 = (ctx) => ({ slot: "icon", node: ctx[19] });
const get_label_slot_changes$4 = (dirty) => ({ node: dirty & 524288 });
const get_label_slot_context$4 = (ctx) => ({ slot: "label", node: ctx[19] });
const get_label_edit_slot_changes = (dirty) => ({
  node: dirty & 524288,
  closeLabelEditor: dirty & 2097152,
  handleKeyDownEventForLabelEditor: dirty & 1048576
});
const get_label_edit_slot_context = (ctx) => ({
  slot: "label-edit",
  node: ctx[19],
  closeLabelEditor: ctx[21],
  handleKeyDownEventForLabelEditor: ctx[20]
});
const get_meta_slot_changes = (dirty) => ({ node: dirty & 524288 });
const get_meta_slot_context = (ctx) => ({
  slot: "right-content",
  node: ctx[19]
});
const get_meta_expanded_view_slot_changes = (dirty) => ({ node: dirty & 524288 });
const get_meta_expanded_view_slot_context = (ctx) => ({
  slot: "meta-expanded-view",
  node: ctx[19]
});
function create_if_block_1$h(ctx) {
  let current;
  const expandable_slot_template = ctx[13].expandable;
  const expandable_slot = create_slot(expandable_slot_template, ctx, ctx[14], get_expandable_slot_context);
  const expandable_slot_or_fallback = expandable_slot || fallback_block_3(ctx);
  return {
    c() {
      if (expandable_slot_or_fallback)
        expandable_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (expandable_slot_or_fallback) {
        expandable_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (expandable_slot) {
        if (expandable_slot.p && (!current || dirty & 540672)) {
          update_slot_base(
            expandable_slot,
            expandable_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(expandable_slot_template, ctx2[14], dirty, get_expandable_slot_changes),
            get_expandable_slot_context
          );
        }
      } else {
        if (expandable_slot_or_fallback && expandable_slot_or_fallback.p && (!current || dirty & 524288)) {
          expandable_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(expandable_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (expandable_slot_or_fallback)
        expandable_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block_3(ctx) {
  let expandable;
  let current;
  expandable = new Expandable({
    props: { node: ctx[19], class: "tv-svg" }
  });
  expandable.$on("expanded", ctx[11]);
  return {
    c() {
      create_component(expandable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expandable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const expandable_changes = {};
      if (dirty & 524288)
        expandable_changes.node = ctx2[19];
      expandable.$set(expandable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expandable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expandable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expandable, detaching);
    }
  };
}
function create_expandable_slot(ctx) {
  let show_if = ctx[19].isExpandable();
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_1$h(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 524288)
        show_if = ctx2[19].isExpandable();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 524288) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$h(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$w(ctx) {
  let current;
  const checkbox_slot_template = ctx[13].checkbox;
  const checkbox_slot = create_slot(checkbox_slot_template, ctx, ctx[14], get_checkbox_slot_context);
  const checkbox_slot_or_fallback = checkbox_slot || fallback_block_2(ctx);
  return {
    c() {
      if (checkbox_slot_or_fallback)
        checkbox_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (checkbox_slot_or_fallback) {
        checkbox_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (checkbox_slot) {
        if (checkbox_slot.p && (!current || dirty & 540672)) {
          update_slot_base(
            checkbox_slot,
            checkbox_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(checkbox_slot_template, ctx2[14], dirty, get_checkbox_slot_changes),
            get_checkbox_slot_context
          );
        }
      } else {
        if (checkbox_slot_or_fallback && checkbox_slot_or_fallback.p && (!current || dirty & 524288)) {
          checkbox_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (checkbox_slot_or_fallback)
        checkbox_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block_2(ctx) {
  let checkbox;
  let current;
  checkbox = new Checkbox({
    props: {
      node: ctx[19],
      disabled: ctx[19].isDisabled()
    }
  });
  checkbox.$on("checked", ctx[8]);
  return {
    c() {
      create_component(checkbox.$$.fragment);
    },
    m(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & 524288)
        checkbox_changes.node = ctx2[19];
      if (dirty & 524288)
        checkbox_changes.disabled = ctx2[19].isDisabled();
      checkbox.$set(checkbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
}
function create_checkbox_slot(ctx) {
  let show_if = ctx[19].isCheckable();
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block$w(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 524288)
        show_if = ctx2[19].isCheckable();
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 524288) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$w(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_icon_slot$1(ctx) {
  let current;
  const icon_slot_template = ctx[13].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[14], get_icon_slot_context$2);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 540672)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(icon_slot_template, ctx2[14], dirty, get_icon_slot_changes$2),
            get_icon_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function fallback_block_1(ctx) {
  let t_value = ctx[19].label + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 524288 && t_value !== (t_value = ctx2[19].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_label_slot$f(ctx) {
  let current;
  const label_slot_template = ctx[13].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[14], get_label_slot_context$4);
  const label_slot_or_fallback = label_slot || fallback_block_1(ctx);
  return {
    c() {
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 540672)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(label_slot_template, ctx2[14], dirty, get_label_slot_changes$4),
            get_label_slot_context$4
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & 524288)) {
          label_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
    }
  };
}
function create_label_edit_slot(ctx) {
  let current;
  const label_edit_slot_template = ctx[13]["label-edit"];
  const label_edit_slot = create_slot(label_edit_slot_template, ctx, ctx[14], get_label_edit_slot_context);
  return {
    c() {
      if (label_edit_slot)
        label_edit_slot.c();
    },
    m(target, anchor) {
      if (label_edit_slot) {
        label_edit_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_edit_slot) {
        if (label_edit_slot.p && (!current || dirty & 3686400)) {
          update_slot_base(
            label_edit_slot,
            label_edit_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(label_edit_slot_template, ctx2[14], dirty, get_label_edit_slot_changes),
            get_label_edit_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_edit_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_edit_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_edit_slot)
        label_edit_slot.d(detaching);
    }
  };
}
function create_right_content_slot(ctx) {
  let current;
  const meta_slot_template = ctx[13].meta;
  const meta_slot = create_slot(meta_slot_template, ctx, ctx[14], get_meta_slot_context);
  return {
    c() {
      if (meta_slot)
        meta_slot.c();
    },
    m(target, anchor) {
      if (meta_slot) {
        meta_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (meta_slot) {
        if (meta_slot.p && (!current || dirty & 540672)) {
          update_slot_base(
            meta_slot,
            meta_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(meta_slot_template, ctx2[14], dirty, get_meta_slot_changes),
            get_meta_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(meta_slot, local);
      current = true;
    },
    o(local) {
      transition_out(meta_slot, local);
      current = false;
    },
    d(detaching) {
      if (meta_slot)
        meta_slot.d(detaching);
    }
  };
}
function create_meta_expanded_view_slot(ctx) {
  let current;
  const meta_expanded_view_slot_template = ctx[13]["meta-expanded-view"];
  const meta_expanded_view_slot = create_slot(meta_expanded_view_slot_template, ctx, ctx[14], get_meta_expanded_view_slot_context);
  return {
    c() {
      if (meta_expanded_view_slot)
        meta_expanded_view_slot.c();
    },
    m(target, anchor) {
      if (meta_expanded_view_slot) {
        meta_expanded_view_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (meta_expanded_view_slot) {
        if (meta_expanded_view_slot.p && (!current || dirty & 540672)) {
          update_slot_base(
            meta_expanded_view_slot,
            meta_expanded_view_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(meta_expanded_view_slot_template, ctx2[14], dirty, get_meta_expanded_view_slot_changes),
            get_meta_expanded_view_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(meta_expanded_view_slot, local);
      current = true;
    },
    o(local) {
      transition_out(meta_expanded_view_slot, local);
      current = false;
    },
    d(detaching) {
      if (meta_expanded_view_slot)
        meta_expanded_view_slot.d(detaching);
    }
  };
}
function create_fragment$16(ctx) {
  let div;
  let treenode;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  treenode = new TreeNode({
    props: {
      node: ctx[7],
      size: ctx[4],
      showIcon: ctx[3] && ctx[12].icon,
      action: ctx[1],
      showMeta: ctx[5],
      showRoot: ctx[2],
      $$slots: {
        "meta-expanded-view": [
          create_meta_expanded_view_slot,
          ({ node }) => ({ 19: node }),
          ({ node }) => node ? 524288 : 0
        ],
        "right-content": [
          create_right_content_slot,
          ({ node }) => ({ 19: node }),
          ({ node }) => node ? 524288 : 0
        ],
        "label-edit": [
          create_label_edit_slot,
          ({ handleKeyDownEventForLabelEditor, closeLabelEditor, node }) => ({
            20: handleKeyDownEventForLabelEditor,
            21: closeLabelEditor,
            19: node
          }),
          ({ handleKeyDownEventForLabelEditor, closeLabelEditor, node }) => (handleKeyDownEventForLabelEditor ? 1048576 : 0) | (closeLabelEditor ? 2097152 : 0) | (node ? 524288 : 0)
        ],
        label: [
          create_label_slot$f,
          ({ node }) => ({ 19: node }),
          ({ node }) => node ? 524288 : 0
        ],
        icon: [
          create_icon_slot$1,
          ({ node }) => ({ 19: node }),
          ({ node }) => node ? 524288 : 0
        ],
        checkbox: [
          create_checkbox_slot,
          ({ node }) => ({ 19: node }),
          ({ node }) => node ? 524288 : 0
        ],
        expandable: [
          create_expandable_slot,
          ({ node }) => ({ 19: node }),
          ({ node }) => node ? 524288 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  treenode.$on("click", ctx[10]);
  return {
    c() {
      div = element("div");
      create_component(treenode.$$.fragment);
      attr(div, "class", div_class_value = classes(ctx[6]));
      attr(div, "role", "tree");
      attr(div, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(treenode, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(div, "keydown", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const treenode_changes = {};
      if (dirty & 128)
        treenode_changes.node = ctx2[7];
      if (dirty & 16)
        treenode_changes.size = ctx2[4];
      if (dirty & 4104)
        treenode_changes.showIcon = ctx2[3] && ctx2[12].icon;
      if (dirty & 2)
        treenode_changes.action = ctx2[1];
      if (dirty & 32)
        treenode_changes.showMeta = ctx2[5];
      if (dirty & 4)
        treenode_changes.showRoot = ctx2[2];
      if (dirty & 3686400) {
        treenode_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treenode.$set(treenode_changes);
      if (!current || dirty & 64 && div_class_value !== (div_class_value = classes(ctx2[6]))) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(treenode.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treenode.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(treenode);
      mounted = false;
      dispose();
    }
  };
}
function instance$16($$self, $$props, $$invalidate) {
  let $root, $$unsubscribe_root = noop, $$subscribe_root = () => ($$unsubscribe_root(), $$unsubscribe_root = subscribe$1(root, ($$value) => $$invalidate(7, $root = $$value)), root);
  $$self.$$.on_destroy.push(() => $$unsubscribe_root());
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { root } = $$props;
  $$subscribe_root();
  let { nodeAction = () => ({}) } = $$props;
  let { showRoot = true } = $$props;
  let { showIcon = true } = $$props;
  let { size = "medium" } = $$props;
  let { showMeta = true } = $$props;
  let { class: _class = "" } = $$props;
  let selectedNode = null;
  function onChecked(e) {
    let { checked, node } = e.detail;
    if (checked) {
      node.checkAll(CheckState.selected);
    } else {
      node.checkAll(CheckState.none);
    }
    dispatch("check", { checked, node });
  }
  function selectNext() {
    if (!selectedNode) {
      selectedNode = root;
      selectedNode.setSelected(true);
      dispatch("select", { node: selectedNode });
    } else {
      const nextNode = selectedNode.selectNext();
      if (nextNode) {
        selectedNode = nextNode;
        dispatch("select", { node: selectedNode });
      }
    }
  }
  function selectPrevious() {
    if (!selectedNode) {
      selectedNode = root;
      selectedNode.setSelected(true);
      dispatch("select", { node: selectedNode });
    } else {
      const nextNode = selectedNode.selectPrevious();
      if (nextNode) {
        selectedNode = nextNode;
        dispatch("select", { node: selectedNode });
      }
    }
  }
  function onKeypress(e) {
    let { key } = e;
    if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
      return;
    }
    if (key === "ArrowDown") {
      selectNext();
    } else if (key === "ArrowUp") {
      selectPrevious();
    } else if (key === "ArrowLeft") {
      if (!selectedNode) {
        return;
      }
      selectedNode.setExpanded(false);
      dispatch("expand", { expanded: false, node: selectedNode });
    } else if (key === "ArrowRight") {
      if (!selectedNode) {
        return;
      }
      if (selectedNode.isExpandable()) {
        selectedNode.setExpanded(true);
        dispatch("expand", { expanded: true, node: selectedNode });
      }
    } else if (key === "Space") {
      if (!selectedNode) {
        return;
      }
      onChecked({
        detail: {
          checked: selectedNode.checkState === CheckState.none,
          node: selectedNode
        }
      });
    }
  }
  function onClick(e) {
    let { node } = e.detail;
    if (node.isExpandable()) {
      node.setExpanded(!node.isExpanded());
      dispatch("expand", { expanded: node.isExpanded(), node });
    }
    if (!node.isDisabled() && node.isSelectable()) {
      if (selectedNode === node)
        return;
      if (selectedNode)
        selectedNode.setSelected(false);
      selectedNode = node;
      if (!node.selected) {
        node.setSelected(true);
      }
      dispatch("select", { node });
    }
  }
  function onExpand(e) {
    dispatch("expand", {
      expanded: e.detail.expanded,
      node: e.detail.node
    });
  }
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$subscribe_root($$invalidate(0, root = $$props2.root));
    if ("nodeAction" in $$props2)
      $$invalidate(1, nodeAction = $$props2.nodeAction);
    if ("showRoot" in $$props2)
      $$invalidate(2, showRoot = $$props2.showRoot);
    if ("showIcon" in $$props2)
      $$invalidate(3, showIcon = $$props2.showIcon);
    if ("size" in $$props2)
      $$invalidate(4, size = $$props2.size);
    if ("showMeta" in $$props2)
      $$invalidate(5, showMeta = $$props2.showMeta);
    if ("class" in $$props2)
      $$invalidate(6, _class = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(0, root.disabled = !showRoot, root);
    }
  };
  return [
    root,
    nodeAction,
    showRoot,
    showIcon,
    size,
    showMeta,
    _class,
    $root,
    onChecked,
    onKeypress,
    onClick,
    onExpand,
    $$slots,
    slots,
    $$scope
  ];
}
class TreeView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$16, create_fragment$16, safe_not_equal, {
      root: 0,
      nodeAction: 1,
      showRoot: 2,
      showIcon: 3,
      size: 4,
      showMeta: 5,
      class: 6
    });
  }
}
class BaseNode {
  constructor(id, label, parent2 = null) {
    __publicField(this, "_showExpandedMetaView", false);
    if (this.constructor === BaseNode) {
      throw new Error("unable to instantiate the abstract class");
    }
    this.id = id;
    this.label = label;
    this.children = null;
    this.parent = parent2;
    this._expanded = false;
    this.selected = false;
    this.checkState = CheckState.none;
    this.listeners = [];
    this.checkable = false;
    this.disabled = false;
    this.selectable = false;
    this.loading = false;
  }
  subscribe(listener) {
    this.listeners.push(listener);
    listener(this);
    return () => {
      this.listeners.splice(this.listeners.indexOf(listener), 1);
    };
  }
  notify() {
    for (let listener of this.listeners) {
      listener(this);
    }
  }
  getId() {
    return this.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(label) {
    this.label = label;
    this.notify();
  }
  getChildCount() {
    return this.children ? this.children.length : 0;
  }
  async getChildren() {
    return this.children ? this.children : [];
  }
  setChildren(children) {
    this.children = children;
  }
  pushChild(child) {
    this.children.push(child);
  }
  getParent() {
    return this.parent;
  }
  setParent(parent2) {
    this.parent = parent2;
  }
  isExpanded() {
    return this._expanded;
  }
  setExpanded(state) {
    if (this.isExpandable() && this._expanded !== state) {
      this._expanded = state;
      this.notify();
    }
    if (state && this.parent) {
      this.parent.setExpanded(true);
    }
  }
  isExpandable() {
    return this.children ? this.children.length > 0 : false;
  }
  isSelectable() {
    return this.selectable && !this.disabled;
  }
  setSelectable(selectable) {
    this.selectable = selectable;
  }
  isLabelEditable() {
    return false;
  }
  editLabel(newLabelValue) {
  }
  getCheckState() {
    return this.checkState;
  }
  setCheckState(checkState) {
    this.checkState = checkState;
    this.notify();
  }
  isDisabled() {
    return this.disabled;
  }
  setDisabled(disabled) {
    this.disabled = disabled;
  }
  isCheckable() {
    return this.checkable && !this.disabled;
  }
  setCheckable(checkable) {
    this.checkable = checkable;
  }
  isLoading() {
    return this.loading;
  }
  setLoading(state) {
    this.loading = state;
    this.notify();
  }
  isRoot() {
    return !this.parent;
  }
  getRoot() {
    let node = this;
    let root = node;
    while (node.parent) {
      root = node.parent;
      node = node.parent;
    }
    return root;
  }
  checkAllChild(state) {
    this.checkState = state;
    if (!this.children) {
      return;
    }
    for (let child of this.children) {
      child.checkState = state;
      child.checkAllChild(state);
    }
  }
  checkAllParent(state) {
    if (this.parent === null)
      return;
    let siblings = this.getSiblings();
    let countOfNone = 0, partial = false;
    const checkableSiblings = siblings.filter((s) => s.isCheckable());
    for (let sibling of checkableSiblings) {
      if (sibling.checkState === CheckState.none) {
        countOfNone++;
      } else if (sibling.checkState === CheckState.indeterminate) {
        partial = true;
        break;
      }
    }
    if (partial || countOfNone > 0 && countOfNone < checkableSiblings.length) {
      this.parent.checkState = CheckState.indeterminate;
    } else if (countOfNone === 0) {
      this.parent.checkState = CheckState.selected;
    } else {
      this.parent.checkState = CheckState.none;
    }
    this.parent.checkAllParent(state);
  }
  checkAll(state) {
    this.checkAllChild(state);
    this.checkAllParent(state);
    this.checkState = state;
    this.getRoot().notify();
  }
  expandedAll(state, root) {
    root._expanded = state;
    for (let child of parent.children) {
      child._expanded = state;
      this.expandedAll(state, child);
    }
    this.notify();
  }
  getSelected() {
    return this.selected;
  }
  setSelected(selected) {
    this.selected = selected;
    this.notify();
  }
  getSiblings() {
    if (this.parent === null)
      return null;
    if (this.parent.getChildCount() > 0)
      return this.parent.children;
    return null;
  }
  findNextSibling() {
    let siblings = this.getSiblings();
    if (!siblings)
      return null;
    const index = siblings.indexOf(this);
    return siblings[index + 1] || this.parent.findNextSibling();
  }
  findPreviousSibling() {
    let siblings = this.getSiblings();
    if (!siblings)
      return null;
    const index = siblings.indexOf(this);
    return siblings[index - 1] || null;
  }
  findInnermostChild() {
    let childCount = this.getChildCount();
    if (childCount === 0 || (!this.isExpanded() || this.isLoading()))
      return this;
    return this.children[childCount - 1].findInnermostChild();
  }
  selectNext() {
    let next;
    if (this.isExpanded() && !this.isLoading() && this.getChildCount() > 0) {
      next = this.children[0];
    } else {
      next = this.findNextSibling();
    }
    if (!next) {
      return null;
    } else if (next.isSelectable()) {
      this.setSelected(false);
      next.setSelected(true);
      return next;
    } else {
      next = next.selectNext();
      if (next) {
        this.setSelected(false);
        return next;
      } else {
        return null;
      }
    }
  }
  selectPrevious() {
    let previous;
    let previousSibling = this.findPreviousSibling();
    if (previousSibling) {
      if (previousSibling.isExpanded() && !previousSibling.isLoading()) {
        previous = previousSibling.findInnermostChild();
      } else {
        previous = previousSibling;
      }
    } else {
      previous = this.parent;
    }
    if (!previous) {
      return null;
    } else if (previous.isSelectable()) {
      this.setSelected(false);
      previous.setSelected(true);
      return previous;
    } else {
      const selectedAncestor = previous.selectPrevious();
      if (selectedAncestor) {
        this.setSelected(false);
        return selectedAncestor;
      } else {
        return null;
      }
    }
  }
  getNodeLevel() {
    if (!this.parent)
      return 0;
    return 1 + this.parent.getNodeLevel();
  }
  set showExpandedMetaView(value) {
    this._showExpandedMetaView = value;
    this.notify();
  }
  get showExpandedMetaView() {
    return this._showExpandedMetaView;
  }
}
var recorder = "";
var Feature;
(function(Feature2) {
  Feature2["command"] = "command";
  Feature2["stream_dom"] = "stream_dom";
  Feature2["state"] = "state";
  Feature2["stream_video"] = "video";
})(Feature || (Feature = {}));
var DocumentState;
(function(DocumentState2) {
  DocumentState2["REQUESTED"] = "requested";
  DocumentState2["RECEIVED"] = "received";
  DocumentState2["LOADED"] = "loaded";
  DocumentState2["FAILED"] = "failed";
})(DocumentState || (DocumentState = {}));
var EventNames;
(function(EventNames2) {
  EventNames2["BROADCAST"] = "BS";
  EventNames2["ALL"] = "all";
  EventNames2["DOM_STREAM"] = "DS";
  EventNames2["WEBRTC_STREAM"] = "WS";
  EventNames2["FRAME_DEL"] = "frame:del";
  EventNames2["FRAME_NEW"] = "frame:new";
  EventNames2["FRAME_UPDATE"] = "frame:update";
  EventNames2["PAGE_DEL"] = "page:del";
  EventNames2["PAGE_NEW"] = "page:new";
  EventNames2["PAGE_UPDATE"] = "page:update";
  EventNames2["VIEWPORT"] = "viewport";
  EventNames2["EXTENSIONS"] = "extensions";
  EventNames2["MSG_EVENT"] = "EV";
  EventNames2["MSG_REQUEST"] = "RQ";
  EventNames2["MSG_RESPONSE"] = "RS";
  EventNames2["MSG_STATE"] = "ST";
  EventNames2["TOPIC_SUBSCRIBE"] = "topic:subscribe";
  EventNames2["TOPIC_UNSUBSCRIBE"] = "topic:unsubscribe";
  EventNames2["CHANGE"] = "change";
})(EventNames || (EventNames = {}));
var OPS;
(function(OPS2) {
  OPS2["CREATE"] = "create";
  OPS2["UPDATE"] = "update";
  OPS2["DELETE"] = "delete";
})(OPS || (OPS = {}));
var StreamTypes;
(function(StreamTypes2) {
  StreamTypes2["AUDIO"] = "audio";
  StreamTypes2["VIDEO"] = "video";
  StreamTypes2["CANVAS"] = "canvas";
})(StreamTypes || (StreamTypes = {}));
var SignalEvent;
(function(SignalEvent2) {
  SignalEvent2["STREAM_VIDEO"] = "stream-video";
  SignalEvent2["MAP_ELEMENT"] = "map-element";
  SignalEvent2["ADD_PEER"] = "add-peer";
  SignalEvent2["CLIENT_CANDIDATE"] = "client-candidate";
  SignalEvent2["CLIENT_DESCRIPTION"] = "client-description";
  SignalEvent2["SERVER_CANDIDATE"] = "server-candidate";
  SignalEvent2["SERVER_DESCRIPTION"] = "server-description";
  SignalEvent2["REMOVE_PEER"] = "remove-peer";
  SignalEvent2["DISCONNECT_ALL"] = "disconnect-all";
})(SignalEvent || (SignalEvent = {}));
var DiffOp;
(function(DiffOp2) {
  DiffOp2[DiffOp2["DEL"] = -1] = "DEL";
  DiffOp2[DiffOp2["INS"] = 1] = "INS";
  DiffOp2[DiffOp2["NOOP"] = 0] = "NOOP";
  DiffOp2[DiffOp2["MOV"] = 2] = "MOV";
})(DiffOp || (DiffOp = {}));
var DocumentContentType;
(function(DocumentContentType2) {
  DocumentContentType2["JSON"] = "application/json";
  DocumentContentType2["HTML"] = "text/html";
})(DocumentContentType || (DocumentContentType = {}));
var Severity;
(function(Severity2) {
  Severity2["Fatal"] = "fatal";
  Severity2["Error"] = "error";
  Severity2["Warning"] = "warning";
  Severity2["Log"] = "log";
  Severity2["Info"] = "info";
  Severity2["Debug"] = "debug";
  Severity2["Critical"] = "critical";
})(Severity || (Severity = {}));
class BBXErrorEvent {
  constructor(e, type) {
    this.name = "BBXErrorEvent";
    this.metadata = {};
    this.source = "bbx-client";
    this.breadcrumbs = [];
    this.message = e.message;
    if (e.stack) {
      this.stack = e.stack;
    }
    if (type) {
      this.type = type;
    }
  }
  setPreviousEvents(crumbs) {
    this.breadcrumbs = crumbs.flatten();
    this.breadcrumbs.sort((a, b) => {
      return a.timestamp > b.timestamp ? 1 : -1;
    });
  }
}
class DOMEventError extends BBXErrorEvent {
  constructor(e, type, url, isMainFrame = false) {
    super(e, type);
    this.name = "DOMEventError";
    if (url) {
      this.metadata["url"] = url;
    }
    this.metadata["isMainFrame"] = isMainFrame;
  }
}
class AppliedDOMStreamEvent {
  constructor(event, start, err) {
    this.executions = [];
    this.event = event;
    this.add(start, err);
  }
  add(start, err) {
    this.executions.push({
      start,
      end: new Date(),
      err
    });
  }
  toBreadCrumb() {
    const breadcrumb = {
      category: this.event.name,
      timestamp: this.executions[0].start.getTime() / 1e3,
      data: {
        count: this.executions.length,
        start: this.executions[0].start,
        end: this.executions[this.executions.length - 1].end
      }
    };
    for (let i = 0; i < this.executions.length; i++) {
      let exec = this.executions[i];
      if (exec.err) {
        breadcrumb.message || (breadcrumb.message = exec.err.message);
        breadcrumb.data[i] = exec.err.message;
        breadcrumb.level || (breadcrumb.level = Severity.Error);
      }
    }
    return breadcrumb;
  }
}
class AppliedDOMStreamEvents {
  constructor(maxLength) {
    this.maxLength = 15;
    this.events = [];
    this.maxLength = maxLength;
  }
  push(event, startTime, err = void 0) {
    const lastAppliedEvent = this.events[this.events.length - 1];
    if (lastAppliedEvent && lastAppliedEvent.event.name === event.name) {
      lastAppliedEvent.add(startTime, err);
      return;
    }
    if (this.events.length === this.maxLength) {
      this.events.shift();
    }
    this.events.push(new AppliedDOMStreamEvent(event, startTime, err));
  }
  flatten() {
    const breadcrumbs = [];
    this.events.map((e) => {
      return e.toBreadCrumb();
    }).forEach((crumb) => {
      breadcrumbs.push(crumb);
    });
    return breadcrumbs;
  }
}
class EventEmitter$1 {
  constructor() {
    this.__ee_listeners = {};
  }
  emit(name, ...args) {
    (this.__ee_listeners[name] || []).forEach((l) => l(...args));
  }
  hasListener(name) {
    return (this.__ee_listeners[name] || []).length > 0;
  }
  off(name, listener) {
    let listeners = this.__ee_listeners[name];
    if (listeners == void 0) {
      listeners = this.__ee_listeners[name] = [];
    }
    let index = listeners.indexOf(listener);
    while (index >= 0) {
      listeners.splice(index, 1);
      index = listeners.indexOf(listener);
    }
    return this;
  }
  on(name, listener) {
    let listeners = this.__ee_listeners[name];
    if (listeners == void 0) {
      listeners = this.__ee_listeners[name] = [];
    }
    listeners.push(listener);
    return this;
  }
  once(name, listener) {
    const l2 = (...args) => {
      this.off(name, l2);
      listener(...args);
    };
    this.on(name, l2);
    return this;
  }
  reset() {
    this.__ee_listeners = [];
  }
  waitForEvent(name, opts) {
    return new Promise((resolve, reject) => {
      const onEvent = (evtData) => {
        if (opts == null ? void 0 : opts.cond) {
          if (opts.cond(evtData)) {
            this.off(name, onEvent);
            resolve(evtData);
          }
          return;
        }
        this.off(name, onEvent);
        resolve(evtData);
      };
      this.on(name, onEvent);
      if (opts == null ? void 0 : opts.timeout) {
        setTimeout(() => {
          this.off(name, onEvent);
          reject(new Error(`Timeout: Event ${name} did not occur within ${opts.timeout}ms`));
        }, opts.timeout);
      }
    });
  }
}
function debounce$1(func2, wait2, immediate = false) {
  let timeout;
  return function(...args) {
    let context = this;
    let callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      timeout = null;
      if (!immediate) {
        func2.apply(context, args);
      }
    }, wait2);
    if (callNow)
      func2.apply(context, args);
  };
}
function findPath(child, root = null, pathArr = []) {
  let parent2 = child.parentElement;
  if (parent2 === null || root == child) {
    let shadow = getHost(child);
    if (!shadow) {
      pathArr.reverse();
      return pathArr;
    } else {
      let i = getNodeIndex(shadow.shadowRoot, child);
      if (i > -1) {
        pathArr.push(i);
      }
      pathArr.push(-1);
      return findPath(shadow, root, pathArr);
    }
  }
  let index = getNodeIndex(parent2, child);
  pathArr.push(index);
  return findPath(parent2, root, pathArr);
}
function getHost(child) {
  let root = child.getRootNode();
  if (root.nodeType == document.DOCUMENT_FRAGMENT_NODE) {
    return root.host;
  }
  return null;
}
function getNodeIndex(parent2, child) {
  let childList = parent2.childNodes;
  for (let i = 0; i < childList.length; ++i) {
    if (childList[i] === child) {
      return i;
    }
  }
  return -1;
}
function getNode(path, doc) {
  let next = doc.documentElement;
  for (let i = 0, len = path.length; i < len; i++) {
    let ind = path[i], child;
    if (ind == -1) {
      child = next.shadowRoot;
    } else {
      child = next.childNodes[path[i]];
    }
    if (!child) {
      throw new Error(`Failed to find node at: ${i} for path: ${path}. Last parent found is: ${next.nodeName}`);
    }
    next = child;
  }
  return next;
}
function createElement(node, parentNamespace) {
  if (!!node[4]) {
    if ("http://www.w3.org/1999/xhtml" === node[4]) {
      return documentCreateElementNS(node[4], node[1].toLowerCase());
    }
    return document.createElementNS(node[4], node[1]);
  } else if (!!parentNamespace && parentNamespace.length > 0) {
    if ("http://www.w3.org/1999/xhtml" === parentNamespace) {
      return documentCreateElementNS(parentNamespace, node[1].toLowerCase());
    }
    return documentCreateElementNS(parentNamespace, node[1]);
  } else {
    return documentCreateElement(node[1].toLowerCase());
  }
}
function documentCreateElementNS(namespace, qualifiedName) {
  try {
    return document.createElementNS(namespace, qualifiedName);
  } catch (e) {
    const div = document.createElementNS(namespace, "div");
    div.innerHTML = `<${qualifiedName} />`;
    return div.firstChild;
  }
}
function documentCreateElement(tagName) {
  try {
    return document.createElement(tagName);
  } catch (e) {
    const div = document.createElement("div");
    div.innerHTML = `<${tagName} />`;
    return div.firstChild;
  }
}
function setAttributes(elem, attributes) {
  for (let i = 0; !!attributes && i < attributes.length; i++) {
    let attribute = attributes[i];
    setAttribute(attribute, elem);
  }
}
function setAttribute(attribute, elem) {
  let keys = Object.keys(attribute);
  let namespace, qualifiedName, value;
  try {
    if (!!keys && keys.length === 2) {
      if ("namespaceURI" === keys[0]) {
        namespace = attribute[keys[0]];
        qualifiedName = keys[1];
        value = attribute[keys[1]];
      } else {
        namespace = attribute[keys[1]];
        qualifiedName = keys[0];
        value = attribute[keys[0]];
      }
      elem.setAttributeNS(namespace, qualifiedName, value);
    } else if (keys.length === 1) {
      qualifiedName = keys[0];
      value = attribute[keys[0]];
      elem.setAttribute(qualifiedName, value);
    }
  } catch (err) {
    if (namespace) {
      console.error("error while setting attributesNs", namespace, qualifiedName, value);
    } else {
      console.error("error while setting attributes", qualifiedName, value);
    }
  }
}
function appendDOM(elem, child) {
  if (child) {
    if (elem.nodeType === Node.COMMENT_NODE) {
      if (child.nodeType === Node.TEXT_NODE) {
        elem.nodeValue += child.nodeValue;
      }
    } else {
      elem.appendChild(child);
    }
  }
}
function patch(elem, jsonNode) {
  let childNodes = jsonNode[3];
  for (let i = 0; !!childNodes && i < childNodes.length; i++) {
    if (!!childNodes[i]) {
      appendDOM(elem, toDOM(childNodes[i], elem.namespaceURI));
    }
  }
  let attributes = jsonNode[2];
  if (!!attributes && attributes.length > 0) {
    setAttributes(elem, attributes);
  }
  return elem;
}
function toDOM(jsonNode, parentNamespace) {
  if (!jsonNode) {
    return null;
  }
  if (jsonNode[0] === Node.TEXT_NODE) {
    jsonNode = jsonNode;
    return document.createTextNode(jsonNode[1]);
  }
  if (jsonNode[0] === Node.CDATA_SECTION_NODE) {
    jsonNode = jsonNode;
    return document.createCDATASection(jsonNode[1]);
  }
  if (jsonNode[0] === Node.COMMENT_NODE) {
    jsonNode = jsonNode;
    return document.createComment(jsonNode[1]);
  }
  jsonNode = jsonNode;
  return patch(createElement(jsonNode, parentNamespace), jsonNode);
}
function parseHTML(documentContent, doc = document) {
  let node;
  if (typeof documentContent == "string") {
    let parser = new DOMParser();
    node = parser.parseFromString(documentContent, "text/html").documentElement;
  } else if (documentContent.type === DocumentContentType.JSON) {
    node = toDOM(documentContent.content, null);
  }
  if (node.nodeType === Node.ELEMENT_NODE) {
    let el = node;
    revertTextNodes(el);
  }
  return node;
}
function parseHTMLFrag(documentContent, doc) {
  let node;
  if (typeof documentContent == "string") {
    node = parseHTMLUsingTemplate(documentContent, doc);
  } else if (documentContent.type === DocumentContentType.JSON) {
    node = toDOM(documentContent.content, null);
  }
  if (node.nodeType == doc.ELEMENT_NODE) {
    revertTextNodes(node);
  }
  return node;
}
function parseHTMLUsingTemplate(html, doc) {
  if (html[0] == "#") {
    return doc.createTextNode(html.slice(1));
  }
  if (html.slice(0, 4) == "<!--") {
    return doc.createComment("");
  }
  const template = doc.createElement("template");
  template.innerHTML = html;
  let clone = doc.importNode(template.content, true);
  return clone.childNodes[0];
}
function revertTextNodes(el) {
  const elTextNodes = Array.from(el.querySelectorAll("text-node"));
  for (let i = 0, len = elTextNodes.length; i < len; i += 1) {
    const tEl = elTextNodes[i];
    tEl.replaceWith(document.createTextNode(tEl.textContent));
  }
}
function applyPatch(doc, path, diffs) {
  let currentInd = 0;
  const parentNode = getNode(path, doc);
  if (!parentNode) {
    throw new Error("Failed to find node for path: " + JSON.stringify(path));
  }
  diffs.forEach((diff) => {
    let op = diff[0];
    switch (op) {
      case DiffOp.NOOP: {
        let count = diff[1];
        currentInd += count;
        break;
      }
      case DiffOp.DEL: {
        let count = diff[1];
        for (let _i = 0; _i < count; _i++) {
          parentNode.childNodes[currentInd].remove();
        }
        break;
      }
      case DiffOp.INS: {
        let nodes = diff[1];
        let refNode = parentNode.childNodes[currentInd];
        for (let _i = 0; _i < nodes.length; _i++) {
          let newNode = parseHTMLFrag(nodes[_i], doc);
          parentNode.insertBefore(newNode, refNode);
        }
        currentInd += nodes.length;
        break;
      }
      case DiffOp.MOV: {
        let movedDOMPaths = diff[1];
        let count = movedDOMPaths.length;
        let refNode = parentNode.childNodes[currentInd];
        for (let i = 0; i < count; i++) {
          let movedPath = movedDOMPaths[i];
          let movedNode = getNode(movedPath, doc);
          if (!movedNode) {
            throw new Error("Failed to find node for path: " + JSON.stringify(movedPath));
          }
          parentNode.insertBefore(movedNode, refNode);
        }
        currentInd += count;
        break;
      }
      default:
        throw new Error();
    }
  });
}
class WebrtcClient extends EventEmitter$1 {
  constructor(id, frame, rtcConfig) {
    super();
    this._rtcEvents = [];
    this.controllers = /* @__PURE__ */ new Map();
    this.rtcConfig = {
      "iceServers": [{
        "urls": "stun:stun.l.google.com:19302"
      }],
      "sdpSemantics": "unified-plan"
    };
    this.id = id;
    this.frame = frame;
  }
  connect() {
    this.peer = new RTCPeerConnection(this.rtcConfig);
    this.peer.ontrack = (track) => {
      const controller = this.controllers.get(track.streams[0].id);
      if (!controller.isTrackEmpty()) {
        controller.initializeTrack(track);
      } else {
        controller.appendTrack(track);
      }
    };
    this.peer.oniceconnectionstatechange = () => {
      if (this.peer.iceConnectionState === "disconnected") {
        this.close();
      }
    };
    this.peer.onnegotiationneeded = async () => {
    };
    this.trigger(SignalEvent.ADD_PEER, {
      id: this.id,
      initiator: false,
      frameId: this.frame.store.id
    });
  }
  close() {
    this.peer.close();
  }
  clientCandidate(ev) {
    this.trigger(SignalEvent.CLIENT_CANDIDATE, {
      id: this.id,
      initiator: false,
      candidate: ev.candidate,
      frameId: this.frame.store.id
    });
  }
  clientDescription(sdp) {
    this.trigger(SignalEvent.CLIENT_DESCRIPTION, {
      id: this.id,
      initiator: false,
      sdp,
      frameId: this.frame.store.id
    });
  }
  async onServerCandidate(candidate) {
    if (candidate) {
      await this.peer.addIceCandidate(candidate);
      this.peer.onicecandidate = this.clientCandidate.bind(this);
    }
  }
  async onServerDescription(sdp) {
    if (sdp) {
      await this.peer.setRemoteDescription(sdp);
      const answer = await this.peer.createAnswer();
      await this.peer.setLocalDescription(answer);
      this.clientDescription(answer);
    }
  }
  onMapElement(event) {
    try {
      let element2 = getNode(event.path, this.frame.getDoc());
      if (event.mappingType === StreamTypes.CANVAS) {
        const canvasController = new CanvasController(event.mappedId, this.frame, element2);
        this.controllers.set(event.mappedId, canvasController);
      } else if (event.mappingType === StreamTypes.VIDEO) {
        const videoController = new VideoController(event.mappedId, this.frame, element2);
        this.controllers.set(event.mappedId, videoController);
      } else if (event.mappingType === StreamTypes.AUDIO) {
        const audioController = new AudioController(event.mappedId, this.frame, element2);
        this.controllers.set(event.mappedId, audioController);
      }
    } catch (e) {
      console.error("stream element not found ", e);
    }
  }
  async onWEBRTCEvent(id, event) {
    if (id !== this.id)
      return;
    if (event.initiator) {
      switch (event.name) {
        case SignalEvent.SERVER_CANDIDATE: {
          await this.onServerCandidate(event.candidate);
          break;
        }
        case SignalEvent.SERVER_DESCRIPTION: {
          await this.onServerDescription(event.sdp);
          break;
        }
        case SignalEvent.MAP_ELEMENT: {
          this.onMapElement(event);
          break;
        }
      }
    }
  }
  trigger(name, params) {
    this.frame.triggerSignallingServer(name, params);
  }
}
class StreamController {
  constructor(frame) {
    this.frame = frame;
    this.istrackInitialized = false;
  }
}
class VideoController extends StreamController {
  constructor(streamId, frame, element2) {
    super(frame);
    this.streamId = streamId;
    this.video = element2;
  }
  getController(id) {
    return this;
  }
  isTrackEmpty() {
    return this.istrackInitialized;
  }
  initializeTrack(event) {
    this.video.srcObject = event.streams[0];
    this.video.addEventListener("loadeddata", () => {
      if (this.video.readyState == 4) {
        this.video.muted = true;
        this.video.autoplay = true;
        this.video.play();
      }
    });
    this.video.addEventListener("playing", (ev) => {
      this.video.muted = false;
    });
    this.video.onerror = (e) => {
      console.error("error ", e);
    };
    this.istrackInitialized = true;
  }
  appendTrack(event) {
    if (event.track.kind === "audio") {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getAudioTracks().forEach((audioTrack) => {
        if (audioTrack.id !== event.track.id) {
          this.video.srcObject.removeTrack(audioTrack);
        }
      });
    } else {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getVideoTracks().forEach((videoTrack) => {
        if (videoTrack.id !== event.track.id)
          this.video.srcObject.removeTrack(videoTrack);
      });
    }
  }
}
class CanvasController extends StreamController {
  constructor(streamId, frame, element2) {
    super(frame);
    this.streamId = streamId;
    this.element = element2;
    this.video = this._getCanvasVideo(this.element);
  }
  getController(id) {
    return this;
  }
  isTrackEmpty() {
    return this.istrackInitialized;
  }
  initializeTrack(event) {
    this.video.srcObject = event.streams[0];
    this.video.addEventListener("loadeddata", () => {
      if (this.video.readyState == 4) {
        this.video.muted = true;
        this.video.autoplay = true;
        this.video.play();
      }
    });
    this.video.onerror = (e) => {
      console.error("error ", e);
    };
    this.istrackInitialized = true;
  }
  appendTrack(event) {
    if (event.track.kind === "audio") {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getAudioTracks().forEach((audioTrack) => {
        if (audioTrack.id !== event.track.id) {
          this.video.srcObject.removeTrack(audioTrack);
        }
      });
    } else {
      this.video.srcObject.addTrack(event.track);
      this.video.srcObject.getVideoTracks().forEach((videoTrack) => {
        if (videoTrack.id !== event.track.id)
          this.video.srcObject.removeTrack(videoTrack);
      });
    }
  }
  _getCanvasVideo(canvas) {
    if (canvas) {
      return this._createVideoElement(canvas);
    }
    return;
  }
  _createVideoElement(canvas) {
    const video = document.createElement("video");
    canvas.classList.forEach((value) => video.classList.add(value));
    video.setAttribute("hidden", "true");
    video.setAttribute("loop", "true");
    this.frame.elMeta.appendChild(video);
    video.addEventListener("play", () => {
      const context = canvas.getContext("2d");
      requestAnimationFrame((time) => {
        this._runVideoInCanvas(context, video);
      });
    });
    return video;
  }
  _runVideoInCanvas(context, video) {
    if (video.paused || video.ended) {
      return;
    }
    this._computeFrame(context, video);
    requestAnimationFrame((time) => {
      this._runVideoInCanvas(context, video);
    });
  }
  _computeFrame(context, video) {
    const width = context.canvas.width;
    const height = context.canvas.height;
    context.drawImage(video, 0, 0, width, height);
    return;
  }
}
class AudioController extends StreamController {
  constructor(streamId, frame, element2) {
    super(frame);
    this.streamId = streamId;
    this.audio = element2;
  }
  getController(id) {
    return this;
  }
  isTrackEmpty() {
    return this.istrackInitialized;
  }
  initializeTrack(event) {
    this.audio.srcObject = event.streams[0];
    this.audio.addEventListener("loadeddata", () => {
      if (this.audio.readyState == 4) {
        this.audio.autoplay = true;
      }
    });
    this.audio.addEventListener("playing", (ev) => {
      this.audio.muted = false;
    });
    this.audio.onerror = (e) => {
      console.error("error ", e);
    };
    this.istrackInitialized = true;
  }
  appendTrack(event) {
    if (event.track.kind === "audio") {
      this.audio.srcObject.addTrack(event.track);
      this.audio.srcObject.getAudioTracks().forEach((audioTrack) => {
        if (audioTrack.id !== event.track.id) {
          this.audio.srcObject.removeTrack(audioTrack);
        }
      });
    } else {
      this.audio.srcObject.addTrack(event.track);
      this.audio.srcObject.getVideoTracks().forEach((videoTrack) => {
        if (videoTrack.id !== event.track.id)
          this.audio.srcObject.removeTrack(videoTrack);
      });
    }
  }
}
let serverObjUrlToClientObjUrl = /* @__PURE__ */ new Map();
class PromiseToAwait extends Promise {
  constructor(executor) {
    let resolve, reject;
    super(executor != null ? executor : (res, rej) => {
      resolve = res;
      reject = rej;
    });
    this.resolve = resolve;
    this.reject = reject;
  }
}
class ResolvablePromise extends Promise {
  constructor(executor) {
    let resolve, reject;
    super(executor != null ? executor : (res, rej) => {
      resolve = res;
      reject = rej;
    });
    this.resolve = resolve;
    this.reject = reject;
  }
  getValue() {
    return this.value;
  }
  setValue(value) {
    this.value = value;
    this.resolve();
  }
}
const BASE_GLOBALS = {
  BigInt,
  BigInt64Array,
  BigUint64Array,
  Float32Array,
  Float64Array,
  Int8Array,
  Int16Array,
  Int32Array,
  Uint8Array,
  Uint16Array,
  Uint32Array,
  Uint8ClampedArray,
  Image,
  Path2D,
  Blob,
  ArrayBuffer,
  Promise: ResolvablePromise
};
class VM {
  constructor(fv) {
    this.globals = {
      ...BASE_GLOBALS,
      $0: {
        createCSS: (...args) => {
          const win = this.fv.getDoc().defaultView;
          return win.createCSS(...args);
        },
        defineElement: (name) => {
          const win = this.fv.getDoc().defaultView;
          return win.defineElement(name, class extends HTMLElement {
          });
        },
        getNode: (...path) => getNode(path, this.fv.getDoc()),
        getImageDataFromDataURL(dataURL) {
          let promise = new ResolvablePromise();
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const img = new Image();
          img.src = dataURL;
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            promise.setValue(ctx.getImageData(0, 0, img.width, img.height));
          };
          return promise;
        }
      },
      $doc: null,
      $win: null
    };
    this.getValue = (valueOrCmd) => {
      if (typeof valueOrCmd === "string" && valueOrCmd.startsWith("$")) {
        if (this.globals[valueOrCmd] === void 0) {
          return valueOrCmd;
        }
        return this.globals[valueOrCmd];
      } else if (Array.isArray(valueOrCmd)) {
        return this.handleCmd(valueOrCmd);
      }
      return valueOrCmd;
    };
    this.fv = fv;
    Object.defineProperty(this.globals, "$doc", {
      get: () => this.fv.getDoc()
    });
    Object.defineProperty(this.globals, "$win", {
      get: () => this.fv.getDoc().defaultView
    });
    const createObjectURLOrig = this.globals.$win.URL.createObjectURL;
    function createObjectURLNew(object2, serverObjUrl) {
      let url = createObjectURLOrig(object2);
      if (serverObjUrl) {
        serverObjUrlToClientObjUrl.set(serverObjUrl, url);
      }
      pendingImgsWithBlobUrls.forEach((imgs, imgUrl) => {
        imgs.forEach((img) => {
          img.src = serverObjUrlToClientObjUrl.get(imgUrl) || img.src;
        });
        pendingImgsWithBlobUrls.delete(imgUrl);
      });
      return url;
    }
    this.globals.$win.URL.createObjectURL = createObjectURLNew;
    const revokeObjectURLOrig = this.globals.$win.URL.revokeObjectURL;
    function revokeObjectURLNew(url) {
      url = serverObjUrlToClientObjUrl.has(url) ? serverObjUrlToClientObjUrl.get(url) : url;
      revokeObjectURLOrig(url);
    }
    this.globals.$win.URL.revokeObjectURL = revokeObjectURLNew;
    this.promiseTick = Promise.resolve();
    window.globals = this.globals;
  }
  async run(cmds) {
    for (let cmd of cmds) {
      try {
        let res = this.handleCmd(cmd);
        if (res instanceof ResolvablePromise || res instanceof PromiseToAwait) {
          res = await res;
        }
      } catch (e) {
        console.error("error running cmd", cmd, e);
        throw Error("error running cmd", { cause: e });
      }
    }
  }
  handleCmd(cmd) {
    const [name, ...args] = cmd;
    switch (name) {
      case "get": {
        const [varRef, key] = args;
        const obj = this.getValue(varRef);
        if (!obj[key]) {
          if (key === "sheet" && obj instanceof HTMLLinkElement) {
            const resolvable = new PromiseToAwait();
            obj.addEventListener("load", () => {
              onload = resolvable.resolve(obj[key]);
              onerror = resolvable.resolve();
            });
            return resolvable;
          }
        }
        return obj[key];
      }
      case "var": {
        const [name2, valueOrCmd] = args;
        let res = this.getValue(valueOrCmd);
        if (res.then && !(res instanceof ResolvablePromise)) {
          const resolvable = res instanceof PromiseToAwait ? res : new ResolvablePromise();
          res.then((v) => {
            this.globals[name2] = v;
            resolvable.resolve();
          }).catch((e) => {
            resolvable.reject(e);
          });
          return resolvable;
        } else {
          this.globals[name2] = this.getValue(valueOrCmd);
          return;
        }
      }
      case "call": {
        const [varRef, func2, ...params] = args;
        const ref = this.getValue(varRef);
        const value = ref[func2](...params.map(this.getValue));
        return value;
      }
      case "list":
        return args.map(this.getValue);
      case "new": {
        const [name2, ...params] = args;
        const clazz = this.globals[name2];
        return new clazz(...params.map(this.getValue));
      }
      case "set": {
        const [varRef, key, valueOrCmd] = args;
        const ref = this.getValue(varRef);
        if (key === "src" && valueOrCmd.startsWith("blob:")) {
          ref[key] = serverObjUrlToClientObjUrl.get(valueOrCmd);
          break;
        }
        ref[key] = this.getValue(valueOrCmd);
        break;
      }
      case "fn": {
        const [params, ...fnCmds] = args;
        return () => {
          fnCmds.forEach((cmd2) => this.handleCmd(cmd2));
        };
      }
      case "await": {
        const [varRef] = args;
        return this.getValue(varRef);
      }
      case "free": {
        const [varRef] = args;
        delete this.globals[varRef];
        break;
      }
      default:
        throw new Error("unknown cmd:" + cmd);
    }
  }
}
class EventQueue {
  constructor(eventHandler) {
    this._hold = false;
    this.queue = [];
    this._processing = false;
    this.lastEvent = null;
    this.eventHandler = eventHandler;
  }
  add(event) {
    this.queue.push(event);
    this.process();
  }
  async process() {
    if (this._hold || this._processing) {
      return;
    }
    this._processing = true;
    while (this.queue.length > 0) {
      if (this._hold) {
        break;
      }
      const event = this.queue.shift();
      this.lastEvent = event.name;
      await this.eventHandler(event);
    }
    this._processing = false;
  }
  hold() {
    this._hold = true;
  }
  release() {
    this._hold = false;
    this.process();
  }
}
const isTouchDevice = () => "ontouchstart" in window || navigator.maxTouchPoints > 0;
var FrameLoadState;
(function(FrameLoadState2) {
  FrameLoadState2[FrameLoadState2["INIT"] = 0] = "INIT";
  FrameLoadState2[FrameLoadState2["LOADING"] = 1] = "LOADING";
  FrameLoadState2[FrameLoadState2["LOADED"] = 2] = "LOADED";
  FrameLoadState2[FrameLoadState2["LOADED_DOCTYPE"] = 3] = "LOADED_DOCTYPE";
  FrameLoadState2[FrameLoadState2["LOADED_DOC"] = 4] = "LOADED_DOC";
})(FrameLoadState || (FrameLoadState = {}));
const MaxReportableErrors = 50;
const INPUT_TO_FILL = ["color", "date", "datetime-local", "file", "image", "month", "time", "week"];
let pendingImgsWithBlobUrls = /* @__PURE__ */ new Map();
const clearPendingImgs = debounce$1(() => {
  pendingImgsWithBlobUrls.forEach((imgs, url) => {
    imgs = imgs.filter((img) => img.isConnected);
    if (imgs.length === 0) {
      pendingImgsWithBlobUrls.delete(url);
    } else {
      pendingImgsWithBlobUrls.set(url, imgs);
    }
  });
}, 1e3);
class FrameView extends EventEmitter$1 {
  constructor(store, pageView) {
    super();
    this._altDown = null;
    this._localFrameLoadState = FrameLoadState.INIT;
    this._streamEvents = [];
    this._data = /* @__PURE__ */ new Map();
    this._scrollsSent = /* @__PURE__ */ new Set();
    this._scrollsReceived = /* @__PURE__ */ new Set();
    this._listenersActive = false;
    this._isDraggingBar = false;
    this._wheeling = false;
    this.clearWheeling = debounce$1(() => {
      this._wheeling = false;
    }, 2e3);
    this.syncScrollAfterWheeling = debounce$1((el) => this._dispatchEventScroll(el), 200);
    this.dispatchEventScroll = async (e) => {
      let target = e.target;
      if (target.nodeType == document.DOCUMENT_NODE) {
        target = target.documentElement;
      }
      this._scrollingElement = target;
      if (this._isDraggingBar || isTouchDevice()) {
        await this._dispatchEventScroll(target);
      }
    };
    this.pageView = pageView;
    this.store = store;
    this.onFrameLoad = this.onFrameLoad.bind(this);
    this._applyDOMEvent = this._applyDOMEvent.bind(this);
    this._events = new EventQueue(this._applyDOMEvent);
    this._events.hold();
    this.elMeta = this.createMetaElement();
    this.streamMap = /* @__PURE__ */ new Map();
    this.appliedDOMEvents = new AppliedDOMStreamEvents(15);
    this._maxErrors = MaxReportableErrors;
    this._listeners = {
      blur: () => this.onBlur(),
      mousedown: (e) => this.dispatchEventMousedown(e),
      mouseup: (e) => this.dispatchEventMouseup(e),
      mousemove: (e) => this.dispatchEventMousemove(e),
      keydown: (e) => this.dispatchEventKeydown(e),
      keyup: (e) => this.dispatchEventKeyup(e),
      wheel: (e) => this.dispatchEventWheel(e),
      change: (e) => this.dispatchEventChange(e),
      input: (e) => this.dispatchEventInput(e),
      scroll: (e) => this.dispatchEventScroll(e),
      click: (e) => {
        if (this.shouldStopPointerEvents(e.target)) {
          e.preventDefault();
          e.stopPropagation();
        }
      }
    };
  }
  onBlur() {
    if (!!this._altDown) {
      this.trigger("keyup", {
        key: this._altDown
      }, this.getDoc().documentElement);
      this._altDown = null;
    }
  }
  addDocListeners() {
    const doc = this.getDoc();
    if (!doc) {
      console.error("FIXME trying to add listener for null document");
      return;
    }
    for (let name in this._listeners) {
      doc.addEventListener(name, this._listeners[name], true);
    }
    this._listenersActive = true;
  }
  appendHost() {
    this.getDoc().documentElement.appendChild(this.elMeta);
  }
  removeHost() {
    this.getDoc().documentElement.removeChild(this.elMeta);
  }
  createMetaElement() {
    if (!customElements.get("bbx-d")) {
      customElements.define("bbx-d", class extends HTMLElement {
        constructor() {
          super();
          this.attachShadow({ mode: "open" });
        }
      });
    }
    const elMeta = document.createElement("bbx-d");
    return elMeta;
  }
  createVM() {
    this._vm = new VM(this);
  }
  destroy() {
    if (this._localFrameLoadState == FrameLoadState.LOADING) {
      this.removeDocListeners();
    }
    this.elMeta.remove();
    this.emit("destroy");
    this.reset();
  }
  _dispatchEventMousemove(el, x, y) {
    this.updateCurrentMouseTarget(el);
    const offset = this.getFrameOffset();
    this.trigger("mousemove", {
      path: findPath(el),
      clientX: Math.round(x + offset[0]),
      clientY: Math.round(y + offset[1]),
      frameId: this.store.id
    }, el);
  }
  dispatchEventMousemove(e) {
    const originalTarget = e.composedPath()[0];
    this._dispatchEventMousemove(originalTarget, e.clientX, e.clientY);
  }
  dispatchEventMousemove2(selector, x, y) {
    let el = querySelectorAll(selector, this.getDoc())[0];
    const rect = el.getBoundingClientRect();
    this._dispatchEventMousemove(el, rect.x + x, rect.y + y);
  }
  getClientR(el) {
    if (el.nodeType != document.ELEMENT_NODE) {
      return null;
    }
    let bcr = el.getBoundingClientRect();
    let offset = this.frameOffSet(this.elFrame, this.store.parentId);
    return {
      top: Math.round(bcr.top + offset.top),
      left: Math.round(bcr.left + offset.left),
      bottom: Math.round(bcr.bottom + offset.top),
      right: Math.round(bcr.right + offset.left)
    };
  }
  frameOffSet(el, parentId) {
    let mainFrameOffset = {
      top: 0,
      left: 0
    };
    let offset = this.pageView.elMainFrame == el ? mainFrameOffset : el.getBoundingClientRect();
    if (!parentId) {
      return offset;
    }
    let parentView = this.pageView.getFrame(parentId);
    let parentFrame = parentView.elFrame;
    parentId = parentView.store.parentId;
    return this.addRect(offset, this.frameOffSet(parentFrame, parentId));
  }
  addRect(a, b) {
    return {
      left: a.left + b.left,
      top: a.top + b.top
    };
  }
  updateCurrentMouseTarget(el) {
    const rect = this.getClientR(el);
    const curRect = this._currentMouseTargetRect;
    if (el == this._currentMouseTarget && rect && rect.top == curRect.top && rect.left == curRect.left && rect.bottom == curRect.bottom && rect.right == curRect.right) {
      return;
    }
    this.trigger("syncsize", {
      path: findPath(el),
      rect,
      frameId: this.store.id
    }, el);
    this._currentMouseTarget = el;
    this._currentMouseTargetRect = rect;
  }
  dispatchEventChange(e) {
    let el = e.target;
    if (el.tagName == "INPUT") {
      let inputTarget = el;
      if (["date", "text", "password", "email"].includes(inputTarget.type)) {
        this.trigger("change", {
          path: findPath(inputTarget),
          value: inputTarget.value,
          frameId: this.store.id
        }, el);
      }
    } else if (el.tagName == "SELECT") {
      let selectTarget = el;
      this.trigger("select", {
        path: findPath(selectTarget),
        indexes: Array.from(selectTarget.selectedOptions).map((o) => o.index),
        frameId: this.store.id
      }, el);
    }
  }
  dispatchEventChange2(selector, value) {
    let el = querySelectorAll(selector, this.getDoc())[0];
    this.trigger(el.tagName == "SELECT" ? "select" : "change", {
      path: findPath(el),
      value,
      frameId: this.store.id
    }, el);
  }
  dispatchEventInput(e) {
    let path;
    let value;
    let target = e.target;
    if (target.tagName == "INPUT") {
      path = findPath(target);
      value = target.value;
    }
    this.trigger("input", {
      path,
      value,
      frameId: this.store.id
    }, target);
  }
  async _dispatchEventScroll(el) {
    let event = {
      path: findPath(el),
      top: el.scrollTop,
      left: el.scrollLeft,
      frameId: this.store.id
    };
    const scrollEventStr = `${event.left}:${event.top}`;
    if (!this._scrollsReceived.has(scrollEventStr)) {
      let res = await this.trigger("scroll", event, el);
      if (!res.noop) {
        this._scrollsSent.add(`${res.scrollLeft}:${res.scrollTop}`);
      }
    } else {
      this._scrollsReceived.delete(scrollEventStr);
    }
  }
  dispatchEventScroll2(selector, left, top) {
    let el = querySelectorAll(selector, this.getDoc())[0];
    el.scrollTo(left, top);
    this._dispatchEventScroll(el);
  }
  dispatchEventWheel(e) {
    let scrollEvent = e;
    let target = e.target;
    const offset = this.getFrameOffset();
    if (target instanceof Document) {
      target = target.documentElement;
    }
    let event = {
      deltaX: scrollEvent.deltaX,
      deltaY: scrollEvent.deltaY,
      path: findPath(target),
      x: scrollEvent.x + offset[0],
      y: scrollEvent.y + offset[1],
      frameId: this.store.id
    };
    this.trigger("wheel", event, target);
    this._wheeling = true;
    this.clearWheeling();
    this.syncScrollAfterWheeling(this._scrollingElement);
  }
  shouldStopPointerEvents(el) {
    return !((el == null ? void 0 : el.tagName) == "SELECT" || (el == null ? void 0 : el.tagName) == "INPUT" && INPUT_TO_FILL.includes(el == null ? void 0 : el.type));
  }
  dispatchEventMousedown(e) {
    if (isClickingOnScrollbar(e)) {
      this._isDraggingBar = true;
      return;
    }
    this.pageView.onMouseDown(e);
    let target = e.target;
    let originalTarget = e.composedPath()[0];
    if (this.shouldStopPointerEvents(originalTarget)) {
      e.stopPropagation();
    }
    this.trigger("mousedown", {
      button: e.button,
      frameId: this.store.id
    }, target);
  }
  dispatchEventMouseup(e) {
    if (this._isDraggingBar) {
      this._isDraggingBar = false;
      return;
    }
    let target = e.target;
    let originalTarget = e.composedPath()[0];
    if (this.shouldStopPointerEvents(originalTarget)) {
      e.stopPropagation();
    }
    this.trigger("mouseup", {
      button: e.button,
      frameId: this.store.id
    }, target);
  }
  dispatchEventKeydown(e) {
    let target = e.target;
    const { key } = e;
    let originalTarget = e.composedPath()[0];
    if ((originalTarget == null ? void 0 : originalTarget.tagName) !== "SELECT") {
      e.preventDefault();
      e.stopPropagation();
    }
    if (key == "Alt") {
      this._altDown = key;
    }
    this.trigger("keydown", {
      key,
      frameId: this.store.id
    }, target);
  }
  dispatchEventKeyup(e) {
    let target = e.target;
    const { key } = e;
    let originalTarget = e.composedPath()[0];
    if ((originalTarget == null ? void 0 : originalTarget.tagName) !== "SELECT") {
      e.preventDefault();
      e.stopPropagation();
    }
    this.trigger("keyup", {
      key,
      frameId: this.store.id
    }, target);
  }
  getDoc() {
    return this.elFrame.contentDocument;
  }
  getMetaEl() {
    return this.elMeta;
  }
  getFrameOffset() {
    return this.pageView.getOffset(this.elFrame);
  }
  getNode(path) {
    return getNode(path, this.getDoc());
  }
  getState() {
    return this._localFrameLoadState;
  }
  isDocReady() {
    return this.getState() == FrameLoadState.LOADED_DOC;
  }
  on_change_attributes({ path, patch: patch2 }) {
    let el = getNode(path, this.getDoc());
    if (!patch2.ns) {
      if (patch2.value === null) {
        el.removeAttribute(patch2.name);
      } else {
        if (patch2.name === "src" && patch2.value.startsWith("blob:")) {
          patch2.value = serverObjUrlToClientObjUrl.get(patch2.value) || patch2.value;
        }
        el.setAttribute(patch2.name, patch2.value);
      }
    } else {
      if (patch2.value === null) {
        el.removeAttributeNS(patch2.ns, patch2.name);
      } else {
        el.setAttributeNS(patch2.ns, patch2.name, patch2.value);
      }
    }
  }
  removeBBXBaseTag() {
    var _a;
    (_a = this.getDoc().documentElement.querySelector("#bbx-base")) == null ? void 0 : _a.remove();
  }
  addBBXBaseTagIfRequired() {
    if (!this.url)
      return;
    let document2 = this.getDoc();
    if (document2.querySelector("base") === null) {
      const base2 = document2.createElement("base");
      base2.setAttribute("href", this.url);
      base2.setAttribute("id", "bbx-base");
      document2.head.appendChild(base2);
    }
  }
  on_change_childlist({ path, patches }) {
    const canAffectHost = path.length == 1;
    canAffectHost && this.removeHost();
    this.removeBBXBaseTag();
    try {
      applyPatch(this.getDoc(), path, patches);
      clearPendingImgs();
    } finally {
      canAffectHost && this.appendHost();
      this.addBBXBaseTagIfRequired();
    }
  }
  on_change_checked({ path, checked }) {
    let input = getNode(path, this.getDoc());
    input.checked = checked;
  }
  on_change_value({ path, value }) {
    let element2 = getNode(path, this.getDoc());
    element2.value = value;
  }
  on_change_text({ path, patch: patch2 }) {
    let node = getNode(path, this.getDoc());
    node.nodeValue = patch2;
  }
  on_bbx_debug({ value }) {
    value && console.log("ignored on_bbx_debug");
  }
  on_bbx_debug_default({ value }) {
    console.log("on_bbx_debug", new Date(), "start comparing HTML", this.store.id);
    let nodeFromServer = parseHTML(value);
    if (nodeFromServer.nodeType === Node.ELEMENT_NODE) {
      let elementFromServer = nodeFromServer;
      let elementFromClient = this.getDoc().documentElement.cloneNode(true);
      let styleElements = elementFromClient.querySelectorAll("style");
      for (let i = 0; i < styleElements.length; i++) {
        styleElements[i].textContent = "";
      }
      let metaElements = elementFromClient.querySelectorAll("meta");
      for (let i = 0; i < metaElements.length; i++) {
        metaElements[i].outerHTML = "<meta/>";
      }
      let bbxElements = elementFromClient.querySelectorAll("bbx-d");
      for (let i = 0; i < bbxElements.length; i++) {
        bbxElements[i].remove();
      }
      styleElements = elementFromServer.querySelectorAll("style");
      for (let i = 0; i < styleElements.length; i++) {
        styleElements[i].textContent = "";
      }
      metaElements = elementFromServer.querySelectorAll("meta");
      for (let i = 0; i < metaElements.length; i++) {
        metaElements[i].outerHTML = "<meta/>";
      }
      const isEqual = elementFromServer.isEqualNode(elementFromClient);
      if (!isEqual) {
        console.log("on_bbx_debug", new Date(), "end comparing HTML", this.store.id, "isEqual", isEqual, elementFromClient.outerHTML === elementFromServer.outerHTML);
        this.pageView.browserView.manager.emit("frame_content_mismatch", elementFromClient, elementFromServer);
      }
    } else {
      console.error("on_bbx_debug", "Invalid Node sent from server");
    }
  }
  async on_content_cmds({ data: cmds }) {
    await this._vm.run(cmds);
  }
  on_document({ value }) {
    this.setState(FrameLoadState.LOADED_DOC);
    const doc = this.getDoc();
    doc.documentElement.replaceWith(parseHTML(value, doc));
    this.appendHost();
    this.addBBXBaseTagIfRequired();
    this._streamEvents.forEach(async (stream, _index) => {
      await this.addPeerToFrame(stream);
    });
    this._streamEvents = [];
    this.emit("document_ready", this);
    this.on_bbx_debug = this.on_bbx_debug_default;
    const blobUrlImgs = doc.documentElement.querySelectorAll('img[src^="blob:"]');
    blobUrlImgs.forEach((img) => {
      const clientObjURL = serverObjUrlToClientObjUrl.get(img.src);
      if (clientObjURL) {
        img.src = clientObjURL;
        return;
      }
      if (!pendingImgsWithBlobUrls.has(img.src)) {
        pendingImgsWithBlobUrls.set(img.src, []);
      }
      pendingImgsWithBlobUrls.get(img.src).push(img);
    });
  }
  on_document_start({ doctype }) {
    this._maxErrors = MaxReportableErrors;
    this.setState(FrameLoadState.LOADING);
    const baseURL = this.pageView.browserView.client.getBaseURL();
    if (this.pageView.browserView.store.isReplay()) {
      const html = "<html><body></body></html>";
      this.elFrame.setAttribute("srcdoc", html);
    } else {
      const scriptConstructedStylesheet = `<script src="${baseURL}/static/frame.js"><\/script>`;
      const html = (doctype ? `<!doctype ${doctype}>` : "") + `<html><body>${scriptConstructedStylesheet}</body></html>`;
      this.elFrame.setAttribute("srcdoc", html);
    }
    this._events.hold();
  }
  on_shadow_root({ path }) {
    let el = getNode(path, this.getDoc());
    if (!el.shadowRoot) {
      el.attachShadow({ mode: "open" });
    }
  }
  on_text_patch({ path, diff }) {
    let el = getNode(path, this.getDoc());
    let oldStr = el.nodeValue;
    let newStr = this.apply_text_patch(oldStr, diff);
    el.nodeValue = newStr;
  }
  apply_text_patch(oldStr, diff) {
    let result = "";
    let currentInd = 0;
    diff.forEach((d) => {
      switch (d[0]) {
        case DiffOp.NOOP:
          let subStr = oldStr.slice(currentInd, currentInd + d[1]);
          result = result + subStr;
          currentInd = currentInd + d[1];
          break;
        case DiffOp.DEL:
          currentInd = currentInd + d[1];
          break;
        case DiffOp.INS:
          result = result + d[1];
          break;
      }
    });
    return result;
  }
  on_focus({ path }) {
    let el = getNode(path, this.getDoc());
    el.focus();
    this.pageView.onFocus(el);
  }
  on_frame_src({ path, childFrameId }) {
    let childFrameView = this.pageView.getFrame(childFrameId);
    let iframe = getNode(path, this.getDoc());
    if (!iframe || !iframe.nodeName.endsWith("FRAME")) {
      console.error("on_frame_src", path, childFrameId, iframe);
      throw new Error("on_frame_src: mismatched path to iframe");
    }
    if (childFrameView)
      childFrameView.setIFrame(iframe);
  }
  on_input({ path, value }) {
    let el = getNode(path, this.getDoc());
    el.value = value;
  }
  on_navigated({ url }) {
    this.url = url;
  }
  on_history_navigated({ url }) {
    this.url = url;
    this.addBBXBaseTagIfRequired();
  }
  on_select({ path, indexes }) {
    let element2 = getNode(path, this.getDoc());
    for (let option of Array.from(element2.options)) {
      option.selected = false;
    }
    for (let idx of indexes) {
      element2.options[idx].selected = true;
    }
  }
  on_select_input({ path, start, end }) {
    let el = getNode(path, this.getDoc());
    if (!el.type || el.type == "text" || el.type == "search" || el.type == "url" || el.type == "tel" || el.type == "password") {
      el.setSelectionRange(start, end);
    }
  }
  on_select_range({ ranges }) {
    const doc = this.getDoc();
    const s = doc.getSelection();
    s.empty();
    ranges.forEach((rangeObj) => {
      let range = doc.createRange();
      let { start, end } = rangeObj;
      range.setStart(getNode(start[0], doc), start[1]);
      range.setEnd(getNode(end[0], doc), end[1]);
      s.addRange(range);
    });
  }
  on_scroll(event) {
    if (this._wheeling) {
      return;
    }
    let path = event.path;
    let el = getNode(path, this.getDoc());
    let left = event.left;
    let top = event.top;
    const scrollEventStr = `${left}:${top}`;
    if (!this._scrollsSent.has(scrollEventStr)) {
      let oldCords = { scrollTop: el.scrollTop, scrollLeft: el.scrollLeft };
      el.scrollTo(left, top);
      let newCords = { scrollTop: el.scrollTop, scrollLeft: el.scrollLeft };
      if (this._listenersActive && (oldCords.scrollTop != newCords.scrollTop || oldCords.scrollLeft != newCords.scrollLeft)) {
        this._scrollsReceived.add(`${el.scrollLeft}:${el.scrollTop}`);
      }
    } else {
      this._scrollsSent.delete(scrollEventStr);
    }
  }
  on_batch(event) {
    let eventBatch = event.patches;
    eventBatch.forEach((aEvent) => {
      let method = `on_${aEvent.name}`;
      if (this[method]) {
        this[method](aEvent);
      }
    });
  }
  onDOMEvent(domStreamEvent) {
    if (domStreamEvent.name === "navigated") {
      this._applyDOMEvent(domStreamEvent);
      return;
    }
    this._events.add({ ...domStreamEvent });
  }
  async _applyDOMEvent(domStreamEvent) {
    domStreamEvent.name = domStreamEvent.name.replace(/:/g, "_");
    let method = `on_${domStreamEvent.name}`;
    let startTime = new Date();
    if (this[method]) {
      try {
        await this[method](domStreamEvent);
      } catch (e) {
        console.warn(`error while processing the DOMEvent ${domStreamEvent.name}`, this.store.id, domStreamEvent, e);
        const domEventError = new DOMEventError(e, method, this.url, this.store.isMain());
        domEventError.setPreviousEvents(this.appliedDOMEvents);
        this.sendError(domEventError);
        this.appliedDOMEvents.push(domStreamEvent, startTime, e);
      }
      this.appliedDOMEvents.push(domStreamEvent, startTime);
      this.emit(domStreamEvent.name, domStreamEvent, this);
      this.emit("bbx", domStreamEvent.name, domStreamEvent, this);
    } else {
      console.warn("TODO: unhandled event:", this.store.id, domStreamEvent.name, domStreamEvent);
    }
  }
  async onWEBRTCEvent(peerId, event) {
    if (event.name === SignalEvent.STREAM_VIDEO) {
      await this.addPeerToFrame(event);
      return;
    }
    await this.webrtcClient.onWEBRTCEvent(peerId, event);
  }
  async addPeerToFrame(event) {
    if (event.name === SignalEvent.STREAM_VIDEO) {
      if (this.webrtcClient) {
        this.webrtcClient.close();
        this.webrtcClient = void 0;
      }
      if (this._isReadyForStreaming()) {
        this.webrtcClient = new WebrtcClient(Math.random().toString(36), this);
        this.webrtcClient.connect();
      } else {
        this._streamEvents.push(event);
      }
    }
  }
  _isReadyForEvents(name) {
    if (name == "document_start") {
      return this._localFrameLoadState >= FrameLoadState.LOADED;
    } else {
      return this._localFrameLoadState >= FrameLoadState.LOADED_DOCTYPE;
    }
  }
  _isReadyForStreaming() {
    return this._localFrameLoadState >= FrameLoadState.LOADED_DOC;
  }
  onFrameLoad() {
    if (this._events.lastEvent === "document_start") {
      this.setState(FrameLoadState.LOADED_DOCTYPE);
      this.removeDocListeners();
      !this._paused && this.addDocListeners();
      this.appendHost();
      this.createVM();
      this.emit("ready", this);
    } else {
      this.setState(FrameLoadState.LOADED);
    }
    this._events.release();
  }
  pause() {
    this._paused = true;
    if (this._localFrameLoadState >= FrameLoadState.LOADED_DOCTYPE) {
      this.removeDocListeners();
    }
  }
  resume() {
    this._paused = false;
    if (this._localFrameLoadState >= FrameLoadState.LOADED_DOCTYPE) {
      this.addDocListeners();
    }
  }
  removeDocListeners() {
    const doc = this.getDoc();
    if (!doc) {
      console.error("FIXME trying to remove listener for null document");
      return;
    }
    for (let name in this._listeners) {
      doc.removeEventListener(name, this._listeners[name], true);
    }
    this._listenersActive = false;
  }
  setState(state) {
    this._localFrameLoadState = state;
  }
  setIFrame(iframe) {
    this.elFrame = iframe;
    if (iframe.contentDocument) {
      this.onFrameLoad();
    }
    this.elFrame.addEventListener("load", this.onFrameLoad);
  }
  trigger(name, params, target) {
    let res = this.pageView.store.trigger(name, params);
    this.emit("trigger", name, params, target, this);
    return res;
  }
  triggerSignallingServer(name, params) {
    this.pageView.store.browser.call("signalEvent", this.pageView.store.id, name, params);
  }
  delData(key) {
    return this._data.delete(key);
  }
  getData(key) {
    return this._data.get(key);
  }
  setData(key, value) {
    return this._data.set(key, value);
  }
  sendError(e) {
    this._maxErrors--;
    if (this._maxErrors > 0) {
      this.pageView.sendError(e);
    } else {
      console.warn("error limit exceeded, max limit is configured to:", MaxReportableErrors, e);
    }
  }
}
class PageView extends EventEmitter$1 {
  constructor(store, browserView) {
    super();
    this.frameViews = /* @__PURE__ */ new Map();
    this.overlays = [];
    this.store = store;
    this.browserView = browserView;
    this.onFrameAdded = this.onFrameAdded.bind(this);
    this.onFrameDetached = this.onFrameDetached.bind(this);
    this.addListeners();
    this.mainFrameView = this.onFrameAdded(this.store.mainFrame);
    this.store.frames.slice(1).forEach((frame) => this.onFrameAdded(frame));
    this.elMainFrame = document.createElement("iframe");
    this.elMainFrame.setAttribute("frameborder", "0");
    this.mainFrameView.setIFrame(this.elMainFrame);
  }
  addListeners() {
    this.store.on("frameadded", this.onFrameAdded);
    this.store.on("framedetached", this.onFrameDetached);
  }
  addOverlay(overlay) {
    this.overlays.push(overlay);
    for (let fv of this.frameViews.values()) {
      overlay.onFrameInit(fv);
    }
  }
  removeOverlay(overlay) {
    let index = this.overlays.indexOf(overlay);
    this.overlays.splice(index, 1);
    for (let fv of this.frameViews.values()) {
      overlay.onFrameUninit(fv);
    }
  }
  destroy() {
    let fvs = [...this.frameViews.values()];
    for (let fv of fvs) {
      this.onFrameDetached(fv.store);
    }
    this.elMainFrame.remove();
    this.store.off("frameadded", this.onFrameAdded);
    this.store.off("framedetached", this.onFrameDetached);
  }
  getOffset(el) {
    if (el == this.elMainFrame) {
      return [0, 0];
    }
    let rect = el.getBoundingClientRect();
    const offset = [rect.left, rect.top];
    const elWin = el.ownerDocument.defaultView;
    const parentOffset = this.getOffset(elWin.frameElement);
    return [offset[0] + parentOffset[0], offset[1] + parentOffset[1]];
  }
  getFrame(frameId) {
    return this.frameViews.get(frameId);
  }
  onDOMEvent(frameId, event) {
    let frameView = this.getFrame(frameId);
    frameView.onDOMEvent(event);
  }
  async onWEBRTCEvent(frameId, peerId, event) {
    await this.getFrame(frameId).onWEBRTCEvent(peerId, event);
  }
  onFrameAdded(frame) {
    const fv = new FrameView(frame, this);
    this.frameViews.set(frame.id, fv);
    this.overlays.forEach((o) => o.onFrameInit(fv));
    this.emit("frameadded", fv);
    return fv;
  }
  onFrameDetached(frame) {
    let fv = this.frameViews.get(frame.id);
    if (fv) {
      for (let overlay of this.overlays) {
        overlay.onFrameUninit(fv);
      }
      fv.destroy();
      this.frameViews.delete(frame.id);
      this.emit("framedetached", fv);
    }
  }
  pause() {
    for (const fv of this.frameViews.values()) {
      fv.pause();
    }
  }
  resume() {
    for (const fv of this.frameViews.values()) {
      fv.resume();
    }
  }
  render() {
    return this.elMainFrame;
  }
  sendError(e) {
    this.browserView.sendError(e);
  }
  onFocus(el) {
    this.focusedElement = el;
  }
  onMouseDown(e) {
    if (!this.focusedElement) {
      return;
    }
    const clickedEl = e.target;
    if (clickedEl.ownerDocument.activeElement !== this.focusedElement) {
      this.focusedElement.focus();
    }
  }
}
class BrowserView extends EventEmitter$1 {
  constructor(options) {
    super();
    this.overlays = [];
    this.pageViews = /* @__PURE__ */ new Map();
    Object.assign(this, options);
    this.manager.addDOMStreamListener(this);
    this.manager.addWEBRTCStreamListener(this);
    this.addListeners();
  }
  async addListeners() {
    if (!this.manager.browser) {
      await this.manager.waitForEvent("ready");
    }
    this.store = this.manager.browser;
    this.client = this.manager.apiClient;
    this.store.on("pageadded", (e) => this.onPageAdded(e));
    this.store.on("pagedeleted", (e) => this.onPageDeleted(e));
    this.store.pages.forEach((page) => this.onPageAdded(page));
    this.resizeObserver = new ResizeObserver((_2) => {
      this.syncSize();
    });
    this.resizeObserver.observe(this.container);
  }
  addPageOverlay(overlay) {
    this.overlays.push(overlay);
    for (let pv of this.pageViews.values()) {
      pv.addOverlay(overlay);
    }
  }
  getPage(id) {
    if (typeof id == "number") {
      let size = this.pageViews.size;
      let index = id;
      if (index < 0) {
        index += size;
      }
      if (index >= size) {
        throw new Error("Page index out of bounds: " + index);
      }
      let pages = this.pageViews.values();
      let i = 0;
      for (let page of pages) {
        if (i == index) {
          return page;
        }
        i += 1;
      }
      throw new Error("(unreachable code) Page not found: " + id);
    } else {
      return this.pageViews.get(id);
    }
  }
  onDOMEvent(pageId, frameId, event) {
    this.getPage(pageId).onDOMEvent(frameId, event);
  }
  async onWEBRTCEvent(pageId, frameId, peerId, event) {
    await this.getPage(pageId).onWEBRTCEvent(frameId, peerId, event);
  }
  onPageAdded(page) {
    let pageView = new PageView(page, this);
    this.pageViews.set(page.id, pageView);
    this.overlays.forEach((o) => pageView.addOverlay(o));
    let el = pageView.render();
    this.setPageElStyle(el);
    this.container.appendChild(el);
    this.emit("pageadded", pageView);
  }
  onPageDeleted(page) {
    let pageView = this.getPage(page.id);
    pageView.destroy();
    this.pageViews.delete(page.id);
    this.emit("pagedeleted", pageView);
  }
  setPageElStyle(el) {
    Object.assign(el.style, {
      position: "absolute",
      height: "100%",
      width: "100%",
      backgroundColor: "#fff"
    });
  }
  getNode(pageId, frameId, path) {
    return this.getPage(pageId).getFrame(frameId).getNode(path);
  }
  async syncSize() {
    let r = this.container.getBoundingClientRect();
    await this.store.call("setViewport", {
      width: Math.trunc(r.width),
      height: Math.trunc(r.height)
    });
  }
  sendError(e) {
    this.client.sendError(e);
  }
  close() {
    this.resizeObserver.unobserve(this.container);
    this.client.close();
    this.emit("close");
  }
}
function isClickingOnScrollbar(e) {
  const el = e.target;
  const rect = el.getBoundingClientRect();
  const doc = el.ownerDocument;
  const isRoot = el === doc.documentElement || el === doc.body;
  const x = e.clientX - (isRoot ? 0 : rect.left);
  const y = e.clientY - (isRoot ? 0 : rect.top);
  const inVerticalScrollbarRange = x >= el.clientWidth && (isRoot || x <= el.offsetWidth);
  const inHorizontalScrollbarRange = y >= el.clientHeight && (isRoot || y <= el.offsetHeight);
  const inScrollbarV = el.scrollHeight > el.clientHeight && y < el.offsetHeight && inVerticalScrollbarRange;
  const inScrollbarH = el.scrollWidth > el.clientWidth && x < el.offsetWidth && inHorizontalScrollbarRange;
  return inScrollbarV || inScrollbarH;
}
function querySelectorAll(selector, doc) {
  if (typeof selector === "string") {
    return Array.from(doc.querySelectorAll(selector));
  } else if (selector.type === "css") {
    return Array.from(doc.querySelectorAll(selector.value));
  } else if (selector.type === "xpath") {
    let els = [];
    let iterator = doc.evaluate(selector.value, doc, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
    try {
      let thisNode = iterator.iterateNext();
      while (thisNode) {
        els.push(thisNode);
        thisNode = iterator.iterateNext();
      }
      return els;
    } catch (e) {
      throw new Error("Document tree modified during iteration" + e);
    }
  } else {
    throw new Error("unsupported selector type:" + selector.type);
  }
}
class PageOverlayBase extends EventEmitter$1 {
  constructor() {
    super(...arguments);
    this._views = /* @__PURE__ */ new Map();
  }
  onFrameInit(fv) {
    let el = this.createEl(fv);
    if (el) {
      el.dataset.name = this.constructor.name;
      this._views.set(fv.store.id, el);
      fv.elMeta.shadowRoot.appendChild(el);
      this.afterViewCreated(fv, el);
    }
    this.afterInit(fv, el);
  }
  onFrameUninit(fv) {
    this.afterUninit(fv);
    this.removeEl(fv);
  }
  afterViewCreated(fv, el) {
  }
  createEl(fv) {
    return document.createElement("div");
  }
  getEl(fv) {
    return this._views.get(fv.store.id);
  }
  removeEl(fv) {
    let el = this.getEl(fv);
    el.parentNode.removeChild(el);
    this._views.delete(fv.store.id);
  }
}
class BaseError extends Error {
  constructor(code, message, opts) {
    var _a;
    super(message, opts);
    __publicField(this, "code");
    __publicField(this, "meta");
    this.code = code;
    this.meta = (_a = opts == null ? void 0 : opts.meta) != null ? _a : {};
  }
  set(key, value) {
    if (typeof key === "object") {
      if (key.hasOwnProperty("message") || key.hasOwnProperty("code")) {
        throw new Error(`meta can't have message or code as keys`);
      }
      Object.assign(this.meta, key);
    } else {
      if (["message", "code"].includes(key)) {
        throw new Error(`meta can't have message or code as keys`);
      }
      this.meta[key] = value;
    }
  }
  get(key) {
    return this.meta[key];
  }
  delete(key) {
    delete this.meta[key];
  }
  toJSON() {
    var _a, _b;
    let serializedCause;
    if (this.cause) {
      serializedCause = (_b = (_a = this.cause).toJSON) == null ? void 0 : _b.call(_a);
      if (!serializedCause) {
        const { code, message, stack } = this.cause;
        serializedCause = {
          code,
          message,
          stack
        };
      }
    }
    return {
      code: this.code,
      message: this.message,
      stack: this.stack,
      cause: serializedCause,
      ...this.meta
    };
  }
}
class StackedError extends BaseError {
  constructor(error, stackLine) {
    const { code, message, stack, stackEx, meta, cause, stackLineNames, ...rest } = error;
    super(code, message, {
      cause: stack ? { stack } : void 0,
      meta
    });
    __publicField(this, "stackEx");
    this.stackEx = stackEx != null ? stackEx : [];
    if (stackLine) {
      this.add(stackLine);
    }
    this.set(rest);
  }
  static handle(error, stackLineName, stackLine = {}) {
    let newStackLine;
    if (typeof stackLineName === "object") {
      newStackLine = stackLineName;
    } else if (typeof stackLineName === "string") {
      newStackLine = {
        __name__: stackLineName,
        ...stackLine
      };
    }
    if (error instanceof StackedError) {
      if (!newStackLine) {
        return error;
      }
      error.add(newStackLine);
      return error;
    } else {
      return new StackedError(error, newStackLine);
    }
  }
  get stackLineNames() {
    return this.stackEx.map((stackLine) => stackLine.__name__).join(".");
  }
  add(name, stackLine = {}) {
    let newStackLine;
    if (typeof name === "object") {
      newStackLine = name;
    } else {
      newStackLine = {
        __name__: name,
        ...stackLine
      };
    }
    this.stackEx.unshift(newStackLine);
  }
  find(sl) {
    if (typeof sl === "string") {
      sl = { __name__: sl };
    }
    const findFn = (stackLine) => Object.keys(sl).every((searchKey) => sl[searchKey] === stackLine[searchKey]);
    return this.stackEx.find(findFn);
  }
  findLast(sl) {
    if (typeof sl === "string") {
      sl = { __name__: sl };
    }
    const findFn = (stackLine) => Object.keys(sl).every((searchKey) => sl[searchKey] === stackLine[searchKey]);
    return this.stackEx.findLast(findFn);
  }
  findIndex(sl) {
    if (typeof sl === "string") {
      sl = { __name__: sl };
    }
    const findFn = (stackLine) => Object.keys(sl).every((searchKey) => sl[searchKey] === stackLine[searchKey]);
    return this.stackEx.findIndex(findFn);
  }
  findLastIndex(sl) {
    if (typeof sl === "string") {
      sl = { __name__: sl };
    }
    const findFn = (stackLine) => Object.keys(sl).every((searchKey) => sl[searchKey] === stackLine[searchKey]);
    return this.stackEx.findLastIndex(findFn);
  }
  clone() {
    const errorClone = new StackedError(this);
    errorClone.stackEx = [...this.stackEx];
    return errorClone;
  }
  toJSON() {
    return {
      ...super.toJSON(),
      stackEx: this.stackEx,
      stackLineNames: this.stackLineNames
    };
  }
}
const ErrorCodes = {
  E_PARSE: "E_PARSE",
  E_INTERRUPT: "E_INTERRUPT",
  E_REQUEST: "E_REQUEST"
};
class EventEmitter {
  constructor() {
    __publicField(this, "__ee_listeners");
    this.__ee_listeners = {};
  }
  emit(name, ...args) {
    (this.__ee_listeners[name] || []).forEach((l) => l(...args));
  }
  hasListener(name) {
    return (this.__ee_listeners[name] || []).length > 0;
  }
  off(name, listener) {
    let listeners = this.__ee_listeners[name];
    if (listeners == void 0) {
      listeners = this.__ee_listeners[name] = [];
    }
    let index = listeners.indexOf(listener);
    while (index >= 0) {
      listeners.splice(index, 1);
      index = listeners.indexOf(listener);
    }
    return this;
  }
  on(name, listener) {
    let listeners = this.__ee_listeners[name];
    if (listeners == void 0) {
      listeners = this.__ee_listeners[name] = [];
    }
    listeners.push(listener);
    return this;
  }
  once(name, listener) {
    const l2 = (...args) => {
      this.off(name, l2);
      listener(...args);
    };
    this.on(name, l2);
    return this;
  }
  removeListeners() {
    this.__ee_listeners = {};
  }
  waitForEvent(name, ...selectors) {
    return new Promise((resolve) => {
      const l2 = (...args) => {
        for (let i = 0, length = selectors.length; i < length; i += 1) {
          if (selectors[i] !== args[i]) {
            return;
          }
        }
        resolve(args[0]);
      };
      this.on(name, l2);
    });
  }
}
class RejectablePromise extends Promise {
  constructor(executor = () => {
  }) {
    let resolve;
    let reject;
    super((res, rej) => {
      resolve = res;
      reject = rej;
      return executor(res, rej);
    });
    __publicField(this, "_resolve");
    __publicField(this, "_reject");
    __publicField(this, "settled", false);
    __publicField(this, "state", "pending");
    this._resolve = resolve;
    this._reject = reject;
  }
  resolve(value) {
    this._resolve(value);
    this.state = "fulfilled";
    this.settled = true;
  }
  reject(reason) {
    this._reject(reason);
    this.state = "rejected";
    this.settled = true;
  }
}
var C = {
  STRING: "string",
  SECRET: "secret",
  INT: "int",
  FLOAT: "float",
  BOOLEAN: "boolean",
  "JSON": "json",
  ARRAY: "array",
  FUNCTION: "function",
  ITERABLE: "iterable",
  VOID: "void",
  BLOCK: "BLOCK",
  VARIABLE_DECLARATION: "VARIABLE_DECLARATION",
  COND: "COND",
  WHILE: "WHILE",
  FOR: "FOR",
  ASSIGNMENT: "ASSIGNMENT",
  VARIABLE_REFERENCE: "VARIABLE_REFERENCE",
  ERROR: "ERROR",
  CLAUSE: "CLAUSE",
  FUNCTION_CALL: "FUNCTION_CALL",
  FUNCTION_DEFINITION: "FUNCTION_DEFINITION",
  FUNCTION_PARAMETER: "FUNCTION_PARAMETER",
  LITERAL: "LITERAL",
  STRUCT: "STRUCT",
  ENUM: "ENUM",
  MAP_NODE: "MAP_NODE",
  ARRAY_NODE: "ARRAY_NODE",
  RETURN: "RETURN",
  OPERATOR: "OPERATOR",
  OP_AND: "and",
  OP_OR: "or",
  OP_NOT: "not",
  DUPLICATE_DECLARATION: "duplicate_declaration",
  MISSING_ARGUMENT: "missing_argument",
  INVALID_SYNTAX: "invalid_syntax",
  TYPE_MISMATCH: "type_mismatch",
  UNDEFINED_TYPE: "undefined_type",
  INVALID_VARIABLE_NAME: "invalid_variable_name",
  INVALID_VARIABLE_REFERENCE: "invalid_variable_reference",
  INVALID_VARIABLE_TYPE: "invalid_variable_type",
  INVALID_FIELD_NAME: "invalid_field_name",
  CHANGE: "change",
  CONTEXT: "_context_",
  UNTITLED: "_untitled_",
  VALUE: "VALUE",
  NULL: "null",
  UNDEFINED: "undefined",
  UNKNOWN: "unknown"
};
const HOOK_EVENT = {
  BEFORE_RUN: "beforeRun",
  BEFORE_EVAL: "beforeEval",
  AFTER_EVAL: "afterEval",
  AFTER_RUN: "afterRun"
};
function isValidFunctionDefinitionSyntax(expr) {
  if (!Array.isArray(expr))
    return false;
  if (expr.length !== 4)
    return false;
  if (expr[0] !== "func")
    return false;
  if (typeof expr[1] !== "string")
    return false;
  if (!Array.isArray(expr[2]))
    return false;
  for (let param of expr[2]) {
    if (!Array.isArray(param))
      return false;
    if (param.length !== 2)
      return false;
    if (typeof param[0] !== "string")
      return false;
    if (typeof param[1] !== "string")
      return false;
  }
  return true;
}
function isValidLambdaSyntax(expr) {
  if (!Array.isArray(expr))
    return false;
  if (expr.length !== 3)
    return false;
  if (expr[0] !== "lambda")
    return false;
  if (!Array.isArray(expr[1]))
    return false;
  for (let param of expr[1]) {
    if (!Array.isArray(param))
      return false;
    if (param.length !== 2)
      return false;
    if (typeof param[0] !== "string")
      return false;
    if (typeof param[1] !== "string")
      return false;
  }
  return true;
}
function isValidVariableDeclarationSyntax(expr) {
  return Array.isArray(expr) && expr.length >= 3 && expr[0] === "var" && typeof expr[1] === "string" && typeof expr[2] === "string";
}
function isDeclaration(node) {
  return isVariableDeclaration(node) || isFunctionDefinition(node);
}
function isFunctionDefinition(node) {
  return node instanceof FunctionDefinition;
}
function isVariableDeclaration(node) {
  return node instanceof VariableDeclaration$1;
}
function getReferences(node) {
  let parent2 = node.parent;
  let index = parent2.nodes.indexOf(node);
  let refs = [];
  for (let i = index + 1; i < parent2.nodes.length; i++) {
    refs.push(...getReferencesInExpr(parent2.nodes[i], node));
  }
  return refs;
}
function getReferencesInExpr(node, ref) {
  var _a;
  let refs = [];
  if (node instanceof VariableReference$1 && node._ref === ref.name && ((_a = node.scope.get(node._ref)) == null ? void 0 : _a.ref) === ref) {
    refs.push(node);
  }
  for (let child of node.children) {
    refs.push(...getReferencesInExpr(child, ref));
  }
  return refs;
}
function getParamReferences(param, root) {
  return getReferencesInExpr(root.expression, param);
}
class ValidationScope extends EventEmitter {
  constructor(parent2) {
    super();
    __publicField(this, "basicTypes", [C.STRING, C.SECRET, C.BOOLEAN, C.JSON, C.ARRAY, C.INT, C.FLOAT]);
    __publicField(this, "parent");
    __publicField(this, "entries", /* @__PURE__ */ new Map());
    this.parent = parent2;
  }
  clearVar() {
    for (let key of this.entries.keys()) {
      if (this.entries.get(key).type === C.VALUE) {
        this.entries.delete(key);
      }
    }
  }
  has(name) {
    var _a;
    return this.entries.has(name) || ((_a = this.parent) == null ? void 0 : _a.has(name)) || false;
  }
  hasBasicType(name) {
    return this.basicTypes.includes(name);
  }
  hasEnum(name) {
    return this.has(name) && this.get(name).type === C.ENUM;
  }
  hasFunc(name) {
    return this.has(name) && this.get(name).type === C.FUNCTION;
  }
  hasStruct(name) {
    return this.has(name) && this.get(name).type === C.STRUCT;
  }
  hasType(name) {
    while (isArrayType(name)) {
      name = getArrayElementType(name);
    }
    return this.hasEnum(name) || this.hasStruct(name) || this.hasBasicType(name);
  }
  hasVar(name) {
    return this.has(name) && this.get(name).type === "VALUE";
  }
  get(name) {
    var _a;
    if (this.entries.has(name)) {
      return this.entries.get(name);
    } else if ((_a = this.parent) == null ? void 0 : _a.has(name)) {
      return this.parent.get(name);
    } else {
      throw new Error(`${name} not found`);
    }
  }
  getBasicTypes() {
    return [...this.basicTypes];
  }
  getEnum(name) {
    if (this.hasEnum(name)) {
      return this.get(name).value;
    } else {
      throw new Error(`No Enum named: ${name}`);
    }
  }
  getAllEnums() {
    let res = /* @__PURE__ */ new Map();
    if (this.parent) {
      res = this.parent.getAllEnums();
    }
    for (let [key, value] of this.entries) {
      if (value.type === C.ENUM) {
        res.set(key, value.value);
      }
    }
    return res;
  }
  getFunc(name) {
    if (this.hasFunc(name)) {
      return this.get(name).value;
    } else {
      throw new Error(`No Function named: ${name}`);
    }
  }
  getAllFuncs() {
    let res = /* @__PURE__ */ new Map();
    if (this.parent) {
      res = this.parent.getAllFuncs();
    }
    for (let [key, value] of this.entries) {
      if (value.type === C.FUNCTION) {
        res.set(key, value.value);
      }
    }
    return res;
  }
  getStruct(name) {
    if (this.hasStruct(name)) {
      return this.get(name).value;
    } else {
      throw new Error(`No Struct named: ${name}`);
    }
  }
  getAllStructs() {
    let res = /* @__PURE__ */ new Map();
    if (this.parent) {
      res = this.parent.getAllStructs();
    }
    for (let [key, value] of this.entries) {
      if (value.type === C.STRUCT) {
        res.set(key, value.value);
      }
    }
    return res;
  }
  getVar(name) {
    if (this.hasVar(name)) {
      return this.get(name).value;
    } else {
      throw new Error(`No Variable named: ${name}`);
    }
  }
  getAllVars() {
    let res = /* @__PURE__ */ new Map();
    if (this.parent) {
      res = this.parent.getAllVars();
    }
    for (let [key, value] of this.entries) {
      if (value.type === C.VALUE) {
        res.set(key, value.value);
      }
    }
    return res;
  }
  setEnum(name, enumDef) {
    this.entries.set(name, { type: C.ENUM, value: enumDef });
  }
  setFunc(name, func2, ref) {
    this.entries.set(name, { type: C.FUNCTION, value: func2, ref });
  }
  setStruct(name, struct) {
    this.entries.set(name, { type: C.STRUCT, value: struct });
  }
  setVar(name, variable, ref) {
    this.entries.set(name, { type: C.VALUE, value: variable, ref });
  }
}
function parseBlock(source, parent2, scope) {
  var _a, _b;
  if (!Array.isArray(source)) {
    throw new Error("Invalid statement list");
  }
  const root = parent2 instanceof Root ? parent2 : parent2.root;
  const allowNamedBlocks = (_a = root.allowNamedBlocks) != null ? _a : false;
  let name = !allowNamedBlocks || parent2 instanceof Root || source[0] !== "block" || !source[1] ? C.UNTITLED : source[1];
  if (allowNamedBlocks && !(parent2 instanceof Root) && source[0] === "block") {
    source = (_b = source[2]) != null ? _b : [];
  }
  return new Block(parent2, scope, name, source);
}
function parseStatement(statement, parent2, scope) {
  const root = parent2 instanceof Root ? parent2 : parent2.root;
  if (Array.isArray(statement)) {
    if (statement.length === 0) {
      throw new Error("Invalid statement");
    } else if (statement[0] === "var") {
      return parseVariableDeclaration(statement, parent2, scope);
    } else if (statement[0] === "cond") {
      return parseConditional(statement, parent2, scope);
    } else if (statement[0] === "=") {
      return parseAssignment(statement, parent2, scope);
    } else if (statement[0] === "return") {
      return _parseReturn(statement, parent2, scope);
    } else if (statement[0] === "for") {
      return parseForStatement(statement, parent2, scope);
    } else if (statement[0] === "while") {
      return parseWhileStatement(statement, parent2, scope);
    } else if (statement[0] === "func") {
      return parseFunctionDefinition(statement, parent2, scope);
    } else if (root.allowNamedBlocks && statement[0] === "block") {
      return parseBlock(statement, parent2, scope);
    }
  }
  return parseExpression(statement, parent2, scope);
}
function parseExpression(expr, parent2, scope) {
  if (expr === void 0 || expr === null) {
    throw new Error("invalid expression");
  }
  if (typeof expr === "string" && expr[0] === "$") {
    if (expr.length === 1) {
      throw new Error(`Invalid expression: ${JSON.stringify(expr)}`);
    }
    return parseVariableReference(expr, parent2, scope);
  } else if (Array.isArray(expr) && expr.length > 0 && typeof expr[0] === "string") {
    if (expr[0] === "ERROR") {
      return new ErrorExp(parent2, scope, expr[1]);
    } else if (expr[0] === C.ARRAY) {
      return parseArray(expr, parent2, scope);
    } else if (expr[0] === "map") {
      return parseMap(expr, parent2, scope);
    } else if (["and", "or", "not"].includes(expr[0])) {
      return parseLogicalOperator(expr, parent2, scope);
    } else if (expr[0] === "->") {
      return parseAccessor(expr, parent2, scope);
    } else if (expr[0] === "secret") {
      return parseSecret(expr, parent2, scope);
    } else if (scope.hasFunc(expr[0])) {
      return _parseFunctionCall(expr, parent2, scope);
    } else if (scope.hasStruct(expr[0])) {
      return parseStruct(expr, parent2, scope);
    } else if (scope.hasEnum(expr[0])) {
      return parseEnum(expr, parent2, scope);
    } else {
      throw new Error(`Type ${expr[0]} not found in scope`);
    }
  } else if (isPlainObject(expr) || Array.isArray(expr) && expr[0] === "array" || isPrimitive(expr)) {
    return parseLiteral(expr, parent2, scope);
  } else {
    throw new Error(`Invalid expression: ${JSON.stringify(expr)}`);
  }
}
function parseSecret(expr, parent2, scope) {
  if (!Array.isArray(expr) || expr.length !== 2 || typeof expr[1] !== "string") {
    throw new Error("Invalid secret expression");
  }
  return new Literal$3(parent2, scope, expr[1], { isSecret: true });
}
function parseMap(expr, parent2, scope) {
  if (expr.length !== 3 || expr[0] !== "map") {
    throw new Error("Invalid map expression");
  }
  return new MapExp(parent2, scope, expr[1], expr[2]);
}
function parseFunctionDefinition(statements, parent2, scope) {
  if (!isValidFunctionDefinitionSyntax(statements)) {
    throw new Error("Invalid function definition syntax");
  }
  return new FunctionDefinition(parent2, scope, statements[1], statements[2], statements.slice(3));
}
function parseArray(expr, parent2, scope) {
  if (expr.length !== 3 || expr[0] !== C.ARRAY || typeof expr[1] !== "string" || !Array.isArray(expr[2])) {
    throw new Error("Invalid array expression");
  }
  return new ArrayExp(parent2, scope, expr[1], expr[2]);
}
function parseStruct(expr, parent2, scope) {
  if (!Array.isArray(expr) || typeof expr[0] !== "string" || expr[1] && !isPlainObject(expr[1])) {
    throw new Error("Invalid struct expression");
  }
  if (!scope.hasStruct(expr[0])) {
    throw new Error("Struct not found in registry");
  }
  return new Struct$2(parent2, scope, expr[0], expr[1]);
}
function parseEnum(expr, parent2, scope) {
  if (!Array.isArray(expr) || typeof expr[0] !== "string") {
    throw new Error("Invalid enum expression");
  }
  if (!scope.hasEnum(expr[0])) {
    throw new Error("Enum not found in registry");
  }
  return new Enum$2(parent2, scope, expr[0], expr[1]);
}
function parseVariableDeclaration(statement, parent2, scope) {
  if (!isValidVariableDeclarationSyntax(statement)) {
    throw new Error("Invalid variable declaration syntax");
  } else if (!scope.hasType(statement[2])) {
    throw new Error("the variable declaration has an invalid type");
  } else {
    return new VariableDeclaration$1(parent2, scope, statement[1], statement[2], statement[3]);
  }
}
function parseConditional(statement, parent2, scope) {
  if (!Array.isArray(statement) || statement.length === 0 || statement[0] !== "cond") {
    throw new Error("Invalid conditional statement");
  }
  return new Conditional(parent2, scope, statement.slice(1));
}
function parseWhileStatement(statement, parent2, scope) {
  if (!Array.isArray(statement) || statement.length === 0 || statement[0] !== "while") {
    throw new Error("Invalid while statement");
  }
  return new While$1(parent2, scope, statement.slice(1));
}
function parseForStatement(statement, parent2, scope) {
  if (!Array.isArray(statement) || statement.length === 0 || statement[0] !== "for") {
    throw new Error("Invalid for statement");
  }
  return new For$1(parent2, scope, statement.slice(1));
}
function parseAssignment(statement, parent2, scope) {
  if (!Array.isArray(statement) || statement.length !== 3 || statement[0] !== "=") {
    throw new Error("Invalid assignment statement");
  }
  return new Assignment$1(parent2, scope, statement[1], statement[2]);
}
function _parseReturn(statement, parent2, scope) {
  if (!Array.isArray(statement)) {
    throw new Error("Invalid return statement");
  }
  return new Return$1(parent2, scope, statement[1]);
}
function parseVariableReference(expr, parent2, scope) {
  if (typeof expr !== "string" || expr.length === 0 || expr[0] !== "$") {
    throw new Error("Invalid variable reference");
  }
  return new VariableReference$1(parent2, scope, expr.slice(1));
}
function parseCallback(expr, parent2, scope) {
  if (typeof expr === "string" && expr.length > 1 && expr[0] === "$") {
    return parseVariableReference(expr, parent2, scope);
  } else {
    return parseLambda(expr, parent2, scope);
  }
}
function parseLambda(statements, parent2, scope) {
  if (!isValidLambdaSyntax(statements)) {
    throw new Error("Invalid Lambda syntax");
  }
  return new Lambda(parent2, scope, statements[1], statements.slice(2));
}
function parseLiteral(expr, parent2, scope) {
  if (!isPrimitive(expr) && (!Array.isArray(expr) || expr[0] !== "array") && !isPlainObject(expr)) {
    throw new Error("Invalid literal");
  }
  return new Literal$3(parent2, scope, expr);
}
function _parseFunctionCall(expr, parent2, scope) {
  if (!Array.isArray(expr) || expr.length === 0 || typeof expr[0] !== "string") {
    throw new Error("Invalid function call");
  }
  if (!scope.hasFunc(expr[0])) {
    throw new Error("Function not found in scope");
  }
  let args = expr.length > 1 ? expr.slice(1) : void 0;
  return new FunctionCall$2(parent2, scope, expr[0], args);
}
function parseLogicalOperator(expr, parent2, scope) {
  if (!Array.isArray(expr) || expr.length === 0 || typeof expr[0] !== "string") {
    throw new Error("Invalid logical operator");
  }
  if (expr[0] === C.OP_NOT && expr.length !== 2) {
    throw new Error("NOT requires exactly one operand");
  }
  const operands = expr.slice(1);
  return new LogicalOperator(parent2, scope, expr[0], operands);
}
function parseAccessor(expr, parent2, scope) {
  if (!Array.isArray(expr) || expr.length == 0) {
    throw new Error("Invalid Accessor");
  }
  if (expr.length !== 3) {
    throw new Error("Accessor requires exactly two operands");
  }
  const operands = expr.slice(1);
  return new Accessor$2(parent2, scope, expr[0], operands);
}
class Declarations extends EventEmitter {
  constructor(root, params = []) {
    super();
    __publicField(this, "_params");
    __publicField(this, "_root");
    this._root = root;
    this._params = [];
    for (let param of params) {
      this.add(param);
    }
  }
  get length() {
    return this._params.length;
  }
  get list() {
    return [...this._params];
  }
  get names() {
    return this._params.map((p) => p.name);
  }
  emitChange() {
    this.emit("change");
    this._root.emit("change");
  }
  add(param) {
    if (this.names.some((p) => p === param.name)) {
      throw new Error(`Param with name "${param.name}" already exists`);
    }
    if (!isValidName(param.name)) {
      throw new Error(`Invalid param name "${param.name}"`);
    }
    this._params.push({ ...param });
    this.emitChange();
  }
  changeType(name, newType) {
    const param = this.get(name);
    if (param.dataType === newType) {
      return;
    }
    param.dataType = newType;
    this.emitChange();
  }
  get(name) {
    if (!this.has(name)) {
      throw new Error(`Param name "${name}" is not found.`);
    }
    return this._params.find((p) => p.name === name);
  }
  has(name) {
    return this._params.findIndex((p) => p.name === name) > -1;
  }
  remove(paramName) {
    let index = this._params.findIndex((p) => p.name === paramName);
    if (index < 0) {
      throw new Error(`Param name "${paramName}" not found`);
    }
    this._params.splice(index, 1);
    this.emitChange();
  }
  rename(paramName, newName) {
    if (paramName === newName)
      return;
    if (this.has(newName)) {
      throw new Error(`Param name "${newName}" already exists`);
    }
    if (!isValidName(newName))
      throw new Error(`Invalid name "${newName}" for param`);
    let param = this.get(paramName);
    let refs = getParamReferences(param, this._root);
    refs.forEach((ref) => {
      ref._ref = newName;
      ref.emitChange();
    });
    param.name = newName;
    this.emitChange();
  }
  toJSON() {
    return structuredClone(this._params);
  }
}
class Root extends EventEmitter {
  constructor(registry, source, opts) {
    var _a, _b, _c;
    super();
    __publicField(this, "allowNamedBlocks");
    __publicField(this, "expression");
    __publicField(this, "declarations");
    __publicField(this, "registry");
    __publicField(this, "scope", new ValidationScope());
    __publicField(this, "updateScope", () => {
      var _a;
      this.scope.clearVar();
      for (let param of this.declarations.list) {
        this.scope.setVar(param.name, { name: param.name, dataType: param.dataType }, param);
      }
      (_a = this.expression) == null ? void 0 : _a.scopeChange(this.scope);
    });
    this.registry = registry;
    this.allowNamedBlocks = (_a = opts == null ? void 0 : opts.allowNamedBlocks) != null ? _a : false;
    this.declarations = new Declarations(this, (_b = opts == null ? void 0 : opts.declarations) != null ? _b : []);
    const sourceType = (_c = opts == null ? void 0 : opts.sourceType) != null ? _c : C.BLOCK;
    for (let name in registry.enums) {
      this.scope.setEnum(name, registry.enums[name]);
    }
    for (let name in registry.structs) {
      this.scope.setStruct(name, registry.structs[name]);
    }
    for (let name in registry.funcs) {
      this.scope.setFunc(name, registry.funcs[name]);
    }
    this.updateScope();
    this.declarations.on("change", this.updateScope);
    if (!Array.isArray(source)) {
      source = [source];
    }
    if (sourceType === C.BLOCK) {
      this.expression = parseBlock(source, this, this.scope);
    } else {
      this.expression = parseStatement(source, this, this.scope);
    }
  }
  emitChange(node) {
    this.emit(C.CHANGE, node);
  }
  async evaluate(vm) {
    let error;
    await vm.runHooks(HOOK_EVENT.BEFORE_RUN);
    try {
      const interruptPromise = vm.appendNewInterruptPromise();
      return await Promise.race([
        interruptPromise,
        this.expression.evaluate(vm)
      ]);
    } catch (err) {
      if (err instanceof ReturnMarker) {
        return err.data;
      }
      error = err;
      const erroredNode = vm.observer.expressionStack.at(-1);
      throw StackedError.handle(err, "node", { path: erroredNode == null ? void 0 : erroredNode.path(), name: erroredNode == null ? void 0 : erroredNode.title });
    } finally {
      vm.interruptPromises.pop();
      await vm.runHooks(HOOK_EVENT.AFTER_RUN, { error });
    }
  }
  getAll() {
    let expressions = [];
    expressions.push(this.expression);
    for (let expression of expressions) {
      expressions.push(...expression.children);
    }
    return expressions;
  }
  hasErrors() {
    return this.getAll().some((node) => node instanceof ErrorExp || node.error instanceof ErrorExp);
  }
  getErrorNodes() {
    return this.getAll().filter((node) => node instanceof ErrorExp || node.error instanceof ErrorExp);
  }
  getNode(path) {
    let targetNode = this.expression;
    for (const idx of path) {
      targetNode = targetNode.children[idx];
    }
    return targetNode;
  }
  toJSON() {
    if (this.hasErrors()) {
      throw new Error("Cannot serialize tree with errors");
    } else {
      return this.expression.toJSON();
    }
  }
  onRenameVar(_varDec) {
    this.updateScope();
  }
  replace(source) {
    this.expression = parseBlock(source, this, this.scope);
    this.emitChange(this.expression);
  }
}
class Expression$1 extends EventEmitter {
  constructor(nodeType, parent2, scope) {
    super();
    __publicField(this, "type");
    __publicField(this, "parent");
    __publicField(this, "scope");
    __publicField(this, "error");
    this.type = nodeType;
    this.parent = parent2;
    this.scope = scope;
  }
  get root() {
    let candidateRoot = this.parent;
    while (!(candidateRoot instanceof Root)) {
      candidateRoot = candidateRoot.parent;
    }
    return candidateRoot;
  }
  get returnType() {
    return C.UNKNOWN;
  }
  get title() {
    return this.type;
  }
  emitChange(node = this) {
    var _a;
    this.emit(C.CHANGE, node);
    (_a = this.parent) == null ? void 0 : _a.emitChange(node);
  }
  async evaluate(vm, ...args) {
    let error;
    await vm.runHooks(HOOK_EVENT.BEFORE_EVAL, { node: this });
    try {
      const interruptPromise = vm.appendNewInterruptPromise();
      return await Promise.race([
        interruptPromise,
        this._evaluate(vm, ...args)
      ]);
    } catch (err) {
      error = err;
      throw error;
    } finally {
      vm.interruptPromises.pop();
      await vm.runHooks(HOOK_EVENT.AFTER_EVAL, { node: this, error });
    }
  }
  scopeChange(scope) {
    this.scope = scope;
    for (let child of this.children) {
      child.scopeChange(scope);
    }
  }
  path() {
    const buildPath = (node, accPath) => {
      if (node.parent instanceof Root) {
        return accPath;
      }
      const idx = node.parent.children.indexOf(node);
      accPath.unshift(idx);
      return buildPath(node.parent, accPath);
    };
    return buildPath(this, []);
  }
}
class Operator extends Expression$1 {
  constructor(parent2, scope, name, operands) {
    super(C.OPERATOR, parent2, scope);
    __publicField(this, "name");
    __publicField(this, "operands", []);
    this.name = name;
    this.operands = this.parse(operands);
  }
  get children() {
    return [...this.operands];
  }
  get title() {
    return this.name;
  }
  parse(operands) {
    return operands.map((operand) => parseExpression(operand, this, this.scope));
  }
  insertAt(index, expressionSource) {
    const node = parseExpression(expressionSource, this, this.scope);
    this.operands.splice(index, 0, node);
    this.emitChange();
    this.emit("child_addition", node);
  }
  remove(node) {
    const index = this.operands.indexOf(node);
    if (index === -1)
      throw new Error("Operand not found in the list");
    this.operands.splice(index, 1);
    this.emitChange();
  }
  replace(oldChild, expressionSource) {
    let index = this.children.indexOf(oldChild);
    if (index < 0) {
      throw new Error("No child matching the given node");
    }
    this.operands[index] = parseExpression(expressionSource, this, this.scope);
    this.emitChange();
  }
}
class LogicalOperator extends Operator {
  get returnType() {
    return C.BOOLEAN;
  }
  async _evaluate(vm) {
    switch (this.name) {
      case C.OP_AND:
        return await this.and(vm);
      case C.OP_OR:
        return await this.or(vm);
      case C.OP_NOT:
        return await this.not(vm);
    }
  }
  async and(vm) {
    for (const operand of this.operands) {
      const result = await operand.evaluate(vm);
      if (!result) {
        return false;
      }
    }
    return true;
  }
  async or(vm) {
    for (const operand of this.operands) {
      const result = await operand.evaluate(vm);
      if (result) {
        return true;
      }
    }
    return false;
  }
  async not(vm) {
    return !await this.operands[0].evaluate(vm);
  }
  insertAt(index, expressionSource) {
    if (this.name === C.OP_NOT) {
      throw new Error("Error: Cannot perform 'insertAt' operation on a NOT operator");
    }
    super.insertAt(index, expressionSource);
  }
  remove(node) {
    if (this.name === C.OP_NOT) {
      throw new Error("Error: Cannot perform 'replace' operation on a NOT operator");
    }
    super.remove(node);
  }
  parse(operandsSource) {
    const operands = [];
    for (let idx = 0; idx < operandsSource.length; idx++) {
      const operandSource = operandsSource[idx];
      let operand = parseExpression(operandSource, this, this.scope);
      if (!(operand instanceof ErrorExp) && operand.returnType !== C.BOOLEAN) {
        let content;
        if (operand instanceof FunctionCall$2) {
          content = `${operand.name} returns ${operand.returnType}`;
        } else if (operand instanceof Literal$3) {
          content = `${operand.value} is of type ${operand.returnType}`;
        } else {
          content = `Got type ${operand.returnType}`;
        }
        const errorMessage = `Error: Type Mismatch - ${content} expected boolean`;
        throw new Error(errorMessage);
      }
      operands.push(operand);
    }
    return operands;
  }
  toJSON() {
    return [this.name, ...this.operands.map((operand) => operand.toJSON())];
  }
}
class Accessor$2 extends Operator {
  get returnType() {
    const structDef = this.scope.get(this.operands[0].returnType).value;
    const fieldName = this.operands[1].value;
    const fieldDef = structDef.fields[fieldName];
    if (!fieldDef) {
      return C.UNKNOWN;
    }
    return structDef.fields[fieldName].types[0];
  }
  async _evaluate(vm) {
    const leftOp = await this.operands[0].evaluate(vm);
    const field = await this.operands[1].evaluate(vm);
    return leftOp[field];
  }
  insertAt() {
    throw new Error("Cannot perform 'insertAt' operation on a Accessor operator");
  }
  replace(oldChild, expressionSource) {
    const index = this.children.indexOf(oldChild);
    if (index < 0) {
      throw new Error("No child matching the given node");
    }
    const newExpr = parseExpression(expressionSource, this, this.scope);
    let structName, structDef, fieldName;
    if (index === 0) {
      structName = newExpr.returnType;
      if (!this.scope.hasStruct(structName)) {
        throw new Error(`${structName} cannot be assigned to a struct`);
      }
      fieldName = this.operands[1].value;
    } else {
      if (newExpr.returnType !== C.STRING) {
        throw new Error(`Field name must be a string got ${newExpr.returnType}`);
      }
      structName = this.operands[0].returnType;
      fieldName = newExpr.value;
    }
    structDef = this.scope.get(structName).value;
    if (!structDef.fields[fieldName]) {
      this.error = new ErrorExp(this, this.scope, C.INVALID_FIELD_NAME, `Field ${fieldName} does not exist on struct ${structName}`);
    } else if (this.error) {
      this.error = void 0;
    }
    this.operands[index] = newExpr;
    this.emitChange();
  }
  parse(operandSource) {
    const operands = super.parse(operandSource);
    if (!(this.scope.hasStruct(operands[0].returnType) || operands[0] instanceof Struct$2)) {
      throw new Error("Left hand side must return a struct");
    }
    if (!(operands[1] instanceof Literal$3 && operands[1].returnType == C.STRING)) {
      throw new Error("Right hand side must be a string");
    }
    const structName = operands[0].returnType;
    const structDef = this.scope.get(structName).value;
    const fieldName = operands[1].value;
    if (!structDef.fields[fieldName]) {
      this.error = new ErrorExp(this, this.scope, C.INVALID_FIELD_NAME, `Field ${fieldName} does not exist on struct ${structName}`);
    }
    return operands;
  }
  toJSON() {
    return ["->", this.operands[0].toJSON(), this.operands[1].toJSON()];
  }
}
class Block extends Expression$1 {
  constructor(parent2, scope, name, source) {
    super(C.BLOCK, parent2, scope);
    __publicField(this, "_name");
    __publicField(this, "nodes", []);
    this.scope = scope;
    this._name = name;
    source == null ? void 0 : source.forEach((statement) => {
      let scope2 = this.getScope(this.nodes.length);
      let node;
      try {
        node = parseStatement(statement, this, scope2);
      } catch (e) {
        console.error(e);
        node = new ErrorExp(this, scope2, C.INVALID_SYNTAX, e.message);
      }
      this.nodes.push(node);
    });
    this.emitChange();
  }
  get name() {
    return this._name;
  }
  set name(name) {
    if (!isValidName(name))
      throw new Error("Invalid name for Block");
    this._name = name;
  }
  get children() {
    return [...this.nodes];
  }
  clear() {
    this.nodes = [];
    this.emitChange();
  }
  async _evaluate(vm) {
    vm.scopeStack.push();
    if (this.name !== C.UNTITLED) {
      vm.scopeStack.set(C.CONTEXT, this.name);
    }
    let result;
    for (let node of this.nodes) {
      result = await node.evaluate(vm);
    }
    vm.scopeStack.pop();
    return result;
  }
  getScope(index) {
    let scope = new ValidationScope(this.scope);
    if (this.parent instanceof _FuncDef) {
      this.parent.parameters.forEach((param) => scope.setVar(param.name, { name: param.name, dataType: param.dataType }, param));
    }
    for (let i = 0; i < index; i++) {
      let node = this.nodes[i];
      if (isVariableDeclaration(node)) {
        scope.setVar(node.name, { name: node.name, dataType: node.dataType }, node);
      } else if (isFunctionDefinition(node)) {
        scope.setFunc(node.name, {
          name: node.name,
          args: Object.fromEntries(node.parameters.map((p) => [p.name, { types: [p.dataType] }])),
          returnType: node.returnType,
          fn: () => () => {
          }
        }, node);
      }
    }
    return scope;
  }
  remove(node) {
    let index = this.nodes.indexOf(node);
    if (index === -1)
      throw new Error("Node not found in the list");
    this.nodes.splice(index, 1);
    this.updateScope(index);
    this.emitChange();
  }
  insertAt(index, statement) {
    let scope = this.getScope(index);
    let node = parseStatement(statement, this, scope);
    if (isDeclaration(node)) {
      if (this.nodes.some((child) => isDeclaration(child) && child.name === node.name)) {
        throw new Error("Declaration with same name already exists in current block");
      }
    }
    this.nodes.splice(index, 0, node);
    this.updateScope(index + 1);
    this.emitChange();
    this.emit("child_addition", node);
  }
  replace(oldChild, statement) {
    let index = this.nodes.indexOf(oldChild);
    if (index === -1)
      throw new Error("Node not found in the list");
    let scope = this.getScope(index);
    let node = parseStatement(statement, this, scope);
    if (isDeclaration(node)) {
      if (this.nodes.some((child) => isDeclaration(child) && child.name === node.name)) {
        throw new Error("Declaration with same name already exists in current block");
      }
    }
    this.nodes[index] = node;
    this.updateScope(index + 1);
    this.emitChange();
  }
  scopeChange(scope) {
    this.scope = scope;
    let children = this.children;
    for (let i = 0; i < children.length; i++) {
      children[i].scopeChange(this.getScope(i));
    }
  }
  toJSON() {
    let res = this.nodes.map((node) => {
      return node.toJSON();
    });
    if (!this.root.allowNamedBlocks || this.parent instanceof Root) {
      return res;
    } else {
      return ["block", this.name, res];
    }
  }
  onRenameVar(varDec) {
    this.updateScope(this.nodes.indexOf(varDec) + 1);
  }
  updateScope(index) {
    for (let i = index; i < this.nodes.length; i++) {
      this.nodes[i].scopeChange(this.getScope(i));
    }
  }
}
class Literal$3 extends Expression$1 {
  constructor(parent2, scope, value, opts) {
    super(C.LITERAL, parent2, scope);
    __publicField(this, "_value");
    __publicField(this, "_returnType");
    this._returnType = getLiteralType(value);
    if (this._returnType === "string") {
      value = unEscapeDollar(value);
    }
    if (opts == null ? void 0 : opts.isSecret) {
      this._returnType = "secret";
    }
    this._value = value;
  }
  get children() {
    return [];
  }
  get returnType() {
    return this._returnType;
  }
  get value() {
    return this._value;
  }
  set returnType(type) {
    this._returnType = type;
  }
  set value(value) {
    this._value = value;
    this.emitChange();
  }
  async _evaluate(_vm) {
    return this.value;
  }
  toJSON() {
    if (this.returnType === "string") {
      return escapeDollar(this.value);
    } else if (this.returnType === "secret") {
      return ["secret", escapeDollar(this.value)];
    } else {
      return this.value;
    }
  }
}
class ArrayExp extends Expression$1 {
  constructor(parent2, scope, elementType, value) {
    super(C.ARRAY_NODE, parent2, scope);
    __publicField(this, "_value");
    __publicField(this, "_elementType");
    __publicField(this, "onChange", (node) => {
      if (!(node instanceof Accessor$2) || this.children.indexOf(node) === -1) {
        return;
      }
      if (node.returnType !== this.elementType) {
        this.error = new ErrorExp(this, this.scope, C.TYPE_MISMATCH, `${this.returnType} cannot have ${node.returnType} as an element`);
      } else if (this.error) {
        this.error = void 0;
      }
    });
    this._elementType = elementType;
    let valueArr = value.map((val) => parseExpression(val, this, this.scope));
    if (valueArr.some((v) => v.returnType !== this._elementType))
      throw new Error("One or more of the array elements are of different type from the array's declared element type");
    this._value = valueArr;
    this.on(C.CHANGE, this.onChange);
  }
  get children() {
    return [...this._value];
  }
  get returnType() {
    return "array<" + this._elementType + ">";
  }
  get value() {
    return this._value;
  }
  get elementType() {
    return this._elementType;
  }
  async _evaluate(vm) {
    let res = [];
    for (let val of this.value) {
      res.push(await val.evaluate(vm));
    }
    return res;
  }
  async replace(oldChild, expression) {
    let index = this.children.indexOf(oldChild);
    if (index < 0) {
      throw new Error("No child matching the given node");
    }
    let exp = this.parse(expression);
    if (exp.returnType !== this.elementType) {
      exp = castToTypeOrError(exp, [this.elementType]);
    }
    this._value[index] = exp;
    this.emitChange();
  }
  parse(value) {
    let node = parseExpression(value, this, this.scope);
    return node;
  }
  toJSON() {
    return ["array", this._elementType, this.value.map((val) => val.toJSON())];
  }
}
class Struct$2 extends Expression$1 {
  constructor(parent2, scope, name, fields) {
    super(C.STRUCT, parent2, scope);
    __publicField(this, "name");
    __publicField(this, "fields");
    __publicField(this, "onChange", (node) => {
      if (!(node instanceof Accessor$2)) {
        return;
      }
      for (let [key, value] of this.fields) {
        if (value === node) {
          const structDef = this.scope.getStruct(this.name);
          const fieldDef = structDef.fields[key];
          if (!fieldDef.types.includes(node.returnType)) {
            this.error = new ErrorExp(this, this.scope, C.TYPE_MISMATCH, `Field of type ${fieldDef.types} cannot be assigned a ${node.returnType}`);
          } else if (this.error) {
            this.error = void 0;
          }
        }
      }
    });
    if (!this.scope.hasStruct(name))
      throw new Error(`Struct ${name} not defined in scope`);
    this.name = name;
    this.fields = fields ? this.prepare(fields) : this.getDefaults(name);
    this.on(C.CHANGE, this.onChange);
  }
  get children() {
    return [...this.fields.values()];
  }
  get returnType() {
    return this.name;
  }
  get(fieldName) {
    return this.fields.get(fieldName);
  }
  has(field) {
    return this.fields.has(field);
  }
  async _evaluate(vm) {
    let struct = {};
    if ([...this.fields.values()].some((value) => value instanceof ErrorExp)) {
      throw new Error("StructNode has an error in one of its fields");
    }
    for (let [key, value] of this.fields) {
      struct[key] = await value.evaluate(vm);
    }
    return struct;
  }
  getDefaults(name) {
    let fieldDefs = this.scope.getStruct(name).fields;
    let fields = /* @__PURE__ */ new Map();
    for (let key in fieldDefs) {
      if (!fieldDefs[key].optional) {
        fields.set(key, getDefault$1(this, this.scope, fieldDefs[key]));
      }
    }
    return fields;
  }
  prepare(fields) {
    let preparedFields = /* @__PURE__ */ new Map();
    let fieldDefs = this.scope.getStruct(this.name).fields;
    for (let key in fieldDefs) {
      if (key in fields) {
        let node = parseExpression(fields[key], this, this.scope);
        let types2 = fieldDefs[key].types;
        if (!types2.includes(node.returnType))
          node = castToTypeOrError(node, types2);
        preparedFields.set(key, node);
      } else if (!fieldDefs[key].optional) {
        throw new Error(`Missing field ${key}`);
      }
    }
    return preparedFields;
  }
  removeOptional(child) {
    let fieldDefs = this.scope.getStruct(this.name).fields;
    for (let [key, value] of this.fields) {
      if (value === child) {
        if (fieldDefs[key].optional) {
          this.fields.delete(key);
          this.emitChange();
          return;
        } else {
          throw new Error("Cannot remove non-optional field");
        }
      }
    }
    throw new Error("Child not found in fields");
  }
  replace(oldChild, newExpression) {
    for (let [key, value] of this.fields) {
      if (value === oldChild) {
        this.set(key, newExpression);
        return;
      }
    }
    throw new Error("oldChild not found in fields");
  }
  set(name, value) {
    let fieldDefs = this.scope.getStruct(this.name).fields;
    if (!fieldDefs.hasOwnProperty(name))
      throw new Error("No field with that name");
    let node = parseExpression(value, this, this.scope);
    let types2 = fieldDefs[name].types;
    if (!types2.includes(node.returnType)) {
      node = castToTypeOrError(node, types2);
    }
    this.fields.set(name, node);
    this.emitChange();
  }
  setAllOptional() {
    let fieldDefs = this.scope.getStruct(this.name).fields;
    for (let key in fieldDefs) {
      if (!this.fields.has(key)) {
        this.fields.set(key, getDefault$1(this, this.scope, fieldDefs[key]));
      }
    }
    this.emitChange();
  }
  toJSON() {
    let fieldObj = {};
    for (let [key, value] of this.fields) {
      fieldObj[key] = value.toJSON();
    }
    return fieldObj;
  }
}
class Enum$2 extends Expression$1 {
  constructor(parent2, scope, name, value) {
    super(C.ENUM, parent2, scope);
    __publicField(this, "name");
    __publicField(this, "_value");
    if (!this.scope.hasEnum(name))
      throw new Error(`Enum ${name} not found in registry`);
    this.name = name;
    this._value = this.checkValidity(value) ? value : this.getDefaults(name);
    if (!this.scope.getEnum(name).values.includes(this.value)) {
      throw new Error(`Invalid enum value: ${this.value}`);
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.emitChange();
  }
  get children() {
    return [];
  }
  get returnType() {
    return this.name;
  }
  checkValidity(value) {
    let enumDef = this.scope.getEnum(this.name);
    if (typeof value !== enumDef.enumType)
      return false;
    return enumDef.values.includes(value);
  }
  async _evaluate(_vm) {
    return this.value;
  }
  getDefaults(name) {
    return this.scope.getEnum(name).values[0];
  }
  toJSON() {
    return this.value;
  }
}
class Return$1 extends Expression$1 {
  constructor(parent2, scope, value) {
    super(C.RETURN, parent2, scope);
    __publicField(this, "_value");
    this._value = this.parse(value);
  }
  get children() {
    if (!this._value) {
      return [];
    } else {
      return [this._value];
    }
  }
  get value() {
    return this._value;
  }
  replace(oldChild, expression) {
    if (oldChild !== this._value) {
      throw new Error("No child matching the given node");
    }
    this._value = this.parse(expression);
    this.emitChange();
  }
  parse(value) {
    if (value === void 0)
      return void 0;
    let node = parseExpression(value, this, this.scope);
    return node;
  }
  async _evaluate(vm) {
    let val;
    if (this._value) {
      val = await this._value.evaluate(vm);
    }
    throw new ReturnMarker(val);
  }
  toJSON() {
    var _a;
    return ["return", (_a = this._value) == null ? void 0 : _a.toJSON()];
  }
}
class FunctionCall$2 extends Expression$1 {
  constructor(parent2, scope, name, argList) {
    super(C.FUNCTION_CALL, parent2, scope);
    __publicField(this, "name");
    __publicField(this, "argList", []);
    __publicField(this, "onChange", (node) => {
      if (!(node instanceof Accessor$2)) {
        return;
      }
      const index = this.argList.indexOf(node);
      if (index === -1) {
        return;
      }
      const funcDef = this.scope.getFunc(this.name);
      const argDef = Object.values(funcDef.args)[index];
      if (!argDef.types.includes(node.returnType)) {
        try {
          castToTypeOrError(node, argDef.types);
        } catch (err) {
          this.error = new ErrorExp(this, this.scope, C.TYPE_MISMATCH, `Field of type ${node.returnType} cannot be assigned to arg of type ${argDef.types}`);
        }
      } else if (this.error) {
        this.error = void 0;
      }
    });
    if (!this.scope.hasFunc(name))
      throw new Error(`Func ${name} not defined in scope`);
    this.name = name;
    this.argList = argList ? this.prepare(argList) : this.getDefaults(name);
    this.on(C.CHANGE, this.onChange);
  }
  get children() {
    return [...this.argList];
  }
  get returnType() {
    return this.scope.getFunc(this.name).returnType;
  }
  get title() {
    return this.name;
  }
  async _evaluate(vm) {
    let argValArr = [];
    for (let arg of this.argList) {
      argValArr.push(await arg.evaluate(vm));
    }
    let func2 = vm.scopeStack.get(this.name);
    if (vm.scopeStack.isFromRegistry(this.name)) {
      return await func2(vm.context, ...argValArr);
    } else {
      return await func2(vm, ...argValArr);
    }
  }
  getDefaults(name) {
    let funcDef = this.scope.getFunc(name);
    let argDefs = Object.values(funcDef.args).filter((argDef) => !argDef.optional);
    return argDefs.map((argDef) => getDefault$1(this, this.scope, argDef));
  }
  prepare(argListSource) {
    let funcDef = this.scope.getFunc(this.name);
    let argList = [];
    let argNames = Object.keys(funcDef.args);
    for (let i = 0; i < argNames.length; i++) {
      let argDef = funcDef.args[argNames[i]];
      if (i < argListSource.length) {
        let node = parseExpression(argListSource[i], this, this.scope);
        if (!(node instanceof ErrorExp) && !argDef.types.includes(node.returnType)) {
          node = castToTypeOrError(node, argDef.types);
        }
        argList.push(node);
      } else if (!argDef.optional) {
        throw new Error(`Missing argument at position ${i}`);
      }
    }
    return argList;
  }
  removeOptional(child) {
    let index = this.argList.indexOf(child);
    if (index === -1)
      throw new Error("Child not found in argList");
    let funcDef = this.scope.getFunc(this.name);
    if (!Object.values(funcDef.args)[index].optional) {
      throw new Error("Argument is not optional");
    }
    for (let i = this.argList.length - 1; i >= index; i--) {
      this.argList.pop();
    }
    this.emitChange();
  }
  replace(oldChild, expression) {
    let index = this.argList.indexOf(oldChild);
    if (index === -1) {
      throw new Error("oldChild is not an argument of this function call");
    }
    let funcDef = this.scope.getFunc(this.name);
    let argDef = Object.values(funcDef.args)[index];
    let newChild = parseExpression(expression, this, this.scope);
    if (argDef.types.includes(newChild.returnType)) {
      this.argList[index] = newChild;
    } else {
      this.argList[index] = castToTypeOrError(newChild, argDef.types);
    }
    this.emitChange();
  }
  addNextOptional(value) {
    let funcDef = this.scope.getFunc(this.name);
    let argDefs = Object.values(funcDef.args);
    if (argDefs.length > this.argList.length) {
      let argDef = argDefs[this.argList.length];
      let newChild = value ? parseExpression(value, this, this.scope) : getDefault$1(this, this.scope, argDef);
      if (!argDef.types.includes(newChild.returnType)) {
        newChild = castToTypeOrError(newChild, argDef.types);
      }
      this.argList.push(newChild);
      this.emitChange();
    } else {
      throw new Error("All optional arguments are already set");
    }
  }
  setAllOptional() {
    let funcDef = this.scope.getFunc(this.name);
    let argDefs = Object.values(funcDef.args);
    for (let i = this.argList.length; i < argDefs.length; i++) {
      let argDef = argDefs[i];
      this.argList.push(getDefault$1(this, this.scope, argDef));
    }
    this.emitChange();
  }
  toJSON() {
    return [this.name, ...this.argList.map((arg) => {
      return arg.toJSON();
    })];
  }
}
class Conditional extends Expression$1 {
  constructor(parent2, scope, source) {
    super(C.COND, parent2, scope);
    __publicField(this, "clauses");
    this.clauses = source && source.length > 0 ? this.prepare(source) : this.getDefaults();
  }
  get children() {
    return [...this.clauses];
  }
  async _evaluate(vm) {
    for (let clause of this.clauses) {
      let { status, value } = await clause.evaluate(vm);
      if (status)
        return value;
    }
    return void 0;
  }
  getDefaults() {
    return [new Clause(this, this.scope)];
  }
  insertAt(index) {
    this.clauses.splice(index, 0, new Clause(this, this.scope, ["or", ["and", true]], []));
    this.emitChange();
  }
  prepare(source) {
    let clauseExps = [];
    for (let clause of source) {
      let condition = clause[0];
      let body;
      if (this.root.allowNamedBlocks && Array.isArray(clause[1]) && clause[1][0] === "block") {
        body = clause[1];
      } else {
        body = clause.slice(1);
      }
      clauseExps.push(new Clause(this, this.scope, condition, body));
    }
    return clauseExps;
  }
  remove(child) {
    let index = -1;
    for (let i = 0; i < this.clauses.length; i++) {
      if (this.clauses[i] === child) {
        index = i;
        break;
      }
    }
    if (index > -1) {
      this.clauses.splice(index, 1);
      this.emitChange();
    }
  }
  replace(oldChild, newSource) {
    let newChild = new Clause(this, this.scope, ...newSource);
    for (let i = 0; i < this.clauses.length; i++) {
      if (this.clauses[i] === oldChild) {
        this.clauses[i] = newChild;
        this.emitChange();
        return;
      }
    }
    throw new Error("Node not found in the list");
  }
  toJSON() {
    return ["cond", ...this.clauses.map((clause) => clause.toJSON())];
  }
}
class For$1 extends Expression$1 {
  constructor(parent2, scope, source) {
    super(C.FOR, parent2, scope);
    __publicField(this, "itemVar");
    __publicField(this, "body");
    __publicField(this, "iterable");
    if (!source)
      throw new Error("expected block for for loop");
    if (!source[0])
      throw new Error("expected var name");
    if (!source[1])
      throw new Error("expected iterable");
    if (!source[2])
      throw new Error("expected body for for loop");
    this.iterable = parseExpression(source[1], this, this.scope);
    this.itemVar = new VariableDeclaration$1(this, this.scope, source[0], this.getItemType(this.iterable.returnType));
    this.itemVar.setDeclarationOnly();
    let forScope = this.getForScope(this.scope);
    this.body = parseBlock(source[2], this, forScope);
  }
  get children() {
    return [this.iterable, this.itemVar, this.body];
  }
  getItemType(iterableType) {
    if (isIterableType(iterableType)) {
      return getIterableElementType(iterableType);
    } else if (isArrayType(iterableType)) {
      return getArrayElementType(iterableType);
    } else if (this.scope.hasStruct(iterableType)) {
      const typ = this.scope.getStruct(iterableType);
      if (typ.iterator === void 0) {
        throw new Error(`Type ${typ.name} is not iterable`);
      }
      return typ.iterator.type;
    } else if (this.scope.hasEnum(iterableType)) {
      const typ = this.scope.getEnum(iterableType);
      if (typ.iterator === void 0) {
        throw new Error(`Type ${typ.name} is not iterable`);
      }
      return typ.iterator.type;
    } else {
      throw new Error(`type ${iterableType} is not iterable`);
    }
  }
  getForScope(scope) {
    const forScope = new ValidationScope(scope);
    const itemType = this.getItemType(this.iterable.returnType);
    forScope.setVar(this.itemVar.name, { name: this.itemVar.name, dataType: itemType }, this.itemVar);
    return forScope;
  }
  async _evaluate(vm) {
    const iterableType = this.iterable.returnType;
    let iter;
    if (isArrayType(iterableType)) {
      iter = await this.iterable.evaluate(vm);
    } else if (isIterableType(iterableType)) {
      iter = await this.iterable.evaluate(vm);
    } else {
      const iterableDef = this.scope.get(this.iterable.returnType).value;
      let iterable = await this.iterable.evaluate(vm);
      iter = await iterableDef.iterator.iter(vm.context, iterable);
    }
    for (let item of iter) {
      vm.scopeStack.push();
      vm.scopeStack.set(this.itemVar.name, item);
      await this.body.evaluate(vm);
      vm.scopeStack.pop();
    }
  }
  onRenameVar(_varDec) {
    this.updateScope(this.scope);
  }
  updateScope(scope) {
    this.iterable.scopeChange(scope);
    const forScope = this.getForScope(scope);
    this.body.scopeChange(forScope);
    this.emitChange();
  }
  scopeChange(scope) {
    this.updateScope(scope);
  }
  replace(_oldChild, expression) {
    this.iterable = parseExpression(expression, this, this.scope);
    this.updateScope(this.scope);
  }
  toJSON() {
    let serializedIterable;
    if (this.iterable instanceof Struct$2 || this.iterable instanceof Enum$2) {
      serializedIterable = [this.iterable.name, this.iterable.toJSON()];
    } else {
      serializedIterable = this.iterable.toJSON();
    }
    return [
      "for",
      this.itemVar.name,
      serializedIterable,
      this.body.toJSON()
    ];
  }
}
class While$1 extends Expression$1 {
  constructor(parent2, scope, source) {
    super(C.WHILE, parent2, scope);
    __publicField(this, "condition");
    __publicField(this, "body");
    if (!source)
      throw new Error("expected block for while loop");
    if (!source[0])
      throw new Error("expected condition");
    if (!source[1])
      throw new Error("expected block");
    this.condition = parseExpression(source[0], this, this.scope);
    this.body = parseBlock(source[1], this, this.scope);
  }
  get children() {
    return [this.condition, this.body];
  }
  async _evaluate(vm) {
    while (await this.condition.evaluate(vm)) {
      await this.body.evaluate(vm);
    }
  }
  toJSON() {
    return ["while", this.condition.toJSON(), this.body.toJSON()];
  }
}
class Clause extends Expression$1 {
  constructor(parent2, scope, condition, body) {
    super(C.CLAUSE, parent2, scope);
    __publicField(this, "condition");
    __publicField(this, "body");
    this.condition = parseExpression(condition != null ? condition : ["or", ["and", true]], this, this.scope);
    if (this.condition.returnType !== "boolean") {
      throw new Error("Condition must return a boolean value");
    }
    this.body = parseBlock(body != null ? body : [], this, this.scope);
  }
  get children() {
    return [this.condition, this.body];
  }
  async _evaluate(vm) {
    if (await this.condition.evaluate(vm)) {
      return {
        status: true,
        value: await this.body.evaluate(vm)
      };
    } else {
      return { status: false };
    }
  }
  replace(oldChild, expression) {
    if (this.condition !== oldChild) {
      throw new Error("No child matching the given node");
    }
    this.condition = parseExpression(expression, this, this.scope);
    this.emitChange();
  }
  toJSON() {
    let body = this.body.toJSON();
    if (this.root.allowNamedBlocks) {
      return [this.condition.toJSON(), body];
    } else {
      return [this.condition.toJSON(), ...body];
    }
  }
}
class VariableDeclaration$1 extends Expression$1 {
  constructor(parent2, scope, name, type, value) {
    var _a;
    super(C.VARIABLE_DECLARATION, parent2, scope);
    __publicField(this, "name");
    __publicField(this, "dataType");
    __publicField(this, "value");
    __publicField(this, "declarationOnly", false);
    this.validateName(name);
    this.name = name;
    this.dataType = type != null ? type : C.INT;
    this.value = (_a = this.parse(value)) != null ? _a : getDefault$1(this, this.scope, { types: [this.dataType] });
  }
  get children() {
    return this.declarationOnly ? [] : [this.value];
  }
  setDeclarationOnly() {
    this.declarationOnly = true;
  }
  changeType(newType) {
    if (newType === this.dataType)
      return;
    this.dataType = newType;
    this.value = getDefault$1(this, this.scope, { types: [newType] });
    const parent2 = this.parent;
    parent2.updateScope(parent2.nodes.indexOf(this) + 1);
    this.emitChange();
  }
  async _evaluate(vm) {
    let value = await this.value.evaluate(vm);
    vm.scopeStack.set(this.name, value);
    return value;
  }
  getDefaults(opts) {
    var _a;
    let type = (_a = opts.type) != null ? _a : C.STRING;
    return {
      name: "_",
      type,
      value: getDefault$1(this, this.scope, { types: [type] })
    };
  }
  parse(value) {
    if (value === void 0)
      return void 0;
    let node = parseExpression(value, this, this.scope);
    if (node.returnType !== this.dataType) {
      node = castToTypeOrError(node, this.dataType);
    }
    return node;
  }
  validateName(name) {
    if (!isValidName(name, { allowFirstUnderscore: true }))
      throw new Error("Invalid name for VariableDeclaration");
    if (this.scope.hasType(name))
      throw new Error("the variable declaration has the same name as a registered type");
  }
  rename(newName) {
    if (this.parent.children.some((child) => (child instanceof VariableDeclaration$1 || child instanceof FunctionDefinition) && child.name === newName)) {
      throw new Error("Variable with same name already exists in current scope");
    }
    this.validateName(newName);
    if (this.parent instanceof Root) {
      throw new Error("Cannot rename variable in root");
    }
    let refs;
    if (this.parent instanceof Block) {
      refs = getReferences(this);
    } else {
      refs = getReferencesInExpr(this.parent, this);
    }
    refs.forEach((ref) => {
      ref._ref = newName;
      ref.emitChange();
    });
    this.name = newName;
    const parent2 = this.parent;
    parent2.onRenameVar(this);
    this.emitChange();
  }
  replace(oldChild, expression) {
    if (oldChild !== this.value) {
      throw new Error("No child matching the given node");
    }
    let value = parseExpression(expression, this, this.scope);
    if (value.returnType !== this.dataType) {
      value = castToTypeOrError(value, this.dataType);
    }
    this.value = value;
    this.emitChange();
  }
  scopeChange(scope) {
    this.scope = scope;
    let parent2 = this.parent;
    let prevSiblings = parent2.children.slice(0, parent2.children.indexOf(this));
    let isDuplicate = prevSiblings.some((child) => isDeclaration(child) && child.name === this.name);
    if (!this.error && isDuplicate) {
      this.error = new ErrorExp(this, this.scope, C.DUPLICATE_DECLARATION);
      this.emit("change");
    } else if (this.error && !isDuplicate) {
      this.error = void 0;
      this.emit("change");
    }
    super.scopeChange(scope);
  }
  toJSON() {
    let json = ["var", this.name, this.dataType];
    if (this.value) {
      json.push(this.value.toJSON());
    }
    return json;
  }
}
class VariableReference$1 extends Expression$1 {
  constructor(parent2, scope, name) {
    super(C.VARIABLE_REFERENCE, parent2, scope);
    __publicField(this, "_ref");
    if (!this.scope.has(name))
      throw new Error(`"${name}" is not a valid identifier`);
    this._ref = name;
  }
  get children() {
    return [];
  }
  get name() {
    return this._ref;
  }
  get returnType() {
    let scopeDef = this.scope.get(this._ref);
    if (scopeDef.type === C.VALUE) {
      return scopeDef.value.dataType;
    } else {
      return scopeDef.type;
    }
  }
  async _evaluate(vm) {
    if (!vm.scopeStack.has(this._ref)) {
      throw new Error(`"${this._ref}" is not a valid identifier`);
    } else {
      return vm.scopeStack.get(this._ref);
    }
  }
  scopeChange(scope) {
    var _a, _b, _c, _d, _e;
    this.scope = scope;
    if (this.scope.hasVar(this.name)) {
      if (((_a = this.error) == null ? void 0 : _a.code) === C.INVALID_VARIABLE_REFERENCE) {
        this.error = void 0;
        this.emit("change");
      }
    } else if (((_b = this.error) == null ? void 0 : _b.code) !== C.INVALID_VARIABLE_REFERENCE) {
      this.error = new ErrorExp(this, this.scope, C.INVALID_VARIABLE_REFERENCE);
      this.emit("change");
    }
    if (((_c = this.error) == null ? void 0 : _c.code) !== C.INVALID_VARIABLE_REFERENCE) {
      if (isMatchingType(this)) {
        if (((_d = this.error) == null ? void 0 : _d.code) === C.TYPE_MISMATCH) {
          this.error = void 0;
          this.emit("change");
        }
      } else if (((_e = this.error) == null ? void 0 : _e.code) !== C.TYPE_MISMATCH) {
        this.error = new ErrorExp(this, this.scope, C.TYPE_MISMATCH);
        this.emit("change");
      }
    }
    super.scopeChange(scope);
  }
  toJSON() {
    return "$" + this.name;
  }
}
class Assignment$1 extends Expression$1 {
  constructor(parent2, scope, reference, value) {
    super(C.ASSIGNMENT, parent2, scope);
    __publicField(this, "reference");
    __publicField(this, "value");
    this.reference = parseVariableReference(reference, this, scope);
    this.value = this.parseValue(value);
  }
  get children() {
    return [this.reference, this.value];
  }
  async _evaluate(vm) {
    let val = await this.value.evaluate(vm);
    let varName = this.reference.name;
    vm.scopeStack.update(varName, val);
    return val;
  }
  parseValue(value) {
    if (value === void 0) {
      return getDefault$1(this, this.scope, { types: [this.reference.returnType] });
    } else {
      let node = parseExpression(value, this, this.scope);
      if (node.returnType !== this.reference.returnType) {
        node = castToTypeOrError(node, this.reference.returnType);
      }
      return node;
    }
  }
  replace(oldChild, expression) {
    let newChild = parseExpression(expression, this, this.scope);
    if (oldChild === this.reference) {
      if (!(newChild instanceof VariableReference$1)) {
        throw new Error("the new value is not of type VariableReference");
      }
      this.reference = newChild;
      if (this.reference.returnType !== this.value.returnType) {
        this.value = getDefault$1(this, this.scope, { types: [this.reference.returnType] });
      }
    } else if (oldChild === this.value) {
      if (newChild.returnType !== this.reference.returnType) {
        newChild = castToTypeOrError(newChild, this.reference.returnType);
      }
      this.value = newChild;
    } else {
      throw new Error("No child matching the given node");
    }
    this.emitChange();
  }
  toJSON() {
    return ["=", this.reference.toJSON(), this.value.toJSON()];
  }
}
class _FuncDef extends Expression$1 {
  constructor(parent2, scope, type, argList, statements) {
    super(type, parent2, scope);
    __publicField(this, "parameters", []);
    __publicField(this, "body");
    if (new Set(argList.map((arg) => arg[0])).size !== argList.length) {
      throw new Error("Duplicate argument names in function definition");
    }
    this.parameters = argList.map(([name, type2]) => new VariableDeclaration$1(this, this.scope, name, type2));
    this.body = parseBlock(statements, this, this.scope);
    this.evaluate = this.evaluate.bind(this);
  }
  get children() {
    return [...this.parameters, ...this.body.nodes];
  }
  get returnType() {
    return this.body.nodes[this.body.nodes.length - 1].returnType;
  }
  async _evaluate(vm, ...args) {
    vm.scopeStack.push();
    for (let i = 0; i < args.length; i++) {
      vm.scopeStack.set(this.parameters[i].name, args[i]);
    }
    let result = await this.body.evaluate(vm);
    vm.scopeStack.pop();
    return result;
  }
}
class Lambda extends _FuncDef {
  constructor(parent2, scope, argList, statements) {
    super(parent2, scope, "LAMBDA", argList, statements);
  }
  toJSON() {
    return ["lambda", this.parameters.map((p) => p.toJSON()), this.returnType, this.body.toJSON()];
  }
}
class FunctionDefinition extends _FuncDef {
  constructor(parent2, scope, name, argList, statements) {
    super(parent2, scope, "FUNCTION_DEFINITION", argList, statements);
    __publicField(this, "name");
    __publicField(this, "call", async (vm, ...args) => {
      return await super._evaluate(vm, ...args);
    });
    this.name = name;
  }
  toJSON() {
    return ["func", this.name, this.parameters.map((p) => p.toJSON()), this.returnType, this.body.toJSON()];
  }
  async _evaluate(vm) {
    vm.scopeStack.set(this.name, this.call);
  }
}
class MapExp extends Expression$1 {
  constructor(parent2, scope, listSource, callbackSource) {
    super(C.MAP_NODE, parent2, scope);
    __publicField(this, "list");
    __publicField(this, "callback");
    let list = parseExpression(listSource, this, this.scope);
    if (!isArrayType(list.returnType)) {
      throw new Error("First argument must be an array");
    }
    this.list = list;
    let callback = parseCallback(callbackSource, this, this.scope);
    if (!(callback instanceof Lambda) && !(callback.returnType === "function")) {
      throw new Error("Callback must be a function definition or a variable reference");
    }
    this.verifyListCallbackMatch(callback);
    this.callback = callback;
  }
  get children() {
    return [this.list, this.callback];
  }
  async _evaluate(vm) {
    let list = await this.list.evaluate(vm);
    let func2;
    if (this.callback instanceof VariableReference$1) {
      func2 = vm.scopeStack.get(this.callback.name);
    } else {
      func2 = this.callback.evaluate;
    }
    let res = [];
    for (let item of list) {
      res.push(await func2(vm, item));
    }
    return res;
  }
  get returnType() {
    return "array:" + this.callback.returnType;
  }
  toJSON() {
    return ["map", this.list.toJSON(), this.callback.toJSON()];
  }
  verifyListCallbackMatch(callback) {
    let argLen;
    if (callback instanceof VariableReference$1) {
      argLen = Object.keys(this.scope.getFunc(callback.name).args).length;
    } else {
      argLen = callback.parameters.length;
    }
    if (argLen !== 1) {
      throw new Error("A Map Callback must have exactly one argument");
    }
    let argTypes;
    if (callback instanceof VariableReference$1) {
      argTypes = Object.values(this.scope.getFunc(callback.name).args)[0].types;
    } else {
      argTypes = [callback.parameters[0].dataType];
    }
    if (!argTypes.includes(this.list.returnType.slice(6, -1))) {
      throw new Error("List and callback must have matching types");
    }
  }
}
class ErrorExp extends Expression$1 {
  constructor(parent2, scope, code, description) {
    super(C.ERROR, parent2, scope);
    __publicField(this, "code");
    __publicField(this, "description");
    this.code = code;
    this.description = description;
  }
  get children() {
    return [];
  }
  async _evaluate(_vm) {
    throw new Error("Error: " + this.code);
  }
  toJSON() {
    return ["ERROR", this.code];
  }
}
class ReturnMarker {
  constructor(data) {
    __publicField(this, "data");
    this.data = data;
  }
}
function castToTypeOrError(originalNode, types2) {
  types2 = Array.isArray(types2) ? types2 : [types2];
  for (const type of types2) {
    try {
      if (originalNode.returnType === C.INT && type === C.FLOAT) {
        if (originalNode instanceof Literal$3) {
          originalNode.returnType = C.FLOAT;
        }
        return originalNode;
      }
      if (!(originalNode instanceof Literal$3)) {
        continue;
      }
      if (originalNode.scope.hasStruct(type) && originalNode.returnType === C.JSON) {
        return parseStruct([type, originalNode.value], originalNode.parent, originalNode.scope);
      } else if (originalNode.scope.hasEnum(type) && (originalNode.returnType === C.STRING || originalNode.returnType === C.INT || originalNode.returnType === C.FLOAT)) {
        return parseEnum([type, originalNode.value], originalNode.parent, originalNode.scope);
      } else if (originalNode.returnType === C.INT && type === C.FLOAT) {
        const value = originalNode.value;
        if (!Number.isInteger(value)) {
          continue;
        }
        const literal = new Literal$3(originalNode.parent, originalNode.scope, value);
        literal.returnType = C.FLOAT;
        return literal;
      }
    } catch (err) {
    }
  }
  throw new Error(`the node: ${JSON.stringify(originalNode.toJSON())}, couldn't be cast to one of the types expected: "${JSON.stringify(types2)}"`);
}
function escapeDollar(value) {
  return value.replace(/^\$/g, "\\$");
}
function getArrayElementType(type) {
  return type.slice(6, -1);
}
function getIterableElementType(type) {
  return type.slice(9, -1);
}
function getDefault$1(parent2, scope, def) {
  if (def.default !== void 0) {
    let node = parseExpression(def.default, parent2, scope);
    if (!def.types.includes(node.returnType)) {
      node = castToTypeOrError(node, def.types);
    }
    return node;
  }
  let type = def.types[0];
  if (type.startsWith(C.ARRAY)) {
    return new ArrayExp(parent2, scope, type.slice(6, -1), []);
  }
  if (scope.hasStruct(type)) {
    return new Struct$2(parent2, scope, type);
  } else if (scope.hasEnum(type)) {
    return new Enum$2(parent2, scope, type, scope.getEnum(type).values[0]);
  } else if (scope.hasFunc(type)) {
    return new FunctionCall$2(parent2, scope, type);
  } else if ([C.STRING, C.SECRET, C.BOOLEAN, C.JSON, C.INT, C.FLOAT].includes(type)) {
    const literal = new Literal$3(parent2, scope, getDefaultPrimitive(type));
    literal.returnType = type;
    return literal;
  } else {
    throw new Error(`Type ${type} not found in scope`);
  }
}
function getDefaultPrimitive(type) {
  switch (type) {
    case C.INT:
      return 0;
    case C.FLOAT:
      return 0;
    case C.STRING:
      return "";
    case C.BOOLEAN:
      return false;
    case C.JSON:
      return {};
    default:
      throw new Error(`Unknown primitive type ${type}`);
  }
}
function getLiteralType(literal) {
  if (isPlainObject(literal)) {
    return C.JSON;
  } else if (typeof literal === "string") {
    return C.STRING;
  } else if (typeof literal === "number") {
    return Number.isInteger(literal) ? C.INT : C.FLOAT;
  } else if (typeof literal === "boolean") {
    return C.BOOLEAN;
  } else {
    throw new Error(`Unknown literal type ${typeof literal}`);
  }
}
function matchesDataType(scope, reqdType, actualType) {
  if (reqdType === actualType) {
    return true;
  } else if (isArrayType(reqdType) && isArrayType(actualType)) {
    const baseReqdType = getArrayElementType(reqdType);
    const baseActualType = getArrayElementType(actualType);
    return matchesDataType(scope, baseReqdType, baseActualType);
  } else if (actualType === "json" && scope.hasStruct(reqdType)) {
    return true;
  } else if (["string", "int"].includes(actualType) && scope.hasEnum(reqdType)) {
    return true;
  }
  return false;
}
function isOfType(scope, value, reqdType) {
  if (reqdType.startsWith("array") && Array.isArray(value)) {
    const reqdBaseType = getArrayElementType(reqdType);
    return value.every((v) => isOfType(scope, v, reqdBaseType));
  } else if (scope.hasEnum(reqdType)) {
    const enumDef = scope.getEnum(reqdType);
    return enumDef.values.includes(value);
  } else if (scope.hasStruct(reqdType) && isPlainObject(value)) {
    const structDef = scope.getStruct(reqdType);
    return Object.entries(structDef.fields).every(([fieldName, fieldDef]) => {
      if (value.hasOwnProperty(fieldName)) {
        return fieldDef.types.some((type) => isOfType(scope, value[fieldName], type));
      } else if (fieldDef.optional) {
        return true;
      }
      return false;
    });
  } else if (isPrimitive(value)) {
    if (typeof value === "number") {
      if (reqdType === "int") {
        return Number.isInteger(value);
      } else if (reqdType === "float") {
        return true;
      }
    }
    return typeof value === reqdType || typeof value === "string" && reqdType === "secret";
  }
  return false;
}
function isArrayType(type) {
  return type.startsWith("array");
}
function isIterableType(type) {
  return type.startsWith("iterable");
}
function isMatchingType(node) {
  if (node.parent instanceof FunctionCall$2) {
    let parent2 = node.parent;
    let index = parent2.argList.indexOf(node);
    let funcDef = parent2.scope.getFunc(parent2.name);
    return Object.values(funcDef.args)[index].types.includes(node.returnType);
  } else if (node.parent instanceof Struct$2) {
    let parent2 = node.parent;
    let index = [...parent2.fields.values()].indexOf(node);
    let structDef = parent2.scope.getStruct(parent2.name);
    return Object.values(structDef.fields)[index].types.includes(node.returnType);
  } else {
    return true;
  }
}
function isPlainObject(value) {
  if (typeof value !== "object" || value.toString() !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function isPrimitive(value) {
  return value !== Object(value);
}
function isValidName(name, opts) {
  if (opts == null ? void 0 : opts.allowFirstUnderscore) {
    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);
  } else {
    return /^[a-zA-Z][a-zA-Z0-9_]*$/.test(name);
  }
}
function isValidType(value) {
  return isPrimitive(value) || isPlainObject(value) || Array.isArray(value);
}
function unEscapeDollar(value) {
  return value.replace(/^\\\$/g, "$");
}
const RESERVED = [C.STRING, C.SECRET, C.INT, C.FLOAT, C.BOOLEAN, C.JSON, C.ARRAY, C.FUNCTION, C.VOID, C.BLOCK, C.VARIABLE_DECLARATION, C.COND, C.VARIABLE_REFERENCE, C.ASSIGNMENT, C.ERROR, C.CLAUSE, C.FUNCTION_CALL, C.FUNCTION_DEFINITION, C.FUNCTION_PARAMETER, C.LITERAL, C.STRUCT, C.ENUM, C.MAP_NODE, C.ARRAY_NODE, C.DUPLICATE_DECLARATION, C.MISSING_ARGUMENT, C.INVALID_SYNTAX, C.TYPE_MISMATCH, C.UNDEFINED_TYPE, C.INVALID_VARIABLE_NAME, C.INVALID_VARIABLE_REFERENCE, C.INVALID_VARIABLE_TYPE, C.OP_AND, C.OP_OR, C.OP_NOT];
class Registry {
  constructor(params = {}) {
    __publicField(this, "basicTypes", [C.STRING, C.SECRET, C.BOOLEAN, C.JSON, C.ARRAY, C.INT, C.FLOAT]);
    __publicField(this, "funcs", {});
    __publicField(this, "structs", {});
    __publicField(this, "enums", {});
    if (params.enums) {
      this.addEnums(params.enums);
    }
    if (params.structs) {
      this.addStructs(params.structs);
    }
    if (params.funcs) {
      this.addFuncs(params.funcs);
    }
  }
  addFunc(name, funcDef) {
    if (RESERVED.includes(name)) {
      throw new Error(`Cannot use reserved word ${name} as function name`);
    }
    if (this.hasDef(name)) {
      throw new Error(`name "${name}" already exists in registry`);
    }
    let gotFirstOptionalArg = false;
    for (let argDef of Object.values(funcDef.args)) {
      if (argDef.optional && !gotFirstOptionalArg) {
        gotFirstOptionalArg = true;
      }
      if (!argDef.optional && gotFirstOptionalArg) {
        throw new Error(`Required argument after optional argument in function ${name}`);
      }
      for (let type of argDef.types) {
        if (!this.hasType(type)) {
          throw new Error(`type "${type}" not found in registry`);
        }
      }
    }
    if (funcDef.returnType !== "void" && !this.hasType(funcDef.returnType)) {
      throw new Error(`Type "${funcDef.returnType}" not found in registry`);
    }
    this.funcs[name] = funcDef;
  }
  addFuncs(funcDefs) {
    for (const [key, value] of Object.entries(funcDefs)) {
      this.addFunc(key, value);
    }
  }
  addStruct(name, typeDef) {
    if (RESERVED.includes(name)) {
      throw new Error(`Cannot use reserved word ${name} as type name`);
    }
    if (this.hasDef(name)) {
      throw new Error(`type "${name}" already exists in registry`);
    }
    this.structs[name] = typeDef;
  }
  addEnum(name, enumDef) {
    if (RESERVED.includes(name)) {
      throw new Error(`Cannot use reserved word ${name} as type name`);
    }
    if (this.hasDef(name)) {
      throw new Error(`type "${name}" already exists in registry`);
    }
    this.enums[name] = enumDef;
  }
  addStructs(typeDefs) {
    for (const [key, value] of Object.entries(typeDefs)) {
      this.addStruct(key, value);
    }
  }
  addEnums(typeDefs) {
    for (const [key, value] of Object.entries(typeDefs)) {
      this.addEnum(key, value);
    }
  }
  clone() {
    return new Registry({
      funcs: this.funcs,
      structs: this.structs,
      enums: this.enums
    });
  }
  getFunc(name) {
    if (this.hasFunc(name)) {
      return this.funcs[name];
    } else {
      throw new Error(`Function ${name} not found in registry`);
    }
  }
  hasDef(name) {
    return this.hasFunc(name) || this.hasType(name);
  }
  hasFunc(name) {
    return name in this.funcs;
  }
  hasBasicType(name) {
    return this.basicTypes.includes(name);
  }
  isContainerType(name) {
    return isArrayType(name) || isIterableType(name);
  }
  getInnerType(name) {
    if (isArrayType(name)) {
      return getArrayElementType(name);
    } else if (isIterableType(name)) {
      return getIterableElementType(name);
    }
    throw "unreachable";
  }
  hasType(name) {
    while (this.isContainerType(name)) {
      name = this.getInnerType(name);
    }
    return this.hasBasicType(name) || this.hasStruct(name) || this.hasEnum(name);
  }
  hasEnum(name) {
    return name in this.enums;
  }
  hasStruct(name) {
    return name in this.structs;
  }
  getStruct(name) {
    if (this.hasStruct(name)) {
      return this.structs[name];
    } else {
      throw new Error(`Struct ${name} not found in registry`);
    }
  }
  getEnum(name) {
    if (this.hasEnum(name)) {
      return this.enums[name];
    } else {
      throw new Error(`Enum ${name} not found in registry`);
    }
  }
}
const MAX_TIMEOUT = 60;
const isSelector = (sel) => {
  return sel.hasOwnProperty("type") && sel.hasOwnProperty("value");
};
class BrowserWrapper {
  constructor(browserImpl) {
    this.browserImpl = browserImpl;
  }
  get status_code() {
    return this.browserImpl.status_code;
  }
  set status_code(code) {
    this.browserImpl.status_code = code;
  }
  get body_text_length() {
    return this.browserImpl.body_text_length;
  }
  set body_text_length(length) {
    this.browserImpl.body_text_length = length;
  }
  capTimeout(opts) {
    if (!opts) {
      return;
    }
    if (opts.timeout && opts.timeout > MAX_TIMEOUT) {
      opts.timeout = MAX_TIMEOUT;
    }
  }
  async click(selector, pos, clickOptions) {
    this.capTimeout(clickOptions);
    return this.browserImpl.click(selector, pos, clickOptions);
  }
  async waitForDoc(opts) {
    this.capTimeout(opts);
    const val = await this._waitForDoc(opts);
    if (!(opts === null || opts === void 0 ? void 0 : opts.frame) || opts.frame === 0) {
      try {
        const bodyTextContent = await this.getElementText({ type: "css", value: "body" });
        this.body_text_length = bodyTextContent.replace(/\s+/g, " ").trim().length;
      } catch (err) {
        this.body_text_length = 0;
        const errorMessage = err.message.toLowerCase();
        const ignoreErrorMessages = [
          "execution context was destroyed",
          "cannot find context with specified id"
        ];
        if (!ignoreErrorMessages.some((msg) => errorMessage.includes(msg))) {
          throw err;
        }
      }
    }
    return val;
  }
  async _waitForDoc(opts) {
    await this.browserImpl.waitForDoc(opts);
    if (opts === null || opts === void 0 ? void 0 : opts.wait_for_redirects) {
      try {
        await this.waitForDocumentRequest({ frame: opts === null || opts === void 0 ? void 0 : opts.frame, timeout: opts.wait_for_redirects });
      } catch (e) {
        return;
      }
      await this._waitForDoc(opts);
    }
  }
  async waitForDocumentRequest(waitDocReqOpts) {
    this.capTimeout(waitDocReqOpts);
    return this.browserImpl.waitForDocumentRequest(waitDocReqOpts);
  }
  async select(selector, value, selectOpts) {
    this.capTimeout(selectOpts);
    return this.browserImpl.select(selector, value, selectOpts);
  }
  async keypress(code, count, keypressOpts) {
    this.capTimeout(keypressOpts);
    return this.browserImpl.keypress(code, count, keypressOpts);
  }
  async mousemove(selector, position, mousemoveOpts) {
    this.capTimeout(mousemoveOpts);
    return this.browserImpl.mousemove(selector, position, mousemoveOpts);
  }
  async drag(selector, position, targetSelector, targetPos, dragOpts) {
    this.capTimeout(dragOpts);
    return this.browserImpl.drag(selector, position, targetSelector, targetPos, dragOpts);
  }
  async fill(selector, text2, typeOpts) {
    this.capTimeout(typeOpts);
    return this.browserImpl.fill(selector, text2, typeOpts);
  }
  async focus(selector, focusOpts) {
    this.capTimeout(focusOpts);
    return this.browserImpl.focus(selector, focusOpts);
  }
  async type(selector, text2, typeOpts) {
    this.capTimeout(typeOpts);
    return this.browserImpl.type(selector, text2, typeOpts);
  }
  async scroll(selector, left, top, scrollOpts) {
    this.capTimeout(scrollOpts);
    return this.browserImpl.scroll(selector, left, top, scrollOpts);
  }
  async open(url, openOpts) {
    this.capTimeout(openOpts);
    return this.browserImpl.open(url, openOpts);
  }
  async getElementsCount(selector, getElementsCountOpts) {
    this.capTimeout(getElementsCountOpts);
    return this.browserImpl.getElementsCount(selector, getElementsCountOpts);
  }
  async getElementText(selector, getElementTextOpts) {
    this.capTimeout(getElementTextOpts);
    try {
      return await this.browserImpl.getElementText(selector, getElementTextOpts);
    } catch (err) {
      if (err.message.toLowerCase().includes("failed to find element matching selector")) {
        return "";
      }
      throw err;
    }
  }
  async getSelectors(selector, getElementTextOpts) {
    this.capTimeout(getElementTextOpts);
    return this.browserImpl.getSelectors(selector, getElementTextOpts);
  }
  async evalOnSelector(selector, func2, arg, evalOpts) {
    this.capTimeout(evalOpts);
    return this.browserImpl.evalOnSelector(selector, func2, arg, evalOpts);
  }
  async destroy() {
    var _a, _b;
    (_b = (_a = this.browserImpl).destroy) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
}
function wait$1(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function containsText(text1, text2) {
  return text1.toLowerCase().includes(text2.toLowerCase());
}
function getContextStack(expression) {
  const contextStack = [null];
  let curExpression = expression;
  while (curExpression instanceof Expression$1) {
    if (curExpression instanceof Block && curExpression.name !== C.UNTITLED) {
      contextStack.push(curExpression.name);
    }
    curExpression = curExpression.parent;
  }
  return contextStack;
}
function getLocator(tagName, tagList, expression) {
  const contextStack = getContextStack(expression);
  while (contextStack.length > 0) {
    const context = contextStack.pop();
    const tagsInContext = tagList.filter((tag) => tag.context === context);
    for (let tag of tagsInContext) {
      if (tag.name === tagName) {
        if (tag.selectors.length > 0) {
          return tag.selectors[0];
        } else {
          throw new Error(`Tag "${tagName}" in context "${context}" has not selector`);
        }
      }
    }
  }
  throw new Error(`Tag "${tagName}" not found in context`);
}
const TIME_LIMIT = 30 * 1e3;
function getStepDefs(defOpts) {
  const getSelector = (tagNameOrLocator, context) => {
    if (isSelector(tagNameOrLocator))
      return tagNameOrLocator;
    return getLocator(tagNameOrLocator, context.tagList, context.getExpression());
  };
  const stepDefs2 = {};
  stepDefs2["click"] = {
    name: "click",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"],
        default: { value: "html", type: "css", meta: {} }
      },
      pos: {
        types: ["position"],
        default: { x: 0, y: 0 }
      },
      options: {
        types: ["click_opts"],
        default: { button: "left", clickCount: 1, delay: 0, frame: 0, timeout: 30 },
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, tagNameOrLocator, pos, opts) => {
      await wait$1(1e3);
      let locator = await getSelector(tagNameOrLocator, context);
      await context.browser.click(locator, pos, opts);
    },
    labels: ["action"]
  };
  stepDefs2["wait_doc"] = {
    name: "wait_doc",
    args: {
      options: {
        types: ["wait_doc_opts"],
        default: { wait_for_redirects: 0, frame: 0, timeout: 30 },
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, opts) => {
      await context.browser.waitForDoc(opts);
    },
    labels: ["action"]
  };
  stepDefs2["select"] = {
    name: "select",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"],
        default: { value: "html", type: "css", meta: {} }
      },
      value: {
        types: [C.STRING],
        default: "Enter Select Option"
      },
      options: {
        types: ["default_opts"],
        default: { frame: 0, timeout: 30 },
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, tagNameOrLocator, value, opts) => {
      await wait$1(1e3);
      let locator = await getSelector(tagNameOrLocator, context);
      await context.browser.select(locator, value, opts);
    },
    labels: ["action"]
  };
  stepDefs2["keypress"] = {
    name: "keypress",
    args: {
      code: {
        types: ["kb_key"],
        default: "Enter"
      },
      count: {
        types: [C.INT],
        default: 1
      },
      options: {
        types: ["keypress_opts"],
        default: { page: 0, timeout: 30 },
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, code, count, opts) => {
      await wait$1(1e3);
      await context.browser.keypress(code, count, opts);
    },
    labels: ["action"]
  };
  stepDefs2["mousemove"] = {
    name: "mousemove",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"],
        default: { value: "html", type: "css", meta: {} }
      },
      pos: {
        types: ["position"],
        default: { x: 0, y: 0 }
      },
      options: {
        types: ["default_opts"],
        default: { frame: 0, timeout: 30 },
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, tagNameOrLocator, pos, opts) => {
      await wait$1(1e3);
      let locator = await getSelector(tagNameOrLocator, context);
      await context.browser.mousemove(locator, pos, opts);
    },
    labels: ["action"]
  };
  stepDefs2["drag"] = {
    name: "drag",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"],
        default: { value: "html", type: "css", meta: {} }
      },
      pos: {
        types: ["position"],
        default: { x: 0, y: 0 }
      },
      targetSelector: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"],
        default: { value: "html", type: "css", meta: {} }
      },
      targetPos: {
        types: ["position"],
        default: { x: 0, y: 0 }
      },
      options: {
        types: ["default_opts"],
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, tagNameOrLocator, pos, targetTagNameOrLocator, targetPos, opts) => {
      await wait$1(1e3);
      let locator = await getSelector(tagNameOrLocator, context);
      let targetLocator = await getSelector(targetTagNameOrLocator, context);
      await context.browser.drag(locator, pos, targetLocator, targetPos, opts);
    },
    labels: ["action"]
  };
  stepDefs2["fill"] = {
    name: "fill",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "selector"],
        default: { value: "html", type: "css", meta: {} }
      },
      value: {
        types: [C.STRING],
        default: "Value to Fill"
      },
      options: {
        types: ["default_opts"],
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, tagNameOrLocator, value, opts) => {
      await wait$1(1e3);
      let locator = (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? getLocator(tagNameOrLocator, context.tagList, context.getExpression()) : tagNameOrLocator;
      await context.browser.fill(locator, value, opts);
    },
    labels: ["action"]
  };
  stepDefs2["focus"] = {
    name: "focus",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"],
        default: { value: "html", type: "css", meta: {} }
      },
      options: {
        types: ["default_opts"],
        default: { frame: 0, timeout: 30 },
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, tagNameOrLocator, opts) => {
      await wait$1(1e3);
      let locator = await getSelector(tagNameOrLocator, context);
      await context.browser.focus(locator, opts);
    },
    labels: ["action"]
  };
  stepDefs2["type"] = {
    name: "type",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"],
        default: { value: "html", type: "css", meta: {} }
      },
      text: {
        types: [C.STRING],
        default: "Enter Text"
      },
      options: {
        types: ["default_opts"],
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, tagNameOrLocator, value, opts) => {
      await wait$1(1e3);
      let locator = await getSelector(tagNameOrLocator, context);
      await context.browser.type(locator, value, opts);
    },
    labels: ["action"]
  };
  stepDefs2["type_secret"] = {
    name: "type_secret",
    args: {
      "locator": {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"],
        default: { value: "html", type: "css", meta: {} }
      },
      text: {
        types: [C.SECRET]
      },
      options: {
        types: ["default_opts"],
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, tagNameOrLocator, value, opts) => {
      await wait$1(1e3);
      let locator = await getSelector(tagNameOrLocator, context);
      await context.browser.type(locator, value, opts);
    },
    labels: ["action"]
  };
  stepDefs2["scroll"] = {
    name: "scroll",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"],
        default: { value: "html", type: "css", meta: {} }
      },
      left: {
        types: [C.INT],
        default: 0
      },
      top: {
        types: [C.INT],
        default: 0
      },
      options: {
        types: ["default_opts"],
        default: { frame: 0, timeout: 30 },
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, tagNameOrLocator, left, top, opts) => {
      await wait$1(1e3);
      let locator = await getSelector(tagNameOrLocator, context);
      await context.browser.scroll(locator, left, top, opts);
    },
    labels: ["action"]
  };
  stepDefs2["wait_for_duration"] = {
    name: "wait_for_duration",
    args: {
      duration: {
        types: [C.INT],
        default: 1
      }
    },
    returnType: C.VOID,
    fn: async (_context, duration) => {
      await wait$1(duration * 1e3);
    },
    labels: ["action"]
  };
  stepDefs2["wait_for_element"] = {
    name: "wait_for_element",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"],
        default: { value: "html", type: "css", meta: {} }
      },
      options: {
        types: ["default_opts"],
        default: { frame: 0, timeout: 30 },
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, tagNameOrLocator, opts) => {
      let locator = await getSelector(tagNameOrLocator, context);
      let elementsCount = await context.browser.getElementsCount(locator, opts);
      let timeOut = Date.now() + TIME_LIMIT;
      while (elementsCount === 0 && timeOut > Date.now()) {
        await wait$1(500);
        elementsCount = await context.browser.getElementsCount(locator, opts);
      }
      if (elementsCount === 0) {
        throw new Error(`No element found for locator: ${locator.value} not found`);
      }
    },
    labels: ["action"]
  };
  stepDefs2["open"] = {
    name: "open",
    args: {
      url: {
        types: [C.STRING],
        default: "https://www.example.com"
      },
      options: {
        types: ["open_opts"],
        default: { page: 0, timeout: 30 },
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, url, opts) => {
      await context.browser.open(url, opts);
    },
    labels: ["action"]
  };
  stepDefs2["go_back"] = {
    name: "go_back",
    args: {
      opts: {
        types: ["go_back_opts"],
        default: { waitUntil: "load", timeout: 30 },
        optional: true
      }
    },
    returnType: C.VOID,
    fn: async (context, opts) => {
      await context.browser.goBack(opts);
    },
    labels: ["action"]
  };
  stepDefs2["assert"] = {
    name: "assert",
    args: {
      "condition": {
        types: [C.BOOLEAN],
        default: ["and", ["element_exists"]]
      },
      "error_code": {
        types: ["error_code"],
        default: "E_ASSERTION_FAILED"
      },
      "message": {
        types: [C.STRING],
        default: "",
        optional: true
      }
    },
    returnType: C.VOID,
    fn: (_context, condition, errorCode, message) => {
      if (!message) {
        message = `Assertion Failed`;
      }
      if (!condition) {
        throw new BaseError(errorCode, message);
      }
    },
    labels: ["action", "utils"]
  };
  stepDefs2["range"] = {
    name: "range",
    args: {
      to: {
        types: [C.INT],
        default: 10
      },
      from: {
        types: [C.INT],
        optional: true,
        default: 0
      },
      step: {
        types: [C.INT],
        optional: true,
        default: 1
      }
    },
    returnType: `iterable<${C.INT}>`,
    fn: async (_context, to, from, step) => new RangeIterator({ to, from, step }),
    labels: ["utils"]
  };
  stepDefs2["panic"] = {
    name: "panic",
    args: {
      "condition": {
        types: [C.BOOLEAN],
        default: ["and", ["element_exists"]]
      },
      "error_code": {
        types: ["error_code"],
        default: "E_REQUEST_FORBIDDEN"
      },
      "message": {
        types: [C.STRING],
        default: ""
      }
    },
    returnType: C.VOID,
    fn: (_context, condition, errorCode, message) => {
      if (condition) {
        throw new BaseError(errorCode, message);
      }
    },
    labels: ["action", "utils"]
  };
  stepDefs2["get_response"] = {
    name: "get_response",
    returnType: "response",
    args: {},
    fn: (context) => {
      return {
        status_code: context.browser.status_code,
        body_text_length: context.browser.body_text_length
      };
    }
  };
  stepDefs2["length"] = {
    name: "length",
    args: {
      str: {
        types: [C.STRING]
      }
    },
    returnType: C.INT,
    fn: async (_context, str) => {
      return str.length;
    },
    labels: ["utils"]
  };
  stepDefs2["lower"] = {
    name: "lower",
    args: {
      str: {
        types: [C.STRING]
      }
    },
    returnType: C.STRING,
    fn: async (_context, str) => {
      return str.toLowerCase();
    },
    labels: ["utils"]
  };
  stepDefs2["upper"] = {
    name: "upper",
    args: {
      str1: {
        types: [C.STRING]
      }
    },
    returnType: C.STRING,
    fn: async (_context, str) => {
      return str.toUpperCase();
    },
    labels: ["utils"]
  };
  stepDefs2["trim"] = {
    name: "trim",
    args: {
      str: {
        types: [C.STRING]
      },
      pos: {
        types: [C.STRING],
        optional: true
      }
    },
    returnType: C.STRING,
    fn: async (_context, str, pos = "BOTH") => {
      if (pos === "LEADING") {
        return str.trimStart();
      } else if (pos === "TRAILING") {
        return str.trimEnd();
      }
      return str.trim();
    },
    labels: ["utils"]
  };
  stepDefs2["substring"] = {
    name: "substring",
    args: {
      str: {
        types: [C.STRING]
      },
      startPos: {
        types: [C.INT]
      },
      endPos: {
        types: [C.INT]
      }
    },
    returnType: C.STRING,
    fn: async (_context, str, startPos, endPos) => {
      return str.slice(startPos, endPos);
    },
    labels: ["utils"]
  };
  stepDefs2["join"] = {
    name: "join",
    args: {
      val: {
        types: ["array<string>"]
      },
      seperator: {
        types: [C.STRING],
        optional: true
      }
    },
    returnType: C.STRING,
    fn: async (_context, val, seperator = "") => {
      return val.join(seperator);
    },
    labels: ["utils"]
  };
  stepDefs2["re_match"] = {
    name: "re_match",
    args: {
      str: {
        types: [C.STRING]
      },
      pattern: {
        types: [C.STRING]
      },
      flags: {
        types: [C.STRING],
        optional: true
      }
    },
    returnType: "array<string>",
    fn: async (_context, str, pattern, flags = "g") => {
      const regex = new RegExp(pattern, flags);
      const matches = str.match(regex);
      return matches ? matches : [];
    },
    labels: ["utils"]
  };
  stepDefs2["re_replace"] = {
    name: "re_replace",
    args: {
      str: {
        types: [C.STRING]
      },
      pattern: {
        types: [C.STRING]
      },
      replacement: {
        types: [C.STRING]
      },
      start: {
        types: [C.INT],
        optional: true
      },
      N: {
        types: [C.INT],
        optional: true
      },
      flags: {
        types: [C.STRING],
        optional: true
      }
    },
    returnType: C.STRING,
    fn: async (_context, str, pattern, replacement, start = 0, N = -1, flags = "") => {
      if (!flags.includes("g")) {
        flags += "g";
      }
      const regex = new RegExp(pattern, flags);
      const limitedReplace = (str2, limit) => {
        return str2.replace(regex, (match) => {
          return limit-- > 0 ? replacement : match;
        });
      };
      if (start > 0) {
        const before = str.substring(0, start);
        let after = str.substring(start);
        after = N >= 0 ? limitedReplace(after, N) : after.replace(regex, replacement);
        return before + after;
      } else {
        return N >= 0 ? limitedReplace(str, N) : str.replace(regex, replacement);
      }
    },
    labels: ["utils"]
  };
  stepDefs2["index"] = {
    name: "index",
    args: {
      val: {
        types: ["array<string>"]
      },
      index: {
        types: [C.INT]
      }
    },
    returnType: C.STRING,
    fn: async (_context, val, index = -1) => {
      if (index < 0 || index >= val.length) {
        throw new Error("Invalid argument: index out of bounds");
      }
      return val[index];
    },
    labels: ["utils"]
  };
  stepDefs2["element_text"] = {
    name: "element_text",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"]
      },
      options: {
        types: ["default_opts"],
        optional: true
      }
    },
    returnType: C.STRING,
    fn: async (context, tagNameOrLocator, opts) => {
      let locator = (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? getLocator(tagNameOrLocator, context.tagList, context.getExpression()) : tagNameOrLocator;
      return await context.browser.getElementText(locator, opts);
    },
    labels: ["element"]
  };
  stepDefs2["element_attr"] = {
    name: "element_attr",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"]
      },
      attr: {
        types: [C.STRING]
      },
      options: {
        types: ["default_opts"],
        optional: true
      }
    },
    returnType: C.STRING,
    fn: async (context, tagNameOrLocator, attr2, opts) => {
      let locator = (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? getLocator(tagNameOrLocator, context.tagList, context.getExpression()) : tagNameOrLocator;
      return await context.browser.evalOnSelector(locator, (el, arg) => {
        var _a;
        return (_a = el.getAttribute(arg.attr)) !== null && _a !== void 0 ? _a : "";
      }, { attr: attr2 }, opts);
    },
    labels: ["element"]
  };
  stepDefs2["element_prop"] = {
    name: "element_prop",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"]
      },
      prop: {
        types: [C.STRING]
      },
      options: {
        types: ["default_opts"],
        optional: true
      }
    },
    returnType: C.STRING,
    fn: async (context, tagNameOrLocator, prop, opts) => {
      let locator = (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? getLocator(tagNameOrLocator, context.tagList, context.getExpression()) : tagNameOrLocator;
      return await context.browser.evalOnSelector(locator, (el, arg) => {
        var _a;
        return (_a = el[arg.prop]) !== null && _a !== void 0 ? _a : "";
      }, { prop }, opts);
    },
    labels: ["element"]
  };
  return stepDefs2;
}
function getConditionDefs(defOpts) {
  const conditionDefs2 = {};
  conditionDefs2["element_exists"] = {
    name: "element_exists",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"]
      },
      options: {
        types: ["default_opts"],
        optional: true
      }
    },
    returnType: C.BOOLEAN,
    fn: async (context, tagNameOrLocator, opts) => {
      let locator = (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? getLocator(tagNameOrLocator, context.tagList, context.getExpression()) : tagNameOrLocator;
      let elementsCount = await context.browser.getElementsCount(locator, opts);
      return elementsCount > 0;
    },
    labels: ["element"]
  };
  conditionDefs2["element_has_text"] = {
    name: "element_has_text",
    args: {
      [(defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? "tag" : "locator"]: {
        types: (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? ["tag", "selector"] : ["selector"]
      },
      text: {
        types: [C.STRING],
        default: "Search Text"
      },
      options: {
        types: ["default_opts"],
        optional: true
      }
    },
    returnType: C.BOOLEAN,
    fn: async (context, tagNameOrLocator, text2, opts = {}) => {
      let locator = (defOpts === null || defOpts === void 0 ? void 0 : defOpts.tagMode) ? getLocator(tagNameOrLocator, context.tagList, context.getExpression()) : tagNameOrLocator;
      opts.state = "attached";
      let elementText = await context.browser.getElementText(locator, opts);
      return containsText(elementText, text2);
    },
    labels: ["element"]
  };
  conditionDefs2["lt"] = {
    name: "lt",
    args: {
      num1: {
        types: [C.FLOAT]
      },
      num2: {
        types: [C.FLOAT]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, num1, num2) => num1 < num2
  };
  conditionDefs2["lte"] = {
    name: "lte",
    args: {
      num1: {
        types: [C.FLOAT]
      },
      num2: {
        types: [C.FLOAT]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, num1, num2) => num1 <= num2
  };
  conditionDefs2["gt"] = {
    name: "gt",
    args: {
      num1: {
        types: [C.FLOAT]
      },
      num2: {
        types: [C.FLOAT]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, num1, num2) => num1 > num2
  };
  conditionDefs2["gte"] = {
    name: "gte",
    args: {
      num1: {
        types: [C.FLOAT]
      },
      num2: {
        types: [C.FLOAT]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, num1, num2) => num1 >= num2
  };
  conditionDefs2["eq"] = {
    name: "eq",
    args: {
      num1: {
        types: [C.FLOAT]
      },
      num2: {
        types: [C.FLOAT]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, num1, num2) => num1 === num2
  };
  conditionDefs2["contains"] = {
    name: "contains",
    args: {
      str1: {
        types: [C.STRING]
      },
      str2: {
        types: [C.STRING]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, str1, str2) => str1.includes(str2)
  };
  conditionDefs2["not_contains"] = {
    name: "not_contains",
    args: {
      str1: {
        types: [C.STRING]
      },
      str2: {
        types: [C.STRING]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, str1, str2) => !str1.includes(str2)
  };
  conditionDefs2["starts_with"] = {
    name: "starts_with",
    args: {
      str1: {
        types: [C.STRING]
      },
      str2: {
        types: [C.STRING]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, str1, str2) => str1.startsWith(str2)
  };
  conditionDefs2["not_starts_with"] = {
    name: "not_starts_with",
    args: {
      str1: {
        types: [C.STRING]
      },
      str2: {
        types: [C.STRING]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, str1, str2) => !str1.startsWith(str2)
  };
  conditionDefs2["ends_with"] = {
    name: "ends_with",
    args: {
      str: {
        types: [C.STRING]
      },
      target: {
        types: [C.STRING]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, str, target) => {
      return str.endsWith(target);
    }
  };
  conditionDefs2["not_ends_with"] = {
    name: "not_ends_with",
    args: {
      str: {
        types: [C.STRING]
      },
      target: {
        types: [C.STRING]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, str, target) => {
      return !str.endsWith(target);
    }
  };
  conditionDefs2["is_empty"] = {
    name: "is_empty",
    args: {
      str1: {
        types: [C.STRING]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, str1) => !str1 || str1.length === 0
  };
  conditionDefs2["not_is_empty"] = {
    name: "not_is_empty",
    args: {
      str1: {
        types: [C.STRING]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, str1) => (str1 === null || str1 === void 0 ? void 0 : str1.length) > 0
  };
  conditionDefs2["match_regex"] = {
    name: "match_regex",
    args: {
      str1: {
        types: [C.STRING]
      },
      regex: {
        types: ["regex"]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, str1, regex) => str1.match(new RegExp(regex.expr, regex.flags))
  };
  conditionDefs2["not_match_regex"] = {
    name: "not_match_regex",
    args: {
      str1: {
        types: [C.STRING]
      },
      regex: {
        types: ["regex"]
      }
    },
    returnType: C.BOOLEAN,
    fn: async (_context, str1, regex) => !str1.match(new RegExp(regex.expr, regex.flags))
  };
  return conditionDefs2;
}
const structDefs = {};
structDefs["selector"] = {
  name: "selector",
  fields: {
    value: {
      types: [C.STRING],
      default: "html"
    },
    type: {
      types: ["selector_type"],
      default: "css"
    },
    meta: {
      types: [C.JSON],
      default: {},
      optional: true
    }
  },
  iterator: {
    type: "selector",
    iter: async (context, selector) => {
      return await context.browser.getSelectors(selector);
    }
  }
};
structDefs["position"] = {
  name: "position",
  fields: {
    x: {
      types: [C.FLOAT],
      default: 0
    },
    y: {
      types: [C.FLOAT],
      default: 0
    }
  }
};
structDefs["frame_locator"] = {
  name: "frame_locator",
  fields: {
    index: {
      types: [C.INT],
      default: 0,
      optional: true
    },
    name: {
      types: [C.STRING],
      default: "",
      optional: true
    },
    page: {
      types: [C.INT],
      default: 0,
      optional: true
    }
  }
};
structDefs["default_opts"] = {
  name: "options",
  fields: {
    frame: {
      types: [C.INT, "frame_locator"],
      default: 0,
      optional: true
    },
    timeout: {
      types: [C.INT],
      default: 30,
      optional: true
    }
  }
};
structDefs["wait_doc_opts"] = {
  name: "options",
  fields: {
    wait_for_redirects: {
      types: [C.INT],
      default: 0,
      optional: true
    },
    frame: {
      types: [C.INT, "frame_locator"],
      default: 0,
      optional: true
    },
    timeout: {
      types: [C.INT],
      default: 30,
      optional: true
    }
  }
};
structDefs["click_opts"] = {
  name: "options",
  fields: {
    frame: {
      types: [C.INT, "frame_locator"],
      default: 0,
      optional: true
    },
    timeout: {
      types: [C.INT],
      default: 30,
      optional: true
    },
    button: {
      types: ["mouse_button"],
      default: "left",
      optional: true
    },
    clickCount: {
      types: [C.INT],
      default: 1,
      optional: true
    },
    delay: {
      types: [C.INT],
      default: 0,
      optional: true
    }
  }
};
structDefs["keypress_opts"] = {
  name: "options",
  fields: {
    page: {
      types: [C.INT],
      default: 0,
      optional: true
    },
    timeout: {
      types: [C.INT],
      default: 30,
      optional: true
    }
  }
};
structDefs["open_opts"] = {
  name: "options",
  fields: {
    page: {
      types: [C.INT],
      default: 0,
      optional: true
    },
    timeout: {
      types: [C.INT],
      default: 30,
      optional: true
    }
  }
};
structDefs["response"] = {
  name: "response",
  fields: {
    status_code: {
      types: [C.INT]
    },
    body_text_length: {
      types: [C.INT]
    }
  }
};
structDefs["regex"] = {
  name: "regex",
  fields: {
    expr: {
      types: [C.STRING]
    },
    flags: {
      types: [C.STRING],
      optional: true
    }
  }
};
class RangeIterator {
  constructor({ to, from = 0, step = 1 }) {
    this.current = from;
    this.to = to;
    this.step = step;
    if (step === 0) {
      throw new Error("Step cannot be 0");
    }
    this.condition = this.step > 0 ? this.lt : this.gt;
  }
  gt(a, b) {
    return a > b;
  }
  lt(a, b) {
    return a < b;
  }
  next() {
    if (this.condition(this.current, this.to)) {
      const result = { done: false, value: this.current };
      this.current = this.current + this.step;
      return result;
    } else {
      return { done: true, value: null };
    }
  }
  [Symbol.iterator]() {
    return this;
  }
}
structDefs["go_back_opts"] = {
  name: "options",
  fields: {
    waitUntil: {
      types: [C.STRING],
      default: "load",
      optional: true
    },
    timeout: {
      types: [C.INT],
      default: 60,
      optional: true
    }
  }
};
const enumDefs = {};
enumDefs["selector_type"] = {
  name: "selector_type",
  enumType: "string",
  values: ["css", "xpath"]
};
enumDefs["kb_key"] = {
  name: "kb_key",
  enumType: "string",
  values: ["ArrowDown", "ArrowLeft", "ArrowRight", "ArrowUp", "Backspace", "Delete", "Enter", "Escape", "Tab"]
};
enumDefs["mouse_button"] = {
  name: "mouse_button",
  enumType: "string",
  values: ["left", "right", "middle", "forward", "back"]
};
enumDefs["error_code"] = {
  name: "error_code",
  enumType: "string",
  values: [
    "E_ASSERT",
    "E_CAPTCHA",
    "E_ELEMENT_NOT_FOUND",
    "E_REQUEST",
    "E_REQUEST_BAD_GATEWAY",
    "E_REQUEST_FORBIDDEN",
    "E_REQUEST_INTERNAL_SERVER_ERROR",
    "E_REQUEST_NOT_FOUND",
    "E_REQUEST_SERVICE_UNAVAILABLE",
    "E_REQUEST_TOO_MANY_REQUESTS",
    "E_REQUEST_UNAUTHORIZED",
    "E_TIMED_OUT",
    "E_UNKNOWN"
  ]
};
const workflowEnums = {
  ["tag"]: {
    name: "tag",
    enumType: "string",
    values: [],
    iterator: {
      type: "selector",
      iter: async (context, tagName) => {
        let locator = getLocator(tagName, context.tagList, context.getExpression());
        return await context.browser.getSelectors(locator);
      }
    }
  }
};
const stepDefs = getStepDefs({ tagMode: true });
const conditionDefs = getConditionDefs({ tagMode: true });
const builtInDeclarations = [
  { name: "start_url", dataType: "string", builtIn: true }
];
function parseSteps(initialSteps, tagNames, opts) {
  if (!opts) {
    opts = {};
  }
  if (!opts.declarations) {
    opts.declarations = [];
  }
  opts.declarations = [...opts.declarations, ...builtInDeclarations];
  workflowEnums.tag.values = [...tagNames];
  return new Root(createRegistry(), initialSteps, { allowNamedBlocks: true, ...opts });
}
function createRegistry() {
  return new Registry({
    funcs: { ...stepDefs, ...conditionDefs },
    structs: { ...structDefs },
    enums: { ...enumDefs, ...workflowEnums }
  });
}
function initListening() {
  this._listeners = [];
  this.on("change", () => {
    this._listeners.forEach((listener) => {
      listener(this);
    });
  });
  this._listening = true;
}
function subscribe(listener) {
  if (!this._listening) {
    this.initListening();
  }
  this._listeners.push(listener);
  listener(this);
  return () => {
    this._listeners.splice(this._listeners.indexOf(listener), 1);
  };
}
Expression$1.prototype.initListening = initListening;
Expression$1.prototype.subscribe = subscribe;
Root.prototype.initListening = initListening;
Root.prototype.subscribe = subscribe;
function ListenerManager(tag, listener) {
  function update(removeMode = false) {
    if (!tag)
      return;
    tag.off("change", listener);
    tag.off("change", updateSelectorGroupListener);
    tag.off("change", updateProcsListener);
    updateSelectorGroupListener(removeMode);
    updateProcsListener(removeMode);
    if (!removeMode) {
      tag.on("change", listener);
      tag.on("change", updateSelectorGroupListener);
      tag.on("change", updateProcsListener);
    }
  }
  function updateExcludeSelectorListener(removeMode = false) {
    let excludes = tag.get("selectors").get("excludes");
    excludes.each((s) => s.off("change", listener));
    if (!removeMode) {
      excludes.each((s) => s.on("change", listener));
    }
  }
  function updateExcludesListener(removeMode = false) {
    let excludes = tag.get("selectors").get("excludes");
    excludes.off("change", listener);
    excludes.off("change", updateExcludeSelectorListener);
    updateExcludeSelectorListener(removeMode);
    if (!removeMode) {
      excludes.on("change", listener);
      excludes.on("change", updateExcludeSelectorListener);
    }
  }
  function updateFieldListener(removeMode = false) {
    let selectors = tag.get("selectors");
    let field = selectors.get("field");
    field.off("change", listener);
    field.off("change", updateFieldParamListener);
    updateFieldParamListener(removeMode);
    if (!removeMode) {
      field.on("change", listener);
      field.on("change", updateFieldParamListener);
    }
  }
  function updateFieldParamListener(removeMode = false) {
    let selectors = tag.get("selectors");
    let field = selectors.get("field");
    let params = field.get("params");
    params.off("change", listener);
    if (!removeMode) {
      params.on("change", listener);
    }
  }
  function updateIncludeSelectorListener(removeMode = false) {
    let includes = tag.get("selectors").get("includes");
    includes.each((s) => s.off("change", listener));
    if (!removeMode) {
      includes.each((s) => s.on("change", listener));
    }
  }
  function updateIncludesListener(removeMode = false) {
    let includes = tag.get("selectors").get("includes");
    includes.off("change", listener);
    includes.off("change", updateIncludeSelectorListener);
    updateIncludeSelectorListener(removeMode);
    if (!removeMode) {
      includes.on("change", listener);
      includes.on("change", updateIncludeSelectorListener);
    }
  }
  function updateMapperListener(removeMode = false) {
    let procs = tag.get("procs");
    let mappers = procs.get("mappers");
    mappers.each((m) => {
      m.off("change", listener);
      m.get("root").off("change", listener);
    });
    if (!removeMode) {
      mappers.each((m) => {
        m.on("change", listener);
        m.get("root").on("change", listener);
      });
    }
  }
  function updateMappersListener(removeMode = false) {
    let procs = tag.get("procs");
    let mappers = procs.get("mappers");
    mappers.off("change", listener);
    mappers.off("change", updateMapperListener);
    updateMapperListener(removeMode);
    if (!removeMode) {
      mappers.on("change", listener);
      mappers.on("change", updateMapperListener);
    }
  }
  function updateParserListener(removeMode = false) {
    let procs = tag.get("procs");
    let parser = procs.get("parser");
    if (parser) {
      parser.off("change", listener);
      parser.off("change", updateParserExprListener);
      updateParserExprListener(removeMode);
      if (!removeMode) {
        parser.on("change", listener);
        parser.on("change", updateParserExprListener);
      }
    }
  }
  function updateParserExprListener(removeMode = false) {
    let procs = tag.get("procs");
    let parser = procs.get("parser");
    if (parser) {
      if (parser.attributes.expr) {
        parser.get("expr").off("change", listener);
        parser.get("expr").get("root").off("change", listener);
        if (!removeMode) {
          parser.get("expr").on("change", listener);
          parser.get("expr").get("root").on("change", listener);
        }
      }
    }
  }
  function updateProcsListener(removeMode = false) {
    let procs = tag.get("procs");
    procs.off("change", listener);
    procs.off("change", updateMappersListener);
    procs.off("change", updateReducerListener);
    procs.off("change", updateParserListener);
    procs.off("change", updateValidatorsListener);
    updateMappersListener(removeMode);
    updateReducerListener(removeMode);
    updateParserListener(removeMode);
    updateValidatorsListener(removeMode);
    if (!removeMode) {
      procs.on("change", listener);
      procs.on("change", updateMappersListener);
      procs.on("change", updateReducerListener);
      procs.on("change", updateParserListener);
      procs.on("change", updateValidatorsListener);
    }
  }
  function updateReducerListener(removeMode = false) {
    let procs = tag.get("procs");
    let reducer = procs.get("reducer");
    if (reducer) {
      reducer.off("change", listener);
      reducer.get("root").off("change", listener);
      if (!removeMode) {
        reducer.on("change", listener);
        reducer.get("root").on("change", listener);
      }
    }
  }
  function updateSelectorGroupListener(removeMode = false) {
    let selectors = tag.get("selectors");
    selectors.off("change", listener);
    selectors.off("change", updateIncludesListener);
    selectors.off("change", updateExcludesListener);
    selectors.off("change", updateFieldListener);
    updateIncludesListener(removeMode);
    updateExcludesListener(removeMode);
    updateFieldListener(removeMode);
    if (!removeMode) {
      selectors.on("change", listener);
      selectors.on("change", updateIncludesListener);
      selectors.on("change", updateExcludesListener);
      selectors.on("change", updateFieldListener);
    }
  }
  function updateValidatorsListener(removeMode = false) {
    let procs = tag.get("procs");
    let validator = procs.get("validator");
    validator.off("change", listener);
    validator.off("change", updateValidatorListener);
    updateValidatorListener(removeMode);
    if (!removeMode) {
      validator.on("change", listener);
      validator.on("change", updateValidatorListener);
    }
  }
  function updateValidatorListener(removeMode = false) {
    let procs = tag.get("procs");
    let validators = procs.get("validator");
    let exprs = validators.get("exprs");
    exprs.each((m) => {
      m.off("change", listener);
      m.get("root").off("change", listener);
    });
    if (!removeMode) {
      exprs.each((m) => {
        m.on("change", listener);
        m.get("root").on("change", listener);
      });
    }
  }
  return {
    remove: () => update(true),
    set: () => update()
  };
}
function getNewTagName(tagList) {
  let i = 0;
  let name = `Tag`;
  while (tagList.models.some((t) => t.get("name") === name)) {
    name = `Tag${++i}`;
  }
  return name;
}
let tagIdGenerator = () => {
  return crypto.randomUUID();
};
function createTag(tagList, tree, opts) {
  var _a, _b, _c, _d, _e;
  tagList.add(new tagList.model({
    id: tagIdGenerator(),
    version: "0",
    name: (_a = opts == null ? void 0 : opts.name) != null ? _a : getNewTagName(tagList),
    context: (_b = opts == null ? void 0 : opts.context) != null ? _b : null,
    frame: (_c = opts == null ? void 0 : opts.frame) != null ? _c : 0,
    selectors: (_d = opts == null ? void 0 : opts.selectors) != null ? _d : [],
    parent_id: (_e = opts.parent_id) != null ? _e : null
  }, tagList));
  let tag = tagList.at(-1);
  tag.setChanged(true);
  updateTagEnum(tree, tagList);
  return tag;
}
function getDefaultTag(node, tagList) {
  let tagsInContext = getTagsInContext(node, tagList);
  if (tagsInContext.length === 0) {
    let contextStack = getContextStack(node);
    let context = contextStack[contextStack.length - 1];
    createTag(tagList, node.root, { context });
    tagsInContext = getTagsInContext(node, tagList);
  }
  return tagsInContext[tagsInContext.length - 1];
}
function getDefaultWorkflowStep(tag, stepName) {
  switch (stepName) {
    case "click":
      return ["click", tag.get("name"), { x: 0, y: 0 }];
    case "select":
      return ["select", tag.get("name"), "select an option"];
    case "mousemove":
      return ["mousemove", tag.get("name"), { x: 0, y: 0 }];
    case "drag":
      return ["drag", tag.get("name"), { x: 0, y: 0 }, tag.get("name"), { x: 0, y: 0 }];
    case "focus":
      return ["focus", tag.get("name")];
    case "type":
      return ["type", tag.get("name"), "enter your text here"];
    case "scroll":
      return ["scroll", tag.get("name"), 0, 0];
    case "wait_for_element":
      return ["wait_for_element", tag.get("name")];
    case "element_exists":
      return ["element_exists", tag.get("name")];
    case "element_has_text":
      return ["element_has_text", tag.get("name"), ""];
    case "element_text":
      return ["element_text", tag.get("name")];
    case "element_attr":
      return ["element_attr", tag.get("name"), ""];
    case "element_prop":
      return ["element_prop", tag.get("name"), ""];
    default:
      throw new Error(`Unknown workflow step name: ${stepName}`);
  }
}
function getTagsInContext(node, tagList) {
  let contextStack = getContextStack(node);
  let tagsInContext = [];
  let tagNames = /* @__PURE__ */ new Set();
  for (let i = contextStack.length - 1; i >= 0; i--) {
    let context = contextStack[i];
    let tags = tagList.models.filter((t) => t.get("context") === context);
    for (let j = tags.length - 1; j >= 0; j--) {
      let tag = tags[j];
      if (!tagNames.has(tag.get("name"))) {
        tagsInContext.unshift(tag);
        tagNames.add(tag.get("name"));
      }
    }
  }
  return tagsInContext;
}
function insertAt$1(node, index, tagList) {
  let tag;
  let tagsInContext = getTagsInContext(node, tagList);
  if (tagsInContext.length > 0) {
    tag = tagsInContext[tagsInContext.length - 1];
  } else {
    let contextStack = getContextStack(node);
    let context = contextStack[contextStack.length - 1];
    tag = createTag(tagList, node.root, { context });
  }
  node.insertAt(index, ["click", tag.get("name"), { x: 0, y: 0 }]);
}
function updateTagEnum(tree, tagList) {
  let tagDef = tree.scope.getEnum("tag");
  tagDef.values = tagList.models.map((t) => t.get("name"));
}
function tooltip(element2, tip) {
  var _a;
  let top = 0;
  let left = 0;
  let timer;
  let tipElement;
  let root = (_a = document.querySelector(".bbx-recorder")) != null ? _a : document.body;
  let rootTop = root.getBoundingClientRect().top;
  let rootLeft = root.getBoundingClientRect().left;
  function setTip() {
    removeTip();
    if (!root)
      return;
    tipElement = document.createElement("span");
    tipElement.textContent = tip;
    tipElement.setAttribute("style", `
      top: ${top - rootTop}px; left: ${left - rootLeft}px; position: absolute;
      border-radius: var(--bbx-border-radius);
      background-color: var(--bbx-color-bg-input);
      opacity: 0.8;
      color: var(--bbx-color-text-active);
      font-size: 0.75rem;
      padding: 0.25rem;
      z-index: 1;
    `);
    root.appendChild(tipElement);
  }
  function removeTip() {
    clearTimeout(timer);
    if (tipElement) {
      tipElement.remove();
      tipElement = void 0;
    }
  }
  function mouseEnter(e) {
    top = e.pageY + 15;
    left = e.pageX - 5;
    timer = setTimeout(setTip, 1e3);
  }
  function mouseMove(e) {
    top = e.pageY + 15;
    left = e.pageX - 5;
    if (tipElement) {
      tipElement.style.left = `${left - rootLeft}px`;
      tipElement.style.top = `${top - rootTop}px`;
    }
  }
  function mouseLeave() {
    removeTip();
  }
  element2.addEventListener("mouseenter", mouseEnter);
  element2.addEventListener("mousemove", mouseMove);
  element2.addEventListener("mouseleave", mouseLeave);
  return {
    update(newTip) {
      tip = newTip;
      if (tipElement) {
        tipElement.textContent = tip;
      }
    },
    destroy() {
      removeTip();
      element2.removeEventListener("mouseenter", mouseEnter);
      element2.removeEventListener("mousemove", mouseMove);
      element2.removeEventListener("mouseleave", mouseLeave);
    }
  };
}
function create_fragment$15(ctx) {
  let a;
  let a_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  return {
    c() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      attr(a, "href", "javascript:void(0)");
      attr(a, "class", "bbx-action-icon bbx-w-1 bbx-h-1");
      attr(a, "style", a_style_value = `${ctx[0] ? "width: " + ctx[0] + "px; height: " + ctx[0] + "px;" : ""}`);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", ctx[3]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1 && a_style_value !== (a_style_value = `${ctx2[0] ? "width: " + ctx2[0] + "px; height: " + ctx2[0] + "px;" : ""}`)) {
        attr(a, "style", a_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { size = null } = $$props;
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [size, $$scope, slots, click_handler2];
}
class IconBtn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$15, create_fragment$15, safe_not_equal, { size: 0 });
  }
}
function create_fragment$14(ctx) {
  let svg;
  let g0;
  let g1;
  let g2;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g0 = svg_element("g");
      g1 = svg_element("g");
      g2 = svg_element("g");
      path = svg_element("path");
      attr(g1, "stroke-linecap", "round");
      attr(g1, "stroke-linejoin", "round");
      attr(path, "d", "M19 5L4.99998 19M5.00001 5L19 19");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", ctx[1]);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g0);
      append(svg, g1);
      append(svg, g2);
      append(g2, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "stroke-width", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$14($$self, $$props, $$invalidate) {
  let { strokeColor = "black" } = $$props;
  let { strokeWidth = 4 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
  };
  return [strokeColor, strokeWidth];
}
class Cross$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$14, create_fragment$14, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
function create_fragment$13(ctx) {
  let svg;
  let g1;
  let g0;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      g1 = svg_element("g");
      g0 = svg_element("g");
      polyline = svg_element("polyline");
      attr(polyline, "fill", "none");
      attr(polyline, "points", "3.7 14.3 9.6 19 20.3 5");
      attr(polyline, "stroke-linecap", "round");
      attr(polyline, "stroke-linejoin", "round");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "stroke-width", ctx[1]);
      attr(svg, "stroke", ctx[0]);
      set_style(svg, "display", "block");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g1);
      append(g1, g0);
      append(g0, polyline);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        attr(svg, "stroke-width", ctx2[1]);
      }
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$13($$self, $$props, $$invalidate) {
  let { strokeColor = "#000000" } = $$props;
  let { strokeWidth = 4 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
  };
  return [strokeColor, strokeWidth];
}
class Tick extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$13, create_fragment$13, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
function keypressEscape(node) {
  const handleKey = (event) => {
    if (event.key == "Escape") {
      node.dispatchEvent(new CustomEvent("escape"));
    }
  };
  document.body.addEventListener("keydown", handleKey, true);
  return {
    destroy() {
      document.body.removeEventListener("keydown", handleKey, true);
    }
  };
}
function keypressEnter(node) {
  const handleKey = (event) => {
    if (event.key == "Enter") {
      node.dispatchEvent(new CustomEvent("enter"));
    }
  };
  document.body.addEventListener("keydown", handleKey, true);
  return {
    destroy() {
      document.body.removeEventListener("keydown", handleKey, true);
    }
  };
}
const MAX_NAME_LENGTH = 20;
const MAX_VALUE_LENGTH = 30;
const MAX_ATTRIBS = 15;
const MAX_PARTIAL_COUNT = 10;
function toMean(cum, curr, i, _2) {
  return cum + (curr - cum) / (i + 1);
}
function toMin(cum, curr) {
  return curr > cum ? cum : curr;
}
function getPartialTokenValues(word, options) {
  let wordArr = [];
  if (!/([a-z][A-Z])|[\-\_\s]/.test(word))
    return wordArr;
  if (options && options.multi && word.length > 3) {
    wordArr = wordArr.concat(getMultiWordArr(word));
  }
  wordArr = wordArr.concat(getWordArr(word));
  wordArr = wordArr.filter((w) => w.length > 3);
  return wordArr.slice(0, (options === null || options === void 0 ? void 0 : options.maxCount) || MAX_PARTIAL_COUNT);
}
function getWordArr(word) {
  word = word.replace(/(.+)([A-Z][a-z])/g, "$1 $2");
  word = word.replace(/([a-z])([A-Z])/, "$1 $2");
  let wordArr = word.split(/[\s\,\_\-\(\)\[\]\=]+/);
  return wordArr;
}
function getMultiWordArr(value) {
  let regexp = /^[a-zA-Z0-9]+[\-\_\s]{1,2}[a-zA-Z0-9]+/;
  let regexp2 = /^[a-zA-Z0-9]+[\-\_\s]{1,2}[a-zA-Z0-9]+[\-\_\s]{1,2}[a-zA-Z-0-9]+/;
  let regexp3 = /\b[a-z]+[A-Z][a-z]{2,}/g;
  let matches = [...value.match(regexp) || []].concat([...value.match(regexp2) || []]).concat([...value.matchAll(regexp3)].map((m) => m[0]));
  return matches;
}
class XSet extends Set {
  static flatten(set2d) {
    let newSet = new XSet();
    for (let es of set2d) {
      for (let x of es) {
        newSet.add(x);
      }
    }
    return newSet;
  }
  constructor(arr) {
    super(arr);
  }
  get length() {
    return this.size;
  }
  get first() {
    let x;
    for (x of this) {
      break;
    }
    return x;
  }
  map(mapMethod) {
    return [...this].map(mapMethod);
  }
  mapToSet(mapMethod) {
    return new XSet(this.map(mapMethod));
  }
  filter(filterMethod) {
    return new XSet([...this].filter(filterMethod));
  }
  intersects(anotherSet) {
    for (let item of this) {
      if (anotherSet.has(item))
        return true;
    }
    return false;
  }
  intersection(anotherSet) {
    let newSet = new XSet();
    for (let x of this) {
      if (anotherSet.has(x))
        newSet.add(x);
    }
    return newSet;
  }
  isSubsetOf(anotherSet) {
    return [...this].every((item) => anotherSet.has(item));
  }
  isEqualTo(anotherSet) {
    return this.isSubsetOf(anotherSet) && anotherSet.isSubsetOf(this);
  }
  difference(anotherSet) {
    let diffList = [];
    for (let item of this) {
      if (!anotherSet.has(item)) {
        diffList.push(item);
      }
    }
    return new XSet(diffList);
  }
  union(anotherSet) {
    let newSet = new XSet();
    for (let item of this) {
      newSet.add(item);
    }
    for (let item of anotherSet) {
      newSet.add(item);
    }
    return newSet;
  }
  clone() {
    return new XSet([...this]);
  }
  toArray() {
    return [...this];
  }
}
let penalWords = ["false", "true", "blank"];
let stylingWords = [
  "css",
  "align",
  "animation",
  "delay",
  "direction",
  "fill",
  "mode",
  "iteration",
  "name",
  "@keyframes",
  "state",
  "timing",
  "function",
  "backface",
  "visibility",
  "background",
  "attachment",
  "clip",
  "image",
  "origin",
  "position",
  "repeat",
  "size",
  "border",
  "bottom",
  "radius",
  "right",
  "style",
  "width",
  "collapse",
  "collapsed",
  "outset",
  "slice",
  "source",
  "spacing",
  "top",
  "box",
  "shadow",
  "sizing",
  "caption",
  "side",
  "clear",
  "column",
  "gap",
  "rule",
  "span",
  "columns",
  "counter",
  "increment",
  "reset",
  "cursor",
  "display",
  "empty",
  "cell",
  "flex",
  "basis",
  "flow",
  "wrap",
  "grow",
  "shrink",
  "float",
  "font",
  "family",
  "adjust",
  "stretch",
  "variant",
  "weight",
  "height",
  "justify",
  "letter",
  "line",
  "margin",
  "max",
  "min",
  "opacity",
  "order",
  "outline",
  "offset",
  "overflow",
  "padding",
  "break",
  "after",
  "before",
  "inside",
  "perspective",
  "quotes",
  "resize",
  "tab",
  "layout",
  "decoration",
  "indent",
  "transform",
  "transition",
  "property",
  "vertical",
  "white",
  "space",
  "word",
  "index",
  "foramt",
  "row",
  "col",
  "format",
  "highlight",
  "vert",
  "middle",
  "large",
  "down",
  "small",
  "overlay",
  "trigger"
];
let cssColorWords = [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgrey",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkslategrey",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dimgrey",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred ",
  "indigo ",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgrey",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightslategrey",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "slategrey",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
];
let cssPositionWords = ["top", "left", "right", "bottom", "position"];
let cssLayoutWords = ["flex", "grid", "col", "row", "inline"];
let fontWords = ["xs", "sm", "lg", "md", "semibold", "bold", "medium", "large", "small"];
let metaWords = ["lang"];
let cssWords = penalWords.concat(stylingWords).concat(cssColorWords).concat(cssPositionWords).concat(cssLayoutWords).concat(fontWords).concat(metaWords);
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var object = {};
var hasOwnProperty = object.hasOwnProperty;
var merge = function merge2(options, defaults) {
  if (!options) {
    return defaults;
  }
  var result = {};
  for (var key in defaults) {
    result[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];
  }
  return result;
};
var regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
var regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
var regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
var cssesc = function cssesc2(string, options) {
  options = merge(options, cssesc2.options);
  if (options.quotes != "single" && options.quotes != "double") {
    options.quotes = "single";
  }
  var quote = options.quotes == "double" ? '"' : "'";
  var isIdentifier = options.isIdentifier;
  var firstChar = string.charAt(0);
  var output = "";
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var character = string.charAt(counter++);
    var codePoint = character.charCodeAt();
    var value = void 0;
    if (codePoint < 32 || codePoint > 126) {
      if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
        var extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
        } else {
          counter--;
        }
      }
      value = "\\" + codePoint.toString(16).toUpperCase() + " ";
    } else {
      if (options.escapeEverything) {
        if (regexAnySingleEscape.test(character)) {
          value = "\\" + character;
        } else {
          value = "\\" + codePoint.toString(16).toUpperCase() + " ";
        }
      } else if (/[\t\n\f\r\x0B]/.test(character)) {
        value = "\\" + codePoint.toString(16).toUpperCase() + " ";
      } else if (character == "\\" || !isIdentifier && (character == '"' && quote == character || character == "'" && quote == character) || isIdentifier && regexSingleEscape.test(character)) {
        value = "\\" + character;
      } else {
        value = character;
      }
    }
    output += value;
  }
  if (isIdentifier) {
    if (/^-[-\d]/.test(output)) {
      output = "\\-" + output.slice(1);
    } else if (/\d/.test(firstChar)) {
      output = "\\3" + firstChar + " " + output.slice(1);
    }
  }
  output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
    if ($1 && $1.length % 2) {
      return $0;
    }
    return ($1 || "") + $2;
  });
  if (!isIdentifier && options.wrap) {
    return quote + output + quote;
  }
  return output;
};
cssesc.options = {
  "escapeEverything": false,
  "isIdentifier": false,
  "quotes": "single",
  "wrap": false
};
cssesc.version = "3.0.0";
var cssesc_1 = cssesc;
function buildQuery$1(tree) {
  tree = tree.clone();
  removeDanglingTokens$1(tree);
  if (tree.tokens.length === 0)
    return "*";
  let path = "";
  let tokens = tree.tokens;
  for (let i = 0; i < tokens.length; i++) {
    if (i > 0 && (tokens[i].depth !== tokens[i - 1].depth || tokens[i].offset !== tokens[i - 1].offset))
      ;
    let tokenString = formatTokens$1(tokens[i], tokens[i].nodeRef);
    path += addConnector$1(tokens[i - 1], tokens[i], path) + tokenString;
  }
  if (tree.tokens[tokens.length - 1].offset !== 0)
    path += "~ *";
  if (tree.tokens[tokens.length - 1].depth !== tree.maxDepth)
    path += " *";
  return path;
}
function addConnector$1(prevToken, curToken, path) {
  if (path === "")
    return "";
  if (prevToken.depth === curToken.depth && prevToken.offset === curToken.offset) {
    return "";
  }
  if (prevToken.offset === 0 && curToken.depth - prevToken.depth === 1 && prevToken.type === "immediate" && curToken.type !== "immediate") {
    return "> ";
  }
  if (prevToken.offset === 0 && prevToken.depth !== curToken.depth) {
    return " ";
  }
  if (prevToken.offset - curToken.offset === 1 && prevToken.depth === curToken.depth && prevToken.type === "immediate") {
    return "+ ";
  }
  if (prevToken.offset < curToken.offset && prevToken.depth === curToken.depth) {
    return "~ ";
  }
  if (prevToken.offset !== 0 && prevToken.depth !== curToken.depth) {
    return "~ * ";
  }
  throw new Error(`unmatched condition in add Connector. prevdepth ${prevToken.depth}, prevOffset ${prevToken.offset}, curDept ${curToken.depth}, curOffset ${curToken.offset}`);
}
function formatTokens$1(token, curr) {
  if (token.type.startsWith("attrib") && (token.name.includes(":") || token.name === "xmlns")) {
    throw new Error("got xmlns token");
  } else if (token.type === "pos") {
    let idx = getNthIndex(curr);
    let resp = idx === 1 ? ":first-child" : `:nth-child(${idx})`;
    return resp;
  } else if (token.type === "tag") {
    return cssesc_1(token.name, { isIdentifier: true });
  } else if (token.type === "attrib" && token.name === "class") {
    if (!/[^a-zA-Z0-9\_\-]/.test(token.value) && token.nodeRef.classList.contains(token.value)) {
      return "." + cssesc_1(token.value, { isIdentifier: true });
    }
    return `[${cssesc_1(token.name, { isIdentifier: true })}*='${cssesc_1(token.value, { isIdentifier: true })}']`;
  } else if (token.type === "attrib" && token.name === "id") {
    return "#" + cssesc_1(token.value, { isIdentifier: true });
  } else if (token.type === "attrib") {
    return `[${cssesc_1(token.name, { isIdentifier: true })}='${cssesc_1(token.value, { isIdentifier: true })}']`;
  } else if (token.type === "attribStart") {
    return `[${cssesc_1(token.name, { isIdentifier: true })}^='${cssesc_1(token.value, { isIdentifier: true })}']`;
  } else if (token.type === "attribEnd") {
    return `[${cssesc_1(token.name, { isIdentifier: true })}$='${cssesc_1(token.value, { isIdentifier: true })}']`;
  } else if (token.type === "attribContain") {
    return `[${cssesc_1(token.name, { isIdentifier: true })}*='${cssesc_1(token.value, { isIdentifier: true })}']`;
  } else if (token.type === "attribOnly") {
    return `[${cssesc_1(token.name, { isIdentifier: true })}]`;
  } else if (token.type === "immediate") {
    return "";
  } else {
    throw new Error("the type " + token.type + " is unhandled");
  }
}
function getNthIndex(node) {
  let parent2 = node.parentElement;
  if (parent2) {
    return Array.from(parent2.children).indexOf(node) + 1;
  } else {
    throw new Error("no parent");
  }
}
function removeDanglingTokens$1(tree) {
  let danglingPos = [];
  for (let i = 0; i < tree.tokens.length; i++) {
    if (tree.tokens[i].type === "pos") {
      let badPos = true;
      for (let j = i - 1; j >= 0; j--) {
        if (tree.tokens[j].depth !== tree.tokens[i].depth || tree.tokens[j].offset !== tree.tokens[i].offset) {
          break;
        }
        if (tree.tokens[j].type === "tag") {
          badPos = false;
          break;
        }
      }
      if (badPos) {
        danglingPos.push(tree.tokens[i]);
      }
    }
  }
  for (let pT of danglingPos) {
    tree.removeToken(pT);
  }
  let danglingImd = [];
  for (let i = 0; i < tree.tokens.length; i++) {
    if (tree.tokens[i].type === "immediate") {
      if (i === 0 || i === tree.tokens.length - 1 || tree.tokens[i].depth !== tree.tokens[i - 1].depth || tree.tokens[i].offset !== tree.tokens[i - 1].offset || !(tree.tokens[i + 1].depth - tree.tokens[i].depth === 1 || tree.tokens[i + 1].depth === tree.tokens[i].depth && tree.tokens[i + 1].offset - tree.tokens[i].offset === 1)) {
        danglingImd.push(tree.tokens[i]);
      }
    }
  }
  for (let iT of danglingImd) {
    tree.removeToken(iT);
  }
}
function write$1(...msg) {
  console.log("SELECTORX", ...msg);
}
let excludeTags = ["script", "style", "link", "head", "noscript", "object", "meta"];
let excludeAttribs = [
  "srcdoc",
  "style",
  "onafterprint",
  "onbeforeprint",
  "onbeforeunload",
  "onerror",
  "onhaschange",
  "onload",
  "onmessage",
  "onoffline",
  "onpagehide",
  "onpageshow",
  "onpopstate",
  "onredo",
  "onresize",
  "onstorage",
  "onundo",
  "onunload",
  "onblur",
  "onchange",
  "oncontextmenu",
  "onfocus",
  "onformchange",
  "onforminput",
  "oninput",
  "oninvalid",
  "onreset",
  "onselect",
  "onsubmit",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onclick",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "onmousedown",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onmousewheel",
  "onscroll",
  "onabort",
  "oncanplay",
  "oncanplaythrough",
  "ondurationchange",
  "onemptied",
  "onended",
  "onerror",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onpause",
  "onplay",
  "onplaying",
  "onprogress",
  "onratechange",
  "onreadystatechange",
  "onseeked",
  "onseeking",
  "onstalled",
  "onsuspend",
  "ontimeupdate",
  "onvolumechange",
  "onwaiting"
];
let priorityNames1 = ["a", "li", "h1", "h2", "h3", "h4", "h5", "title"];
let priorityNames2 = [
  "td",
  "tr",
  "table",
  "ul",
  "ol",
  "header",
  "footer",
  "img",
  "label",
  "section"
];
let priorityPos = ["td", "tr", "li", "a"];
let priorityValues1 = ["result", "upvote", "downvote", "price", "product", "rating", "rated"];
let priorityValues2 = ["feature", "vote", "heading", "rate"];
class SelectorNode {
  static addNewToken(type, name, value, depth, offset, nodeRef, tokens, filterCallback2) {
    if (["attrib", "attribContain", "attribStart", "attribEnd", "text"].includes(type) && value && (!Token.isNotRandGen(value) || Token.isUUID(value)))
      return;
    if (typeof filterCallback2 === "undefined" || filterCallback2(type, name, value, depth, offset)) {
      let token = Token.createNew(type, name, value, depth, offset, nodeRef);
      if (!tokens.includes(token))
        tokens.unshift(token);
    }
  }
  static addTextTokens(depth, offset, nodeRef, tokens, coveredNodes, unsatisfied, filterCallback2) {
    let textArr = this.getTextArrFromNode(nodeRef, coveredNodes, unsatisfied);
    textArr = textArr.filter((text2) => !text2.includes("'") && text2.length > 3);
    for (let text2 of textArr) {
      this.addNewToken("text", "text", text2, depth, offset, nodeRef, tokens, filterCallback2);
    }
  }
  static addPartialTokens(name, value, words, depth, offset, nodeRef, onlyContains, tokens, filterCallback2) {
    if (Token.isUUID(value))
      return;
    for (let word of words) {
      let type = "attribContain";
      if (!onlyContains) {
        if (value.indexOf(word) === 0) {
          type = "attribStart";
        } else if (value.indexOf(word) === value.length - word.length) {
          type = "attribEnd";
        }
      }
      this.addNewToken(type, name, word, depth, offset, nodeRef, tokens, filterCallback2);
    }
  }
  static buildTree(targetNode, root, options, unsatisfied, filterCallback2) {
    let coveredNodes = [];
    let tokens = [];
    let maxDepth = this.getMaxDepth(targetNode, root);
    let depth = maxDepth;
    let currentNode = targetNode;
    if (!currentNode.contains(targetNode)) {
      throw new Error("target is not in subtree");
    }
    while (currentNode && root.contains(currentNode)) {
      this.generateTokens(currentNode, options, depth, 0, tokens, coveredNodes, unsatisfied, filterCallback2);
      if (options.siblingNodes) {
        let leftSib = getLeftSibling(currentNode);
        if (leftSib) {
          this.generateTokens(leftSib.node, options, depth, -1, tokens, coveredNodes, unsatisfied, filterCallback2);
          let leftSib2 = getLeftSibling(leftSib.node);
          if (leftSib2) {
            this.generateTokens(leftSib2.node, options, depth, -2, tokens, coveredNodes, unsatisfied, filterCallback2);
          }
        }
      }
      depth -= 1;
      if (currentNode.parentNode) {
        currentNode = currentNode.parentNode;
      }
    }
    return new SelectorNode(targetNode, root, tokens, maxDepth);
  }
  static generateTokens(nodeRef, options, depth, offset, tokens, coveredNodes, unsatisfied, filterCallback2) {
    var _a;
    let element2 = nodeRef;
    this.addNewToken("immediate", null, null, depth, offset, nodeRef, tokens, filterCallback2);
    if (element2.parentElement) {
      this.addNewToken("pos", element2.tagName.toLowerCase(), getNthIndex(nodeRef).toString(), depth, offset, nodeRef, tokens, filterCallback2);
    }
    if (options.text) {
      this.addTextTokens(depth, offset, nodeRef, tokens, coveredNodes, unsatisfied, filterCallback2);
    }
    let attributes = Array.from(element2.attributes).slice(0, MAX_ATTRIBS);
    let classList = ((_a = element2.classList) === null || _a === void 0 ? void 0 : _a.length) > 0 ? Array.from(element2.classList).slice(0, MAX_ATTRIBS) : [];
    for (let { name, value } of attributes) {
      if (name.length > MAX_NAME_LENGTH || name.includes(":") || name.indexOf("xmlns") >= 0 || excludeAttribs.includes(name))
        continue;
      if (value.trim().length > 0) {
        if (name === "class") {
          classList.forEach((className) => this.addNewToken("attrib", name, className, depth, offset, nodeRef, tokens, filterCallback2));
        } else {
          if (value.length <= MAX_VALUE_LENGTH)
            this.addNewToken("attrib", name, value, depth, offset, nodeRef, tokens, filterCallback2);
        }
      }
      if (name !== "id" && name !== "class")
        this.addNewToken("attribOnly", name, null, depth, offset, nodeRef, tokens, filterCallback2);
    }
    if (options.partAttrib) {
      for (let className of classList) {
        let words = getPartialTokenValues(className, { multi: true });
        words = [...new Set(words)];
        this.addPartialTokens("class", className, words, depth, offset, nodeRef, true, tokens, filterCallback2);
      }
      for (let { name, value } of attributes) {
        if (name === "class")
          continue;
        if (name.length > MAX_NAME_LENGTH || name.includes(":") || name.indexOf("xmlns") >= 0 || excludeAttribs.includes(name))
          continue;
        if (value.trim().length > 0) {
          let words = getPartialTokenValues(value, { multi: true });
          words = [...new Set(words)];
          this.addPartialTokens(name, value, words, depth, offset, nodeRef, false, tokens, filterCallback2);
        }
      }
    }
    this.addNewToken("tag", element2.tagName.toLowerCase(), null, depth, offset, nodeRef, tokens, filterCallback2);
  }
  static getMaxDepth(targetNode, root) {
    let depth = 0;
    let currentNode = root;
    while (currentNode !== targetNode) {
      depth += 1;
      for (let child of Array.from(currentNode.childNodes)) {
        if (child.contains(targetNode)) {
          currentNode = child;
          break;
        }
      }
    }
    return depth;
  }
  static getTextArrFromNode(node, coveredNodes, unsatisfied) {
    if (coveredNodes.includes(node)) {
      return [];
    }
    coveredNodes.push(node);
    if (node.nodeType === 3) {
      let wordArr = getWordArr(node.textContent || "");
      if (wordArr.length === 0)
        return [];
      else if (wordArr.length <= 3)
        return [node.textContent.trim()];
      else if (wordArr.length <= 5)
        return wordArr;
      else
        return [];
    } else if (node.nodeType === 1) {
      let wordArr = [];
      for (let child of Array.from(node.childNodes)) {
        if (coveredNodes.includes(child) || unsatisfied.some((u) => child.contains(u)))
          break;
        wordArr = wordArr.concat(this.getTextArrFromNode(child, coveredNodes, unsatisfied));
        if (wordArr.length > MAX_ATTRIBS)
          break;
      }
      return wordArr.slice(0, MAX_ATTRIBS);
    }
    return [];
  }
  addToken(token) {
    if (this.includes(token))
      return;
    this._tokens.push(token);
    this.sortTokens();
  }
  clone(flushTokens = false) {
    let tokens = flushTokens ? [] : this.tokens;
    return new SelectorNode(this.targetNode, this._root, tokens, this.maxDepth);
  }
  constructor(targetNode, root, tokens, maxDepth) {
    this.targetNode = targetNode;
    this._root = root;
    this._tokens = [...tokens];
    this.maxDepth = maxDepth;
  }
  hasSimilarToken(token, isOnlyStem = false) {
    let tokens = this._tokens;
    if (isOnlyStem)
      tokens = tokens.filter((t) => t.offset === 0);
    for (let t of tokens) {
      if (t.equals(token))
        return true;
    }
    return false;
  }
  includes(token, isOnlyStem = false) {
    let tokens = this._tokens;
    if (isOnlyStem)
      tokens = tokens.filter((t) => t.offset === 0);
    for (let t of tokens) {
      if (t.exacts(token))
        return true;
    }
    return false;
  }
  get length() {
    return this._tokens.filter((n) => n.offset === 0).length;
  }
  removeToken(token) {
    let idx = this._tokens.indexOf(token);
    if (idx === -1)
      throw new Error(`token not in current tree: ${token.type}, ${token.name}, ${token.value} `);
    this._tokens.splice(idx, 1);
    return idx;
  }
  sortTokens() {
    this._tokens.sort((t1, t2) => {
      if (t1.depth !== t2.depth)
        return t1.depth - t2.depth;
      else if (t1.offset !== t2.offset)
        return t1.offset - t2.offset;
      else if (t1.internalPriorityNumber != t2.internalPriorityNumber)
        return t1.internalPriorityNumber - t2.internalPriorityNumber;
      else if (t1.name != t2.name)
        return t1.name.localeCompare(t2.name);
      else
        return t1.value.localeCompare(t2.value);
    });
  }
  get tokens() {
    return this._tokens;
  }
}
class Token {
  constructor(type, name, value, depth, offset, nodeRef) {
    this._value = value;
    this._type = type;
    this._name = name;
    this._depth = depth;
    this._offset = offset;
    this.nodeRef = nodeRef;
    this._metrics = null;
    this.internalPriorityNumber = Token.getInternalPriorityNumber(this.type, this.name);
  }
  get depth() {
    return this._depth;
  }
  equals(another) {
    return this.value === another.value && this.type === another.type && this.name === another.name;
  }
  exacts(another) {
    return this.value === another.value && this.type === another.type && this.name === another.name && this.depth === another.depth && this.offset === another.offset;
  }
  getScore(weights) {
    let score = 0;
    let metric;
    for (metric in this.metrics) {
      score += weights[metric] * this.metrics[metric];
    }
    return score;
  }
  get metrics() {
    if (this._metrics)
      return this._metrics;
    else
      throw new Error("metrics not yet updated");
  }
  get name() {
    return this._name || "";
  }
  get offset() {
    return this._offset;
  }
  get type() {
    return this._type;
  }
  get value() {
    return this._value || "";
  }
  updateMetrics(selectorTree, selectorTrees, rejectTrees) {
    let isOnlyStem = this.offset === 0;
    this._metrics = {
      numPaths: selectorTrees.filter((tree) => tree.hasSimilarToken(this, isOnlyStem)).length / selectorTrees.length,
      rightLean: this.depth / selectorTree.maxDepth,
      specificity: Token.getSpecificity(this.type, this.name, this.value),
      isDirectAncestor: this.offset === 0 ? 1 : 0,
      nameCssAttribProb: Token.getCSSAttribProb(this.name),
      valueCssAttribProb: Token.getCSSAttribProb(this.value),
      namePriority: Token.getNamePriority(this.name),
      valuePriority: Token.getValuePriority(this.value),
      rejectPaths: rejectTrees.filter((tree) => tree.hasSimilarToken(this, true)).length / (rejectTrees.length || 1),
      nameContainsNumber: Token.checkIfNameContainsNumber(this.name),
      valueContainsNumber: Token.checkIfContainsNumber(this.value),
      shallowRightLean: Token.getShallowRightLean(this, selectorTree),
      tokensPathsRatio: Token.getTokensPathsRatio(this, selectorTrees),
      numOfSameTokensToRight: Token.getNumOfSameTokensToRight(this, selectorTree),
      valueContainsSpecialChar: /[^a-zA-Z-_\s0-9]/.test(this.value) ? 1 : 0
    };
  }
  static createNew(type, name, value, depth, offset, nodeRef) {
    if (type === "tag") {
      return new TokenTag(type, name, value, depth, offset, nodeRef);
    } else if (type === "pos") {
      return new TokenPos(type, name, value, depth, offset, nodeRef);
    } else if (type === "immediate") {
      return new TokenImmediate(type, name, value, depth, offset, nodeRef);
    } else {
      return new Token(type, name, value, depth, offset, nodeRef);
    }
  }
  static checkIfContainsNumber(value) {
    return value.replace(/\D/g, "").length > 0 ? 1 : 0;
  }
  static checkIfNameContainsNumber(name) {
    let goodTagsList = ["h1", "h2", "h3", "h4", "h5", "h6", "h7"];
    if (goodTagsList.includes(name))
      return 0;
    return Token.checkIfContainsNumber(name);
  }
  static isNotRandGen(value) {
    if (value.length === 0)
      return 1;
    let valueWhiteList = ["txt", "btn"];
    if (/([a-zA-Z]|\b)\d+[a-zA-Z]/.test(value))
      return 0;
    if (/[0-9]{3,}/.test(value))
      return 0;
    let validLen = value.replace(/[^a-zA-Z]/g, "").length;
    if (validLen === 3) {
      if (valueWhiteList.includes(value.toLowerCase()))
        return 1;
      else
        return 0;
    }
    if (validLen < 3)
      return 0;
    let wordArr = getWordArr(value);
    if (wordArr.length === 0)
      return 1;
    let probs = wordArr.map((word) => {
      if (/\b\d{1,2}\b/.test(word)) {
        return 1;
      } else {
        word = word.toLowerCase();
        if (word.length > 2 && !/[aeiouy]/.test(word))
          return 0;
        if (/[^aeiouy]{4,}/.test(word))
          return 0;
        return 1;
      }
    });
    return probs.reduce(toMin);
  }
  static isUUID(value) {
    value = value.toLowerCase();
    if (/[0-9abcdef]{8}-[0-9abcdef]{4}-[0-9abcdef]{4}-[0-9abcdef]{4}-[0-9abcdef]{12}/.test(value)) {
      return 1;
    }
    value = value.replace(/[\-_]/g, "");
    if (value.length === 32 && !/[hijklmnopqrstuvwxyz]/.test(value)) {
      return 1;
    }
    return 0;
  }
  static getCSSAttribProb(value) {
    if (value === "")
      return 0;
    let wordArr = getWordArr(value);
    let scoreArr = wordArr.map((word) => {
      word = word.toLowerCase();
      for (let badWord of cssWords) {
        if (word === badWord)
          return 1;
      }
      return 0;
    });
    return scoreArr.reduce(toMean);
  }
  static getInternalPriorityNumber(type, name) {
    if (type === "tag")
      return 0;
    else if (type === "attrib" && name === "id")
      return 1;
    else if (type === "attrib" && name === "class")
      return 2;
    else if (type === "attrib")
      return 3;
    else if (type === "attribOnly")
      return 4;
    else if (type === "attribStart")
      return 5;
    else if (type === "attribContain")
      return 6;
    else if (type === "attribEnd")
      return 7;
    else if (type === "text")
      return 8;
    else if (type === "pos")
      return 9;
    else if (type === "immediate")
      return 10;
    else
      throw new Error("unhandled case in getInternalPriorityNumber " + type + " " + name + " ");
  }
  static getNamePriority(name) {
    name = name.toLowerCase();
    if (name.startsWith("aria-")) {
      return 1;
    } else if (priorityNames1.includes(name)) {
      return 1;
    } else if (priorityNames2.includes(name)) {
      return 0.7;
    }
    return 0;
  }
  static getNumOfSameTokensToRight(token, tree) {
    let filteredTokens = tree.tokens.filter((t) => {
      return t.equals(token) && (t.depth > token.depth || t.depth === token.depth && t.offset > token.offset);
    });
    return filteredTokens.length;
  }
  static getShallowRightLean(token, selectorTree) {
    let nodeRefs = selectorTree.tokens.filter((t) => t.offset === 0).sort((t1, t2) => t1.depth - t2.depth).map((t) => t.nodeRef);
    let childCountList = [...new Set(nodeRefs)].map((n) => n.childNodes.length);
    let totalShallowDepth = childCountList.slice(0, selectorTree.length).filter((x) => x > 1).length + 1;
    let currentTokenShallowDepth = childCountList.slice(0, token.depth).filter((x) => x > 1).length + 1;
    return currentTokenShallowDepth / totalShallowDepth;
  }
  static getSpecificity(typ, name, value) {
    if (typ === "attrib")
      return 0.8;
    if (typ === "attribStart")
      return 0.75;
    if (typ === "attribEnd")
      return 0.725;
    if (typ === "attribContain")
      return 0.7;
    if (typ === "attribOnly")
      return 0.6;
    if (typ === "text")
      return 0.55;
    if (typ === "tag")
      return 0.5;
    if (typ === "pos")
      return 0.3;
    if (typ === "immediate")
      return 0.2;
    throw new Error(`unknown token: ${typ}, ${name}, ${value}`);
  }
  static getTokensPathsRatio(token, selectorTrees) {
    let count = 0;
    for (let tree of selectorTrees) {
      for (let tkn of tree.tokens.filter((t) => t.offset === 0)) {
        if (tkn.equals(token))
          count++;
      }
    }
    let x = count / selectorTrees.length;
    let a = 3.5;
    return Math.exp(a * (1 - x + Math.log(x)));
  }
  static getValuePriority(value) {
    value = value.toLowerCase();
    if (priorityValues1.some((v) => value.includes(v))) {
      return 1;
    }
    if (priorityValues2.some((v) => value.includes(v))) {
      return 0.5;
    }
    return 0;
  }
  static getVowelRatio(value) {
    value = value.toLowerCase().replace(/[^a-z]/g, "");
    if (value.length === 0)
      return 0;
    let vowels = value.replace(/[^aeiou]/g, "");
    return vowels.length / value.length;
  }
  static printTokens(tokens, weights) {
    let writeArr = [];
    let rank = 1;
    for (let token of tokens) {
      writeArr.push(`${rank++}`);
      writeArr.push(`"${token.value}"-"${token.name}"-"${token.type}"-depth ${token.depth}"-offset ${token.offset}"`);
      writeArr.push(`score: ${token.getScore(weights)}`);
      let metric;
      for (metric in token.metrics) {
        writeArr.push(`${metric} ${token.metrics[metric]}`);
      }
      writeArr.push(`
`);
    }
    write$1(writeArr.join("\n"));
  }
}
Token.separator = "<<<---|||--->>>";
class TokenTag extends Token {
  updateMetrics(selectorTree, selectorTrees, rejectTrees) {
    super.updateMetrics(selectorTree, selectorTrees, rejectTrees);
    if (this._metrics) {
      this._metrics.valueCssAttribProb = 0;
      this._metrics.nameContainsNumber = 0;
      this._metrics.valueContainsNumber = 0;
    }
  }
}
class TokenPos extends Token {
  updateMetrics(selectorTree, selectorTrees, rejectTrees) {
    super.updateMetrics(selectorTree, selectorTrees, rejectTrees);
    if (this._metrics) {
      this._metrics.namePriority = this.getNamePriority();
      this._metrics.valueCssAttribProb = 0;
      this._metrics.nameContainsNumber = 0;
      this._metrics.valueContainsNumber = 0;
    }
  }
  getNamePriority() {
    if (priorityPos.includes(this.name.toLocaleLowerCase())) {
      return 0.65;
    }
    return 0;
  }
}
class TokenImmediate extends Token {
  getScore(weights) {
    if (this._metrics) {
      return super.getScore(weights);
    } else {
      return 0;
    }
  }
  updateMetrics(selectorTree, selectorTrees, rejectTrees) {
    super.updateMetrics(selectorTree, selectorTrees, rejectTrees);
    if (this._metrics) {
      this._metrics.valueCssAttribProb = 0;
      this._metrics.nameContainsNumber = 0;
      this._metrics.valueContainsNumber = 0;
    }
  }
}
function getLeftSibling(node) {
  if (node.parentNode && node.parentNode.children.length > 0) {
    let children = Array.from(node.parentNode.children);
    let node_idx = children.indexOf(node);
    let i = node_idx - 1;
    while (i >= 0) {
      if (!excludeTags.includes(children[i].nodeName.toLowerCase())) {
        return { node: children[i], immediate: node_idx - i === 1 };
      }
      i--;
    }
  }
  return null;
}
function buildQuery(tree) {
  tree = tree.clone();
  removeDanglingTokens(tree);
  if (tree.tokens.length === 0)
    return "//*";
  tree.targetNode.ownerDocument;
  let path = "";
  let curPath = "";
  let addWildTag = false;
  let tokens = tree.tokens;
  for (let i = 0; i < tree.tokens.length; i++) {
    addWildTag = false;
    if (i === 0 || tokens[i].depth !== tokens[i - 1].depth || tokens[i].offset !== tokens[i - 1].offset) {
      curPath = "";
      if (tokens[i].type !== "tag") {
        addWildTag = true;
        curPath += "*";
      }
    }
    let relativeTo = getRelativeTo(tokens, i);
    let tokenString = formatTokens(tokens[i], tokens[i].nodeRef, relativeTo, curPath);
    path += addConnector(tokens[i - 1], tokens[i], path) + (addWildTag ? "*" : "") + tokenString;
    curPath += tokenString;
  }
  if (tree.tokens[tokens.length - 1].offset !== 0)
    path += "/following-sibling::*";
  if (tree.tokens[tree.tokens.length - 1].depth !== tree.maxDepth)
    path += "//*";
  return path;
}
function addConnector(prevToken, curToken, path) {
  if (path === "")
    return "//";
  else if (prevToken.depth === curToken.depth && prevToken.offset === curToken.offset) {
    return "";
  } else if (prevToken.offset === 0 && curToken.depth - prevToken.depth === 1 && prevToken.type === "immediate") {
    return "/";
  } else if (prevToken.offset === 0 && prevToken.depth !== curToken.depth) {
    return "//";
  } else if (prevToken.offset < curToken.offset && prevToken.depth === curToken.depth) {
    return "/following-sibling::";
  } else if (prevToken.offset !== 0 && prevToken.depth !== curToken.depth) {
    return "/following-sibling::*//";
  } else
    throw new Error("unmatched condition");
}
function formatTokens(token, curr, relativeTo, path) {
  if (token.type.startsWith("attrib") && (token.name.includes(":") || token.name === "xmlns")) {
    throw new Error("got xmlns token");
  } else if (token.type === "tag") {
    let tag = token.name.trim();
    return /[^a-zA-Z0-9]/.test(tag) || tag === "svg" ? `*[name()='${tag}']` : tag;
  } else if (token.type === "attrib" && token.name !== "class") {
    return `[@${token.name}=${escapeXpath(token.value)}]`;
  } else if (token.type === "attribStart") {
    return `[starts-with(@${token.name},${escapeXpath(token.value)})]`;
  } else if (token.type === "attribEnd") {
    return `[contains(@${token.name},${escapeXpath(token.value)})]`;
  } else if (token.type === "attribContain" || token.name === "class") {
    return `[contains(@${token.name},${escapeXpath(token.value)})]`;
  } else if (token.type === "attribOnly") {
    return "[boolean(@" + token.name + ")]";
  } else if (token.type === "text") {
    return "[contains(string(),'" + token.value + "')]";
  } else if (token.type === "immediate") {
    return "";
  } else if (token.type === "pos") {
    let idx = getIdxRelativeTo(curr, relativeTo, path);
    if (idx === -1)
      throw new Error('curr element not related to "relativeTo" node');
    return `[${idx + 1}]`;
  } else {
    throw new Error("the token type " + token.type + " is unhandled");
  }
}
function getIdxRelativeTo(curr, relativeTo, path) {
  let prefix = "";
  if (relativeTo.parentNode === curr.parentNode) {
    prefix = "following-sibling::";
  } else if (relativeTo === curr.parentNode) {
    prefix = "child::";
  } else {
    throw new Error("couldnt set context");
  }
  let xpResult = curr.ownerDocument.evaluate(prefix + path, relativeTo, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
  const nodes = [];
  let node = xpResult.iterateNext();
  while (node) {
    nodes.push(node);
    node = xpResult.iterateNext();
  }
  return nodes.indexOf(curr);
}
function escapeXpath(val) {
  let hasSingle = val.includes("'"), hasDouble = val.includes('"');
  if (!hasSingle) {
    return `'${val}'`;
  } else if (!hasDouble) {
    return `"${val}"`;
  } else {
    let strs = val.split("'");
    let start = "concat(";
    let mid = strs.map((s) => "'" + s + "'").join(`, "'" ,`);
    let end = ")";
    return start + mid + end;
  }
}
function getRelativeTo(tokens, I) {
  let curr = tokens[I];
  let linkNode;
  for (let i = I - 1; i >= 0; i--) {
    if (tokens[i].offset !== curr.offset || tokens[i].depth !== curr.depth) {
      linkNode = tokens[i].nodeRef;
      break;
    }
  }
  if (linkNode && linkNode.parentNode === curr.nodeRef.parentNode) {
    return linkNode;
  } else {
    return curr.nodeRef.parentNode;
  }
}
function removeDanglingTokens(tree) {
  let danglingPos = [];
  for (let i = 0; i < tree.tokens.length; i++) {
    if (tree.tokens[i].type === "pos") {
      if (i === 0 || tree.tokens[i - 1].depth !== tree.tokens[i].depth || tree.tokens[i - 1].offset !== tree.tokens[i].offset) {
        danglingPos.push(tree.tokens[i]);
      }
    }
  }
  for (let pT of danglingPos) {
    tree.removeToken(pT);
  }
  let danglingImd = [];
  for (let i = 0; i < tree.tokens.length; i++) {
    if (tree.tokens[i].type === "immediate") {
      if (i === 0 || i === tree.tokens.length - 1 || tree.tokens[i].depth !== tree.tokens[i - 1].depth || tree.tokens[i].offset !== tree.tokens[i - 1].offset || !(tree.tokens[i + 1].depth - tree.tokens[i].depth === 1 || tree.tokens[i + 1].depth === tree.tokens[i].depth && tree.tokens[i + 1].offset - tree.tokens[i].offset === 1)) {
        danglingImd.push(tree.tokens[i]);
      }
    }
  }
  for (let iT of danglingImd) {
    tree.removeToken(iT);
  }
}
function write(...msg) {
  console.log("SELECTORX", ...msg);
}
let coreWeights = {
  numPaths: 8,
  rightLean: 2,
  specificity: 3,
  isDirectAncestor: 2,
  nameCssAttribProb: -4,
  valueCssAttribProb: -4,
  namePriority: 2,
  valuePriority: 1,
  rejectPaths: 0,
  nameContainsNumber: -2,
  valueContainsNumber: -1,
  shallowRightLean: 1,
  tokensPathsRatio: 1,
  numOfSameTokensToRight: -1,
  valueContainsSpecialChar: -2
};
let similarWeights = {
  numPaths: 8,
  rightLean: 0,
  specificity: 1,
  isDirectAncestor: 0,
  nameCssAttribProb: -2,
  valueCssAttribProb: -2,
  namePriority: 0,
  valuePriority: 0,
  rejectPaths: -2,
  nameContainsNumber: 0,
  valueContainsNumber: -1,
  shallowRightLean: 0,
  tokensPathsRatio: 0,
  numOfSameTokensToRight: 0,
  valueContainsSpecialChar: 0
};
class Core {
  constructor(options) {
    this._selected = new XSet();
    this._rejected = new XSet();
    this._doc = document;
    this._root = document.documentElement;
    this._queryCache = /* @__PURE__ */ new Map();
    this._selectorTrees = new XSet();
    this._startTime = 0;
    this.debug = false;
    this._options = options;
    this._tokenOpts = {
      text: true,
      partAttrib: true,
      immediate: true,
      siblingNodes: true,
      selectorType: "CSS"
    };
    this._weights = coreWeights;
    this._unionSeparator = " , ";
    if (options && options.debug)
      this.debug = options.debug;
  }
  isRejection(node) {
    return this._rejected.has(node);
  }
  isSelection(node) {
    return this._selected.has(node);
  }
  get rejected() {
    return [...this._rejected];
  }
  reset() {
    var _a;
    this._selected = new XSet();
    this._rejected = new XSet();
    this._selectorTrees = new XSet();
    if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.root) {
      this._root = this._options.root;
    } else {
      this._root = this._doc.documentElement;
    }
    this._queryCache = /* @__PURE__ */ new Map();
  }
  get selected() {
    return [...this._selected];
  }
  _buildQuery(_2) {
    throw new Error("Method not Implemented");
  }
  _checkTreeValidity(tree) {
    let queried = this._query(tree);
    return queried.length > 0 && queried.has(tree.targetNode);
  }
  async _getOrderedTokens(selectorTrees) {
    let rejectorTrees = this._getSelectorTreeArr(this._rejected);
    let selectorTree = selectorTrees.first;
    let tokens = [...selectorTree.tokens];
    this._updateTokenMetrics(tokens, selectorTrees, rejectorTrees);
    return await this._orderTokens(tokens);
  }
  _getSelectorTreeArr(unsatisfied) {
    if (this._root) {
      return unsatisfied.mapToSet((node) => {
        var _a;
        return SelectorNode.buildTree(node, this._root, this._tokenOpts, unsatisfied.toArray(), (_a = this._options) === null || _a === void 0 ? void 0 : _a.filterCallback);
      });
    } else
      throw new Error("root node not set");
  }
  async _orderTokens(tokens) {
    var _a;
    let tokenSorter = (_a = this._options) === null || _a === void 0 ? void 0 : _a.tokenSorter;
    if (typeof tokenSorter !== "undefined") {
      this.debug && write("token Sorter plugin present");
      tokens = await tokenSorter(tokens);
    } else {
      tokens.sort((t1, t2) => {
        let score1 = t1.getScore(this._weights);
        let score2 = t2.getScore(this._weights);
        if (score1 != score2)
          return score2 - score1;
        else if (t1.type === "text" && t2.type === "text") {
          if (t1.offset != t2.offset)
            return t2.offset - t1.offset;
          return -1;
        } else if (t1.name === t2.name)
          return t2.value.length - t1.value.length;
        else
          return t1.name.length + t1.value.length - (t2.name.length + t2.value.length);
      });
    }
    return tokens;
  }
  async _predict() {
    this._selectorTrees = new XSet();
    let unsatisfied = this._selected.clone();
    let count = 0;
    this._startTime = Date.now();
    while (unsatisfied.length > 0) {
      this._timeout();
      let selectorTree = await this._simplify(unsatisfied);
      let preds = this._query(selectorTree);
      unsatisfied = unsatisfied.difference(preds);
      if (unsatisfied.length > 0) {
        selectorTree = await this._simplify(preds);
        preds = this._query(selectorTree);
      }
      this._selectorTrees.add(selectorTree);
      count += 1;
      if (count > this._selected.length)
        throw new Error("stuck in loop");
    }
    return this._selectorTrees.map((tree) => this._buildQuery(tree)).join(this._unionSeparator);
  }
  _query(selectorTree) {
    let selector = this._buildQuery(selectorTree);
    if (!this._queryCache.has(selector)) {
      this._queryCache.set(selector, this._querySelectorAll(selector));
    }
    return this._queryCache.get(selector);
  }
  _querySelectorAll(_2) {
    throw new Error("method not implemented");
  }
  _removeBadTokens(selectorTree) {
    let tree = selectorTree.clone();
    let tokens = tree.tokens;
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i].type === "pos" && (i === 0 || tokens[i - 1].depth !== tokens[i].depth || tokens[i - 1].offset !== tokens[i].offset)) {
        tokens.splice(i, 1);
      }
    }
    for (let i = 0; i < tokens.length; i++) {
      if (tokens[i].type === "immediate" && (i === 0 || tokens[i - 1].depth !== tokens[i].depth || tokens[i - 1].offset !== tokens[i].offset)) {
        tokens.splice(i, 1);
      }
    }
    return tree;
  }
  async _simplify(_2) {
    throw new Error("method not implemented");
  }
  _timeout() {
    var _a, _b;
    if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.timeout) && Date.now() - this._startTime > this._options.timeout) {
      this.reset();
      throw new Error(`Time limit exceeded, took more than ${(_b = this._options) === null || _b === void 0 ? void 0 : _b.timeout}ms to generate selectors`);
    }
  }
  _updateTokenMetrics(tokens, selectorTrees, rejectorTrees) {
    for (let token of tokens) {
      token.updateMetrics(selectorTrees.first, selectorTrees.toArray(), rejectorTrees.toArray());
    }
  }
  _updateRoot() {
    var _a;
    if (this.selected.length === 0)
      return;
    this._queryCache = /* @__PURE__ */ new Map();
    this._doc = this._selected.first.ownerDocument;
    if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.root) {
      this._root = this._options.root;
      if (this._root.ownerDocument !== this._doc) {
        throw new Error("root node does not belong to the same document");
      }
    } else {
      this._root = this._doc.documentElement;
    }
    for (let node of this._selected) {
      if (node.ownerDocument !== this._doc)
        throw new Error("elements do not belong to the same document");
    }
    for (let node of this._rejected) {
      if (node.ownerDocument !== this._doc)
        throw new Error("elements do not belong to the same document");
    }
  }
}
class Get extends Core {
  constructor(selected, options) {
    super(options);
    this._selected = new XSet(selected);
    this._updateRoot();
  }
  _checkConvergence(selectorTree, lastQueried, unsatisfied) {
    let queried = this._query(selectorTree);
    if (!this._checkTreeValidity(selectorTree)) {
      console.log("tree", [...selectorTree.tokens]);
      console.log("query", this._buildQuery(selectorTree));
      throw new Error("not a valid tree was built");
    }
    if (queried.isEqualTo(unsatisfied))
      return 2;
    if (queried.isSubsetOf(unsatisfied))
      return 3;
    if (queried.isSubsetOf(lastQueried) && !queried.isEqualTo(lastQueried))
      return 1;
    return 0;
  }
  _addToken(selectorTree, token, unsatisfied) {
    let tree = selectorTree.clone();
    let lastQueried = this._query(tree);
    tree.addToken(token);
    let convergence = this._checkConvergence(tree, lastQueried, unsatisfied);
    return { convergence, tree };
  }
  _shakeTree(tree, tokenBuildOrder) {
    let queried = this._query(tree);
    let tokens = tokenBuildOrder.filter((token) => tree.tokens.includes(token));
    tokens = tokens.reverse();
    for (let token of tokens) {
      this.debug && console.log("removing", token.type, token.name, token.value, token.depth, token.offset);
      tree.removeToken(token);
      let newQueried = this._query(tree);
      if (!newQueried.isSubsetOf(this._selected) || !newQueried.has(tree.targetNode) || !queried.isSubsetOf(newQueried)) {
        this.debug && console.log("added back");
        tree.addToken(token);
      } else {
        this.debug && console.log("query", this._buildQuery(tree));
      }
    }
  }
  async _simplify(unsatisfied) {
    this.debug && console.log("number of unsatisified", unsatisfied.length);
    let selectorTrees = this._getSelectorTreeArr(unsatisfied);
    let tokenBuildOrder = await this._getOrderedTokens(selectorTrees);
    if (!this._checkTreeValidity(selectorTrees.first) || !(this._query(selectorTrees.first).length === 1)) {
      this.reset();
      throw new Error("not a valid tree was built " + this._buildQuery(selectorTrees.first));
    }
    let selectorTree = selectorTrees.first.clone(true);
    this.debug && Token.printTokens(tokenBuildOrder, this._weights);
    let convergence = 0;
    for (let token of tokenBuildOrder) {
      this._timeout();
      this.debug && console.log(token.type, token.name, token.value, token.depth, token.offset);
      let status = this._addToken(selectorTree, token, unsatisfied);
      selectorTree = status.tree;
      convergence = status.convergence;
      this.debug && console.log("status", status.convergence, "selector", this._buildQuery(selectorTree));
      if (convergence >= 2)
        break;
    }
    this.debug && console.log("after loop", this._buildQuery(selectorTree));
    this._shakeTree(selectorTree, tokenBuildOrder);
    this.debug && console.log("after shake tree", this._buildQuery(selectorTree));
    return selectorTree;
  }
}
class GetCSS extends Get {
  constructor(selected, options) {
    super(selected, options);
    this._tokenOpts.text = false;
    this._unionSeparator = " , ";
  }
  _buildQuery(selectorTree) {
    selectorTree = this._removeBadTokens(selectorTree);
    return buildQuery$1(selectorTree);
  }
  _querySelectorAll(selector) {
    if (!selector)
      return new XSet();
    if (!this._doc)
      throw new Error("document not set");
    if (!this._root) {
      throw new Error("root node not set");
    }
    return new XSet(Array.from(this._root.querySelectorAll(selector)));
  }
}
async function getCSS$1(selected, options) {
  if (selected.length === 1 && !selected[0].parentElement) {
    return ":root";
  }
  return await new GetCSS(selected, options)._predict();
}
class GetXPATH extends Get {
  constructor(selected, options) {
    super(selected, options);
    this._tokenOpts.selectorType = "XPATH";
    this._tokenOpts.text = (options === null || options === void 0 ? void 0 : options.useText) || false;
    this._unionSeparator = " | ";
  }
  _buildQuery(selectorTree) {
    selectorTree = this._removeBadTokens(selectorTree);
    return buildQuery(selectorTree);
  }
  _querySelectorAll(selector) {
    let queried = new XSet();
    if (!this._doc)
      throw new Error("document not set");
    if (selector && selector.trim().length > 0) {
      const contextNode = this._root || this._doc;
      let iterator = this._doc.evaluate(selector, contextNode, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
      try {
        let thisNode = iterator.iterateNext();
        while (thisNode) {
          queried.add(thisNode);
          thisNode = iterator.iterateNext();
        }
      } catch (e) {
        throw new Error("Document tree modified during iteration" + e);
      }
    }
    return queried;
  }
}
async function getXPATH$1(selected, options) {
  return await new GetXPATH(selected, options)._predict();
}
async function getXpath(selected, options) {
  console.warn("Deprecated: getXpath is deprecated and will be discontinued from 1-Jan-2023, please use getXPATH");
  return await getXPATH$1(selected, options);
}
class Similar extends Core {
  constructor(options) {
    super();
    this._latestAction = Similar.NO_ACTION;
    this._similar = new XSet();
    this._tokenOpts.partAttrib = false;
    this._tokenOpts.text = false;
    this._tokenOpts.siblingNodes = false;
    this._weights = similarWeights;
    if (options && options.debug)
      this.debug = options.debug;
  }
  async addRejection(node) {
    await this._add(node, this._rejected, this._selected, Similar.ADDED_REJECTION);
  }
  async addSelection(node) {
    await this._add(node, this._selected, this._rejected, Similar.ADDED_SELECTION);
  }
  async removeRejection(node) {
    await this._remove(node, this._rejected, Similar.REMOVED_REJECTION);
  }
  async removeSelection(node) {
    await this._remove(node, this._selected, Similar.REMOVED_SELECTION);
  }
  async update() {
    this._updateRoot();
    if (this._selected.length === 0)
      throw new Error("empty list of selected");
    await this._predict();
    let preds = XSet.flatten(this._selectorTrees.mapToSet((tree) => this._query(tree)));
    this._similar = preds.difference(this._selected);
  }
  get similar() {
    return [...this._similar];
  }
  isSimilar(node) {
    return this._similar.has(node);
  }
  reset() {
    super.reset();
    this._rejected = new XSet();
    this._similar = new XSet();
    this._latestAction = Similar.NO_ACTION;
  }
  async set(targArr) {
    let target = new XSet(targArr);
    this.reset();
    let match = false;
    let pending = target.clone();
    while (pending.length > 0) {
      let node = pending.first;
      await this.addSelection(node);
      let rejectables = this._similar.difference(target);
      while (rejectables.length > 0) {
        await this.addRejection(rejectables.first);
        rejectables = this._similar.difference(target);
      }
      let preds = this.selected.concat(this.similar);
      pending = target.filter((node2) => !preds.includes(node2));
      if (pending.length === 0 && rejectables.length === 0) {
        match = true;
        break;
      }
    }
    if (!match)
      throw new Error("could not create a set of selection and rejection for the given list of elements");
  }
  async _add(node, addList, remList, status) {
    if (addList.length > 0 && this._doc != node.ownerDocument) {
      throw new Error("element not part of document");
    }
    if (remList.length > 0 && this._doc != node.ownerDocument) {
      throw new Error("element not part of document");
    }
    if (remList.has(node)) {
      remList.delete(node);
    }
    if (!addList.has(node)) {
      addList.add(node);
      this._latestAction = status;
      await this.update();
    }
  }
  get _additionalUnsatisfied() {
    let lastSimilar = this._latestAction === Similar.ADDED_SELECTION ? this._similar : new XSet();
    let queriedSoFar = XSet.flatten(this._selectorTrees.mapToSet((tree) => this._query(tree)));
    return lastSimilar.difference(queriedSoFar);
  }
  _buildQuery(selectorTree) {
    selectorTree = this._removeBadTokens(selectorTree);
    return buildQuery$1(selectorTree);
  }
  _isCoveringExtra(queried, lastQueried, unsatisfied) {
    let covered = queried.intersection(unsatisfied);
    let extra = covered.difference(lastQueried);
    return extra.size > 0;
  }
  _isDesiredSimplification(tree, unsatisfied, lastQueried) {
    let alreadyCovered = this._selected.difference(unsatisfied);
    let queried = this._query(tree);
    return this._checkTreeValidity(tree) && !queried.intersects(alreadyCovered) && !queried.intersects(this._rejected) && (this._unAffectingDiscard(queried, lastQueried) || this._isCoveringExtra(queried, lastQueried, unsatisfied));
  }
  _isDoneSimplifying(queried, unsatisfied) {
    return unsatisfied.isSubsetOf(queried);
  }
  _querySelectorAll(selector) {
    if (!selector)
      return new XSet();
    let queried = Array.from(this._root.querySelectorAll(selector));
    return new XSet(queried);
  }
  async _remove(node, remList, status) {
    if (remList.length > 0 && this._doc != node.ownerDocument) {
      throw new Error("element not part of document");
    }
    if (remList.has(node)) {
      remList.delete(node);
      this._latestAction = status;
      await this.update();
    }
  }
  async _simplify(unsatisfied) {
    unsatisfied = unsatisfied.union(this._additionalUnsatisfied);
    let selectorTrees = this._getSelectorTreeArr(unsatisfied);
    let discardOrder = (await this._getOrderedTokens(selectorTrees)).reverse();
    this.debug && Token.printTokens(discardOrder, this._weights);
    if (!this._checkTreeValidity(selectorTrees.first) || !(this._query(selectorTrees.first).length === 1)) {
      this.reset();
      throw new Error("not a valid tree was built " + this._buildQuery(selectorTrees.first));
    }
    let selectorTree = selectorTrees.first.clone();
    let lastQueried = this._query(selectorTree);
    for (let discardable of discardOrder) {
      this._timeout();
      selectorTree.removeToken(discardable);
      if (this._isDesiredSimplification(selectorTree, unsatisfied, lastQueried)) {
        lastQueried = this._query(selectorTree);
      } else {
        selectorTree.addToken(discardable);
      }
      if (this._isDoneSimplifying(lastQueried, unsatisfied))
        break;
    }
    return selectorTree;
  }
  _unAffectingDiscard(queried, lastQueried) {
    return lastQueried.isEqualTo(queried);
  }
  _updateRoot() {
    super._updateRoot();
    let updated = true;
    while (updated) {
      updated = false;
      for (let child of Array.from(this._root.childNodes)) {
        if (this.selected.every((node) => child.contains(node)) && this.selected.every((node) => node != child)) {
          this._root = child;
          updated = true;
        }
      }
    }
  }
}
Similar.ADDED_SELECTION = 1;
Similar.REMOVED_SELECTION = 2;
Similar.ADDED_REJECTION = 3;
Similar.REMOVED_REJECTION = 4;
Similar.NO_ACTION = 0;
class Selector$1 {
  constructor(value, meta = {}) {
    this.value = value;
    this.meta = meta;
  }
  toJSON() {
    return {
      type: this.getType(),
      meta: this.meta,
      value: this.value
    };
  }
}
class CSSSelector extends Selector$1 {
  select(doc) {
    return Promise.resolve([...doc.querySelectorAll(this.value)]);
  }
  getType() {
    return "css";
  }
}
class XPathSelector extends Selector$1 {
  constructor() {
    super(...arguments);
    this.document = document;
  }
  select(doc) {
    let resultSet = document.evaluate(this.value, doc, null, XPathResult.ANY_TYPE, null);
    let aResult = resultSet.iterateNext(), results = [];
    while (aResult && aResult.nodeType === document.ELEMENT_NODE) {
      results.push(aResult);
      aResult = resultSet.iterateNext();
    }
    return Promise.resolve(results);
  }
  setDocument(doc) {
    this.document = doc;
  }
  getType() {
    return "xpath";
  }
}
function isLocatorExpression(expr) {
  return expr instanceof Struct$2 && expr.name === "selector" || expr instanceof Enum$2 && expr.name === "tag";
}
const KEY_FV_DATA$1 = "bbx:fr:overlay";
class PageOverlay extends PageOverlayBase {
  constructor(page, options = {}) {
    super();
    this.active = false;
    this.onFrameNavigated = (_event, fv) => {
      this.removeFrameOverlay(fv);
    };
    this.onFrameReady = (_event, fv) => {
      if (!this.active)
        return;
      let oldOverlay = fv.getData(KEY_FV_DATA$1);
      if (oldOverlay) {
        this.removeFrameOverlay(fv);
      }
      let frameOverlay = this.createFrameOverlay(fv, this.getEl(fv));
      fv.setData(KEY_FV_DATA$1, frameOverlay);
    };
    this.page = page;
    this.options = options;
  }
  afterInit(fv) {
    fv.on("document", this.onFrameReady);
    fv.on("navigated", this.onFrameNavigated);
    if (fv.isDocReady()) {
      this.onFrameReady(null, fv);
    }
  }
  afterViewCreated(fv) {
    let { stylesheet } = this.options;
    let root = fv.getMetaEl().shadowRoot;
    if (root && stylesheet) {
      let link = document.createElement("link");
      link.setAttribute("rel", "stylesheet");
      link.setAttribute("href", stylesheet);
      root.appendChild(link);
    }
  }
  afterUninit(fv) {
    fv.off("document_ready", this.onFrameReady);
    this.removeFrameOverlay(fv);
  }
  removeFrameOverlay(fv) {
    let frameOverlay = fv.getData(KEY_FV_DATA$1);
    if (frameOverlay) {
      frameOverlay.uninit();
      fv.delData(KEY_FV_DATA$1);
    }
  }
  setActive(active) {
    if (active !== this.active) {
      this.active = active;
      active ? this.page.addOverlay(this) : this.page.removeOverlay(this);
      this.emit("active", this.active);
    }
  }
}
function getPath(child, root = child.ownerDocument.documentElement, pathArr = []) {
  let parent2 = child.parentElement;
  if (parent2 === null || root == child) {
    pathArr.reverse();
    return pathArr;
  }
  let childList = parent2.childNodes;
  let index = 0;
  for (let i = 0; i < childList.length; ++i) {
    if (childList[i] === child) {
      index = i;
      break;
    }
  }
  pathArr.push(index);
  return getPath(parent2, root, pathArr);
}
function isAfter(lPath, rPath) {
  let lLen = lPath.length, rLen = rPath.length;
  for (let x = 0, len = Math.min(lLen, rLen); x < len; x += 1) {
    let lI = lPath[x];
    let rI = rPath[x];
    if (lI == rI) {
      continue;
    }
    return lI > rI;
  }
  return lLen > rLen;
}
class TargetBase extends EventEmitter$1 {
  constructor(el) {
    super();
    this._path = null;
    this.el = el;
    this.addListeners();
  }
  addListeners() {
    let io = new IntersectionObserver((_entries) => {
      this.emit("change");
    });
    io.observe(this.el);
    if (typeof ResizeObserver != "undefined") {
      let ro = new ResizeObserver((_entries) => {
        this.emit("change");
      });
      ro.observe(this.el);
    }
  }
  create(_overlay) {
  }
  destroy(_overlay) {
  }
  get() {
    return this.el;
  }
  _getPath() {
    if (!this._path) {
      this._path = getPath(this.el);
    }
    return this._path;
  }
  isAfter(rTarget) {
    return isAfter(this._getPath(), rTarget._getPath());
  }
  setActive(_active) {
  }
  setEl(el) {
    this.el = el;
    this.emit("change");
  }
  update(_rect, _overlay) {
  }
}
class FrameOverlayBase extends EventEmitter$1 {
  constructor(fv, el) {
    super();
    this.hoverTarget = null;
    this._qRender = true;
    this._lastAnimId = 0;
    this.fv = fv;
    this.doc = fv.getDoc();
    fv.pause();
    let win = this.doc.defaultView;
    if (win == null) {
      throw new Error("Invalid state - window not found");
    }
    this.win = win;
    this.el = el;
    this.targets = [];
    this.listeners = this.createListeners();
    this.render = this.render.bind(this);
    this.init().then();
  }
  isMeta(el) {
    let meta = this.fv.getMetaEl();
    return meta == el || meta.contains(el);
  }
  createListeners() {
    let win = this.win;
    if (win == null) {
      throw new Error("Unknown window");
    }
    return {
      click: (e) => this._onClick(e),
      pointerdown: (e) => this._onMouseDown(e),
      pointerover: (e) => this._onMouseOver(e),
      pointerout: (e) => this._onMouseOut(e),
      pointerup: (e) => this._onMouseUp(e),
      resize: [win, (e) => this._onResize(e)],
      scroll: [win, (e) => this._onScroll(e)]
    };
  }
  addListeners() {
    let doc = this.fv.getDoc();
    for (let name in this.listeners) {
      let listenerData = this.listeners[name];
      if (typeof listenerData == "function") {
        doc.addEventListener(name, listenerData, true);
      } else {
        listenerData[0].addEventListener(name, listenerData[1], true);
      }
    }
  }
  removeListeners() {
    let doc = this.fv.getDoc();
    for (let name in this.listeners) {
      let listenerData = this.listeners[name];
      if (typeof listenerData == "function") {
        doc == null ? void 0 : doc.removeEventListener(name, listenerData, true);
      } else {
        listenerData[0].removeEventListener(name, listenerData[1], true);
      }
    }
  }
  async init() {
    this.addListeners();
  }
  uninit() {
    this.fv.resume();
    this.removeListeners();
  }
  _onClick(e) {
    if (this.isMeta(e.target))
      return;
    e.preventDefault();
    e.stopPropagation();
  }
  _onMouseDown(e) {
    if (this.isMeta(e.target))
      return;
    e.preventDefault();
    e.stopPropagation();
    this.setHoverTarget(null);
  }
  _onMouseOver(e) {
    if (this.isMeta(e.target))
      return;
    let el = e.target;
    this.onHover(el, this._getEventData(el));
  }
  _onMouseOut(e) {
    if (this.isMeta(e.target))
      return;
    if (e.relatedTarget == null) {
      this.setHoverTarget(null);
    }
  }
  _onMouseUp(e) {
    if (this.isMeta(e.target))
      return;
    let el = e.target;
    if (e.pageX >= el.getBoundingClientRect().right)
      return;
    this.onClick(el, this._getEventData(el));
  }
  _onResize(_2) {
    this.render();
  }
  _onScroll(_2) {
    this.render();
  }
  _getEventData(el) {
    let parents = [];
    let children = [];
    let target;
    for (let aTarget of this.targets) {
      let anEl = aTarget.get();
      if (anEl == el) {
        target = aTarget;
      } else if (anEl.contains(el)) {
        parents.push(aTarget);
      } else if (el.contains(anEl)) {
        children.push(aTarget);
      }
    }
    if (!target && parents.length > 0) {
      target = parents[parents.length - 1];
    }
    return {
      target,
      parents,
      children
    };
  }
  setHoverTarget(target, meta = {}) {
    if (target == null) {
      this.hoverTarget = null;
    } else {
      this.hoverTarget = [target, meta];
    }
    this.render();
  }
  addTarget(target) {
    let targets = this.targets;
    let insertAt2 = this.targets.length;
    for (let i = 0, len = targets.length; i < len; i += 1) {
      let aTarget = targets[i];
      if (aTarget.isAfter(target)) {
        insertAt2 = i;
        break;
      }
    }
    this.targets.splice(insertAt2, 0, target);
    target.create(this);
    this.render();
    target.on("change", this.render);
  }
  clearTargets() {
    this.targets.forEach((t) => t.destroy(this));
    this.targets = [];
    this.reset();
  }
  removeTarget(target) {
    target.destroy(this);
    this.targets = this.targets.filter((t) => t !== target);
    this.render();
  }
  removeTargetBy(fn) {
    this.targets = this.targets.filter((target) => !fn(target));
    this.render();
  }
  render() {
    if (this._qRender) {
      cancelAnimationFrame(this._lastAnimId);
      this._lastAnimId = requestAnimationFrame(() => {
        this._qRender = false;
        this.render();
      });
      return;
    }
    this.reset();
    this.targets.forEach((target) => {
      this.renderTarget(target);
    });
    if (this.hoverTarget) {
      this.renderHoverTarget(...this.hoverTarget);
    }
    this._qRender = true;
  }
}
function getRect(el) {
  let { x, y, width, height } = el.getBoundingClientRect();
  if (width == 0 && height == 0) {
    let { previousElementSibling, parentElement } = el;
    if (previousElementSibling) {
      let r2 = getRect(previousElementSibling);
      x = r2.x;
      y = r2.y + r2.height;
      width = r2.width;
    } else if (parentElement) {
      let r2 = getRect(parentElement);
      x = r2.x;
      y = r2.y;
      width = r2.width;
    }
  }
  return { x, y, width, height };
}
class CanvasFrameOverlay extends FrameOverlayBase {
  constructor(fv, el) {
    super(fv, el);
    this.canvas = this.createCanvas(fv.getDoc());
    let ctx = this.canvas.getContext("2d");
    if (ctx == null)
      throw new Error("Invalid state - context is null");
    this.ctx = ctx;
    el.appendChild(this.canvas);
  }
  createCanvas(doc) {
    let canvas = doc.createElement("canvas");
    Object.assign(canvas.style, this.getCanvasStyles());
    return canvas;
  }
  renderHoverTarget(target, meta) {
    let { ctx } = this;
    let { x, y, width, height } = getRect(target);
    let x1 = x + 0.5;
    let y1 = y + 0.5;
    let x2 = x + width - 0.5;
    let y2 = y + height - 0.5;
    let hoverStyles = this.getHoverStyles(target, meta);
    ctx.fillStyle = hoverStyles.fillStyle;
    ctx.fillRect(x, y, width, height);
    ctx.setLineDash([5, 3]);
    ctx.beginPath();
    ctx.strokeStyle = hoverStyles.strokeStyle;
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y1);
    ctx.moveTo(x1, y2);
    ctx.lineTo(x2, y2);
    ctx.moveTo(x1, y1);
    ctx.lineTo(x1, y2);
    ctx.moveTo(x2, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.closePath();
    ctx.setLineDash([]);
  }
  renderTarget(target) {
    let rect = getRect(target.get());
    let { ctx } = this;
    let styles = this.getTargetStyles(target);
    Object.assign(ctx, styles);
    ctx.clearRect(rect.x, rect.y, rect.width, rect.height);
    ctx.strokeRect(rect.x + 0.5, rect.y + 0.5, rect.width - 0.5, rect.height - 0.5);
    if (styles.fillStyle) {
      ctx.fillStyle = styles.fillStyle;
      ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
    }
    target.update(rect, this);
  }
  reset() {
    this.resetCanvasSize();
    let { ctx } = this;
    ctx.clearRect(0, 0, this.win.innerWidth, this.win.innerHeight);
    Object.assign(ctx, this.getOverlayStyles());
    ctx.fillRect(0, 0, this.win.innerWidth, this.win.innerHeight);
  }
  getCanvasStyles() {
    return {
      pointerEvents: "none",
      position: "fixed",
      left: 0,
      top: 0,
      width: "100vw",
      height: "100vh",
      zIndex: 999999
    };
  }
  getHoverStyles(_target, _meta) {
    return {
      fillStyle: "rgba(0, 100, 255, .1)",
      strokeStyle: "rgba(0, 0, 250, .5)",
      lineWidth: 1
    };
  }
  getOverlayStyles() {
    return {
      fillStyle: "rgba(0, 0, 0, .2)"
    };
  }
  getTargetStyles(_target) {
    return {
      strokeStyle: "rgba(40, 120, 220, 1)",
      lineWidth: 1
    };
  }
  resetCanvasSize() {
    this.canvas.setAttribute("width", this.win.innerWidth + "");
    this.canvas.setAttribute("height", this.win.innerHeight + "");
  }
  uninit() {
    super.uninit();
    this.canvas.remove();
  }
}
async function select(selector, doc, rootNode = document) {
  let selectorObj = selectorBuilder(selector, rootNode);
  return selectorObj.select(doc);
}
const filterCallback = (_type, name, value) => {
  return !(["href", "src", "srcset", "hasinclude__", "include__"].includes(name) && (value == null ? void 0 : value.length) < 30);
};
function getCSS(targetEls, root) {
  return getCSS$1(targetEls, {
    root,
    timeout: 500,
    filterCallback
  });
}
function getXPATH(targetEls, root) {
  return getXPATH$1(targetEls, {
    timeout: 500,
    filterCallback
  });
}
function selectorBuilder(selector, doc = document) {
  switch (selector.type) {
    case "css":
      return new CSSSelector(selector.value, selector.meta);
    case "xpath":
      const xpathSelector = new XPathSelector(selector.value, selector.meta);
      xpathSelector.setDocument(doc);
      return new XPathSelector(selector.value, selector.meta);
    default:
      throw new Error("Unknown selector type: " + selector.type);
  }
}
const KEY_FV_DATA = "bbx:fr:overlay";
class Target extends TargetBase {
  constructor(el, _overlay) {
    super(el);
    this.active = false;
  }
  setActive(active) {
    if (this.active != active) {
      this.active = active;
      this.emit("change");
    }
  }
}
class PickerFrameOverlay extends CanvasFrameOverlay {
  constructor(fv, el, frameIndex, selector) {
    super(fv, el);
    this.selector = selector;
    this.frameIndex = frameIndex;
    this.updateTargets();
    this.onClick = this.onClick.bind(this);
  }
  updateTargets() {
    this.clearTargets();
    this.setTargets();
  }
  async setTargets() {
    if (!this.selector)
      return;
    let els = await this.selector.select(this.fv.getDoc());
    els.forEach((el) => {
      let target = new Target(el, this);
      if (el == this.currentElement) {
        this.setCurrentTarget(target);
      }
      this.addTarget(target);
    });
  }
  removeCurrentTarget() {
    if (this.currentTarget) {
      this.currentTarget.setActive(false);
    }
  }
  setCurrentTarget(target) {
    this.currentTarget = target;
    target.setActive(true);
  }
  async onClick(el) {
    let type = this.selector.getType();
    let constructor = type === "css" ? CSSSelector : XPathSelector;
    let getSelector = type === "css" ? getCSS : getXPATH;
    this.selector = new constructor(await getSelector([el]));
    this.updateTargets();
    this.emit("change", { selector: this.selector, frameIndex: this.frameIndex });
  }
  onHover(el, { target }) {
    this.currentElement = el;
    if (target && target.get() == el) {
      this.setHoverTarget(null);
    } else {
      this.setHoverTarget(el);
    }
    this.removeCurrentTarget();
    if (target) {
      this.setCurrentTarget(target);
    }
  }
  getTargetStyles(target) {
    let styles = super.getTargetStyles(target);
    if (target.active) {
      styles.lineWidth = 2;
    }
    return styles;
  }
}
class PickerPageOverlay extends PageOverlay {
  constructor(page, selector, selectorFrameIndex = 0) {
    super(page);
    this.onChange = ({ selector: selector2, frameIndex }) => {
      this.selector = selector2;
      this.emit("change", { selector: selector2.toJSON(), frameIndex });
    };
    this.onClose = () => {
      this.setActive(false);
    };
    this.selector = selector;
    this.selectorFrameIndex = selectorFrameIndex;
  }
  createFrameOverlay(fv, el) {
    let index = fv.store.getIndex();
    let pickerFrameOverlay;
    if (index === this.selectorFrameIndex) {
      pickerFrameOverlay = new PickerFrameOverlay(fv, el, index, this.selector);
    } else {
      pickerFrameOverlay = new PickerFrameOverlay(fv, el, index);
    }
    pickerFrameOverlay.on("change", this.onChange);
    pickerFrameOverlay.on("close", this.onClose);
    return pickerFrameOverlay;
  }
  afterUninit(fv) {
    let frameOverlay = fv.getData(KEY_FV_DATA);
    if (frameOverlay) {
      frameOverlay.off("change", this.onChange);
      frameOverlay.off("close", this.onClose);
    }
    super.afterUninit(fv);
  }
}
function create_default_slot_1$j(ctx) {
  let tick_1;
  let current;
  tick_1 = new Tick({ props: { strokeColor: "blue" } });
  return {
    c() {
      create_component(tick_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tick_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tick_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tick_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tick_1, detaching);
    }
  };
}
function create_default_slot$v(ctx) {
  let cross;
  let current;
  cross = new Cross$1({ props: { strokeColor: "red" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_fragment$12(ctx) {
  let div2;
  let select2;
  let option0;
  let option1;
  let t2;
  let input;
  let t3;
  let div0;
  let iconbtn0;
  let t4;
  let div1;
  let iconbtn1;
  let current;
  let mounted;
  let dispose;
  iconbtn0 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot_1$j] },
      $$scope: { ctx }
    }
  });
  iconbtn0.$on("click", ctx[3]);
  iconbtn1 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot$v] },
      $$scope: { ctx }
    }
  });
  iconbtn1.$on("click", ctx[7]);
  return {
    c() {
      div2 = element("div");
      select2 = element("select");
      option0 = element("option");
      option0.textContent = "CSS";
      option1 = element("option");
      option1.textContent = "XPath";
      t2 = space();
      input = element("input");
      t3 = space();
      div0 = element("div");
      create_component(iconbtn0.$$.fragment);
      t4 = space();
      div1 = element("div");
      create_component(iconbtn1.$$.fragment);
      option0.__value = "css";
      option0.value = option0.__value;
      option1.__value = "xpath";
      option1.value = option1.__value;
      attr(select2, "class", "bbx-flex-grow");
      attr(input, "type", "text");
      input.value = ctx[0];
      set_style(input, "width", "100%");
      attr(div0, "class", "bbx-icon-container");
      attr(div1, "class", "bbx-icon-container");
      attr(div2, "class", "bbx-flex bbx-center bbx-pad bbx-gap bbx-rounded bbx-shadow");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, select2);
      append(select2, option0);
      append(select2, option1);
      select_option(select2, ctx[1]);
      append(div2, t2);
      append(div2, input);
      append(div2, t3);
      append(div2, div0);
      mount_component(iconbtn0, div0, null);
      append(div2, t4);
      append(div2, div1);
      mount_component(iconbtn1, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(select2, "change", ctx[5]),
          listen(input, "input", ctx[4]),
          action_destroyer(keypressEscape.call(null, div2)),
          listen(div2, "escape", ctx[8]),
          action_destroyer(keypressEnter.call(null, div2)),
          listen(div2, "enter", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 2) {
        select_option(select2, ctx2[1]);
      }
      if (!current || dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
      const iconbtn0_changes = {};
      if (dirty & 16384) {
        iconbtn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn0.$set(iconbtn0_changes);
      const iconbtn1_changes = {};
      if (dirty & 16384) {
        iconbtn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn1.$set(iconbtn1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbtn0.$$.fragment, local);
      transition_in(iconbtn1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbtn0.$$.fragment, local);
      transition_out(iconbtn1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(iconbtn0);
      destroy_component(iconbtn1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$12($$self, $$props, $$invalidate) {
  const browserView = getContext("browserView");
  const dispatch = createEventDispatcher();
  let { value } = $$props;
  let { type } = $$props;
  let { frame } = $$props;
  let pickerOverlay;
  function showPickerOverlay(value2, type2) {
    destroyPickerOverlay();
    if (browserView) {
      let pageView = browserView.getPage(-1);
      pickerOverlay = new PickerPageOverlay(pageView, selectorBuilder({ value: value2, type: type2 }), frame);
      pickerOverlay.on("change", changeSelector);
      pickerOverlay.setActive(true);
    }
  }
  function destroyPickerOverlay() {
    pickerOverlay == null ? void 0 : pickerOverlay.off("change", changeSelector);
    pickerOverlay == null ? void 0 : pickerOverlay.setActive(false);
    pickerOverlay = null;
  }
  function changeSelector(e) {
    $$invalidate(0, value = e.selector.value);
    $$invalidate(1, type = e.selector.type);
    $$invalidate(6, frame = e.frameIndex);
  }
  function save() {
    dispatch("save", { value, type, frame });
  }
  function updateValue(e) {
    $$invalidate(0, value = e.target.value);
    showPickerOverlay(value, type);
  }
  async function updateType(e) {
    if (e.target.value === type)
      return;
    if (browserView) {
      let selector = selectorBuilder({ value, type });
      let pv = browserView.getPage(-1);
      let fv = pv.getFrame(pv.store.frames[frame].id);
      let els = await selector.select(fv.getDoc());
      if (e.target.value === "css") {
        $$invalidate(0, value = els.length > 0 ? await getCSS(els) : "#enter-your-selector-here");
      } else if (e.target.value === "xpath") {
        $$invalidate(0, value = els.length > 0 ? await getXPATH(els) : "//enter-your-selector-here");
      }
    } else {
      $$invalidate(0, value = e.target.value === "xpath" ? "//enter-your-selector-here" : "#enter-your-selector-here");
    }
    $$invalidate(1, type = e.target.value);
    showPickerOverlay(value, type);
  }
  showPickerOverlay(value, type);
  onDestroy(() => {
    destroyPickerOverlay();
  });
  const click_handler2 = () => dispatch("cancel");
  const escape_handler = () => dispatch("cancel");
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("frame" in $$props2)
      $$invalidate(6, frame = $$props2.frame);
  };
  return [
    value,
    type,
    dispatch,
    save,
    updateValue,
    updateType,
    frame,
    click_handler2,
    escape_handler
  ];
}
class Selector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$12, create_fragment$12, safe_not_equal, { value: 0, type: 1, frame: 6 });
  }
}
function create_else_block_1$3(ctx) {
  let span;
  let t_value = getSummary(ctx[7]) + "";
  let t;
  let tooltip_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
      if (!mounted) {
        dispose = action_destroyer(tooltip_action = tooltip.call(null, span, ctx[1]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 128 && t_value !== (t_value = getSummary(ctx2[7]) + ""))
        set_data(t, t_value);
      if (tooltip_action && is_function(tooltip_action.update) && dirty & 2)
        tooltip_action.update.call(null, ctx2[1]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$v(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$g, create_else_block$h];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$h(ctx) {
  let span;
  let t_value = getSummary(ctx[7]) + "";
  let t;
  let tooltip_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "bbx-inline-editable");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
      if (!mounted) {
        dispose = [
          action_destroyer(tooltip_action = tooltip.call(null, span, ctx[1])),
          listen(span, "mouseenter", ctx[11]),
          listen(span, "mouseleave", ctx[12]),
          listen(span, "click", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 128 && t_value !== (t_value = getSummary(ctx2[7]) + ""))
        set_data(t, t_value);
      if (tooltip_action && is_function(tooltip_action.update) && dirty & 2)
        tooltip_action.update.call(null, ctx2[1]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$g(ctx) {
  let editselector;
  let current;
  editselector = new Selector({
    props: {
      value: ctx[5],
      type: ctx[6],
      frame: ctx[4]
    }
  });
  editselector.$on("save", ctx[9]);
  editselector.$on("cancel", ctx[10]);
  return {
    c() {
      create_component(editselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editselector_changes = {};
      if (dirty & 32)
        editselector_changes.value = ctx2[5];
      if (dirty & 64)
        editselector_changes.type = ctx2[6];
      if (dirty & 16)
        editselector_changes.frame = ctx2[4];
      editselector.$set(editselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editselector, detaching);
    }
  };
}
function create_fragment$11(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$v, create_else_block_1$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 129)
      show_if = null;
    if (show_if == null)
      show_if = !!(ctx2[7].name === "selector" && ctx2[0].fields.get("value") instanceof Literal$3);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$11($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(7, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node } = $$props;
  $$subscribe_node();
  let { label } = $$props;
  let editMode = false;
  let hovering = false;
  let editFrame, editSelectorValue, editSelectorType;
  function getFrameIndex$1(parentNode) {
    if (parentNode instanceof FunctionCall$2)
      return getFrameIndex(parentNode);
    return 0;
  }
  function setEditMode() {
    $$invalidate(4, editFrame = getFrameIndex$1($node.parent));
    $$invalidate(5, editSelectorValue = $node.get("value").value);
    $$invalidate(6, editSelectorType = $node.get("type").value);
    $$invalidate(2, editMode = true);
  }
  function setFrame$1(parentNode, frame) {
    if (parentNode instanceof FunctionCall$2)
      setFrame(parentNode, frame);
  }
  function updateSelector({ detail }) {
    setFrame$1($node.parent, detail.frame);
    $node.parent.replace($node, [
      "selector",
      {
        value: detail.value,
        type: detail.type,
        meta: {}
      }
    ]);
    $$invalidate(2, editMode = false);
  }
  const cancel_handler = () => $$invalidate(2, editMode = false);
  const mouseenter_handler = () => $$invalidate(3, hovering = true);
  const mouseleave_handler = () => $$invalidate(3, hovering = false);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  return [
    node,
    label,
    editMode,
    hovering,
    editFrame,
    editSelectorValue,
    editSelectorType,
    $node,
    setEditMode,
    updateSelector,
    cancel_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
class Struct$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$11, create_fragment$11, safe_not_equal, { node: 0, label: 1 });
  }
}
function autofocus(node) {
  setTimeout(() => {
    node.focus();
  }, 10);
}
function create_if_block$u(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[0]);
      attr(div, "class", "invalid-tooltip");
      attr(div, "style", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
      if (dirty & 2) {
        attr(div, "style", ctx2[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$10(ctx) {
  let if_block_anchor;
  let if_block = ctx[0] && create_if_block$u(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$u(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$10($$self, $$props, $$invalidate) {
  let validationStyle;
  let { message } = $$props;
  let { rect } = $$props;
  $$self.$$set = ($$props2) => {
    if ("message" in $$props2)
      $$invalidate(0, message = $$props2.message);
    if ("rect" in $$props2)
      $$invalidate(2, rect = $$props2.rect);
  };
  $$self.$$.update = () => {
    var _a, _b;
    if ($$self.$$.dirty & 4) {
      $$invalidate(1, validationStyle = `display: inline-block; top: ${(_a = rect == null ? void 0 : rect.top) != null ? _a : 0}px; left: ${(_b = rect == null ? void 0 : rect.left) != null ? _b : 0}px;`);
    }
  };
  return [message, validationStyle, rect];
}
class ValidationTooltip extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$10, create_fragment$10, safe_not_equal, { message: 0, rect: 2 });
  }
}
function create_fragment$$(ctx) {
  let li;
  let a;
  let a_href_value;
  let a_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let a_levels = [
    { href: a_href_value = "#" },
    {
      class: a_class_value = "dropdown-item " + ctx[0]
    },
    { role: "menuitem" },
    { tabindex: "-1" },
    ctx[1]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[4]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { href: a_href_value },
        (!current || dirty & 1 && a_class_value !== (a_class_value = "dropdown-item " + ctx2[0])) && { class: a_class_value },
        { role: "menuitem" },
        { tabindex: "-1" },
        dirty & 2 && ctx2[1]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$$($$self, $$props, $$invalidate) {
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: clazz = "dropdown-item" } = $$props;
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, clazz = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  return [clazz, $$restProps, $$scope, slots, click_handler2];
}
class MenuItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$$, create_fragment$$, safe_not_equal, { class: 0 });
  }
}
function clickOutside(node) {
  const handleClick = (event) => {
    if (!node.contains(event.target)) {
      node.dispatchEvent(new CustomEvent("outclick"));
    }
  };
  document.addEventListener("click", handleClick, true);
  return {
    destroy() {
      document.removeEventListener("click", handleClick, true);
    }
  };
}
const get_top_slot_changes$1 = (dirty) => ({});
const get_top_slot_context$1 = (ctx) => ({});
const get_action_slot_changes = (dirty) => ({});
const get_action_slot_context = (ctx) => ({ onClick: ctx[12] });
const get_label_post_slot_changes$2 = (dirty) => ({});
const get_label_post_slot_context$2 = (ctx) => ({});
const get_label_slot_changes$3 = (dirty) => ({});
const get_label_slot_context$3 = (ctx) => ({});
const get_label_pre_slot_changes$1 = (dirty) => ({});
const get_label_pre_slot_context$1 = (ctx) => ({});
const get_icon_slot_changes$1 = (dirty) => ({});
const get_icon_slot_context$1 = (ctx) => ({});
function create_else_block$g(ctx) {
  let current;
  const action_slot_template = ctx[22].action;
  const action_slot = create_slot(action_slot_template, ctx, ctx[21], get_action_slot_context);
  return {
    c() {
      if (action_slot)
        action_slot.c();
    },
    m(target, anchor) {
      if (action_slot) {
        action_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (action_slot) {
        if (action_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(action_slot_template, ctx2[21], dirty, get_action_slot_changes),
            get_action_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(action_slot, local);
      current = true;
    },
    o(local) {
      transition_out(action_slot, local);
      current = false;
    },
    d(detaching) {
      if (action_slot)
        action_slot.d(detaching);
    }
  };
}
function create_if_block_1$f(ctx) {
  let a;
  let t0;
  let t1;
  let t2;
  let a_class_value;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = ctx[22].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[21], get_icon_slot_context$1);
  const label_pre_slot_template = ctx[22]["label-pre"];
  const label_pre_slot = create_slot(label_pre_slot_template, ctx, ctx[21], get_label_pre_slot_context$1);
  const label_slot_template = ctx[22].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[21], get_label_slot_context$3);
  const label_slot_or_fallback = label_slot || fallback_block$1(ctx);
  const label_post_slot_template = ctx[22]["label-post"];
  const label_post_slot = create_slot(label_post_slot_template, ctx, ctx[21], get_label_post_slot_context$2);
  let a_levels = [
    { href: "#" },
    {
      class: a_class_value = "gap-2 " + ctx[2]
    },
    ctx[15]
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  return {
    c() {
      a = element("a");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      if (label_pre_slot)
        label_pre_slot.c();
      t1 = space();
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      t2 = space();
      if (label_post_slot)
        label_post_slot.c();
      set_attributes(a, a_data);
      toggle_class(a, "show", ctx[0]);
      toggle_class(a, "dropdown-toggle", ctx[8]);
      toggle_class(a, "disabled", ctx[7]);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (icon_slot) {
        icon_slot.m(a, null);
      }
      append(a, t0);
      if (label_pre_slot) {
        label_pre_slot.m(a, null);
      }
      append(a, t1);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(a, null);
      }
      append(a, t2);
      if (label_post_slot) {
        label_post_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[12]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(icon_slot_template, ctx2[21], dirty, get_icon_slot_changes$1),
            get_icon_slot_context$1
          );
        }
      }
      if (label_pre_slot) {
        if (label_pre_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            label_pre_slot,
            label_pre_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(label_pre_slot_template, ctx2[21], dirty, get_label_pre_slot_changes$1),
            get_label_pre_slot_context$1
          );
        }
      }
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(label_slot_template, ctx2[21], dirty, get_label_slot_changes$3),
            get_label_slot_context$3
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & 2048)) {
          label_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (label_post_slot) {
        if (label_post_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            label_post_slot,
            label_post_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(label_post_slot_template, ctx2[21], dirty, get_label_post_slot_changes$2),
            get_label_post_slot_context$2
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        { href: "#" },
        (!current || dirty & 4 && a_class_value !== (a_class_value = "gap-2 " + ctx2[2])) && { class: a_class_value },
        dirty & 32768 && ctx2[15]
      ]));
      toggle_class(a, "show", ctx2[0]);
      toggle_class(a, "dropdown-toggle", ctx2[8]);
      toggle_class(a, "disabled", ctx2[7]);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(label_pre_slot, local);
      transition_in(label_slot_or_fallback, local);
      transition_in(label_post_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(label_pre_slot, local);
      transition_out(label_slot_or_fallback, local);
      transition_out(label_post_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (icon_slot)
        icon_slot.d(detaching);
      if (label_pre_slot)
        label_pre_slot.d(detaching);
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
      if (label_post_slot)
        label_post_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function fallback_block$1(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[11]);
      attr(span, "class", "flex-1");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2048)
        set_data(t, ctx2[11]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block$t(ctx) {
  let t;
  let current;
  const top_slot_template = ctx[22].top;
  const top_slot = create_slot(top_slot_template, ctx, ctx[21], get_top_slot_context$1);
  const default_slot_template = ctx[22].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
  return {
    c() {
      if (top_slot)
        top_slot.c();
      t = space();
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (top_slot) {
        top_slot.m(target, anchor);
      }
      insert(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (top_slot) {
        if (top_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            top_slot,
            top_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(top_slot_template, ctx2[21], dirty, get_top_slot_changes$1),
            get_top_slot_context$1
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(top_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(top_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (top_slot)
        top_slot.d(detaching);
      if (detaching)
        detach(t);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$_(ctx) {
  let div1;
  let current_block_type_index;
  let if_block0;
  let t0;
  let div0;
  let t1;
  let ul;
  let ul_class_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$f, create_else_block$g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[14].action)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[0] && create_if_block$t(ctx);
  return {
    c() {
      div1 = element("div");
      if_block0.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      ul = element("ul");
      if (if_block1)
        if_block1.c();
      set_style(div0, "position", "absolute");
      set_style(div0, "inset", "0");
      set_style(div0, "pointer-events", "none");
      attr(ul, "class", ul_class_value = "dropdown-menu min-w-[200px] " + ctx[3]);
      attr(ul, "style", ctx[4]);
      toggle_class(ul, "d-none", !ctx[0]);
      attr(div1, "class", div1_class_value = "dropdown " + ctx[9]);
      attr(div1, "style", ctx[1]);
      attr(div1, "title", ctx[6]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if_blocks[current_block_type_index].m(div1, null);
      append(div1, t0);
      append(div1, div0);
      ctx[23](div0);
      append(div1, t1);
      append(div1, ul);
      if (if_block1)
        if_block1.m(ul, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(ul, "click", ctx[24]),
          action_destroyer(clickOutside.call(null, div1)),
          action_destroyer(keypressEscape.call(null, div1)),
          listen(div1, "escape", ctx[13]),
          listen(div1, "outclick", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div1, t0);
      }
      if (ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$t(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(ul, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & 8 && ul_class_value !== (ul_class_value = "dropdown-menu min-w-[200px] " + ctx2[3])) {
        attr(ul, "class", ul_class_value);
      }
      if (!current || dirty & 16) {
        attr(ul, "style", ctx2[4]);
      }
      if (!current || dirty & 9) {
        toggle_class(ul, "d-none", !ctx2[0]);
      }
      if (!current || dirty & 512 && div1_class_value !== (div1_class_value = "dropdown " + ctx2[9])) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & 2) {
        attr(div1, "style", ctx2[1]);
      }
      if (!current || dirty & 64) {
        attr(div1, "title", ctx2[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      ctx[23](null);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$_($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "id",
    "items",
    "style",
    "actionClass",
    "dropDownClass",
    "dropDownStyle",
    "toggle",
    "title",
    "defaultActionLabel",
    "disabled",
    "showToggleButton",
    "show",
    "placement",
    "strategy",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { id = null } = $$props;
  let { items = [] } = $$props;
  let { style = "height: min-content" } = $$props;
  let { actionClass = "" } = $$props;
  let { dropDownClass = "" } = $$props;
  let { dropDownStyle = "" } = $$props;
  let { toggle = true } = $$props;
  let { title = "" } = $$props;
  let { defaultActionLabel = "<None>" } = $$props;
  let { disabled = false } = $$props;
  let { showToggleButton = false } = $$props;
  let { show = false } = $$props;
  let { placement = "bottom-end" } = $$props;
  let { strategy = "fixed" } = $$props;
  let { class: clazz = "" } = $$props;
  let actionEl;
  let dd;
  let dispatch = createEventDispatcher();
  let selectedItem;
  selectedItem = getSelectedItem();
  let label;
  onMount(() => {
    dd = new bootstrap.Dropdown(
      actionEl,
      {
        popperConfig: (defaultBsConfig) => {
          if (placement) {
            return { ...defaultBsConfig, placement, strategy };
          }
          return defaultBsConfig;
        }
      }
    );
    return () => {
      dd.dispose();
    };
  });
  function getLabel() {
    return !id ? defaultActionLabel : (selectedItem == null ? void 0 : selectedItem.name) || "<NA>";
  }
  function getSelectedItem() {
    let item = items == null ? void 0 : items.find((item2) => item2.id === id);
    if (item) {
      return item;
    }
    if (id && (selectedItem == null ? void 0 : selectedItem.id) == id) {
      return selectedItem;
    }
  }
  function onClick() {
    if (disabled) {
      $$invalidate(0, show = false);
      dd.hide();
      return;
    }
    $$invalidate(0, show = !show);
    if (show) {
      dd.show();
    } else {
      dd.hide();
    }
    dispatch(show ? "open" : "close");
  }
  function close2() {
    if (!show)
      return;
    dd.hide();
    $$invalidate(0, show = false);
    dispatch("close");
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      actionEl = $$value;
      $$invalidate(10, actionEl);
    });
  }
  const click_handler2 = () => toggle && close2();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(16, id = $$new_props.id);
    if ("items" in $$new_props)
      $$invalidate(17, items = $$new_props.items);
    if ("style" in $$new_props)
      $$invalidate(1, style = $$new_props.style);
    if ("actionClass" in $$new_props)
      $$invalidate(2, actionClass = $$new_props.actionClass);
    if ("dropDownClass" in $$new_props)
      $$invalidate(3, dropDownClass = $$new_props.dropDownClass);
    if ("dropDownStyle" in $$new_props)
      $$invalidate(4, dropDownStyle = $$new_props.dropDownStyle);
    if ("toggle" in $$new_props)
      $$invalidate(5, toggle = $$new_props.toggle);
    if ("title" in $$new_props)
      $$invalidate(6, title = $$new_props.title);
    if ("defaultActionLabel" in $$new_props)
      $$invalidate(18, defaultActionLabel = $$new_props.defaultActionLabel);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("showToggleButton" in $$new_props)
      $$invalidate(8, showToggleButton = $$new_props.showToggleButton);
    if ("show" in $$new_props)
      $$invalidate(0, show = $$new_props.show);
    if ("placement" in $$new_props)
      $$invalidate(19, placement = $$new_props.placement);
    if ("strategy" in $$new_props)
      $$invalidate(20, strategy = $$new_props.strategy);
    if ("class" in $$new_props)
      $$invalidate(9, clazz = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 196608) {
      selectedItem = getSelectedItem();
    }
    if ($$self.$$.dirty & 458752) {
      $$invalidate(11, label = getLabel());
    }
  };
  return [
    show,
    style,
    actionClass,
    dropDownClass,
    dropDownStyle,
    toggle,
    title,
    disabled,
    showToggleButton,
    clazz,
    actionEl,
    label,
    onClick,
    close2,
    $$slots,
    $$restProps,
    id,
    items,
    defaultActionLabel,
    placement,
    strategy,
    $$scope,
    slots,
    div0_binding,
    click_handler2
  ];
}
class Menu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$_, create_fragment$_, safe_not_equal, {
      id: 16,
      items: 17,
      style: 1,
      actionClass: 2,
      dropDownClass: 3,
      dropDownStyle: 4,
      toggle: 5,
      title: 6,
      defaultActionLabel: 18,
      disabled: 7,
      showToggleButton: 8,
      show: 0,
      placement: 19,
      strategy: 20,
      class: 9
    });
  }
}
const { Map: Map_1 } = globals;
function get_each_context$a(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  child_ctx[25] = i;
  return child_ctx;
}
const get_label_pre_slot_changes = (dirty) => ({});
const get_label_pre_slot_context = (ctx) => ({ slot: "label-pre" });
const get_label_post_slot_changes$1 = (dirty) => ({});
const get_label_post_slot_context$1 = (ctx) => ({ slot: "label-post" });
function create_default_slot_2$9(ctx) {
  let t_value = ctx[3].get(ctx[23]) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 24 && t_value !== (t_value = ctx2[3].get(ctx2[23]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$a(key_1, ctx) {
  let first;
  let menuitem;
  let current;
  function click_handler_1() {
    return ctx[18](ctx[23]);
  }
  menuitem = new MenuItem({
    props: {
      class: ctx[25] === ctx[7] ? "active" : "",
      $$slots: { default: [create_default_slot_2$9] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", click_handler_1);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(menuitem.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 144)
        menuitem_changes.class = ctx[25] === ctx[7] ? "active" : "";
      if (dirty & 4194328) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(menuitem, detaching);
    }
  };
}
function create_if_block_1$e(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      class: "active",
      $$slots: { default: [create_default_slot_1$i] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[19]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 4194368) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_1$i(ctx) {
  let t0;
  let t1;
  return {
    c() {
      t0 = text("Add new: ");
      t1 = text(ctx[6]);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 64)
        set_data(t1, ctx2[6]);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot$u(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let t;
  let current;
  let each_value = ctx[4];
  const get_key = (ctx2) => ctx2[23];
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$a(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
  }
  let if_block = ctx[0] && ctx[6].length > 0 && ctx[4].length === 0 && create_if_block_1$e(ctx);
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      set_style(div, "max-height", "400px");
      set_style(div, "overflow", "auto");
      attr(div, "class", "list-group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2200) {
        each_value = ctx2[4];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$a, t, get_each_context$a);
        check_outros();
      }
      if (ctx2[0] && ctx2[6].length > 0 && ctx2[4].length === 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 81) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$e(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_label_pre_slot(ctx) {
  let current;
  const label_pre_slot_template = ctx[16]["label-pre"];
  const label_pre_slot = create_slot(label_pre_slot_template, ctx, ctx[22], get_label_pre_slot_context);
  return {
    c() {
      if (label_pre_slot)
        label_pre_slot.c();
    },
    m(target, anchor) {
      if (label_pre_slot) {
        label_pre_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_pre_slot) {
        if (label_pre_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            label_pre_slot,
            label_pre_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(label_pre_slot_template, ctx2[22], dirty, get_label_pre_slot_changes),
            get_label_pre_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_pre_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_pre_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_pre_slot)
        label_pre_slot.d(detaching);
    }
  };
}
function create_label_post_slot$4(ctx) {
  let current;
  const label_post_slot_template = ctx[16]["label-post"];
  const label_post_slot = create_slot(label_post_slot_template, ctx, ctx[22], get_label_post_slot_context$1);
  return {
    c() {
      if (label_post_slot)
        label_post_slot.c();
    },
    m(target, anchor) {
      if (label_post_slot) {
        label_post_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_post_slot) {
        if (label_post_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            label_post_slot,
            label_post_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(label_post_slot_template, ctx2[22], dirty, get_label_post_slot_changes$1),
            get_label_post_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_post_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_post_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_post_slot)
        label_post_slot.d(detaching);
    }
  };
}
function create_top_slot$2(ctx) {
  let div;
  let input;
  let input_placeholder_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "class", "form-control form-control-sm");
      input.value = ctx[6];
      attr(input, "placeholder", input_placeholder_value = "replace '" + ctx[2] + "' with ...");
      set_style(div, "padding-left", "var(--bbx-gap)");
      set_style(div, "padding-right", "var(--bbx-gap)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      ctx[17](input);
      if (!mounted) {
        dispose = [
          action_destroyer(autofocus.call(null, input)),
          listen(input, "keydown", ctx[10]),
          listen(input, "input", ctx[12]),
          listen(input, "click", click_handler)
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 64 && input.value !== ctx2[6]) {
        input.value = ctx2[6];
      }
      if (dirty & 4 && input_placeholder_value !== (input_placeholder_value = "replace '" + ctx2[2] + "' with ...")) {
        attr(input, "placeholder", input_placeholder_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$s(ctx) {
  let validationtooltip;
  let current;
  validationtooltip = new ValidationTooltip({
    props: { message: ctx[1] }
  });
  return {
    c() {
      create_component(validationtooltip.$$.fragment);
    },
    m(target, anchor) {
      mount_component(validationtooltip, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const validationtooltip_changes = {};
      if (dirty & 2)
        validationtooltip_changes.message = ctx2[1];
      validationtooltip.$set(validationtooltip_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(validationtooltip.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(validationtooltip.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(validationtooltip, detaching);
    }
  };
}
function create_fragment$Z(ctx) {
  let menu;
  let t;
  let if_block_anchor;
  let current;
  const menu_spread_levels = [ctx[13]];
  let menu_props = {
    $$slots: {
      top: [create_top_slot$2],
      "label-post": [create_label_post_slot$4],
      "label-pre": [create_label_pre_slot],
      default: [create_default_slot$u]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < menu_spread_levels.length; i += 1) {
    menu_props = assign(menu_props, menu_spread_levels[i]);
  }
  menu = new Menu({ props: menu_props });
  menu.$on("open", ctx[20]);
  menu.$on("escape", ctx[21]);
  let if_block = ctx[1] && create_if_block$s(ctx);
  return {
    c() {
      create_component(menu.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = dirty & 8192 ? get_spread_update(menu_spread_levels, [get_spread_object(ctx2[13])]) : {};
      if (dirty & 4194557) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$s(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
const click_handler = (e) => e.stopPropagation();
function instance$Z($$self, $$props, $$invalidate) {
  const omit_props_names = ["addNew", "options", "labels", "validationMessage", "value"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  let { addNew = false } = $$props;
  let { options } = $$props;
  let { labels = void 0 } = $$props;
  let { validationMessage = void 0 } = $$props;
  let { value } = $$props;
  labels = labels != null ? labels : [...options];
  let labelByOption = /* @__PURE__ */ new Map();
  options.forEach((option, i) => labelByOption.set(option, labels[i]));
  let filteredOptions = [...options];
  let inputComponent;
  let inputValue = "";
  let selectedIndex = -1;
  function createOption(value2) {
    dispatch("create", value2);
  }
  function handleKeyPress(e) {
    if (e.key === "Enter" && filteredOptions.length > 0) {
      dispatch("select", filteredOptions[selectedIndex]);
    } else if (e.keyCode === 38 || e.shiftKey && e.keyCode === 9) {
      e.preventDefault();
      if (selectedIndex === -1) {
        $$invalidate(7, selectedIndex = filteredOptions.length - 1);
      } else {
        $$invalidate(7, selectedIndex = Math.max(selectedIndex - 1, 0));
      }
    } else if (e.keyCode === 40 || e.keyCode === 9) {
      e.preventDefault();
      $$invalidate(7, selectedIndex = Math.min(selectedIndex + 1, filteredOptions.length - 1));
    } else if (e.keyCode === 27) {
      dispatch("cancel");
    }
  }
  function selectOption(option) {
    dispatch("select", option);
  }
  function updateEditValue(e) {
    $$invalidate(6, inputValue = e.target.value);
    $$invalidate(4, filteredOptions = options.filter((option) => {
      var _a;
      return (_a = labelByOption.get(option)) == null ? void 0 : _a.toLowerCase().includes(inputValue == null ? void 0 : inputValue.toLowerCase());
    }));
    $$invalidate(7, selectedIndex = inputValue.length > 0 ? 0 : -1);
  }
  onMount(() => {
    inputComponent == null ? void 0 : inputComponent.focus();
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputComponent = $$value;
      $$invalidate(5, inputComponent);
    });
  }
  const click_handler_1 = (option) => selectOption(option);
  const click_handler_2 = () => createOption(inputValue);
  function open_handler(event) {
    bubble.call(this, $$self, event);
  }
  const escape_handler = () => dispatch("cancel");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("addNew" in $$new_props)
      $$invalidate(0, addNew = $$new_props.addNew);
    if ("options" in $$new_props)
      $$invalidate(15, options = $$new_props.options);
    if ("labels" in $$new_props)
      $$invalidate(14, labels = $$new_props.labels);
    if ("validationMessage" in $$new_props)
      $$invalidate(1, validationMessage = $$new_props.validationMessage);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 49160) {
      {
        $$invalidate(4, filteredOptions = [...options]);
        if (!labels || labels.length !== options.length) {
          $$invalidate(14, labels = [...options]);
        }
        $$invalidate(3, labelByOption = /* @__PURE__ */ new Map());
        options.forEach((option, i) => labelByOption.set(option, labels[i]));
      }
    }
  };
  return [
    addNew,
    validationMessage,
    value,
    labelByOption,
    filteredOptions,
    inputComponent,
    inputValue,
    selectedIndex,
    dispatch,
    createOption,
    handleKeyPress,
    selectOption,
    updateEditValue,
    $$restProps,
    labels,
    options,
    slots,
    input_binding,
    click_handler_1,
    click_handler_2,
    open_handler,
    escape_handler,
    $$scope
  ];
}
class SearchSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
      addNew: 0,
      options: 15,
      labels: 14,
      validationMessage: 1,
      value: 2
    });
  }
}
function create_fragment$Y(ctx) {
  let svg;
  let g;
  let path;
  let g_transform_value;
  let svg_style_value;
  let svg_levels = [
    { class: ctx[4] },
    { fill: ctx[0] },
    { "stroke-width": ctx[1] },
    {
      style: svg_style_value = "width: " + ctx[2] + "; height: " + ctx[2] + ";"
    },
    { viewBox: "0 0 24 24" },
    { xmlns: "http://www.w3.org/2000/svg" },
    ctx[5]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      path = svg_element("path");
      attr(path, "d", "m4.8 21.57 2.422 2.43 11.978-12-11.978-12-2.422 2.43 9.547 9.57z");
      attr(g, "transform", g_transform_value = ctx[3] ? transform : "");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 8 && g_transform_value !== (g_transform_value = ctx2[3] ? transform : "")) {
        attr(g, "transform", g_transform_value);
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & 16 && { class: ctx2[4] },
        dirty & 1 && { fill: ctx2[0] },
        dirty & 2 && { "stroke-width": ctx2[1] },
        dirty & 4 && svg_style_value !== (svg_style_value = "width: " + ctx2[2] + "; height: " + ctx2[2] + ";") && { style: svg_style_value },
        { viewBox: "0 0 24 24" },
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & 32 && ctx2[5]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
let transform = "rotate(180 12 12)";
function instance$Y($$self, $$props, $$invalidate) {
  const omit_props_names = ["strokeColor", "strokeWidth", "size", "flip", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { strokeColor = "#000000" } = $$props;
  let { strokeWidth = 4 } = $$props;
  let { size = "8px" } = $$props;
  let { flip = false } = $$props;
  let { class: clazz = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("strokeColor" in $$new_props)
      $$invalidate(0, strokeColor = $$new_props.strokeColor);
    if ("strokeWidth" in $$new_props)
      $$invalidate(1, strokeWidth = $$new_props.strokeWidth);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("flip" in $$new_props)
      $$invalidate(3, flip = $$new_props.flip);
    if ("class" in $$new_props)
      $$invalidate(4, clazz = $$new_props.class);
  };
  return [strokeColor, strokeWidth, size, flip, clazz, $$restProps];
}
class AngleRight extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {
      strokeColor: 0,
      strokeWidth: 1,
      size: 2,
      flip: 3,
      class: 4
    });
  }
}
function create_label_post_slot$3(ctx) {
  let angleright;
  let current;
  angleright = new AngleRight({
    props: {
      class: "bbx-rotate-90",
      size: "8",
      strokeColor: "#999"
    }
  });
  return {
    c() {
      create_component(angleright.$$.fragment);
    },
    m(target, anchor) {
      mount_component(angleright, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(angleright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(angleright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(angleright, detaching);
    }
  };
}
function create_fragment$X(ctx) {
  let searchselect;
  let current;
  searchselect = new SearchSelect({
    props: {
      dropDownStyle: "font-size: 0.7rem;",
      style: "width: fit-content;",
      value: getSummary(ctx[0]),
      actionClass: "bbx-step__header bbx-flex bbx-align-center bbx-h-1 bbx-gap bbx-not-link",
      defaultActionLabel: getSummary(ctx[0]),
      options: Object.keys(ctx[1]),
      $$slots: { "label-post": [create_label_post_slot$3] },
      $$scope: { ctx }
    }
  });
  searchselect.$on("open", ctx[4]);
  searchselect.$on("select", ctx[3]);
  return {
    c() {
      create_component(searchselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchselect, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchselect_changes = {};
      if (dirty & 1)
        searchselect_changes.value = getSummary(ctx2[0]);
      if (dirty & 1)
        searchselect_changes.defaultActionLabel = getSummary(ctx2[0]);
      if (dirty & 2)
        searchselect_changes.options = Object.keys(ctx2[1]);
      if (dirty & 512) {
        searchselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      searchselect.$set(searchselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchselect, detaching);
    }
  };
}
function instance$X($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(5, $node = $$value)), node);
  let $tagList;
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node } = $$props;
  $$subscribe_node();
  const ctx = getContext("expressionCtx");
  const mode = getContext("mode");
  const tagList = getContext("tagList");
  component_subscribe($$self, tagList, (value) => $$invalidate(6, $tagList = value));
  let matchingAccessors = [];
  function replaceExpression({ detail }) {
    let expression = matchingAccessors[detail];
    if (mode === "workflow" && node.scope.hasFunc(detail) && Object.values(node.scope.getFunc(detail).args).some((argDef) => argDef.types.includes("tag"))) {
      let defaultTag = getDefaultTag($node, $tagList);
      expression = getDefaultWorkflowStep(defaultTag, detail);
    }
    $node.parent.replace($node, expression);
  }
  function onOpen() {
    $$invalidate(1, matchingAccessors = getMatchingAccessors(node, [node.returnType], ctx.replace));
  }
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
  };
  return [node, matchingAccessors, tagList, replaceExpression, onOpen];
}
class Accessor$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$X, create_fragment$X, safe_not_equal, { node: 0 });
  }
}
function get_each_context$9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function create_if_block_4$5(ctx) {
  let select2;
  let mounted;
  let dispose;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
  }
  return {
    c() {
      select2 = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_style(select2, "width", "100%");
      if (ctx[5] === void 0)
        add_render_callback(() => ctx[15].call(select2));
    },
    m(target, anchor) {
      insert(target, select2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select2, null);
        }
      }
      select_option(select2, ctx[5], true);
      if (!mounted) {
        dispose = listen(select2, "change", ctx[15]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$9(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select2, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 34) {
        select_option(select2, ctx2[5]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select2);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$7(ctx) {
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      set_style(textarea, "width", "100%");
      set_style(textarea, "height", "20px");
      textarea.value = ctx[5];
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[14]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 34) {
        textarea.value = ctx2[5];
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$9(ctx) {
  let select2;
  let option0;
  let option1;
  let select_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      select2 = element("select");
      option0 = element("option");
      option0.textContent = "true";
      option1 = element("option");
      option1.textContent = "false";
      option0.__value = "true";
      option0.value = option0.__value;
      option1.__value = "false";
      option1.value = option1.__value;
      set_style(select2, "width", "100%");
    },
    m(target, anchor) {
      insert(target, select2, anchor);
      append(select2, option0);
      append(select2, option1);
      select_option(select2, ctx[5] ? "true" : "false");
      if (!mounted) {
        dispose = listen(select2, "change", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 34 && select_value_value !== (select_value_value = ctx2[5] ? "true" : "false")) {
        select_option(select2, ctx2[5] ? "true" : "false");
      }
    },
    d(detaching) {
      if (detaching)
        detach(select2);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$d(ctx) {
  let input;
  let input_min_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "number");
      set_style(input, "width", "100%");
      attr(input, "min", input_min_value = ctx[2] ? void 0 : 0);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[5]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[11]),
          listen(input, "input", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4 && input_min_value !== (input_min_value = ctx2[2] ? void 0 : 0)) {
        attr(input, "min", input_min_value);
      }
      if (dirty & 34 && to_number(input.value) !== ctx2[5]) {
        set_input_value(input, ctx2[5]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$r(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      set_style(input, "width", "100%");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[5]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 34 && input.value !== ctx2[5]) {
        set_input_value(input, ctx2[5]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$9(ctx) {
  let option;
  let t_value = ctx[20] + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[20];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[20] + ""))
        set_data(t, t_value);
      if (dirty & 2 && option_value_value !== (option_value_value = ctx2[20])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_default_slot_1$h(ctx) {
  let tick_1;
  let current;
  tick_1 = new Tick({ props: { strokeColor: "blue" } });
  return {
    c() {
      create_component(tick_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tick_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tick_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tick_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tick_1, detaching);
    }
  };
}
function create_default_slot$t(ctx) {
  let cross;
  let current;
  cross = new Cross$1({ props: { strokeColor: "red" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_fragment$W(ctx) {
  var _a;
  let div2;
  let t0;
  let div0;
  let iconbtn0;
  let t1;
  let div1;
  let iconbtn1;
  let t2;
  let validationtooltip;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === "string" || ctx2[0] === "secret")
      return create_if_block$r;
    if (ctx2[0] === "int" || ctx2[0] === "float")
      return create_if_block_1$d;
    if (ctx2[0] === "boolean")
      return create_if_block_2$9;
    if (ctx2[0] === "json" || ctx2[0] === "array")
      return create_if_block_3$7;
    if (ctx2[0] === "select")
      return create_if_block_4$5;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  iconbtn0 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot_1$h] },
      $$scope: { ctx }
    }
  });
  iconbtn0.$on("click", ctx[7]);
  iconbtn1 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot$t] },
      $$scope: { ctx }
    }
  });
  iconbtn1.$on("click", ctx[16]);
  validationtooltip = new ValidationTooltip({
    props: {
      message: ctx[3],
      rect: {
        top: (_a = ctx[4]) == null ? void 0 : _a.getBoundingClientRect().height
      }
    }
  });
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div0 = element("div");
      create_component(iconbtn0.$$.fragment);
      t1 = space();
      div1 = element("div");
      create_component(iconbtn1.$$.fragment);
      t2 = space();
      create_component(validationtooltip.$$.fragment);
      attr(div0, "class", "bbx-icon-container");
      attr(div1, "class", "bbx-icon-container");
      attr(div2, "class", "bbx-inline-editor");
      set_style(div2, "position", "relative");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t0);
      append(div2, div0);
      mount_component(iconbtn0, div0, null);
      append(div2, t1);
      append(div2, div1);
      mount_component(iconbtn1, div1, null);
      append(div2, t2);
      mount_component(validationtooltip, div2, null);
      ctx[17](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(keypressEscape.call(null, div2)),
          listen(div2, "escape", ctx[18]),
          action_destroyer(clickOutside.call(null, div2)),
          listen(div2, "outclick", ctx[19]),
          action_destroyer(keypressEnter.call(null, div2)),
          listen(div2, "enter", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div2, t0);
        }
      }
      const iconbtn0_changes = {};
      if (dirty & 8388608) {
        iconbtn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn0.$set(iconbtn0_changes);
      const iconbtn1_changes = {};
      if (dirty & 8388608) {
        iconbtn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn1.$set(iconbtn1_changes);
      const validationtooltip_changes = {};
      if (dirty & 8)
        validationtooltip_changes.message = ctx2[3];
      if (dirty & 16)
        validationtooltip_changes.rect = {
          top: (_a2 = ctx2[4]) == null ? void 0 : _a2.getBoundingClientRect().height
        };
      validationtooltip.$set(validationtooltip_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbtn0.$$.fragment, local);
      transition_in(iconbtn1.$$.fragment, local);
      transition_in(validationtooltip.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbtn0.$$.fragment, local);
      transition_out(iconbtn1.$$.fragment, local);
      transition_out(validationtooltip.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block) {
        if_block.d();
      }
      destroy_component(iconbtn0);
      destroy_component(iconbtn1);
      destroy_component(validationtooltip);
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$W($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { value } = $$props;
  let { type } = $$props;
  let { options = [] } = $$props;
  let { allowNegative = true } = $$props;
  let { validationMessage } = $$props;
  let editorComponent;
  let newValue = type === "json" || type === "array" ? JSON.stringify(value) : value;
  function saveValue() {
    if (type === "int" || type === "float") {
      if (!allowNegative && newValue < 0)
        $$invalidate(5, newValue = 0);
      $$invalidate(5, newValue = Number(newValue));
    } else if (type === "boolean") {
      $$invalidate(5, newValue = Boolean(newValue));
    } else if (type === "json" || type === "array") {
      $$invalidate(5, newValue = JSON.parse(newValue));
    }
    dispatch("save", newValue);
  }
  function handleInput(e, type2) {
    const value2 = e.target.value;
    if (type2 === "int") {
      $$invalidate(5, newValue = parseInt(value2));
    } else if (type2 === "float") {
      $$invalidate(5, newValue = parseFloat(value2));
    }
  }
  function input_input_handler() {
    newValue = this.value;
    $$invalidate(5, newValue);
    $$invalidate(1, options);
  }
  function input_input_handler_1() {
    newValue = to_number(this.value);
    $$invalidate(5, newValue);
    $$invalidate(1, options);
  }
  const input_handler = (e) => handleInput(e, type);
  const change_handler = (e) => $$invalidate(5, newValue = e.target.value === "true");
  const input_handler_1 = (e) => $$invalidate(5, newValue = e.target.value);
  function select_change_handler() {
    newValue = select_value(this);
    $$invalidate(5, newValue);
    $$invalidate(1, options);
  }
  const click_handler2 = () => dispatch("cancel");
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      editorComponent = $$value;
      $$invalidate(4, editorComponent);
    });
  }
  const escape_handler = () => dispatch("cancel");
  const outclick_handler = () => dispatch("cancel");
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(9, value = $$props2.value);
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("allowNegative" in $$props2)
      $$invalidate(2, allowNegative = $$props2.allowNegative);
    if ("validationMessage" in $$props2)
      $$invalidate(3, validationMessage = $$props2.validationMessage);
  };
  return [
    type,
    options,
    allowNegative,
    validationMessage,
    editorComponent,
    newValue,
    dispatch,
    saveValue,
    handleInput,
    value,
    input_input_handler,
    input_input_handler_1,
    input_handler,
    change_handler,
    input_handler_1,
    select_change_handler,
    click_handler2,
    div2_binding,
    escape_handler,
    outclick_handler
  ];
}
class Literal$2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$W, create_fragment$W, safe_not_equal, {
      value: 9,
      type: 0,
      options: 1,
      allowNegative: 2,
      validationMessage: 3
    });
  }
}
function create_else_block$f(ctx) {
  let span;
  let t_value = ctx[3].value + "";
  let t;
  let tooltip_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "bbx-inline-editable");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
      if (!mounted) {
        dispose = [
          action_destroyer(tooltip_action = tooltip.call(null, span, ctx[1])),
          listen(span, "click", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3].value + ""))
        set_data(t, t_value);
      if (tooltip_action && is_function(tooltip_action.update) && dirty & 2)
        tooltip_action.update.call(null, ctx2[1]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$q(ctx) {
  let editliteral;
  let current;
  editliteral = new Literal$2({
    props: {
      value: ctx[3].value,
      type: "select",
      options: ctx[5] === "workflow" && ctx[3].name === "tag" ? getTagsInContext(ctx[3], ctx[4]).map(func$2) : ctx[3].scope.getEnum(ctx[3].name).values
    }
  });
  editliteral.$on("save", ctx[7]);
  editliteral.$on("cancel", ctx[9]);
  return {
    c() {
      create_component(editliteral.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editliteral, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editliteral_changes = {};
      if (dirty & 8)
        editliteral_changes.value = ctx2[3].value;
      if (dirty & 24)
        editliteral_changes.options = ctx2[5] === "workflow" && ctx2[3].name === "tag" ? getTagsInContext(ctx2[3], ctx2[4]).map(func$2) : ctx2[3].scope.getEnum(ctx2[3].name).values;
      editliteral.$set(editliteral_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editliteral.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editliteral.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editliteral, detaching);
    }
  };
}
function create_fragment$V(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$q, create_else_block$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
const func$2 = (tag) => tag.get("name");
function instance$V($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(3, $node = $$value)), node);
  let $tagList;
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node } = $$props;
  $$subscribe_node();
  let { label } = $$props;
  const mode = getContext("mode");
  const tagList = getContext("tagList");
  component_subscribe($$self, tagList, (value) => $$invalidate(4, $tagList = value));
  let editMode = false;
  function saveLiteral(e) {
    $$invalidate(2, editMode = false);
    $$invalidate(0, node.value = e.detail, node);
  }
  function editValue() {
    if (mode === "workflow") {
      let tagDef = $node.scope.getEnum("tag");
      tagDef.values = tagList.models.map((tag) => tag.get("name"));
    }
    $$invalidate(2, editMode = true);
  }
  const cancel_handler = () => $$invalidate(2, editMode = false);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  return [
    node,
    label,
    editMode,
    $node,
    $tagList,
    mode,
    tagList,
    saveLiteral,
    editValue,
    cancel_handler
  ];
}
class Enum$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$V, create_fragment$V, safe_not_equal, { node: 0, label: 1 });
  }
}
function create_else_block$e(ctx) {
  let span;
  let t;
  let tooltip_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t = text(ctx[4]);
      attr(span, "class", "bbx-inline-editable px-1 py-0");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
      if (!mounted) {
        dispose = [
          action_destroyer(tooltip_action = tooltip.call(null, span, ctx[1])),
          listen(span, "click", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        set_data(t, ctx2[4]);
      if (tooltip_action && is_function(tooltip_action.update) && dirty & 2)
        tooltip_action.update.call(null, ctx2[1]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$p(ctx) {
  let editliteral;
  let current;
  editliteral = new Literal$2({
    props: {
      value: ctx[2].value,
      type: ctx[2].returnType
    }
  });
  editliteral.$on("save", ctx[5]);
  editliteral.$on("cancel", ctx[6]);
  return {
    c() {
      create_component(editliteral.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editliteral, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editliteral_changes = {};
      if (dirty & 4)
        editliteral_changes.value = ctx2[2].value;
      if (dirty & 4)
        editliteral_changes.type = ctx2[2].returnType;
      editliteral.$set(editliteral_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editliteral.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editliteral.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editliteral, detaching);
    }
  };
}
function create_fragment$U(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$p, create_else_block$e];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$U($$self, $$props, $$invalidate) {
  let value;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(2, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node } = $$props;
  $$subscribe_node();
  let { label } = $$props;
  let editMode = false;
  function saveLiteral(e) {
    $$invalidate(3, editMode = false);
    $$invalidate(0, node.value = e.detail, node);
  }
  const cancel_handler = () => $$invalidate(3, editMode = false);
  const click_handler2 = () => $$invalidate(3, editMode = true);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(4, value = getSummary($node));
    }
  };
  return [
    node,
    label,
    $node,
    editMode,
    value,
    saveLiteral,
    cancel_handler,
    click_handler2
  ];
}
class Literal$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$U, create_fragment$U, safe_not_equal, { node: 0, label: 1 });
  }
}
const get_label_post_slot_changes = (dirty) => ({});
const get_label_post_slot_context = (ctx) => ({ slot: "label-post" });
function create_label_post_slot$2(ctx) {
  let current;
  const label_post_slot_template = ctx[7]["label-post"];
  const label_post_slot = create_slot(label_post_slot_template, ctx, ctx[10], get_label_post_slot_context);
  return {
    c() {
      if (label_post_slot)
        label_post_slot.c();
    },
    m(target, anchor) {
      if (label_post_slot) {
        label_post_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_post_slot) {
        if (label_post_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            label_post_slot,
            label_post_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(label_post_slot_template, ctx2[10], dirty, get_label_post_slot_changes),
            get_label_post_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_post_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_post_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_post_slot)
        label_post_slot.d(detaching);
    }
  };
}
function create_fragment$T(ctx) {
  let searchselect;
  let current;
  const searchselect_spread_levels = [
    { value: filterText },
    {
      options: Object.keys(ctx[1])
    },
    ctx[6]
  ];
  let searchselect_props = {
    $$slots: { "label-post": [create_label_post_slot$2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < searchselect_spread_levels.length; i += 1) {
    searchselect_props = assign(searchselect_props, searchselect_spread_levels[i]);
  }
  searchselect = new SearchSelect({ props: searchselect_props });
  searchselect.$on("open", ctx[8]);
  searchselect.$on("select", ctx[4]);
  searchselect.$on("cancel", ctx[9]);
  return {
    c() {
      create_component(searchselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchselect, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchselect_changes = dirty & 66 ? get_spread_update(searchselect_spread_levels, [
        dirty & 0 && { value: filterText },
        dirty & 2 && {
          options: Object.keys(ctx2[1])
        },
        dirty & 64 && get_spread_object(ctx2[6])
      ]) : {};
      if (dirty & 1024) {
        searchselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      searchselect.$set(searchselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchselect, detaching);
    }
  };
}
let filterText = "";
function instance$T($$self, $$props, $$invalidate) {
  const omit_props_names = ["node"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(11, $node = $$value)), node);
  let $tagList;
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  let { node } = $$props;
  $$subscribe_node();
  const ctx = getContext("expressionCtx");
  const mode = getContext("mode");
  const tagList = getContext("tagList");
  component_subscribe($$self, tagList, (value) => $$invalidate(12, $tagList = value));
  let alternateExpressions = {};
  function replaceExpression({ detail }) {
    let expression = alternateExpressions[detail];
    if (mode === "workflow" && node.scope.hasFunc(detail) && Object.values(node.scope.getFunc(detail).args).some((argDef) => argDef.types.includes("tag"))) {
      let defaultTag = getDefaultTag($node, $tagList);
      expression = getDefaultWorkflowStep(defaultTag, detail);
    }
    $node.parent.replace($node, expression);
    dispatch("close");
  }
  function onOpen() {
    $$invalidate(1, alternateExpressions = getAlternateExpressions($node, ctx.replace));
  }
  const open_handler = () => onOpen();
  const cancel_handler = () => dispatch("close");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("node" in $$new_props)
      $$subscribe_node($$invalidate(0, node = $$new_props.node));
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  return [
    node,
    alternateExpressions,
    dispatch,
    tagList,
    replaceExpression,
    onOpen,
    $$restProps,
    slots,
    open_handler,
    cancel_handler,
    $$scope
  ];
}
class Replace extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$T, create_fragment$T, safe_not_equal, { node: 0 });
  }
}
function create_fragment$S(ctx) {
  let span1;
  let t0;
  let span0;
  let t1_value = getSummary(ctx[0]) + "";
  let t1;
  let tooltip_action;
  let current;
  let mounted;
  let dispose;
  let if_block = replaceNode;
  return {
    c() {
      span1 = element("span");
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      attr(span0, "class", "bbx-step__header");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, t0);
      append(span1, span0);
      append(span0, t1);
      ctx[3](span0);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(tooltip_action = tooltip.call(null, span0, ctx[1]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t1_value !== (t1_value = getSummary(ctx2[0]) + ""))
        set_data(t1, t1_value);
      if (tooltip_action && is_function(tooltip_action.update) && dirty & 2)
        tooltip_action.update.call(null, ctx2[1]);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span1);
      ctx[3](null);
      mounted = false;
      dispose();
    }
  };
}
let replaceNode = false;
function instance$S($$self, $$props, $$invalidate) {
  let { node } = $$props;
  let { label } = $$props;
  let component;
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      component = $$value;
      $$invalidate(2, component);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(0, node = $$props2.node);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  return [node, label, component, span0_binding];
}
class FunctionCall$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$S, create_fragment$S, safe_not_equal, { node: 0, label: 1 });
  }
}
function create_fragment$R(ctx) {
  let span;
  let t_value = getSummary(ctx[2]) + "";
  let t;
  let tooltip_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      set_style(span, "word-break", "break-word");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
      if (!mounted) {
        dispose = action_destroyer(tooltip_action = tooltip.call(null, span, ctx[1]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && t_value !== (t_value = getSummary(ctx2[2]) + ""))
        set_data(t, t_value);
      if (tooltip_action && is_function(tooltip_action.update) && dirty & 2)
        tooltip_action.update.call(null, ctx2[1]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function instance$R($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(2, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node } = $$props;
  $$subscribe_node();
  let { label = $node.type } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  return [node, label, $node];
}
class Default extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$R, create_fragment$R, safe_not_equal, { node: 0, label: 1 });
  }
}
const get_second_row_after_slot_changes = (dirty) => ({});
const get_second_row_after_slot_context = (ctx) => ({ getRect: ctx[4] });
const get_second_row_slot_changes = (dirty) => ({});
const get_second_row_slot_context = (ctx) => ({ getRect: ctx[4] });
const get_second_row_before_slot_changes = (dirty) => ({});
const get_second_row_before_slot_context = (ctx) => ({ getRect: ctx[4] });
const get_first_row_after_2_slot_changes = (dirty) => ({});
const get_first_row_after_2_slot_context = (ctx) => ({ getRect: ctx[4] });
const get_first_row_after_1_slot_changes = (dirty) => ({});
const get_first_row_after_1_slot_context = (ctx) => ({ getRect: ctx[4] });
const get_first_row_slot_changes = (dirty) => ({});
const get_first_row_slot_context = (ctx) => ({ getRect: ctx[4] });
const get_first_row_before_slot_changes = (dirty) => ({});
const get_first_row_before_slot_context = (ctx) => ({ getRect: ctx[4] });
function create_if_block$o(ctx) {
  let div3;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let current;
  const second_row_before_slot_template = ctx[6]["second-row-before"];
  const second_row_before_slot = create_slot(second_row_before_slot_template, ctx, ctx[5], get_second_row_before_slot_context);
  const second_row_slot_template = ctx[6]["second-row"];
  const second_row_slot = create_slot(second_row_slot_template, ctx, ctx[5], get_second_row_slot_context);
  const second_row_after_slot_template = ctx[6]["second-row-after"];
  const second_row_after_slot = create_slot(second_row_after_slot_template, ctx, ctx[5], get_second_row_after_slot_context);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      if (second_row_before_slot)
        second_row_before_slot.c();
      t0 = space();
      div1 = element("div");
      if (second_row_slot)
        second_row_slot.c();
      t1 = space();
      div2 = element("div");
      if (second_row_after_slot)
        second_row_after_slot.c();
      attr(div0, "class", "bbx-flex bbx-center bbx-w-1");
      attr(div1, "class", "bbx-pad-x bbx-flex-grow");
      attr(div2, "class", "bbx-flex-no-shrink");
      attr(div3, "class", "bbx-flex bbx-pad-x bbx-pad-y bbx-center bbx-w-full");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      if (second_row_before_slot) {
        second_row_before_slot.m(div0, null);
      }
      append(div3, t0);
      append(div3, div1);
      if (second_row_slot) {
        second_row_slot.m(div1, null);
      }
      append(div3, t1);
      append(div3, div2);
      if (second_row_after_slot) {
        second_row_after_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (second_row_before_slot) {
        if (second_row_before_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            second_row_before_slot,
            second_row_before_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(second_row_before_slot_template, ctx2[5], dirty, get_second_row_before_slot_changes),
            get_second_row_before_slot_context
          );
        }
      }
      if (second_row_slot) {
        if (second_row_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            second_row_slot,
            second_row_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(second_row_slot_template, ctx2[5], dirty, get_second_row_slot_changes),
            get_second_row_slot_context
          );
        }
      }
      if (second_row_after_slot) {
        if (second_row_after_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            second_row_after_slot,
            second_row_after_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(second_row_after_slot_template, ctx2[5], dirty, get_second_row_after_slot_changes),
            get_second_row_after_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(second_row_before_slot, local);
      transition_in(second_row_slot, local);
      transition_in(second_row_after_slot, local);
      current = true;
    },
    o(local) {
      transition_out(second_row_before_slot, local);
      transition_out(second_row_slot, local);
      transition_out(second_row_after_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (second_row_before_slot)
        second_row_before_slot.d(detaching);
      if (second_row_slot)
        second_row_slot.d(detaching);
      if (second_row_after_slot)
        second_row_after_slot.d(detaching);
    }
  };
}
function create_fragment$Q(ctx) {
  let div5;
  let div4;
  let div0;
  let div0_class_value;
  let t0;
  let div1;
  let t1;
  let div2;
  let div2_class_value;
  let t2;
  let div3;
  let div3_class_value;
  let t3;
  let div5_class_value;
  let current;
  let mounted;
  let dispose;
  const first_row_before_slot_template = ctx[6]["first-row-before"];
  const first_row_before_slot = create_slot(first_row_before_slot_template, ctx, ctx[5], get_first_row_before_slot_context);
  const first_row_slot_template = ctx[6]["first-row"];
  const first_row_slot = create_slot(first_row_slot_template, ctx, ctx[5], get_first_row_slot_context);
  const first_row_after_1_slot_template = ctx[6]["first-row-after-1"];
  const first_row_after_1_slot = create_slot(first_row_after_1_slot_template, ctx, ctx[5], get_first_row_after_1_slot_context);
  const first_row_after_2_slot_template = ctx[6]["first-row-after-2"];
  const first_row_after_2_slot = create_slot(first_row_after_2_slot_template, ctx, ctx[5], get_first_row_after_2_slot_context);
  let if_block = !ctx[2] && create_if_block$o(ctx);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      if (first_row_before_slot)
        first_row_before_slot.c();
      t0 = space();
      div1 = element("div");
      if (first_row_slot)
        first_row_slot.c();
      t1 = space();
      div2 = element("div");
      if (first_row_after_1_slot)
        first_row_after_1_slot.c();
      t2 = space();
      div3 = element("div");
      if (first_row_after_2_slot)
        first_row_after_2_slot.c();
      t3 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", div0_class_value = "bbx-flex bbx-center " + (ctx[0] ? "bbx-h-1" : "bbx-h-2") + " bbx-w-1");
      attr(div1, "class", "bbx-pad-x bbx-flex-grow");
      attr(div2, "class", div2_class_value = "bbx-flex-no-shrink " + (ctx[0] ? "" : "bbx-h-3/2") + " bbx-w-3/2");
      attr(div3, "class", div3_class_value = "bbx-flex-no-shrink " + (ctx[0] ? "" : "bbx-h-3/2") + " bbx-w-3/2");
      attr(div4, "class", "bbx-flex bbx-pad-x bbx-center bbx-w-full");
      attr(div5, "class", div5_class_value = "bbx-flex-col bbx-center bbx-border bbx-rounded " + (ctx[1] ? "bbx-shadow-fade" : ""));
      set_style(div5, "position", "relative");
      set_style(div5, "background-color", "var(--bbx-color-menu-bg)");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      if (first_row_before_slot) {
        first_row_before_slot.m(div0, null);
      }
      append(div4, t0);
      append(div4, div1);
      if (first_row_slot) {
        first_row_slot.m(div1, null);
      }
      append(div4, t1);
      append(div4, div2);
      if (first_row_after_1_slot) {
        first_row_after_1_slot.m(div2, null);
      }
      append(div4, t2);
      append(div4, div3);
      if (first_row_after_2_slot) {
        first_row_after_2_slot.m(div3, null);
      }
      append(div5, t3);
      if (if_block)
        if_block.m(div5, null);
      ctx[9](div5);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div5, "mouseenter", ctx[7]),
          listen(div5, "mouseleave", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (first_row_before_slot) {
        if (first_row_before_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            first_row_before_slot,
            first_row_before_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(first_row_before_slot_template, ctx2[5], dirty, get_first_row_before_slot_changes),
            get_first_row_before_slot_context
          );
        }
      }
      if (!current || dirty & 1 && div0_class_value !== (div0_class_value = "bbx-flex bbx-center " + (ctx2[0] ? "bbx-h-1" : "bbx-h-2") + " bbx-w-1")) {
        attr(div0, "class", div0_class_value);
      }
      if (first_row_slot) {
        if (first_row_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            first_row_slot,
            first_row_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(first_row_slot_template, ctx2[5], dirty, get_first_row_slot_changes),
            get_first_row_slot_context
          );
        }
      }
      if (first_row_after_1_slot) {
        if (first_row_after_1_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            first_row_after_1_slot,
            first_row_after_1_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(first_row_after_1_slot_template, ctx2[5], dirty, get_first_row_after_1_slot_changes),
            get_first_row_after_1_slot_context
          );
        }
      }
      if (!current || dirty & 1 && div2_class_value !== (div2_class_value = "bbx-flex-no-shrink " + (ctx2[0] ? "" : "bbx-h-3/2") + " bbx-w-3/2")) {
        attr(div2, "class", div2_class_value);
      }
      if (first_row_after_2_slot) {
        if (first_row_after_2_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            first_row_after_2_slot,
            first_row_after_2_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(first_row_after_2_slot_template, ctx2[5], dirty, get_first_row_after_2_slot_changes),
            get_first_row_after_2_slot_context
          );
        }
      }
      if (!current || dirty & 1 && div3_class_value !== (div3_class_value = "bbx-flex-no-shrink " + (ctx2[0] ? "" : "bbx-h-3/2") + " bbx-w-3/2")) {
        attr(div3, "class", div3_class_value);
      }
      if (!ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$o(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div5, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 2 && div5_class_value !== (div5_class_value = "bbx-flex-col bbx-center bbx-border bbx-rounded " + (ctx2[1] ? "bbx-shadow-fade" : ""))) {
        attr(div5, "class", div5_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(first_row_before_slot, local);
      transition_in(first_row_slot, local);
      transition_in(first_row_after_1_slot, local);
      transition_in(first_row_after_2_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(first_row_before_slot, local);
      transition_out(first_row_slot, local);
      transition_out(first_row_after_1_slot, local);
      transition_out(first_row_after_2_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (first_row_before_slot)
        first_row_before_slot.d(detaching);
      if (first_row_slot)
        first_row_slot.d(detaching);
      if (first_row_after_1_slot)
        first_row_after_1_slot.d(detaching);
      if (first_row_after_2_slot)
        first_row_after_2_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$Q($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { compact = false } = $$props;
  let { highlight = false } = $$props;
  let { hideSecondRow = false } = $$props;
  let component;
  function getRect2() {
    return component.getBoundingClientRect();
  }
  function mouseenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div5_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      component = $$value;
      $$invalidate(3, component);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("compact" in $$props2)
      $$invalidate(0, compact = $$props2.compact);
    if ("highlight" in $$props2)
      $$invalidate(1, highlight = $$props2.highlight);
    if ("hideSecondRow" in $$props2)
      $$invalidate(2, hideSecondRow = $$props2.hideSecondRow);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [
    compact,
    highlight,
    hideSecondRow,
    component,
    getRect2,
    $$scope,
    slots,
    mouseenter_handler,
    mouseleave_handler,
    div5_binding
  ];
}
class Card extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {
      compact: 0,
      highlight: 1,
      hideSecondRow: 2
    });
  }
}
function create_fragment$P(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M3 9.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z");
      attr(svg, "fill", "black");
      set_style(svg, "width", ctx[0]);
      set_style(svg, "height", ctx[0]);
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 16 16");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        set_style(svg, "width", ctx2[0]);
      }
      if (dirty & 1) {
        set_style(svg, "height", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$P($$self, $$props, $$invalidate) {
  let { size = "12px" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
  };
  return [size];
}
class Ellipsis extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$P, create_fragment$P, safe_not_equal, { size: 0 });
  }
}
const get_items_slot_changes = (dirty) => ({});
const get_items_slot_context = (ctx) => ({});
function create_label_slot$e(ctx) {
  let ellipsis;
  let current;
  ellipsis = new Ellipsis({});
  return {
    c() {
      create_component(ellipsis.$$.fragment);
    },
    m(target, anchor) {
      mount_component(ellipsis, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(ellipsis.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ellipsis.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(ellipsis, detaching);
    }
  };
}
function create_default_slot$s(ctx) {
  let current;
  const items_slot_template = ctx[2].items;
  const items_slot = create_slot(items_slot_template, ctx, ctx[5], get_items_slot_context);
  return {
    c() {
      if (items_slot)
        items_slot.c();
    },
    m(target, anchor) {
      if (items_slot) {
        items_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (items_slot) {
        if (items_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            items_slot,
            items_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(items_slot_template, ctx2[5], dirty, get_items_slot_changes),
            get_items_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(items_slot, local);
      current = true;
    },
    o(local) {
      transition_out(items_slot, local);
      current = false;
    },
    d(detaching) {
      if (items_slot)
        items_slot.d(detaching);
    }
  };
}
function create_fragment$O(ctx) {
  let menu;
  let current;
  const menu_spread_levels = [{ class: ctx[0] }, ctx[1]];
  let menu_props = {
    $$slots: {
      default: [create_default_slot$s],
      label: [create_label_slot$e]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < menu_spread_levels.length; i += 1) {
    menu_props = assign(menu_props, menu_spread_levels[i]);
  }
  menu = new Menu({ props: menu_props });
  menu.$on("click", close);
  menu.$on("escape", close);
  menu.$on("outclick", close);
  menu.$on("open", ctx[3]);
  menu.$on("close", ctx[4]);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = dirty & 3 ? get_spread_update(menu_spread_levels, [
        dirty & 1 && { class: ctx2[0] },
        dirty & 2 && get_spread_object(ctx2[1])
      ]) : {};
      if (dirty & 32) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$O($$self, $$props, $$invalidate) {
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: clazz = "" } = $$props;
  function open_handler(event) {
    bubble.call(this, $$self, event);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, clazz = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  return [clazz, $$restProps, slots, open_handler, close_handler, $$scope];
}
class MenuBtn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$O, create_fragment$O, safe_not_equal, { class: 0 });
  }
}
const get_label_slot_changes$2 = (dirty) => ({});
const get_label_slot_context$2 = (ctx) => ({});
const get_title_slot_changes = (dirty) => ({});
const get_title_slot_context = (ctx) => ({});
const get_status_slot_changes = (dirty) => ({});
const get_status_slot_context = (ctx) => ({});
const get_menu_items_slot_changes$1 = (dirty) => ({});
const get_menu_items_slot_context$1 = (ctx) => ({});
const get_error_slot_changes$1 = (dirty) => ({});
const get_error_slot_context$1 = (ctx) => ({});
const get_summary_slot_changes$1 = (dirty) => ({ getRect: dirty & 134217728 });
const get_summary_slot_context$1 = (ctx) => ({ getRect: ctx[27] });
function create_if_block_1$c(ctx) {
  let button;
  let angleright;
  let current;
  let mounted;
  let dispose;
  angleright = new AngleRight({
    props: {
      strokeColor: "var(--bbx-color-gray)",
      class: ctx[0] ? "bbx-rotate-90" : ""
    }
  });
  return {
    c() {
      button = element("button");
      create_component(angleright.$$.fragment);
      attr(button, "class", "btn btn-link d-flex align-items-center justify-content-center p-0 pt-1 shadow-none");
      set_style(button, "width", "1rem");
      set_style(button, "height", "1rem");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(angleright, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[14]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const angleright_changes = {};
      if (dirty & 1)
        angleright_changes.class = ctx2[0] ? "bbx-rotate-90" : "";
      angleright.$set(angleright_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(angleright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(angleright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      destroy_component(angleright);
      mounted = false;
      dispose();
    }
  };
}
function create_first_row_before_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] && create_if_block_1$c(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_first_row_slot(ctx) {
  let div1;
  let t;
  let div0;
  let current;
  const title_slot_template = ctx[20].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[24], get_title_slot_context);
  const label_slot_template = ctx[20].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[24], get_label_slot_context$2);
  return {
    c() {
      div1 = element("div");
      if (title_slot)
        title_slot.c();
      t = space();
      div0 = element("div");
      if (label_slot)
        label_slot.c();
      attr(div0, "class", "text-secondary ms-1");
      attr(div1, "class", "d-flex justify-content-start align-items-center");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (title_slot) {
        title_slot.m(div1, null);
      }
      append(div1, t);
      append(div1, div0);
      if (label_slot) {
        label_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 16777216)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[24],
            !current ? get_all_dirty_from_scope(ctx2[24]) : get_slot_changes(title_slot_template, ctx2[24], dirty, get_title_slot_changes),
            get_title_slot_context
          );
        }
      }
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 16777216)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[24],
            !current ? get_all_dirty_from_scope(ctx2[24]) : get_slot_changes(label_slot_template, ctx2[24], dirty, get_label_slot_changes$2),
            get_label_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (title_slot)
        title_slot.d(detaching);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_first_row_after_1_slot(ctx) {
  let current;
  const status_slot_template = ctx[20].status;
  const status_slot = create_slot(status_slot_template, ctx, ctx[24], get_status_slot_context);
  return {
    c() {
      if (status_slot)
        status_slot.c();
    },
    m(target, anchor) {
      if (status_slot) {
        status_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (status_slot) {
        if (status_slot.p && (!current || dirty & 16777216)) {
          update_slot_base(
            status_slot,
            status_slot_template,
            ctx2,
            ctx2[24],
            !current ? get_all_dirty_from_scope(ctx2[24]) : get_slot_changes(status_slot_template, ctx2[24], dirty, get_status_slot_changes),
            get_status_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(status_slot, local);
      current = true;
    },
    o(local) {
      transition_out(status_slot, local);
      current = false;
    },
    d(detaching) {
      if (status_slot)
        status_slot.d(detaching);
    }
  };
}
function create_items_slot$2(ctx) {
  let current;
  const menu_items_slot_template = ctx[20]["menu-items"];
  const menu_items_slot = create_slot(menu_items_slot_template, ctx, ctx[24], get_menu_items_slot_context$1);
  return {
    c() {
      if (menu_items_slot)
        menu_items_slot.c();
    },
    m(target, anchor) {
      if (menu_items_slot) {
        menu_items_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (menu_items_slot) {
        if (menu_items_slot.p && (!current || dirty & 16777216)) {
          update_slot_base(
            menu_items_slot,
            menu_items_slot_template,
            ctx2,
            ctx2[24],
            !current ? get_all_dirty_from_scope(ctx2[24]) : get_slot_changes(menu_items_slot_template, ctx2[24], dirty, get_menu_items_slot_changes$1),
            get_menu_items_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu_items_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menu_items_slot, local);
      current = false;
    },
    d(detaching) {
      if (menu_items_slot)
        menu_items_slot.d(detaching);
    }
  };
}
function create_first_row_after_2_slot(ctx) {
  let div;
  let menubtn;
  let current;
  menubtn = new MenuBtn({
    props: {
      $$slots: { items: [create_items_slot$2] },
      $$scope: { ctx }
    }
  });
  menubtn.$on("open", ctx[15]);
  menubtn.$on("close", ctx[21]);
  return {
    c() {
      div = element("div");
      create_component(menubtn.$$.fragment);
      attr(div, "class", "bbx-flex bbx-h-full bbx-w-full bbx-align-center bbx-justify-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(menubtn, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const menubtn_changes = {};
      if (dirty & 16777216) {
        menubtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menubtn.$set(menubtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menubtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menubtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(menubtn);
    }
  };
}
function create_if_block$n(ctx) {
  let code;
  let current;
  const summary_slot_template = ctx[20].summary;
  const summary_slot = create_slot(summary_slot_template, ctx, ctx[24], get_summary_slot_context$1);
  return {
    c() {
      code = element("code");
      if (summary_slot)
        summary_slot.c();
    },
    m(target, anchor) {
      insert(target, code, anchor);
      if (summary_slot) {
        summary_slot.m(code, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (summary_slot) {
        if (summary_slot.p && (!current || dirty & 150994944)) {
          update_slot_base(
            summary_slot,
            summary_slot_template,
            ctx2,
            ctx2[24],
            !current ? get_all_dirty_from_scope(ctx2[24]) : get_slot_changes(summary_slot_template, ctx2[24], dirty, get_summary_slot_changes$1),
            get_summary_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(summary_slot, local);
      current = true;
    },
    o(local) {
      transition_out(summary_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(code);
      if (summary_slot)
        summary_slot.d(detaching);
    }
  };
}
function create_second_row_slot(ctx) {
  let div;
  let t;
  let current;
  let if_block = (!ctx[0] || ctx[2]) && create_if_block$n(ctx);
  const error_slot_template = ctx[20].error;
  const error_slot = create_slot(error_slot_template, ctx, ctx[24], get_error_slot_context$1);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (error_slot)
        error_slot.c();
      attr(div, "class", "bbx-flex-col bbx-gap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      if (error_slot) {
        error_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (!ctx2[0] || ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$n(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (error_slot) {
        if (error_slot.p && (!current || dirty & 16777216)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            ctx2[24],
            !current ? get_all_dirty_from_scope(ctx2[24]) : get_slot_changes(error_slot_template, ctx2[24], dirty, get_error_slot_changes$1),
            get_error_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(error_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(error_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      if (error_slot)
        error_slot.d(detaching);
    }
  };
}
function create_fragment$N(ctx) {
  let div;
  let card;
  let div_style_value;
  let current;
  card = new Card({
    props: {
      compact: ctx[4],
      highlight: ctx[5],
      hideSecondRow: ctx[11],
      $$slots: {
        "second-row": [
          create_second_row_slot,
          ({ getRect: getRect2 }) => ({ 27: getRect2 }),
          ({ getRect: getRect2 }) => getRect2 ? 134217728 : 0
        ],
        "first-row-after-2": [create_first_row_after_2_slot],
        "first-row-after-1": [create_first_row_after_1_slot],
        "first-row": [create_first_row_slot],
        "first-row-before": [create_first_row_before_slot]
      },
      $$scope: { ctx }
    }
  });
  card.$on("mouseenter", ctx[22]);
  card.$on("mouseleave", ctx[23]);
  return {
    c() {
      div = element("div");
      create_component(card.$$.fragment);
      attr(div, "class", ctx[6]);
      attr(div, "style", div_style_value = "position: relative;" + ctx[10]);
      toggle_class(div, "bbx-highlight", ctx[9] && !ctx[13]);
      set_style(div, "margin-left", ctx[3]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(card, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const card_changes = {};
      if (dirty & 16)
        card_changes.compact = ctx2[4];
      if (dirty & 32)
        card_changes.highlight = ctx2[5];
      if (dirty & 2048)
        card_changes.hideSecondRow = ctx2[11];
      if (dirty & 150995079) {
        card_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card.$set(card_changes);
      if (!current || dirty & 64) {
        attr(div, "class", ctx2[6]);
      }
      if (!current || dirty & 1024 && div_style_value !== (div_style_value = "position: relative;" + ctx2[10])) {
        attr(div, "style", div_style_value);
      }
      if (!current || dirty & 8768) {
        toggle_class(div, "bbx-highlight", ctx2[9] && !ctx2[13]);
      }
      const style_changed = dirty & 1024;
      if (style_changed || dirty & 1032) {
        set_style(div, "margin-left", ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(card);
    }
  };
}
function instance$N($$self, $$props, $$invalidate) {
  let hideSecondRow;
  let $highlightNodes;
  let { $$slots: slots = {}, $$scope } = $$props;
  const highlightNodes = getContext("highlightNodes");
  component_subscribe($$self, highlightNodes, (value) => $$invalidate(19, $highlightNodes = value));
  const highlightStyle = getContext("highlightStyle");
  const dispatch = createEventDispatcher();
  let { node } = $$props;
  let { expanded = false } = $$props;
  let { showExpandIcon = true } = $$props;
  let { showSummaryWhenExpanded = false } = $$props;
  let { indent } = $$props;
  let { compact = false } = $$props;
  let { highlight = false } = $$props;
  let { hideSummaryRow = false } = $$props;
  let { hasError = false } = $$props;
  let { class: classes2 = "" } = $$props;
  let menuActive = false;
  let hoveringMenu = false;
  let highlighted;
  function toggleExpand() {
    dispatch("toggleExpand");
  }
  function onMenuOpen() {
    $$invalidate(7, menuActive = true);
    dispatch("menuOpen");
  }
  const getHighlightStyle = () => {
    if (typeof highlightStyle === "function") {
      return highlightStyle(node);
    }
    return highlighted ? highlightStyle : "";
  };
  let finalHighlightStyle = "";
  const close_handler = () => $$invalidate(7, menuActive = false);
  const mouseenter_handler = () => $$invalidate(8, hoveringMenu = true);
  const mouseleave_handler = () => $$invalidate(8, hoveringMenu = false);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(16, node = $$props2.node);
    if ("expanded" in $$props2)
      $$invalidate(0, expanded = $$props2.expanded);
    if ("showExpandIcon" in $$props2)
      $$invalidate(1, showExpandIcon = $$props2.showExpandIcon);
    if ("showSummaryWhenExpanded" in $$props2)
      $$invalidate(2, showSummaryWhenExpanded = $$props2.showSummaryWhenExpanded);
    if ("indent" in $$props2)
      $$invalidate(3, indent = $$props2.indent);
    if ("compact" in $$props2)
      $$invalidate(4, compact = $$props2.compact);
    if ("highlight" in $$props2)
      $$invalidate(5, highlight = $$props2.highlight);
    if ("hideSummaryRow" in $$props2)
      $$invalidate(17, hideSummaryRow = $$props2.hideSummaryRow);
    if ("hasError" in $$props2)
      $$invalidate(18, hasError = $$props2.hasError);
    if ("class" in $$props2)
      $$invalidate(6, classes2 = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(24, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 589824) {
      $$invalidate(9, highlighted = $highlightNodes == null ? void 0 : $highlightNodes.includes(node));
    }
    if ($$self.$$.dirty & 393221) {
      $$invalidate(11, hideSecondRow = hideSummaryRow || expanded && !showSummaryWhenExpanded && !hasError);
    }
    if ($$self.$$.dirty & 524288) {
      $$invalidate(10, finalHighlightStyle = $highlightNodes && getHighlightStyle());
    }
  };
  return [
    expanded,
    showExpandIcon,
    showSummaryWhenExpanded,
    indent,
    compact,
    highlight,
    classes2,
    menuActive,
    hoveringMenu,
    highlighted,
    finalHighlightStyle,
    hideSecondRow,
    highlightNodes,
    highlightStyle,
    toggleExpand,
    onMenuOpen,
    node,
    hideSummaryRow,
    hasError,
    $highlightNodes,
    slots,
    close_handler,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
class Node$2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$N, create_fragment$N, safe_not_equal, {
      node: 16,
      expanded: 0,
      showExpandIcon: 1,
      showSummaryWhenExpanded: 2,
      indent: 3,
      compact: 4,
      highlight: 5,
      hideSummaryRow: 17,
      hasError: 18,
      class: 6
    });
  }
}
function updateModalPosition(modalElement) {
  const rect = modalElement.getBoundingClientRect();
  let windowHeight = window.innerHeight;
  let windowWidth = window.innerWidth;
  const modalBottom = rect.top + modalElement.offsetHeight;
  let y = modalBottom > windowHeight ? modalBottom - windowHeight : 0;
  const modalRightOverflow = rect.right - windowWidth;
  let x = modalRightOverflow > 0 ? modalRightOverflow : 0;
  return { x, y };
}
function create_fragment$M(ctx) {
  let div1;
  let div0;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "bbx-modal-item");
      attr(div0, "style", ctx[2]);
      attr(div1, "class", "bbx-modal bbx-flex bbx-justify-center bbx-border");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[9](div0);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(keypressEscape.call(null, div0)),
          listen(div0, "escape", function() {
            if (is_function(ctx[0]))
              ctx[0].apply(this, arguments);
          }),
          action_destroyer(clickOutside.call(null, div0)),
          listen(div0, "outclick", function() {
            if (is_function(ctx[0]))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[7],
            !current ? get_all_dirty_from_scope(ctx[7]) : get_slot_changes(default_slot_template, ctx[7], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4) {
        attr(div0, "style", ctx[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$M($$self, $$props, $$invalidate) {
  let style;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { close: close2 = () => void 0 } = $$props;
  let { rect = { top: 0, left: 0, right: 0 } } = $$props;
  let top = rect.top;
  let left = rect.left;
  let right = rect.right;
  let modalElement;
  onMount(() => {
    let offsets = updateModalPosition(modalElement);
    $$invalidate(4, top = top - offsets.y);
    $$invalidate(5, left = left ? left - offsets.x : left);
    $$invalidate(6, right = right ? right - offsets.x : right);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modalElement = $$value;
      $$invalidate(1, modalElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("close" in $$props2)
      $$invalidate(0, close2 = $$props2.close);
    if ("rect" in $$props2)
      $$invalidate(3, rect = $$props2.rect);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 112) {
      $$invalidate(2, style = `top: ${top}px;` + (left ? `left: ${left}px;` : `right: ${window.innerWidth - right}px;`));
    }
  };
  return [
    close2,
    modalElement,
    style,
    rect,
    top,
    left,
    right,
    $$scope,
    slots,
    div0_binding
  ];
}
class Modal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$M, create_fragment$M, safe_not_equal, { close: 0, rect: 3 });
  }
}
function create_default_slot_1$g(ctx) {
  let cross;
  let current;
  cross = new Cross$1({ props: { strokeColor: "#666" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_default_slot$r(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let iconbtn;
  let t2;
  let div3;
  let t3;
  let div4;
  let a;
  let t5;
  let button;
  let t6;
  let current;
  let mounted;
  let dispose;
  iconbtn = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot_1$g] },
      $$scope: { ctx }
    }
  });
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[0]);
      t1 = space();
      div1 = element("div");
      create_component(iconbtn.$$.fragment);
      t2 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      t3 = space();
      div4 = element("div");
      a = element("a");
      a.textContent = "Cancel";
      t5 = space();
      button = element("button");
      t6 = text(ctx[2]);
      attr(div0, "class", "bbx-header");
      attr(div2, "class", "bbx-modal-title");
      attr(div3, "class", "bbx-pad-2");
      attr(a, "class", "");
      attr(a, "href", "#");
      attr(button, "class", "bbx-primary");
      button.disabled = ctx[3];
      attr(div4, "class", "bbx-flex bbx-pad-2 bbx-gap-2x bbx-align-center");
      set_style(div4, "justify-content", "right");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      mount_component(iconbtn, div1, null);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      insert(target, t3, anchor);
      insert(target, div4, anchor);
      append(div4, a);
      append(div4, t5);
      append(div4, button);
      append(button, t6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div1, "click", ctx[6]),
          listen(a, "click", prevent_default(ctx[7])),
          listen(button, "click", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & 1)
        set_data(t0, ctx2[0]);
      const iconbtn_changes = {};
      if (dirty & 1024) {
        iconbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn.$set(iconbtn_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4)
        set_data(t6, ctx2[2]);
      if (!current || dirty & 8) {
        button.disabled = ctx2[3];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbtn.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(iconbtn.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(iconbtn);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div3);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div4);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$L(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      rect: ctx[1],
      close: ctx[9],
      $$slots: { default: [create_default_slot$r] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 2)
        modal_changes.rect = ctx2[1];
      if (dirty & 1037) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$L($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  let { title } = $$props;
  let { rect } = $$props;
  let { actionLabel = "Save" } = $$props;
  let { disableAction = false } = $$props;
  const click_handler2 = () => dispatch("cancel");
  const click_handler_1 = () => dispatch("cancel");
  const click_handler_2 = () => dispatch("save");
  const func2 = () => dispatch("cancel");
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("rect" in $$props2)
      $$invalidate(1, rect = $$props2.rect);
    if ("actionLabel" in $$props2)
      $$invalidate(2, actionLabel = $$props2.actionLabel);
    if ("disableAction" in $$props2)
      $$invalidate(3, disableAction = $$props2.disableAction);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  return [
    title,
    rect,
    actionLabel,
    disableAction,
    dispatch,
    slots,
    click_handler2,
    click_handler_1,
    click_handler_2,
    func2,
    $$scope
  ];
}
class SaveCancelModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$L, create_fragment$L, safe_not_equal, {
      title: 0,
      rect: 1,
      actionLabel: 2,
      disableAction: 3
    });
  }
}
function create_if_block$m(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[1]);
      attr(div, "class", "text-danger");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$q(ctx) {
  let div;
  let textarea;
  let textarea_style_value;
  let t;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block$m(ctx);
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      t = space();
      if (if_block)
        if_block.c();
      textarea.value = ctx[2];
      attr(textarea, "style", textarea_style_value = "width:100%;height: 20vh;" + (ctx[4] ? "" : "color: red;") + (ctx[1] ? "border: 1px solid red;" : ""));
      textarea.autofocus = true;
      set_style(div, "width", "20vw");
      set_style(div, "max-height", "22vw");
      set_style(div, "overflow-y", "auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      ctx[8](textarea);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      textarea.focus();
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        textarea.value = ctx2[2];
      }
      if (dirty & 18 && textarea_style_value !== (textarea_style_value = "width:100%;height: 20vh;" + (ctx2[4] ? "" : "color: red;") + (ctx2[1] ? "border: 1px solid red;" : ""))) {
        attr(textarea, "style", textarea_style_value);
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$m(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[8](null);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$K(ctx) {
  let savecancelmodal;
  let current;
  savecancelmodal = new SaveCancelModal({
    props: {
      title: "Source Editor",
      rect: ctx[0],
      disableAction: !ctx[4],
      $$slots: { default: [create_default_slot$q] },
      $$scope: { ctx }
    }
  });
  savecancelmodal.$on("cancel", ctx[9]);
  savecancelmodal.$on("save", ctx[10]);
  return {
    c() {
      create_component(savecancelmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savecancelmodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savecancelmodal_changes = {};
      if (dirty & 1)
        savecancelmodal_changes.rect = ctx2[0];
      if (dirty & 16)
        savecancelmodal_changes.disableAction = !ctx2[4];
      if (dirty & 2078) {
        savecancelmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savecancelmodal.$set(savecancelmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savecancelmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savecancelmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savecancelmodal, detaching);
    }
  };
}
function instance$K($$self, $$props, $$invalidate) {
  let { source } = $$props;
  let { rect } = $$props;
  let { errorMessage } = $$props;
  let serializedSource = JSON.stringify(source, null, 2);
  let textComponent;
  const dispatch = createEventDispatcher();
  let jsonIsValid = true;
  onMount(() => {
  });
  function changeSource(e) {
    $$invalidate(2, serializedSource = e.target.value);
    try {
      JSON.parse(serializedSource);
      $$invalidate(4, jsonIsValid = true);
    } catch (e2) {
      $$invalidate(4, jsonIsValid = false);
    }
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      textComponent = $$value;
      $$invalidate(3, textComponent);
    });
  }
  const cancel_handler = () => dispatch("cancel");
  const save_handler = () => dispatch("save", JSON.parse(serializedSource));
  $$self.$$set = ($$props2) => {
    if ("source" in $$props2)
      $$invalidate(7, source = $$props2.source);
    if ("rect" in $$props2)
      $$invalidate(0, rect = $$props2.rect);
    if ("errorMessage" in $$props2)
      $$invalidate(1, errorMessage = $$props2.errorMessage);
  };
  return [
    rect,
    errorMessage,
    serializedSource,
    textComponent,
    jsonIsValid,
    dispatch,
    changeSource,
    source,
    textarea_binding,
    cancel_handler,
    save_handler
  ];
}
class SourceEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$K, create_fragment$K, safe_not_equal, { source: 7, rect: 0, errorMessage: 1 });
  }
}
function create_fragment$J(ctx) {
  let svg;
  let path;
  let animateTransform;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      animateTransform = svg_element("animateTransform");
      attr(animateTransform, "attributeName", "transform");
      attr(animateTransform, "attributeType", "XML");
      attr(animateTransform, "type", "rotate");
      attr(animateTransform, "dur", "1s");
      attr(animateTransform, "from", "0 50 50");
      attr(animateTransform, "to", "360 50 50");
      attr(animateTransform, "repeatCount", "indefinite");
      attr(path, "fill", ctx[0]);
      attr(path, "d", "M31.6,3.5C5.9,13.6-6.6,42.7,3.5,68.4c10.1,25.7,39.2,38.3,64.9,28.1l-3.1-7.9c-21.3,8.4-45.4-2-53.8-23.3\n  c-8.4-21.3,2-45.4,23.3-53.8L31.6,3.5z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "x", "0px");
      attr(svg, "y", "0px");
      attr(svg, "viewBox", "0 0 100 100");
      attr(svg, "xml:space", "preserve");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(path, animateTransform);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(path, "fill", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$J($$self, $$props, $$invalidate) {
  let { strokeColor = "#000000" } = $$props;
  let { strokeWidth = 4 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
  };
  return [strokeColor, strokeWidth];
}
class Loading extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$J, create_fragment$J, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
function create_fragment$I(ctx) {
  let svg;
  let g4;
  let g3;
  let g1;
  let g0;
  let path;
  let g2;
  let polygon;
  return {
    c() {
      svg = svg_element("svg");
      g4 = svg_element("g");
      g3 = svg_element("g");
      g1 = svg_element("g");
      g0 = svg_element("g");
      path = svg_element("path");
      g2 = svg_element("g");
      polygon = svg_element("polygon");
      attr(path, "d", "M181.512,363.024C81.43,363.024,0,281.601,0,181.513C0,81.424,81.43,0,181.512,0 c100.083,0,181.513,81.424,181.513,181.513C363.025,281.601,281.595,363.024,181.512,363.024z M181.512,11.71 C87.88,11.71,11.71,87.886,11.71,181.513s76.17,169.802,169.802,169.802c93.633,0,169.803-76.175,169.803-169.802 S275.145,11.71,181.512,11.71z");
      attr(polygon, "points", "147.957,258.935 83.068,194.046 91.348,185.767 147.957,242.375 271.171,119.166 279.451,127.445 ");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      attr(svg, "viewBox", "-18.15 -18.15 399.32 399.32");
      attr(svg, "fill", ctx[0]);
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", ctx[1]);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g4);
      append(g4, g3);
      append(g3, g1);
      append(g1, g0);
      append(g0, path);
      append(g3, g2);
      append(g2, polygon);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "fill", ctx2[0]);
      }
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "stroke-width", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$I($$self, $$props, $$invalidate) {
  let { strokeColor = "#000000" } = $$props;
  let { strokeWidth = 8 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
  };
  return [strokeColor, strokeWidth];
}
class TickCircle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$I, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
function create_fragment$H(ctx) {
  let svg;
  let g0;
  let g1;
  let g2;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g0 = svg_element("g");
      g1 = svg_element("g");
      g2 = svg_element("g");
      path = svg_element("path");
      attr(g0, "id", "SVGRepo_bgCarrier");
      attr(g0, "stroke-width", "0");
      attr(g1, "id", "SVGRepo_tracerCarrier");
      attr(g1, "stroke-linecap", "round");
      attr(g1, "stroke-linejoin", "round");
      attr(path, "d", "M166.926,155.377c8.633-10.416,14.741-22.853,17.662-35.965l14.641,3.262c-3.435,15.42-10.612,30.039-20.754,42.275 L166.926,155.377z M162.129,20.796c-12.603-9.675-27.482-16.296-43.03-19.146l-2.705,14.754c13.219,2.424,25.876,8.057,36.6,16.291 L162.129,20.796z M4.476,71.48l14.351,4.365C22.735,62.992,29.764,51.047,39.153,41.3L28.35,30.894 C17.326,42.338,9.07,56.373,4.476,71.48z M33.814,175.861c11.849,10.591,26.185,18.314,41.459,22.332l3.817-14.506 c-12.992-3.419-25.192-9.992-35.281-19.01L33.814,175.861z M12.953,149.881l13.083-7.338c-6.587-11.744-10.334-25.08-10.835-38.564 l-14.989,0.559C0.801,120.389,5.207,136.068,12.953,149.881z M61.936,24.369C74.073,18.152,87.179,15,100.888,15V0 C85.005,0,69.171,3.811,55.097,11.019L61.936,24.369z M200.998,89.399c-1.771-15.729-7.349-31.032-16.13-44.254l-12.495,8.299 c7.469,11.247,12.213,24.261,13.72,37.635L200.998,89.399z M108.462,201.21c15.8-1.181,31.303-6.177,44.832-14.448l-7.824-12.797 c-11.506,7.033-24.689,11.282-38.125,12.286L108.462,201.21z");
      attr(g2, "id", "SVGRepo_iconCarrier");
      attr(svg, "fill", ctx[2]);
      attr(svg, "height", ctx[1]);
      attr(svg, "width", ctx[0]);
      attr(svg, "version", "1.1");
      attr(svg, "id", "Capa_1");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      attr(svg, "viewBox", "0 0 201.21 201.21");
      attr(svg, "xml:space", "preserve");
      attr(svg, "stroke", "#000000");
      attr(svg, "stroke-width", "0.0020121");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g0);
      append(svg, g1);
      append(svg, g2);
      append(g2, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        attr(svg, "fill", ctx2[2]);
      }
      if (dirty & 2) {
        attr(svg, "height", ctx2[1]);
      }
      if (dirty & 1) {
        attr(svg, "width", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let { width = "20px" } = $$props;
  let { height = "20px" } = $$props;
  let { fill = "#000000" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("fill" in $$props2)
      $$invalidate(2, fill = $$props2.fill);
  };
  return [width, height, fill];
}
class DashedCircle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$H, safe_not_equal, { width: 0, height: 1, fill: 2 });
  }
}
function create_fragment$G(ctx) {
  let svg;
  let g4;
  let g3;
  let g1;
  let g0;
  let path;
  let g2;
  return {
    c() {
      svg = svg_element("svg");
      g4 = svg_element("g");
      g3 = svg_element("g");
      g1 = svg_element("g");
      g0 = svg_element("g");
      path = svg_element("path");
      g2 = svg_element("g");
      attr(path, "d", "M181.512,363.024C81.43,363.024,0,281.601,0,181.513C0,81.424,81.43,0,181.512,0 c100.083,0,181.513,81.424,181.513,181.513C363.025,281.601,281.595,363.024,181.512,363.024z M181.512,11.71 C87.88,11.71,11.71,87.886,11.71,181.513s76.17,169.802,169.802,169.802c93.633,0,169.803-76.175,169.803-169.802 S275.145,11.71,181.512,11.71z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      attr(svg, "viewBox", "-18.15 -18.15 399.32 399.32");
      attr(svg, "fill", ctx[0]);
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", ctx[1]);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g4);
      append(g4, g3);
      append(g3, g1);
      append(g1, g0);
      append(g0, path);
      append(g3, g2);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "fill", ctx2[0]);
      }
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "stroke-width", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$G($$self, $$props, $$invalidate) {
  let { strokeColor = "#000000" } = $$props;
  let { strokeWidth = 4 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
  };
  return [strokeColor, strokeWidth];
}
class HollowCircle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$G, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
const get_tip_slot_changes = (dirty) => ({});
const get_tip_slot_context = (ctx) => ({});
function create_else_block$d(ctx) {
  let current;
  const tip_slot_template = ctx[5].tip;
  const tip_slot = create_slot(tip_slot_template, ctx, ctx[4], get_tip_slot_context);
  return {
    c() {
      if (tip_slot)
        tip_slot.c();
    },
    m(target, anchor) {
      if (tip_slot) {
        tip_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tip_slot) {
        if (tip_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            tip_slot,
            tip_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(tip_slot_template, ctx2[4], dirty, get_tip_slot_changes),
            get_tip_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tip_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tip_slot, local);
      current = false;
    },
    d(detaching) {
      if (tip_slot)
        tip_slot.d(detaching);
    }
  };
}
function create_if_block$l(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$F(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block;
  let div0_style_value;
  let t;
  let current;
  const if_block_creators = [create_if_block$l, create_else_block$d];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "bbx-tooltip-text bbx-pad-x");
      attr(div0, "style", div0_style_value = `top: ${ctx[1]}px; left: ${ctx[2]}px; visibility: ${ctx[3] ? "visible" : "hidden"}`);
      attr(div1, "class", "bbx-tooltip");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div1, t);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
      if (!current || dirty & 14 && div0_style_value !== (div0_style_value = `top: ${ctx2[1]}px; left: ${ctx2[2]}px; visibility: ${ctx2[3] ? "visible" : "hidden"}`)) {
        attr(div0, "style", div0_style_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$F($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { tip } = $$props;
  let top = 0;
  let left = 0;
  let visible = false;
  $$self.$$set = ($$props2) => {
    if ("tip" in $$props2)
      $$invalidate(0, tip = $$props2.tip);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [tip, top, left, visible, $$scope, slots];
}
class Tooltip extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$F, create_fragment$F, safe_not_equal, { tip: 0 });
  }
}
function create_if_block_5$3(ctx) {
  let dashedcircle;
  let current;
  dashedcircle = new DashedCircle({ props: { fill: "#6c757d" } });
  return {
    c() {
      create_component(dashedcircle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dashedcircle, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(dashedcircle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dashedcircle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dashedcircle, detaching);
    }
  };
}
function create_if_block_4$4(ctx) {
  let tooltip2;
  let current;
  tooltip2 = new Tooltip({
    props: {
      tip: "Error",
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tooltip2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tooltip2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tooltip_changes = {};
      if (dirty & 4096) {
        tooltip_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip2.$set(tooltip_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tooltip2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tooltip2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tooltip2, detaching);
    }
  };
}
function create_if_block_3$6(ctx) {
  let tooltip2;
  let current;
  tooltip2 = new Tooltip({
    props: {
      tip: "Done",
      $$slots: { default: [create_default_slot_2$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tooltip2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tooltip2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tooltip_changes = {};
      if (dirty & 4096) {
        tooltip_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip2.$set(tooltip_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tooltip2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tooltip2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tooltip2, detaching);
    }
  };
}
function create_if_block_1$b(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$8, create_else_block$c];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    var _a;
    if (dirty & 106)
      show_if = null;
    if (show_if == null)
      show_if = !!(ctx2[3].playing.at(-1) === ctx2[5] || ctx2[1] && !((_a = ctx2[6]) == null ? void 0 : _a.isExpanded()));
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$k(ctx) {
  let tooltip2;
  let current;
  tooltip2 = new Tooltip({
    props: {
      tip: "Error",
      $$slots: { default: [create_default_slot$p] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tooltip2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tooltip2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tooltip_changes = {};
      if (dirty & 4096) {
        tooltip_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tooltip2.$set(tooltip_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tooltip2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tooltip2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tooltip2, detaching);
    }
  };
}
function create_default_slot_3$5(ctx) {
  let cross;
  let current;
  cross = new Cross$1({ props: { strokeColor: "red" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_default_slot_2$8(ctx) {
  let tickcircle;
  let current;
  tickcircle = new TickCircle({
    props: { strokeColor: "green", strokeWidth: 18 }
  });
  return {
    c() {
      create_component(tickcircle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tickcircle, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tickcircle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tickcircle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tickcircle, detaching);
    }
  };
}
function create_else_block$c(ctx) {
  let hollowcircle;
  let current;
  hollowcircle = new HollowCircle({
    props: { strokeColor: "blue", strokeWidth: 18 }
  });
  return {
    c() {
      create_component(hollowcircle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(hollowcircle, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(hollowcircle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hollowcircle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(hollowcircle, detaching);
    }
  };
}
function create_if_block_2$8(ctx) {
  let tooltip2;
  let current;
  tooltip2 = new Tooltip({
    props: {
      tip: "Running",
      $$slots: { default: [create_default_slot_1$f] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tooltip2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tooltip2, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(tooltip2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tooltip2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tooltip2, detaching);
    }
  };
}
function create_default_slot_1$f(ctx) {
  let loading;
  let current;
  loading = new Loading({
    props: { strokeColor: "blue", strokeWidth: 18 }
  });
  return {
    c() {
      create_component(loading.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loading, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(loading.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loading.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loading, detaching);
    }
  };
}
function create_default_slot$p(ctx) {
  let cross;
  let current;
  cross = new Cross$1({ props: { strokeColor: "red" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_fragment$E(ctx) {
  let div;
  let show_if;
  let show_if_1;
  let show_if_2;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [
    create_if_block$k,
    create_if_block_1$b,
    create_if_block_3$6,
    create_if_block_4$4,
    create_if_block_5$3
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a, _b, _c, _d;
    if (dirty & 40)
      show_if = null;
    if (dirty & 40)
      show_if_1 = null;
    if (dirty & 40)
      show_if_2 = null;
    if (ctx2[4])
      return 0;
    if (show_if == null)
      show_if = !!(((_a = ctx2[3]) == null ? void 0 : _a.isPlaying) && ((_b = ctx2[3]) == null ? void 0 : _b.playing.includes(ctx2[5])));
    if (show_if)
      return 1;
    if (show_if_1 == null)
      show_if_1 = !!((_c = ctx2[3]) == null ? void 0 : _c.completed.includes(ctx2[5]));
    if (show_if_1)
      return 2;
    if (show_if_2 == null)
      show_if_2 = !!((_d = ctx2[3]) == null ? void 0 : _d.errored.includes(ctx2[5]));
    if (show_if_2)
      return 3;
    if (ctx2[0].parent instanceof Root || ctx2[2] && (ctx2[0].parent instanceof Block || ctx2[0].parent instanceof Conditional))
      return 4;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let div_levels = [{ class: "bbx-w-full bbx-h-full" }, ctx[8]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { class: "bbx-w-full bbx-h-full" },
        dirty & 256 && ctx2[8]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function instance$E($$self, $$props, $$invalidate) {
  const omit_props_names = ["node", "stNode"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(5, $node = $$value)), node);
  let $replayStatus;
  let $stNode, $$unsubscribe_stNode = noop, $$subscribe_stNode = () => ($$unsubscribe_stNode(), $$unsubscribe_stNode = subscribe$1(stNode, ($$value) => $$invalidate(6, $stNode = $$value)), stNode);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  $$self.$$.on_destroy.push(() => $$unsubscribe_stNode());
  let { node } = $$props;
  $$subscribe_node();
  let { stNode } = $$props;
  $$subscribe_stNode();
  const root = node.root;
  const replayStatus = getContext("replayStatus");
  component_subscribe($$self, replayStatus, (value) => $$invalidate(3, $replayStatus = value));
  let markError = false;
  let runOnce = false;
  root.on("change", updateError);
  function hasError(node2) {
    if (node2 instanceof ErrorExp || node2.error !== void 0) {
      return true;
    }
    return node2.children.some((child) => hasError(child));
  }
  function updateError() {
    $$invalidate(4, markError = hasError($node));
  }
  updateError();
  onDestroy(() => {
    root.off("change", updateError);
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("node" in $$new_props)
      $$subscribe_node($$invalidate(0, node = $$new_props.node));
    if ("stNode" in $$new_props)
      $$subscribe_stNode($$invalidate(1, stNode = $$new_props.stNode));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      if (!runOnce && ($replayStatus == null ? void 0 : $replayStatus.isPlaying)) {
        $$invalidate(2, runOnce = true);
      }
    }
  };
  return [
    node,
    stNode,
    runOnce,
    $replayStatus,
    markError,
    $node,
    $stNode,
    replayStatus,
    $$restProps
  ];
}
class ExpressionStatus extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$E, safe_not_equal, { node: 0, stNode: 1 });
  }
}
const get_children_slot_changes = (dirty) => ({
  node: dirty & 2,
  level: dirty & 4,
  expanded: dirty & 1
});
const get_children_slot_context = (ctx) => ({
  node: ctx[1],
  level: ctx[2],
  expanded: ctx[0]
});
const get_label_slot_changes$1 = (dirty) => ({});
const get_label_slot_context$1 = (ctx) => ({});
const get_menu_items_slot_changes = (dirty) => ({});
const get_menu_items_slot_context = (ctx) => ({
  getRect: ctx[20],
  replaceNode: ctx[21],
  editSource: ctx[18]
});
const get_summary_slot_changes = (dirty) => ({});
const get_summary_slot_context = (ctx) => ({ getRect: ctx[20] });
const get_error_slot_changes = (dirty) => ({ error: dirty & 1024 });
const get_error_slot_context = (ctx) => ({ error: ctx[10] });
function create_else_block$b(ctx) {
  let a;
  let span;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      span = element("span");
      t = text(ctx[8]);
      attr(span, "class", "flex-1");
      attr(a, "href", "#");
      attr(a, "class", "gap-2 bbx-step__header bbx-flex bbx-align-center bbx-h-1 bbx-gap bbx-not-link");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, span);
      append(span, t);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[26]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 256)
        set_data(t, ctx2[8]);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$3(ctx) {
  let replace;
  let current;
  replace = new Replace({
    props: {
      node: ctx[1],
      actionClass: "bbx-step__header bbx-flex bbx-align-center bbx-h-1 bbx-gap\n             bbx-not-link " + (!ctx[5] ? "bbx-cursor-default" : "") + " " + (ctx[15] ? "bbx-red-underline" : ""),
      style: "width: fit-content",
      defaultActionLabel: ctx[8],
      $$slots: { "label-post": [create_label_post_slot$1] },
      $$scope: { ctx }
    }
  });
  replace.$on("close", ctx[28]);
  return {
    c() {
      create_component(replace.$$.fragment);
    },
    m(target, anchor) {
      mount_component(replace, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const replace_changes = {};
      if (dirty & 2)
        replace_changes.node = ctx2[1];
      if (dirty & 32800)
        replace_changes.actionClass = "bbx-step__header bbx-flex bbx-align-center bbx-h-1 bbx-gap\n             bbx-not-link " + (!ctx2[5] ? "bbx-cursor-default" : "") + " " + (ctx2[15] ? "bbx-red-underline" : "");
      if (dirty & 256)
        replace_changes.defaultActionLabel = ctx2[8];
      if (dirty & 536872960) {
        replace_changes.$$scope = { dirty, ctx: ctx2 };
      }
      replace.$set(replace_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(replace.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(replace.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(replace, detaching);
    }
  };
}
function create_label_post_slot$1(ctx) {
  let div;
  let angleright;
  let current;
  angleright = new AngleRight({
    props: { size: "8", strokeColor: "#999" }
  });
  return {
    c() {
      div = element("div");
      create_component(angleright.$$.fragment);
      attr(div, "slot", "label-post");
      attr(div, "class", "bbx-rotate-90");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(angleright, div, null);
      ctx[27](div);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(angleright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(angleright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(angleright);
      ctx[27](null);
    }
  };
}
function create_title_slot(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$3, create_else_block$b];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 2)
      show_if = null;
    if (show_if == null)
      show_if = !!isReplaceable(ctx2[1]);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_label_slot$d(ctx) {
  let current;
  const label_slot_template = ctx[25].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[29], get_label_slot_context$1);
  return {
    c() {
      if (label_slot)
        label_slot.c();
    },
    m(target, anchor) {
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 536870912)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[29],
            !current ? get_all_dirty_from_scope(ctx2[29]) : get_slot_changes(label_slot_template, ctx2[29], dirty, get_label_slot_changes$1),
            get_label_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_status_slot(ctx) {
  let expressionstatus;
  let current;
  expressionstatus = new ExpressionStatus({ props: { node: ctx[1] } });
  return {
    c() {
      create_component(expressionstatus.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expressionstatus, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const expressionstatus_changes = {};
      if (dirty & 2)
        expressionstatus_changes.node = ctx2[1];
      expressionstatus.$set(expressionstatus_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expressionstatus.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expressionstatus.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expressionstatus, detaching);
    }
  };
}
function create_menu_items_slot$h(ctx) {
  let current;
  const menu_items_slot_template = ctx[25]["menu-items"];
  const menu_items_slot = create_slot(menu_items_slot_template, ctx, ctx[29], get_menu_items_slot_context);
  return {
    c() {
      if (menu_items_slot)
        menu_items_slot.c();
    },
    m(target, anchor) {
      if (menu_items_slot) {
        menu_items_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (menu_items_slot) {
        if (menu_items_slot.p && (!current || dirty & 536870912)) {
          update_slot_base(
            menu_items_slot,
            menu_items_slot_template,
            ctx2,
            ctx2[29],
            !current ? get_all_dirty_from_scope(ctx2[29]) : get_slot_changes(menu_items_slot_template, ctx2[29], dirty, get_menu_items_slot_changes),
            get_menu_items_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu_items_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menu_items_slot, local);
      current = false;
    },
    d(detaching) {
      if (menu_items_slot)
        menu_items_slot.d(detaching);
    }
  };
}
function create_summary_slot$e(ctx) {
  let current;
  const summary_slot_template = ctx[25].summary;
  const summary_slot = create_slot(summary_slot_template, ctx, ctx[29], get_summary_slot_context);
  return {
    c() {
      if (summary_slot)
        summary_slot.c();
    },
    m(target, anchor) {
      if (summary_slot) {
        summary_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (summary_slot) {
        if (summary_slot.p && (!current || dirty & 536870912)) {
          update_slot_base(
            summary_slot,
            summary_slot_template,
            ctx2,
            ctx2[29],
            !current ? get_all_dirty_from_scope(ctx2[29]) : get_slot_changes(summary_slot_template, ctx2[29], dirty, get_summary_slot_changes),
            get_summary_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(summary_slot, local);
      current = true;
    },
    o(local) {
      transition_out(summary_slot, local);
      current = false;
    },
    d(detaching) {
      if (summary_slot)
        summary_slot.d(detaching);
    }
  };
}
function create_if_block_3$5(ctx) {
  let div;
  let t_value = ctx[9].error.code + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 512 && t_value !== (t_value = ctx2[9].error.code + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$7(ctx) {
  let div;
  let t_value = ctx[10].message + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && t_value !== (t_value = ctx2[10].message + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function fallback_block(ctx) {
  let t;
  let if_block1_anchor;
  let if_block0 = ctx[9].error && create_if_block_3$5(ctx);
  let if_block1 = ctx[10] && create_if_block_2$7(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[9].error) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$5(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[10]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$7(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_error_slot$3(ctx) {
  let current;
  const error_slot_template = ctx[25].error;
  const error_slot = create_slot(error_slot_template, ctx, ctx[29], get_error_slot_context);
  const error_slot_or_fallback = error_slot || fallback_block(ctx);
  return {
    c() {
      if (error_slot_or_fallback)
        error_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (error_slot_or_fallback) {
        error_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (error_slot) {
        if (error_slot.p && (!current || dirty & 536871936)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            ctx2[29],
            !current ? get_all_dirty_from_scope(ctx2[29]) : get_slot_changes(error_slot_template, ctx2[29], dirty, get_error_slot_changes),
            get_error_slot_context
          );
        }
      } else {
        if (error_slot_or_fallback && error_slot_or_fallback.p && (!current || dirty & 1536)) {
          error_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(error_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(error_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (error_slot_or_fallback)
        error_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block_1$a(ctx) {
  let current;
  const children_slot_template = ctx[25].children;
  const children_slot = create_slot(children_slot_template, ctx, ctx[29], get_children_slot_context);
  return {
    c() {
      if (children_slot)
        children_slot.c();
    },
    m(target, anchor) {
      if (children_slot) {
        children_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (children_slot) {
        if (children_slot.p && (!current || dirty & 536870919)) {
          update_slot_base(
            children_slot,
            children_slot_template,
            ctx2,
            ctx2[29],
            !current ? get_all_dirty_from_scope(ctx2[29]) : get_slot_changes(children_slot_template, ctx2[29], dirty, get_children_slot_changes),
            get_children_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(children_slot, local);
      current = true;
    },
    o(local) {
      transition_out(children_slot, local);
      current = false;
    },
    d(detaching) {
      if (children_slot)
        children_slot.d(detaching);
    }
  };
}
function create_if_block$j(ctx) {
  let sourceeditor;
  let current;
  sourceeditor = new SourceEditor({
    props: {
      errorMessage: ctx[13],
      source: ctx[9].toJSON(),
      rect: ctx[20]()
    }
  });
  sourceeditor.$on("cancel", ctx[17]);
  sourceeditor.$on("save", ctx[22]);
  return {
    c() {
      create_component(sourceeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sourceeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sourceeditor_changes = {};
      if (dirty & 8192)
        sourceeditor_changes.errorMessage = ctx2[13];
      if (dirty & 512)
        sourceeditor_changes.source = ctx2[9].toJSON();
      sourceeditor.$set(sourceeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sourceeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sourceeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sourceeditor, detaching);
    }
  };
}
function create_fragment$D(ctx) {
  let node_1;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  node_1 = new Node$2({
    props: {
      node: ctx[1],
      compact: ctx[3],
      expanded: ctx[0],
      showExpandIcon: ctx[4],
      highlight: ctx[6],
      hideSummaryRow: ctx[7],
      hasError: !!(ctx[9].error || ctx[10]),
      indent: "calc(var(--bbx-gap) * 2 * " + ctx[2] + ")",
      $$slots: {
        error: [create_error_slot$3],
        summary: [create_summary_slot$e],
        "menu-items": [create_menu_items_slot$h],
        status: [create_status_slot],
        label: [create_label_slot$d],
        title: [create_title_slot]
      },
      $$scope: { ctx }
    }
  });
  node_1.$on("toggleExpand", ctx[19]);
  let if_block0 = ctx[0] && create_if_block_1$a(ctx);
  let if_block1 = ctx[14] && create_if_block$j(ctx);
  return {
    c() {
      create_component(node_1.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(node_1, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const node_1_changes = {};
      if (dirty & 2)
        node_1_changes.node = ctx2[1];
      if (dirty & 8)
        node_1_changes.compact = ctx2[3];
      if (dirty & 1)
        node_1_changes.expanded = ctx2[0];
      if (dirty & 16)
        node_1_changes.showExpandIcon = ctx2[4];
      if (dirty & 64)
        node_1_changes.highlight = ctx2[6];
      if (dirty & 128)
        node_1_changes.hideSummaryRow = ctx2[7];
      if (dirty & 1536)
        node_1_changes.hasError = !!(ctx2[9].error || ctx2[10]);
      if (dirty & 4)
        node_1_changes.indent = "calc(var(--bbx-gap) * 2 * " + ctx2[2] + ")";
      if (dirty & 536911650) {
        node_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      node_1.$set(node_1_changes);
      if (ctx2[0]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$a(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[14]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 16384) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$j(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(node_1.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(node_1.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(node_1, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function containsError(node) {
  if (node.type === "ERROR" || node.error)
    return true;
  return node.children.some(containsError);
}
function instance$D($$self, $$props, $$invalidate) {
  let isExpWithErr;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(9, $node = $$value)), node);
  let $replayStatus;
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { compact = false } = $$props;
  let { expanded = false } = $$props;
  let { isExpandable = $node.children.length > 0 || hasOptionals($node) } = $$props;
  let { keepExpanded = false } = $$props;
  let { replaceable = true } = $$props;
  let { highlight = false } = $$props;
  let { hideSummaryRow = false } = $$props;
  let { title } = $$props;
  const replayStatus = getContext("replayStatus");
  component_subscribe($$self, replayStatus, (value) => $$invalidate(24, $replayStatus = value));
  let error;
  let rowComponent;
  let showNodeReplacementWizard = false;
  let sourceEditError;
  let sourceEditMode = false;
  function cancelSourceEdit() {
    $$invalidate(13, sourceEditError = void 0);
    $$invalidate(14, sourceEditMode = false);
  }
  function editSource() {
    $$invalidate(13, sourceEditError = void 0);
    $$invalidate(14, sourceEditMode = true);
  }
  function expandChildren() {
    if (isExpandable)
      $$invalidate(0, expanded = !expanded || keepExpanded);
  }
  function getRect2() {
    let { left, top, right } = rowComponent.getBoundingClientRect();
    return {
      left: left - 10,
      top: top - 10,
      right: right - 10
    };
  }
  function replaceNode2() {
    if (isReplaceable($node)) {
      $$invalidate(12, showNodeReplacementWizard = true);
    }
  }
  function saveSource({ detail }) {
    try {
      node.parent.replace(node, detail);
    } catch (e) {
      console.error(e);
      $$invalidate(13, sourceEditError = e.message);
      return;
    }
    $$invalidate(13, sourceEditError = void 0);
    $$invalidate(14, sourceEditMode = false);
  }
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rowComponent = $$value;
      $$invalidate(11, rowComponent);
    });
  }
  const close_handler = () => $$invalidate(12, showNodeReplacementWizard = false);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(1, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(2, level = $$props2.level);
    if ("compact" in $$props2)
      $$invalidate(3, compact = $$props2.compact);
    if ("expanded" in $$props2)
      $$invalidate(0, expanded = $$props2.expanded);
    if ("isExpandable" in $$props2)
      $$invalidate(4, isExpandable = $$props2.isExpandable);
    if ("keepExpanded" in $$props2)
      $$invalidate(23, keepExpanded = $$props2.keepExpanded);
    if ("replaceable" in $$props2)
      $$invalidate(5, replaceable = $$props2.replaceable);
    if ("highlight" in $$props2)
      $$invalidate(6, highlight = $$props2.highlight);
    if ("hideSummaryRow" in $$props2)
      $$invalidate(7, hideSummaryRow = $$props2.hideSummaryRow);
    if ("title" in $$props2)
      $$invalidate(8, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(29, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16777728) {
      if ($replayStatus == null ? void 0 : $replayStatus.error) {
        let erroredNode = $replayStatus.errored.at(-1);
        if ($node === erroredNode) {
          $$invalidate(10, error = $replayStatus.error);
        } else if ($replayStatus.errored.includes($node)) {
          $$invalidate(0, expanded = true);
        } else {
          $$invalidate(10, error = void 0);
        }
      } else {
        $$invalidate(10, error = void 0);
      }
    }
    if ($$self.$$.dirty & 512) {
      $$invalidate(15, isExpWithErr = containsError($node));
    }
  };
  return [
    expanded,
    node,
    level,
    compact,
    isExpandable,
    replaceable,
    highlight,
    hideSummaryRow,
    title,
    $node,
    error,
    rowComponent,
    showNodeReplacementWizard,
    sourceEditError,
    sourceEditMode,
    isExpWithErr,
    replayStatus,
    cancelSourceEdit,
    editSource,
    expandChildren,
    getRect2,
    replaceNode2,
    saveSource,
    keepExpanded,
    $replayStatus,
    slots,
    click_handler2,
    div_binding,
    close_handler,
    $$scope
  ];
}
class Expression extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$D, safe_not_equal, {
      node: 1,
      level: 2,
      compact: 3,
      expanded: 0,
      isExpandable: 4,
      keepExpanded: 23,
      replaceable: 5,
      highlight: 6,
      hideSummaryRow: 7,
      title: 8
    });
  }
}
function create_fragment$C(ctx) {
  let svg;
  let g;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      path = svg_element("path");
      attr(path, "d", "M31.449 6.748c-0.337-0.155-0.737-0.096-1.017 0.152l-5.041 4.528-4.551-4.669 4.506-5.204c0.245-0.283 0.305-0.673 0.152-1.016s-0.489-0.553-0.86-0.553h-0.271c-2.785 0-7.593 0.239-9.739 2.417l-0.433 0.43c-2.29 2.337-2.697 6.168-1.49 9.081l-11.54 11.778c-1.556 1.578-1.556 4.135 0 5.713l1.409 1.428c0.778 0.788 1.798 1.183 2.818 1.183s2.040-0.395 2.817-1.183l11.71-11.804c1.107 0.599 2.625 0.989 3.899 0.989 2.043 0 3.98-0.824 5.454-2.32l0.427-0.433c2.331-2.364 2.296-7.416 2.306-9.638 0.001-0.378-0.216-0.721-0.554-0.878zM28.302 15.906l-0.371 0.433c-1.117 1.134-2.578 1.677-4.114 1.677-0.76 0-1.784-0.143-2.476-0.431-0.625-0.259-1.206-0.634-1.725-1.107l-12.818 12.925c-0.376 0.382-0.876 0.592-1.408 0.592s-1.032-0.21-1.409-0.592l-1.408-1.427c-0.777-0.788-0.777-2.070-0.001-2.857l12.524-12.777c-0.42-0.611-0.706-1.278-0.877-1.968h-0.001c-0.482-1.95-0.201-4.644 1.313-6.189l0.431-0.435c1.298-1.317 4.67-1.707 6.537-1.822l-3.668 4.236c-0.328 0.379-0.311 0.95 0.038 1.309l5.798 5.948c0.352 0.362 0.92 0.383 1.299 0.047l4.082-3.676c-0.122 1.98-0.506 4.856-1.748 6.115z");
      attr(svg, "fill", "#000000");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "stroke", ctx[0]);
      attr(svg, "stroke-width", ctx[1]);
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "stroke", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "stroke-width", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let { strokeColor = "#000000" } = $$props;
  let { strokeWidth = 2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("strokeWidth" in $$props2)
      $$invalidate(1, strokeWidth = $$props2.strokeWidth);
  };
  return [strokeColor, strokeWidth];
}
class Wrench extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$C, safe_not_equal, { strokeColor: 0, strokeWidth: 1 });
  }
}
function create_if_block$i(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<a href="javascript:void(0)">Set optional Arguments</a>`;
      attr(div0, "class", "bbx-expand-angle bbx-pad");
      attr(div1, "class", "bbx-pad-y");
      attr(div2, "class", "bbx-flex bbx-center bbx-border bbx-rounded");
      set_style(div2, "margin-left", "calc(var(--bbx-gap) * 2 * " + ctx[1] + ")");
      set_style(div2, "background-color", "var(--bbx-color-menu-bg)");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t0);
      append(div2, div1);
      if (!mounted) {
        dispose = listen(div1, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        set_style(div2, "margin-left", "calc(var(--bbx-gap) * 2 * " + ctx2[1] + ")");
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$B(ctx) {
  let if_block_anchor;
  let if_block = ctx[3] > 0 && create_if_block$i(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[3] > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$i(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(2, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node } = $$props;
  $$subscribe_node();
  let { level } = $$props;
  let noOfUnsetOptionals;
  const click_handler2 = () => $node.setAllOptional();
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      {
        if ($node.type === C.FUNCTION_CALL) {
          $$invalidate(3, noOfUnsetOptionals = Object.keys($node.scope.getFunc($node.name).args).length - $node.argList.length);
        } else {
          $$invalidate(3, noOfUnsetOptionals = Object.keys($node.scope.getStruct($node.name).fields).length - $node.fields.size);
        }
      }
    }
  };
  return [node, level, $node, noOfUnsetOptionals, click_handler2];
}
class SetOptional extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$B, safe_not_equal, { node: 0, level: 1 });
  }
}
function create_fragment$A(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", ctx[0]);
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(path, "d", "M10.0002 5H8.2002C7.08009 5 6.51962 5 6.0918 5.21799C5.71547 5.40973 5.40973 5.71547 5.21799 6.0918C5 6.51962 5 7.08009 5 8.2002V15.8002C5 16.9203 5 17.4801 5.21799 17.9079C5.40973 18.2842 5.71547 18.5905 6.0918 18.7822C6.5192 19 7.07899 19 8.19691 19H15.8031C16.921 19 17.48 19 17.9074 18.7822C18.2837 18.5905 18.5905 18.2839 18.7822 17.9076C19 17.4802 19 16.921 19 15.8031V14M20 9V4M20 4H15M20 4L13 11");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(path, "stroke", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$A($$self, $$props, $$invalidate) {
  let { strokeColor = "#000000" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
  };
  return [strokeColor];
}
class External extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$A, safe_not_equal, { strokeColor: 0 });
  }
}
const get_parent_context_menu_slot_changes$d = (dirty) => ({ getRect: dirty & 1048576 });
const get_parent_context_menu_slot_context$d = (ctx) => ({ getRect: ctx[20] });
function create_default_slot_1$e(ctx) {
  let external;
  let current;
  external = new External({});
  return {
    c() {
      create_component(external.$$.fragment);
    },
    m(target, anchor) {
      mount_component(external, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(external.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(external.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(external, detaching);
    }
  };
}
function create_summary_slot$d(ctx) {
  let div2;
  let div0;
  let t0_value = ctx[7](ctx[4].argList[0].value) + "";
  let t0;
  let t1;
  let div1;
  let iconbtn;
  let current;
  let mounted;
  let dispose;
  iconbtn = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot_1$e] },
      $$scope: { ctx }
    }
  });
  iconbtn.$on("click", ctx[10]);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      create_component(iconbtn.$$.fragment);
      attr(div0, "class", "bbx-inline-editable");
      attr(div2, "class", "bbx-flex bbx-gap bbx-align-center");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      mount_component(iconbtn, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[11]),
          listen(div0, "keydown", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 16) && t0_value !== (t0_value = ctx2[7](ctx2[4].argList[0].value) + ""))
        set_data(t0, t0_value);
      const iconbtn_changes = {};
      if (dirty & 16384) {
        iconbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn.$set(iconbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(iconbtn);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$o(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$g(ctx) {
  let menuitem;
  let t;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$o] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", function() {
    if (is_function(ctx[22]))
      ctx[22].apply(this, arguments);
  });
  const parent_context_menu_slot_template = ctx[12]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[14], get_parent_context_menu_slot_context$d);
  return {
    c() {
      create_component(menuitem.$$.fragment);
      t = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      insert(target, t, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 16384) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 1064960)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[14],
            !current ? get_all_dirty_from_scope(ctx[14]) : get_slot_changes(parent_context_menu_slot_template, ctx[14], dirty, get_parent_context_menu_slot_changes$d),
            get_parent_context_menu_slot_context$d
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_if_block$h(ctx) {
  let searchselect;
  let current;
  searchselect = new SearchSelect({
    props: {
      value: "",
      rect: ctx[6].getBoundingClientRect(),
      options: ctx[5].models.map(func$1),
      labels: ctx[5].models.map(func_1),
      addNew: true
    }
  });
  searchselect.$on("select", ctx[9]);
  searchselect.$on("create", ctx[8]);
  searchselect.$on("cancel", ctx[13]);
  return {
    c() {
      create_component(searchselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchselect, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(searchselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchselect, detaching);
    }
  };
}
function create_fragment$z(ctx) {
  let expression;
  let t;
  let if_block_anchor;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[1],
      highlight: ctx[2],
      isExpandable: false,
      title: ctx[4].name,
      $$slots: {
        "menu-items": [
          create_menu_items_slot$g,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            20: getRect2,
            21: replaceNode2,
            22: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 1048576 : 0) | (replaceNode2 ? 2097152 : 0) | (editSource ? 4194304 : 0)
        ],
        summary: [create_summary_slot$d]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[3] && create_if_block$h(ctx);
  return {
    c() {
      create_component(expression.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 2)
        expression_changes.level = ctx2[1];
      if (dirty & 4)
        expression_changes.highlight = ctx2[2];
      if (dirty & 16)
        expression_changes.title = ctx2[4].name;
      if (dirty & 5259280) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$h(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
const func$1 = (s) => s.get("id");
const func_1 = (s) => s.get("name");
function instance$z($$self, $$props, $$invalidate) {
  let $schemaList;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(4, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  const schemaList = getContext("schemaList");
  component_subscribe($$self, schemaList, (value) => $$invalidate(15, $schemaList = value));
  const createSchema = getContext("createSchema");
  const setActiveSchema = getContext("setActiveSchema");
  const setTagMode = getContext("setTagMode");
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { highlight = false } = $$props;
  let replaceSchema = false;
  let titleComponent;
  function getSchemaName(schemaId) {
    return $schemaList.filter((s) => s.get("id") === schemaId)[0].get("name");
  }
  function onCreate({ detail }) {
    $$invalidate(3, replaceSchema = false);
    node.replace(node.argList[0], createSchema(detail).get("id"));
  }
  function onSelectId({ detail }) {
    $$invalidate(3, replaceSchema = false);
    node.replace(node.argList[0], detail);
  }
  function openSchemaForEdit() {
    let schema = $schemaList.filter((s) => s.get("id") === node.argList[0].value)[0];
    setActiveSchema(schema);
    setTagMode(true);
  }
  function setReplaceSchema(e) {
    if (e.type !== "click" && (e.type !== "keydown" || e.key !== "Enter"))
      return;
    $$invalidate(3, replaceSchema = true);
  }
  const cancel_handler = () => $$invalidate(3, replaceSchema = false);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("highlight" in $$props2)
      $$invalidate(2, highlight = $$props2.highlight);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  return [
    node,
    level,
    highlight,
    replaceSchema,
    $node,
    schemaList,
    titleComponent,
    getSchemaName,
    onCreate,
    onSelectId,
    openSchemaForEdit,
    setReplaceSchema,
    slots,
    cancel_handler,
    $$scope
  ];
}
class Scrape extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$z, safe_not_equal, { node: 0, level: 1, highlight: 2 });
  }
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  child_ctx[24] = i;
  return child_ctx;
}
const get_parent_context_menu_slot_changes_1 = (dirty) => ({ getRect: dirty & 2097152 });
const get_parent_context_menu_slot_context_1 = (ctx) => ({ getRect: ctx[21] });
function get_each_context$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  child_ctx[24] = i;
  return child_ctx;
}
const get_parent_context_menu_slot_changes$c = (dirty) => ({ getRect: dirty & 2097152 });
const get_parent_context_menu_slot_context$c = (ctx) => ({ getRect: ctx[21] });
function create_else_block$a(ctx) {
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[1],
      compact: ctx[3],
      highlight: ctx[4],
      title: ctx[0].name,
      $$slots: {
        children: [create_children_slot$a],
        "menu-items": [
          create_menu_items_slot$f,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            21: getRect2,
            25: replaceNode2,
            26: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 2097152 : 0) | (replaceNode2 ? 33554432 : 0) | (editSource ? 67108864 : 0)
        ],
        error: [
          create_error_slot$2,
          ({ error }) => ({ 27: error }),
          ({ error }) => error ? 134217728 : 0
        ],
        summary: [create_summary_slot$c],
        label: [create_label_slot$c]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 2)
        expression_changes.level = ctx2[1];
      if (dirty & 8)
        expression_changes.compact = ctx2[3];
      if (dirty & 16)
        expression_changes.highlight = ctx2[4];
      if (dirty & 1)
        expression_changes.title = ctx2[0].name;
      if (dirty & 204488687) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function create_if_block$g(ctx) {
  let scrape;
  let current;
  scrape = new Scrape({
    props: {
      node: ctx[0],
      level: ctx[1],
      highlight: ctx[4],
      $$slots: {
        "parent-context-menu": [
          create_parent_context_menu_slot$3,
          ({ getRect: getRect2 }) => ({ 21: getRect2 }),
          ({ getRect: getRect2 }) => getRect2 ? 2097152 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(scrape.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scrape, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const scrape_changes = {};
      if (dirty & 1)
        scrape_changes.node = ctx2[0];
      if (dirty & 2)
        scrape_changes.level = ctx2[1];
      if (dirty & 16)
        scrape_changes.highlight = ctx2[4];
      if (dirty & 3145728) {
        scrape_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scrape.$set(scrape_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scrape.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scrape.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scrape, detaching);
    }
  };
}
function create_if_block_8$1(ctx) {
  let span;
  let t;
  let tooltip_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
      if (!mounted) {
        dispose = action_destroyer(tooltip_action = tooltip.call(null, span, ctx[5].join(" | ")));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
      if (tooltip_action && is_function(tooltip_action.update) && dirty & 32)
        tooltip_action.update.call(null, ctx2[5].join(" | "));
    },
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_label_slot$c(ctx) {
  let if_block_anchor;
  let if_block = ctx[2] && create_if_block_8$1(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_8$1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_7$1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block_1(key_1, ctx) {
  let first;
  let switch_instance;
  let t;
  let if_block_anchor;
  let current;
  var switch_value = inlineByType(ctx[22]);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[22],
        label: ctx2[12][ctx2[24]].name
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  let if_block = ctx[24] < ctx[13].length - 1 && create_if_block_7$1();
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty & 8192)
        switch_instance_changes.node = ctx[22];
      if (dirty & 12288)
        switch_instance_changes.label = ctx[12][ctx[24]].name;
      if (dirty & 8192 && switch_value !== (switch_value = inlineByType(ctx[22]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if (ctx[24] < ctx[13].length - 1) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_7$1();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_summary_slot$c(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[13];
  const get_key = (ctx2) => ctx2[22];
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 12288) {
        each_value_1 = ctx2[13];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1, each_1_anchor, get_each_context_1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_5$2(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_6$2, create_else_block_2$1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[14])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "d-flex bbx-error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_else_block_2$1(ctx) {
  let span;
  let t_value = ctx[27].message + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 134217728 && t_value !== (t_value = ctx2[27].message + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_6$2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[14];
  function switch_props(ctx2) {
    return { props: { error: ctx2[27] } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 134217728)
        switch_instance_changes.error = ctx2[27];
      if (switch_value !== (switch_value = ctx2[14])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_2$6(ctx) {
  var _a, _b;
  let show_if = ctx[27] && ((_a = ctx[27].stackEx) == null ? void 0 : _a.length) === 1 && ((_b = ctx[27]) == null ? void 0 : _b.message.startsWith("Timeout 30000ms exceeded."));
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_3$4(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & 134217728)
        show_if = ctx2[27] && ((_a2 = ctx2[27].stackEx) == null ? void 0 : _a2.length) === 1 && ((_b2 = ctx2[27]) == null ? void 0 : _b2.message.startsWith("Timeout 30000ms exceeded."));
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 134217728) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3$4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$2, create_else_block_1$2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[10])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_1$2(ctx) {
  let a;
  let div1;
  let t;
  let div0;
  let wrench;
  let current;
  let mounted;
  let dispose;
  wrench = new Wrench({});
  return {
    c() {
      a = element("a");
      div1 = element("div");
      t = text("Fix Selector\n                ");
      div0 = element("div");
      create_component(wrench.$$.fragment);
      set_style(div0, "width", "10px");
      set_style(div0, "height", "10px");
      attr(div1, "class", "bbx-recommend bbx-editable active");
      attr(a, "href", "javascript:void(0)");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, div1);
      append(div1, t);
      append(div1, div0);
      mount_component(wrench, div0, null);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", ctx[15]);
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(wrench.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(wrench.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      destroy_component(wrench);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$2(ctx) {
  let editselector;
  let current;
  editselector = new Selector({
    props: {
      value: ctx[8],
      type: ctx[9],
      frame: ctx[7]
    }
  });
  editselector.$on("save", ctx[16]);
  editselector.$on("cancel", ctx[19]);
  return {
    c() {
      create_component(editselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editselector_changes = {};
      if (dirty & 256)
        editselector_changes.value = ctx2[8];
      if (dirty & 512)
        editselector_changes.type = ctx2[9];
      if (dirty & 128)
        editselector_changes.frame = ctx2[7];
      editselector.$set(editselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editselector, detaching);
    }
  };
}
function create_error_slot$2(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[27] && create_if_block_5$2(ctx);
  let if_block1 = !ctx[11] && create_if_block_2$6(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[27]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 134217728) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[11]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_default_slot_1$d(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$f(ctx) {
  let menuitem;
  let t;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$d] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", function() {
    if (is_function(ctx[26]))
      ctx[26].apply(this, arguments);
  });
  const parent_context_menu_slot_template = ctx[17]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[20], get_parent_context_menu_slot_context_1);
  return {
    c() {
      create_component(menuitem.$$.fragment);
      t = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      insert(target, t, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 1048576) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 3145728)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[20],
            !current ? get_all_dirty_from_scope(ctx[20]) : get_slot_changes(parent_context_menu_slot_template, ctx[20], dirty, get_parent_context_menu_slot_changes_1),
            get_parent_context_menu_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_if_block_1$9(ctx) {
  let menuitem;
  let current;
  function click_handler2() {
    return ctx[18](ctx[22]);
  }
  menuitem = new MenuItem({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$n] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", click_handler2);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 1048576) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot$n(ctx) {
  let t;
  return {
    c() {
      t = text("Remove Optional Argument");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_parent_context_menu_slot_1(ctx) {
  let show_if = isOptionalNode(ctx[22]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_1$9(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 64)
        show_if = isOptionalNode(ctx2[22]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_each_block$8(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = getComponent(ctx[22]);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[22],
        level: ctx2[1] + 1,
        label: ctx2[12][ctx2[24]].name,
        types: ctx2[12][ctx2[24]].types,
        compact: ctx2[3],
        $$slots: {
          "parent-context-menu": [
            create_parent_context_menu_slot_1,
            ({ getRect: getRect2 }) => ({ 21: getRect2 }),
            ({ getRect: getRect2 }) => getRect2 ? 2097152 : 0
          ]
        },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty & 64)
        switch_instance_changes.node = ctx[22];
      if (dirty & 2)
        switch_instance_changes.level = ctx[1] + 1;
      if (dirty & 4160)
        switch_instance_changes.label = ctx[12][ctx[24]].name;
      if (dirty & 4160)
        switch_instance_changes.types = ctx[12][ctx[24]].types;
      if (dirty & 8)
        switch_instance_changes.compact = ctx[3];
      if (dirty & 1048640) {
        switch_instance_changes.$$scope = { dirty, ctx };
      }
      if (dirty & 64 && switch_value !== (switch_value = getComponent(ctx[22]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_children_slot$a(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let setoptional;
  let current;
  let each_value = ctx[6].argList;
  const get_key = (ctx2) => ctx2[22];
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$8(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
  }
  setoptional = new SetOptional({
    props: {
      node: ctx[0],
      level: ctx[1] + 1
    }
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      create_component(setoptional.$$.fragment);
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, t, anchor);
      mount_component(setoptional, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 4170) {
        each_value = ctx2[6].argList;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block$8, t, get_each_context$8);
        check_outros();
      }
      const setoptional_changes = {};
      if (dirty & 1)
        setoptional_changes.node = ctx2[0];
      if (dirty & 2)
        setoptional_changes.level = ctx2[1] + 1;
      setoptional.$set(setoptional_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(setoptional.$$.fragment, local);
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(setoptional.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(t);
      destroy_component(setoptional, detaching);
    }
  };
}
function create_parent_context_menu_slot$3(ctx) {
  let current;
  const parent_context_menu_slot_template = ctx[17]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[20], get_parent_context_menu_slot_context$c);
  return {
    c() {
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 3145728)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(parent_context_menu_slot_template, ctx2[20], dirty, get_parent_context_menu_slot_changes$c),
            get_parent_context_menu_slot_context$c
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_fragment$y(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$g, create_else_block$a];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6].name === "scrape")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$y($$self, $$props, $$invalidate) {
  let summaryChildren;
  let args;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(6, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  const errorMessageComponent = getContext("errorMessageComponent");
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label = void 0 } = $$props;
  let { compact = false } = $$props;
  let { highlight = false } = $$props;
  let { types: types2 = [] } = $$props;
  let editFrame, editSelectorValue, editSelectorType;
  let editMode = false;
  let fixedSelector = false;
  async function fixSelection() {
    let selectorNode = getSelectorNode($node);
    if (selectorNode) {
      $$invalidate(7, editFrame = getFrameIndex($node));
      let selector = selectorNode.toJSON()[1];
      $$invalidate(8, editSelectorValue = selector.value);
      $$invalidate(9, editSelectorType = selector.type);
      $$invalidate(10, editMode = true);
    }
  }
  function updateSelector({ detail }) {
    let selectorNode = getSelectorNode($node);
    if (selectorNode) {
      setFrame($node, detail.frame);
      $node.replace(selectorNode, [
        "selector",
        {
          value: escapeDollar(detail.value),
          type: detail.type,
          meta: {}
        }
      ]);
      $$invalidate(11, fixedSelector = true);
      $$invalidate(10, editMode = false);
    }
  }
  const click_handler2 = (child) => child.parent.removeOptional(child);
  const cancel_handler = () => $$invalidate(10, editMode = false);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("compact" in $$props2)
      $$invalidate(3, compact = $$props2.compact);
    if ("highlight" in $$props2)
      $$invalidate(4, highlight = $$props2.highlight);
    if ("types" in $$props2)
      $$invalidate(5, types2 = $$props2.types);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      $$invalidate(13, summaryChildren = $node.argList.filter((child) => !isOptionalNode(child)));
    }
    if ($$self.$$.dirty & 64) {
      $$invalidate(12, args = Object.entries($node.scope.getFunc($node.name).args).map(([argName, def]) => ({ name: argName, types: def.types })));
    }
  };
  return [
    node,
    level,
    label,
    compact,
    highlight,
    types2,
    $node,
    editFrame,
    editSelectorValue,
    editSelectorType,
    editMode,
    fixedSelector,
    args,
    summaryChildren,
    errorMessageComponent,
    fixSelection,
    updateSelector,
    slots,
    click_handler2,
    cancel_handler,
    $$scope
  ];
}
class FunctionCall extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$y, safe_not_equal, {
      node: 0,
      level: 1,
      label: 2,
      compact: 3,
      highlight: 4,
      types: 5
    });
  }
}
const get_parent_context_menu_slot_changes$b = (dirty) => ({ getRect: dirty & 67108864 });
const get_parent_context_menu_slot_context$b = (ctx) => ({ getRect: ctx[26] });
function get_each_context$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i][0];
  child_ctx[23] = list[i][1];
  return child_ctx;
}
function create_label_slot$b(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[4]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        set_data(t, ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block_1$1(ctx) {
  let t_value = getSummary(ctx[10]) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && t_value !== (t_value = getSummary(ctx2[10]) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$5, create_else_block$9];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$9(ctx) {
  let div;
  let t_value = getSummary(ctx[10]) + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-inline-editable");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (!mounted) {
        dispose = [
          listen(div, "mouseenter", ctx[18]),
          listen(div, "mouseleave", ctx[19]),
          listen(div, "click", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && t_value !== (t_value = getSummary(ctx2[10]) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$5(ctx) {
  let editselector;
  let current;
  editselector = new Selector({
    props: {
      value: ctx[8],
      type: ctx[9],
      frame: ctx[7]
    }
  });
  editselector.$on("save", ctx[12]);
  editselector.$on("cancel", ctx[17]);
  return {
    c() {
      create_component(editselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editselector_changes = {};
      if (dirty & 256)
        editselector_changes.value = ctx2[8];
      if (dirty & 512)
        editselector_changes.type = ctx2[9];
      if (dirty & 128)
        editselector_changes.frame = ctx2[7];
      editselector.$set(editselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editselector, detaching);
    }
  };
}
function create_summary_slot$b(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$8, create_else_block_1$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 1)
      show_if = null;
    if (show_if == null)
      show_if = !!(ctx2[0].name === "selector" && ctx2[0].fields.get("value") instanceof Literal$3);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_2$7(ctx) {
  let t;
  return {
    c() {
      t = text("Replace");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$c(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$e(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let current;
  function click_handler_1() {
    return ctx[15](ctx[27]);
  }
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_2$7] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", click_handler_1);
  function click_handler_2() {
    return ctx[16](ctx[28]);
  }
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$c] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", click_handler_2);
  const parent_context_menu_slot_template = ctx[13]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[20], get_parent_context_menu_slot_context$b);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem0_changes = {};
      if (dirty & 1048576) {
        menuitem0_changes.$$scope = { dirty, ctx };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 1048576) {
        menuitem1_changes.$$scope = { dirty, ctx };
      }
      menuitem1.$set(menuitem1_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 68157440)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[20],
            !current ? get_all_dirty_from_scope(ctx[20]) : get_slot_changes(parent_context_menu_slot_template, ctx[20], dirty, get_parent_context_menu_slot_changes$b),
            get_parent_context_menu_slot_context$b
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_if_block$f(ctx) {
  let menuitem;
  let current;
  function click_handler2() {
    return ctx[14](ctx[23]);
  }
  menuitem = new MenuItem({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$m] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", click_handler2);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 1048576) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot$m(ctx) {
  let t;
  return {
    c() {
      t = text("Remove Optional Field");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_parent_context_menu_slot$2(ctx) {
  let show_if = isOptionalNode(ctx[23]);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block$f(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1024)
        show_if = isOptionalNode(ctx2[23]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$f(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_each_block$7(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = getComponent(ctx[23]);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[23],
        level: ctx2[1] + 1,
        label: ctx2[4],
        compact: ctx2[2],
        $$slots: {
          "parent-context-menu": [
            create_parent_context_menu_slot$2,
            ({ getRect: getRect2 }) => ({ 26: getRect2 }),
            ({ getRect: getRect2 }) => getRect2 ? 67108864 : 0
          ]
        },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty & 1024)
        switch_instance_changes.node = ctx[23];
      if (dirty & 2)
        switch_instance_changes.level = ctx[1] + 1;
      if (dirty & 1024)
        switch_instance_changes.label = ctx[4];
      if (dirty & 4)
        switch_instance_changes.compact = ctx[2];
      if (dirty & 1049600) {
        switch_instance_changes.$$scope = { dirty, ctx };
      }
      if (dirty & 1024 && switch_value !== (switch_value = getComponent(ctx[23]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_children_slot$9(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let setoptional;
  let current;
  let each_value = [...ctx[10].fields.entries()];
  const get_key = (ctx2) => ctx2[23];
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$7(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$7(key, child_ctx));
  }
  setoptional = new SetOptional({
    props: {
      node: ctx[0],
      level: ctx[1] + 1
    }
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      create_component(setoptional.$$.fragment);
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, t, anchor);
      mount_component(setoptional, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1030) {
        each_value = [...ctx2[10].fields.entries()];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block$7, t, get_each_context$7);
        check_outros();
      }
      const setoptional_changes = {};
      if (dirty & 1)
        setoptional_changes.node = ctx2[0];
      if (dirty & 2)
        setoptional_changes.level = ctx2[1] + 1;
      setoptional.$set(setoptional_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(setoptional.$$.fragment, local);
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(setoptional.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(t);
      destroy_component(setoptional, detaching);
    }
  };
}
function create_fragment$x(ctx) {
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[1],
      highlight: ctx[3],
      compact: ctx[2],
      title: ctx[10].name,
      $$slots: {
        children: [create_children_slot$9],
        "menu-items": [
          create_menu_items_slot$e,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            26: getRect2,
            27: replaceNode2,
            28: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 67108864 : 0) | (replaceNode2 ? 134217728 : 0) | (editSource ? 268435456 : 0)
        ],
        summary: [create_summary_slot$b],
        label: [create_label_slot$b]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 2)
        expression_changes.level = ctx2[1];
      if (dirty & 8)
        expression_changes.highlight = ctx2[3];
      if (dirty & 4)
        expression_changes.compact = ctx2[2];
      if (dirty & 1024)
        expression_changes.title = ctx2[10].name;
      if (dirty & 470812663) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(10, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label = "" } = $$props;
  let { compact = false } = $$props;
  let { highlight = false } = $$props;
  let editMode = false;
  let hovering = false;
  let editFrame, editSelectorValue, editSelectorType;
  function getFrameIndex$1(parentNode) {
    if (parentNode instanceof FunctionCall$2)
      return getFrameIndex(parentNode);
    return 0;
  }
  function setEditMode() {
    $$invalidate(7, editFrame = getFrameIndex$1($node.parent));
    $$invalidate(8, editSelectorValue = $node.get("value").value);
    $$invalidate(9, editSelectorType = $node.get("type").value);
    $$invalidate(5, editMode = true);
  }
  function setFrame$1(parentNode, frame) {
    if (parentNode instanceof FunctionCall$2)
      setFrame(parentNode, frame);
  }
  function updateSelector({ detail }) {
    setFrame$1($node.parent, detail.frame);
    $node.parent.replace($node, [
      "selector",
      {
        value: escapeDollar(detail.value),
        type: detail.type,
        meta: {}
      }
    ]);
    $$invalidate(5, editMode = false);
  }
  const click_handler2 = (child) => child.parent.removeOptional(child);
  const click_handler_1 = (replaceNode2) => replaceNode2();
  const click_handler_2 = (editSource) => editSource();
  const cancel_handler = () => $$invalidate(5, editMode = false);
  const mouseenter_handler = () => $$invalidate(6, hovering = true);
  const mouseleave_handler = () => $$invalidate(6, hovering = false);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(4, label = $$props2.label);
    if ("compact" in $$props2)
      $$invalidate(2, compact = $$props2.compact);
    if ("highlight" in $$props2)
      $$invalidate(3, highlight = $$props2.highlight);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  return [
    node,
    level,
    compact,
    highlight,
    label,
    editMode,
    hovering,
    editFrame,
    editSelectorValue,
    editSelectorType,
    $node,
    setEditMode,
    updateSelector,
    slots,
    click_handler2,
    click_handler_1,
    click_handler_2,
    cancel_handler,
    mouseenter_handler,
    mouseleave_handler,
    $$scope
  ];
}
class Struct extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$x, safe_not_equal, {
      node: 0,
      level: 1,
      label: 4,
      compact: 2,
      highlight: 3
    });
  }
}
const get_parent_context_menu_slot_changes$a = (dirty) => ({ getRect: dirty & 65536 });
const get_parent_context_menu_slot_context$a = (ctx) => ({ getRect: ctx[16] });
function create_label_slot$a(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$8(ctx) {
  let div;
  let t_value = getSummary(ctx[5]) + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-editable");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (!mounted) {
        dispose = listen(div, "click", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = getSummary(ctx2[5]) + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$7(ctx) {
  let editliteral;
  let current;
  editliteral = new Literal$2({
    props: {
      value: ctx[5].value,
      type: ctx[5].returnType
    }
  });
  editliteral.$on("save", ctx[9]);
  editliteral.$on("cancel", ctx[12]);
  return {
    c() {
      create_component(editliteral.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editliteral, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editliteral_changes = {};
      if (dirty & 32)
        editliteral_changes.value = ctx2[5].value;
      if (dirty & 32)
        editliteral_changes.type = ctx2[5].returnType;
      editliteral.$set(editliteral_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editliteral.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editliteral.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editliteral, detaching);
    }
  };
}
function create_summary_slot$a(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$7, create_else_block$8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_1$b(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$e(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$l] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[10]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 16384) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot$l(ctx) {
  let t;
  return {
    c() {
      t = text("Create Input Field");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$d(ctx) {
  let menuitem;
  let t0;
  let show_if = ctx[8] && ["secret", "string", "int", "float", "boolean"].includes(ctx[5].returnType);
  let t1;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$b] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", function() {
    if (is_function(ctx[18]))
      ctx[18].apply(this, arguments);
  });
  let if_block = show_if && create_if_block$e(ctx);
  const parent_context_menu_slot_template = ctx[11]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[14], get_parent_context_menu_slot_context$a);
  return {
    c() {
      create_component(menuitem.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      insert(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t1, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 16384) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
      if (dirty & 32)
        show_if = ctx[8] && ["secret", "string", "int", "float", "boolean"].includes(ctx[5].returnType);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$e(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 81920)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[14],
            !current ? get_all_dirty_from_scope(ctx[14]) : get_slot_changes(parent_context_menu_slot_template, ctx[14], dirty, get_parent_context_menu_slot_changes$a),
            get_parent_context_menu_slot_context$a
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      transition_in(if_block);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      transition_out(if_block);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t1);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_fragment$w(ctx) {
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[1],
      compact: ctx[4],
      highlight: ctx[3],
      hideSummaryRow: ctx[0].returnType === "boolean",
      title: ctx[7],
      $$slots: {
        "menu-items": [
          create_menu_items_slot$d,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            16: getRect2,
            17: replaceNode2,
            18: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 65536 : 0) | (replaceNode2 ? 131072 : 0) | (editSource ? 262144 : 0)
        ],
        summary: [create_summary_slot$a],
        label: [create_label_slot$a]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 2)
        expression_changes.level = ctx2[1];
      if (dirty & 16)
        expression_changes.compact = ctx2[4];
      if (dirty & 8)
        expression_changes.highlight = ctx2[3];
      if (dirty & 1)
        expression_changes.hideSummaryRow = ctx2[0].returnType === "boolean";
      if (dirty & 128)
        expression_changes.title = ctx2[7];
      if (dirty & 344164) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  var _a;
  let title;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(5, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label = "" } = $$props;
  let { highlight = false } = $$props;
  let { compact = false } = $$props;
  const optInParams = (_a = getContext("optInParams")) != null ? _a : false;
  const params = getContext("params");
  let editMode = false;
  function saveLiteral(e) {
    $$invalidate(6, editMode = false);
    $$invalidate(0, node.value = e.detail, node);
  }
  function makeParam() {
    let name = params.generateName();
    params.add({
      name,
      dataType: node.returnType,
      default: node.value
    });
    node.parent.replace(node, "$" + name);
  }
  const cancel_handler = () => $$invalidate(6, editMode = false);
  const click_handler2 = () => $$invalidate(6, editMode = true);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("highlight" in $$props2)
      $$invalidate(3, highlight = $$props2.highlight);
    if ("compact" in $$props2)
      $$invalidate(4, compact = $$props2.compact);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 33) {
      $$invalidate(7, title = $node.returnType === "boolean" ? $node.value : `<${node.returnType}>`);
    }
  };
  return [
    node,
    level,
    label,
    highlight,
    compact,
    $node,
    editMode,
    title,
    optInParams,
    saveLiteral,
    makeParam,
    slots,
    cancel_handler,
    click_handler2,
    $$scope
  ];
}
class Literal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$w, safe_not_equal, {
      node: 0,
      level: 1,
      label: 2,
      highlight: 3,
      compact: 4
    });
  }
}
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
const get_parent_context_menu_slot_changes$9 = (dirty) => ({ getRect: dirty & 67108864 });
const get_parent_context_menu_slot_context$9 = (ctx) => ({ getRect: ctx[26] });
function create_label_slot$9(ctx) {
  let t;
  return {
    c() {
      t = text("var");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$7(ctx) {
  let button;
  let t0;
  let t1_value = ctx[10].name + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t0 = text("$");
      t1 = text(t1_value);
      attr(button, "class", "bbx-editable px-1");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[19]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && t1_value !== (t1_value = ctx2[10].name + ""))
        set_data(t1, t1_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$3(ctx) {
  let editliteral;
  let current;
  editliteral = new Literal$2({
    props: {
      validationMessage: ctx[8],
      value: ctx[10].name,
      type: "string"
    }
  });
  editliteral.$on("save", ctx[12]);
  editliteral.$on("cancel", ctx[18]);
  return {
    c() {
      create_component(editliteral.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editliteral, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editliteral_changes = {};
      if (dirty & 256)
        editliteral_changes.validationMessage = ctx2[8];
      if (dirty & 1024)
        editliteral_changes.value = ctx2[10].name;
      editliteral.$set(editliteral_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editliteral.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editliteral.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editliteral, detaching);
    }
  };
}
function create_if_block_2$4(ctx) {
  let span;
  let t1;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = inlineByType(ctx[10].value);
  function switch_props(ctx2) {
    return { props: { node: ctx2[10].value } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      span = element("span");
      span.textContent = "=";
      t1 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      insert(target, span, anchor);
      insert(target, t1, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 1024)
        switch_instance_changes.node = ctx2[10].value;
      if (dirty & 1024 && switch_value !== (switch_value = inlineByType(ctx2[10].value))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_summary_slot$9(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  const if_block_creators = [create_if_block_3$3, create_else_block$7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[11] && create_if_block_2$4(ctx);
  return {
    c() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "d-flex gap-2 align-items-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      if (ctx2[11])
        if_block1.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_1$6(ctx) {
  let menuitem;
  let current;
  function click_handler2() {
    return ctx[16](ctx[26]);
  }
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_2$6] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", click_handler2);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 4194304) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_2$6(ctx) {
  let t;
  return {
    c() {
      t = text("Change Type");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$a(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$c(ctx) {
  let t0;
  let menuitem;
  let t1;
  let current;
  let if_block = ctx[11] && create_if_block_1$6(ctx);
  function click_handler_1() {
    return ctx[17](ctx[28]);
  }
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$a] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", click_handler_1);
  const parent_context_menu_slot_template = ctx[15]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[22], get_parent_context_menu_slot_context$9);
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      create_component(menuitem.$$.fragment);
      t1 = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem, target, anchor);
      insert(target, t1, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[11])
        if_block.p(ctx, dirty);
      const menuitem_changes = {};
      if (dirty & 4194304) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 71303168)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[22],
            !current ? get_all_dirty_from_scope(ctx[22]) : get_slot_changes(parent_context_menu_slot_template, ctx[22], dirty, get_parent_context_menu_slot_changes$9),
            get_parent_context_menu_slot_context$9
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(menuitem.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(menuitem.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t1);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_children_slot$8(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = getComponent(ctx[10].value);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[10].value,
        level: ctx2[2] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 1024)
        switch_instance_changes.node = ctx2[10].value;
      if (dirty & 4)
        switch_instance_changes.level = ctx2[2] + 1;
      if (dirty & 1024 && switch_value !== (switch_value = getComponent(ctx2[10].value))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block$d(ctx) {
  let savecancelmodal;
  let current;
  savecancelmodal = new SaveCancelModal({
    props: {
      rect: ctx[7],
      title: "Change Type",
      $$slots: { default: [create_default_slot$k] },
      $$scope: { ctx }
    }
  });
  savecancelmodal.$on("save", ctx[14]);
  savecancelmodal.$on("cancel", ctx[21]);
  return {
    c() {
      create_component(savecancelmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savecancelmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savecancelmodal_changes = {};
      if (dirty & 128)
        savecancelmodal_changes.rect = ctx2[7];
      if (dirty & 4194880) {
        savecancelmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savecancelmodal.$set(savecancelmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savecancelmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savecancelmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savecancelmodal, detaching);
    }
  };
}
function create_each_block$6(ctx) {
  let option;
  let t_value = ctx[23] + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[23];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 512 && t_value !== (t_value = ctx2[23] + ""))
        set_data(t, t_value);
      if (dirty & 512 && option_value_value !== (option_value_value = ctx2[23])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_default_slot$k(ctx) {
  let select2;
  let mounted;
  let dispose;
  let each_value = ctx[9];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
  }
  return {
    c() {
      select2 = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, select2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select2, null);
        }
      }
      select_option(select2, ctx[6]);
      if (!mounted) {
        dispose = listen(select2, "change", ctx[20]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 512) {
        each_value = ctx2[9];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select2, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 576) {
        select_option(select2, ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select2);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$v(ctx) {
  let expression;
  let t;
  let if_block_anchor;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[2],
      compact: ctx[3],
      highlight: ctx[1],
      title: ctx[10].name,
      $$slots: {
        children: [create_children_slot$8],
        "menu-items": [
          create_menu_items_slot$c,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            26: getRect2,
            27: replaceNode2,
            28: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 67108864 : 0) | (replaceNode2 ? 134217728 : 0) | (editSource ? 268435456 : 0)
        ],
        summary: [create_summary_slot$9],
        label: [create_label_slot$9]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[5] && create_if_block$d(ctx);
  return {
    c() {
      create_component(expression.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 4)
        expression_changes.level = ctx2[2];
      if (dirty & 8)
        expression_changes.compact = ctx2[3];
      if (dirty & 2)
        expression_changes.highlight = ctx2[1];
      if (dirty & 1024)
        expression_changes.title = ctx2[10].name;
      if (dirty & 339739924) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$d(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let types2;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(10, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { highlight = false } = $$props;
  let { level = 0 } = $$props;
  let { compact = false } = $$props;
  let canChangeTypeAndValue = !node.declarationOnly;
  let renameMode = false;
  let typeChangeMode = false;
  let selectedType = $node.dataType;
  let rect;
  let renameError = void 0;
  function renameVariable({ detail }) {
    $$invalidate(8, renameError = void 0);
    try {
      $node.rename(detail);
      $$invalidate(4, renameMode = false);
    } catch (e) {
      $$invalidate(8, renameError = e.message);
    }
  }
  function changeType(getRect2) {
    $$invalidate(7, rect = getRect2());
    $$invalidate(5, typeChangeMode = true);
  }
  function saveType() {
    $node.changeType(selectedType);
    $$invalidate(5, typeChangeMode = false);
  }
  const click_handler2 = (getRect2) => changeType(getRect2);
  const click_handler_1 = (editSource) => editSource();
  const cancel_handler = () => $$invalidate(4, renameMode = false);
  const click_handler_2 = () => {
    $$invalidate(4, renameMode = true);
    $$invalidate(8, renameError = void 0);
  };
  const change_handler = (e) => $$invalidate(6, selectedType = e.target.value);
  const cancel_handler_1 = () => $$invalidate(5, typeChangeMode = false);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("highlight" in $$props2)
      $$invalidate(1, highlight = $$props2.highlight);
    if ("level" in $$props2)
      $$invalidate(2, level = $$props2.level);
    if ("compact" in $$props2)
      $$invalidate(3, compact = $$props2.compact);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$invalidate(9, types2 = ["string", "int", "float", "boolean"]);
  return [
    node,
    highlight,
    level,
    compact,
    renameMode,
    typeChangeMode,
    selectedType,
    rect,
    renameError,
    types2,
    $node,
    canChangeTypeAndValue,
    renameVariable,
    changeType,
    saveType,
    slots,
    click_handler2,
    click_handler_1,
    cancel_handler,
    click_handler_2,
    change_handler,
    cancel_handler_1,
    $$scope
  ];
}
class VariableDeclaration extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$v, safe_not_equal, {
      node: 0,
      highlight: 1,
      level: 2,
      compact: 3
    });
  }
}
const get_parent_context_menu_slot_changes$8 = (dirty) => ({ getRect: dirty & 1024 });
const get_parent_context_menu_slot_context$8 = (ctx) => ({ getRect: ctx[10] });
function create_label_slot$8(ctx) {
  var _a;
  let t_value = ((_a = ctx[3]) != null ? _a : "variable") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 8 && t_value !== (t_value = ((_a2 = ctx2[3]) != null ? _a2 : "variable") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$9(ctx) {
  let t;
  return {
    c() {
      t = text("Replace");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$j(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$b(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let current;
  function click_handler2() {
    return ctx[7](ctx[11]);
  }
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$9] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", click_handler2);
  function click_handler_1() {
    return ctx[8](ctx[12]);
  }
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$j] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", click_handler_1);
  const parent_context_menu_slot_template = ctx[6]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[9], get_parent_context_menu_slot_context$8);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem0_changes = {};
      if (dirty & 512) {
        menuitem0_changes.$$scope = { dirty, ctx };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 512) {
        menuitem1_changes.$$scope = { dirty, ctx };
      }
      menuitem1.$set(menuitem1_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 1536)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[9],
            !current ? get_all_dirty_from_scope(ctx[9]) : get_slot_changes(parent_context_menu_slot_template, ctx[9], dirty, get_parent_context_menu_slot_changes$8),
            get_parent_context_menu_slot_context$8
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_fragment$u(ctx) {
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[2],
      highlight: ctx[1],
      compact: ctx[4],
      title: "$" + ctx[5].name,
      $$slots: {
        "menu-items": [
          create_menu_items_slot$b,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            10: getRect2,
            11: replaceNode2,
            12: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 1024 : 0) | (replaceNode2 ? 2048 : 0) | (editSource ? 4096 : 0)
        ],
        label: [create_label_slot$8]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 4)
        expression_changes.level = ctx2[2];
      if (dirty & 2)
        expression_changes.highlight = ctx2[1];
      if (dirty & 16)
        expression_changes.compact = ctx2[4];
      if (dirty & 32)
        expression_changes.title = "$" + ctx2[5].name;
      if (dirty & 7688) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(5, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { highlight = false } = $$props;
  let { level = 0 } = $$props;
  let { label = void 0 } = $$props;
  let { compact = false } = $$props;
  const click_handler2 = (replaceNode2) => replaceNode2();
  const click_handler_1 = (editSource) => editSource();
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("highlight" in $$props2)
      $$invalidate(1, highlight = $$props2.highlight);
    if ("level" in $$props2)
      $$invalidate(2, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(3, label = $$props2.label);
    if ("compact" in $$props2)
      $$invalidate(4, compact = $$props2.compact);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    node,
    highlight,
    level,
    label,
    compact,
    $node,
    slots,
    click_handler2,
    click_handler_1,
    $$scope
  ];
}
class VariableReference extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$u, safe_not_equal, {
      node: 0,
      highlight: 1,
      level: 2,
      label: 3,
      compact: 4
    });
  }
}
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  child_ctx[29] = i;
  return child_ctx;
}
function create_else_block$6(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = getComponent(ctx[4]);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[4],
        level: ctx2[1],
        compact: "true",
        $$slots: {
          "parent-context-menu": [create_parent_context_menu_slot$1]
        },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 16)
        switch_instance_changes.node = ctx2[4];
      if (dirty & 2)
        switch_instance_changes.level = ctx2[1];
      if (dirty & 1073741841) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & 16 && switch_value !== (switch_value = getComponent(ctx2[4]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_2$3(ctx) {
  let div1;
  let div0;
  let t1;
  let previous_key = ctx[4].operands[0];
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let key_block = create_key_block(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "NOT";
      t1 = space();
      key_block.c();
      attr(div0, "class", "bbx-flex bbx-pad-x bbx-step__header");
      set_style(div0, "flex-direction", "row-reverse");
      attr(div1, "class", div1_class_value = "bbx-flex-col bbx-pad bbx-gap bbx-border bbx-rounded " + (ctx[3] ? "bbx-shadow-highlight" : ""));
      set_style(div1, "background-color", "var(--bbx-color-menu-bg)");
      set_style(div1, "border-color", "rgba(128,128,128,0.2)");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t1);
      key_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div1, "mouseenter", ctx[16]),
          listen(div1, "mouseleave", ctx[17])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16 && safe_not_equal(previous_key, previous_key = ctx2[4].operands[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div1, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (!current || dirty & 8 && div1_class_value !== (div1_class_value = "bbx-flex-col bbx-pad bbx-gap bbx-border bbx-rounded " + (ctx2[3] ? "bbx-shadow-highlight" : ""))) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      key_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$c(ctx) {
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let div0;
  let span;
  let t1;
  let t2_value = ctx[6](ctx[4]) ? "OR" : "AND";
  let t2;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[4].operands;
  const get_key = (ctx2) => ctx2[27];
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$5(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      div0 = element("div");
      span = element("span");
      t1 = text("+");
      t2 = text(t2_value);
      attr(span, "class", "bbx-btn-x bbx-flex bbx-center");
      attr(div0, "class", "bbx-flex bbx-w-full");
      set_style(div0, "flex-direction", "row-reverse");
      attr(div1, "class", div1_class_value = "bbx-flex-col bbx-pad bbx-gap bbx-border bbx-rounded " + (ctx[3] ? "bbx-shadow-highlight" : ""));
      set_style(div1, "background-color", "var(--bbx-color-menu-bg)");
      set_style(div1, "border-color", "rgba(128,128,128,0.2)");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      append(div1, t0);
      append(div1, div0);
      append(div0, span);
      append(span, t1);
      append(span, t2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span, "click", ctx[13]),
          listen(div1, "mouseenter", ctx[14]),
          listen(div1, "mouseleave", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 86) {
        each_value = ctx2[4].operands;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$5, t0, get_each_context$5);
        check_outros();
      }
      if ((!current || dirty & 16) && t2_value !== (t2_value = ctx2[6](ctx2[4]) ? "OR" : "AND"))
        set_data(t2, t2_value);
      if (!current || dirty & 8 && div1_class_value !== (div1_class_value = "bbx-flex-col bbx-pad bbx-gap bbx-border bbx-rounded " + (ctx2[3] ? "bbx-shadow-highlight" : ""))) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_6$1(ctx) {
  let menuitem0;
  let t;
  let menuitem1;
  let current;
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", ctx[18]);
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", ctx[19]);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t = space();
      create_component(menuitem1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t, anchor);
      mount_component(menuitem1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & 1073741824) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 1073741824) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t);
      destroy_component(menuitem1, detaching);
    }
  };
}
function create_default_slot_4$2(ctx) {
  let t;
  return {
    c() {
      t = text("Add Expression Before");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$4(ctx) {
  let t;
  return {
    c() {
      t = text("Add Expression After");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_5$1(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      class: "bbx-warn",
      $$slots: { default: [create_default_slot_2$5] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[21]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 1073741824) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_if_block_4$1(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      class: "bbx-warn",
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[20]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 1073741824) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_2$5(ctx) {
  let t;
  return {
    c() {
      t = text("Remove Negation");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$8(ctx) {
  let t;
  return {
    c() {
      t = text("Negate");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3$2(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$i] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[22]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 1073741824) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot$i(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_parent_context_menu_slot$1(ctx) {
  let show_if_3 = ctx[8](ctx[4].parent);
  let t0;
  let show_if_1;
  let show_if_2;
  let current_block_type_index;
  let if_block1;
  let t1;
  let show_if = ctx[12](ctx[4]);
  let if_block2_anchor;
  let current;
  let if_block0 = show_if_3 && create_if_block_6$1(ctx);
  const if_block_creators = [create_if_block_4$1, create_if_block_5$1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    var _a;
    if (dirty & 16)
      show_if_1 = null;
    if (dirty & 1)
      show_if_2 = null;
    if (show_if_1 == null)
      show_if_1 = !!!ctx2[7](ctx2[4].parent);
    if (show_if_1)
      return 0;
    if (show_if_2 == null)
      show_if_2 = !!["and", "or"].includes((_a = ctx2[0].parent) == null ? void 0 : _a.parent.name);
    if (show_if_2)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, -1))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block2 = show_if && create_if_block_3$2(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        show_if_3 = ctx2[8](ctx2[4].parent);
      if (show_if_3) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        } else {
          if_block1 = null;
        }
      }
      if (dirty & 16)
        show_if = ctx2[12](ctx2[4]);
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_3$2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function create_key_block(ctx) {
  let condition;
  let current;
  condition = new Condition({
    props: {
      node: ctx[4].operands[0],
      level: ctx[1]
    }
  });
  return {
    c() {
      create_component(condition.$$.fragment);
    },
    m(target, anchor) {
      mount_component(condition, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const condition_changes = {};
      if (dirty & 16)
        condition_changes.node = ctx2[4].operands[0];
      if (dirty & 2)
        condition_changes.level = ctx2[1];
      condition.$set(condition_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(condition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(condition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(condition, detaching);
    }
  };
}
function create_if_block_1$5(ctx) {
  let div;
  let t_value = ctx[6](ctx[4]) ? "OR" : "AND";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-flex bbx-pad-x bbx-step__header");
      set_style(div, "flex-direction", "row-reverse");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = ctx2[6](ctx2[4]) ? "OR" : "AND"))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$5(key_1, ctx) {
  let first;
  let condition;
  let t;
  let if_block_anchor;
  let current;
  condition = new Condition({
    props: {
      node: ctx[27],
      level: ctx[1],
      highlight: ctx[2]
    }
  });
  let if_block = ctx[29] < ctx[4].operands.length - 1 && create_if_block_1$5(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(condition.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(condition, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const condition_changes = {};
      if (dirty & 16)
        condition_changes.node = ctx[27];
      if (dirty & 2)
        condition_changes.level = ctx[1];
      if (dirty & 4)
        condition_changes.highlight = ctx[2];
      condition.$set(condition_changes);
      if (ctx[29] < ctx[4].operands.length - 1) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1$5(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(condition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(condition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(condition, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$t(ctx) {
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$c, create_if_block_2$3, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 16)
      show_if = null;
    if (dirty & 16)
      show_if_1 = null;
    if (show_if == null)
      show_if = !!ctx2[8](ctx2[4]);
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!ctx2[7](ctx2[4]);
    if (show_if_1)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function addNegation(node) {
  node.parent.replace(node, ["not", node.toJSON()]);
}
function removeNegation(node) {
  let grandParent = node.parent.parent;
  grandParent.replace(node.parent, node.toJSON());
}
function instance$t($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(4, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { highlight = false } = $$props;
  const expressionCtx = getContext("expressionCtx");
  const TARGET = { BEFORE: 0, AFTER: 1 };
  let hoveringExpression = false;
  function isOr(node2) {
    return node2.type === C.OPERATOR && node2.name === C.OP_OR;
  }
  function isAnd(node2) {
    return node2.type === C.OPERATOR && node2.name === C.OP_AND;
  }
  function isNot(node2) {
    return node2.type === C.OPERATOR && node2.name === C.OP_NOT;
  }
  function isAndOr(node2) {
    return isAnd(node2) || isOr(node2);
  }
  function isLogical(node2) {
    return isAndOr(node2) || isNot(node2);
  }
  function appendOperand(parent2) {
    parent2.insertAt(parent2.operands.length, getDefaultOperand(parent2));
  }
  function addSiblingOperand(node2, location) {
    const parent2 = node2.parent;
    const index = parent2.operands.indexOf(node2);
    node2.parent.insertAt(index + location, getDefaultOperand(parent2));
  }
  function getDefaultOperand(node2) {
    const expr = getDefaultExpression(node2.name, expressionCtx.replace.defaultExprs);
    return expr[1];
  }
  function deleteOperand(node2) {
    if (isLogical(node2.parent)) {
      if (node2.parent.operands.length === 1) {
        deleteOperand(node2.parent);
      } else {
        node2.parent.remove(node2);
      }
    } else {
      if (node2.name === C.OP_NOT) {
        return;
      }
      node2.remove(node2.operands[0]);
    }
  }
  function canDelete(leaf) {
    let arg = leaf.parent;
    while (isLogical(arg.parent)) {
      arg = arg.parent;
    }
    if (isAndOr(arg)) {
      return true;
    }
    let temp = leaf.parent;
    while (isLogical(temp)) {
      if (isAndOr(temp) && temp.operands.length > 1) {
        return true;
      }
      temp = temp.parent;
    }
    return false;
  }
  const click_handler2 = () => appendOperand($node);
  const mouseenter_handler = () => isAndOr($node.parent) && $$invalidate(3, hoveringExpression = true);
  const mouseleave_handler = () => $$invalidate(3, hoveringExpression = false);
  const mouseenter_handler_1 = () => isAndOr($node.parent) && $$invalidate(3, hoveringExpression = true);
  const mouseleave_handler_1 = () => $$invalidate(3, hoveringExpression = false);
  const click_handler_1 = () => addSiblingOperand($node, TARGET.BEFORE);
  const click_handler_2 = () => addSiblingOperand($node, TARGET.AFTER);
  const click_handler_3 = () => addNegation($node);
  const click_handler_4 = () => removeNegation($node);
  const click_handler_5 = () => deleteOperand($node);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("highlight" in $$props2)
      $$invalidate(2, highlight = $$props2.highlight);
  };
  return [
    node,
    level,
    highlight,
    hoveringExpression,
    $node,
    TARGET,
    isOr,
    isNot,
    isAndOr,
    appendOperand,
    addSiblingOperand,
    deleteOperand,
    canDelete,
    click_handler2,
    mouseenter_handler,
    mouseleave_handler,
    mouseenter_handler_1,
    mouseleave_handler_1,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5
  ];
}
class Condition extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$t, safe_not_equal, { node: 0, level: 1, highlight: 2 });
  }
}
function create_default_slot$h(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_items_slot$1(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[11]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 262144) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_if_block$b(ctx) {
  let sourceeditor;
  let current;
  sourceeditor = new SourceEditor({
    props: {
      source: ctx[7].toJSON(),
      rect: ctx[9]()
    }
  });
  sourceeditor.$on("cancel", ctx[17]);
  sourceeditor.$on("save", ctx[10]);
  return {
    c() {
      create_component(sourceeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sourceeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sourceeditor_changes = {};
      if (dirty & 128)
        sourceeditor_changes.source = ctx2[7].toJSON();
      sourceeditor.$set(sourceeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sourceeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sourceeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sourceeditor, detaching);
    }
  };
}
function create_fragment$s(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let menubtn;
  let t2;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  menubtn = new MenuBtn({
    props: {
      $$slots: { items: [create_items_slot$1] },
      $$scope: { ctx }
    }
  });
  menubtn.$on("open", ctx[12]);
  menubtn.$on("close", ctx[13]);
  let if_block = ctx[6] && create_if_block$b(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[2]);
      t1 = space();
      div1 = element("div");
      create_component(menubtn.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div0, "class", "bbx-step__header");
      set_style(div1, "visibility", ctx[4] || ctx[5] ? "visible" : "hidden");
      attr(div2, "class", "bbx-flex");
      set_style(div2, "margin-left", "calc(var(--bbx-gap)*2 * " + ctx[1] + ")");
      set_style(div2, "margin-right", "var(--bbx-gap)");
      set_style(div2, "justify-content", "space-between");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      mount_component(menubtn, div1, null);
      ctx[14](div2);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div2, "mouseenter", ctx[15]),
          listen(div2, "mouseleave", ctx[16])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 4)
        set_data(t0, ctx2[2]);
      const menubtn_changes = {};
      if (dirty & 262144) {
        menubtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menubtn.$set(menubtn_changes);
      if (!current || dirty & 48) {
        set_style(div1, "visibility", ctx2[4] || ctx2[5] ? "visible" : "hidden");
      }
      if (!current || dirty & 2) {
        set_style(div2, "margin-left", "calc(var(--bbx-gap)*2 * " + ctx2[1] + ")");
      }
      if (ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$b(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menubtn.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(menubtn.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(menubtn);
      ctx[14](null);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(7, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { title = "Header" } = $$props;
  let component;
  let showMenu = false;
  let menuActive = false;
  let sourceEditMode = false;
  function editSource() {
    $$invalidate(6, sourceEditMode = true);
  }
  function getRect2() {
    let { left, top, right } = component.getBoundingClientRect();
    return {
      left: left - 10,
      top: top - 10,
      right: right - 10
    };
  }
  function saveSource({ detail }) {
    node.parent.replace(node, detail);
    $$invalidate(6, sourceEditMode = false);
  }
  const click_handler2 = () => editSource();
  const open_handler = () => $$invalidate(5, menuActive = true);
  const close_handler = () => $$invalidate(5, menuActive = false);
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      component = $$value;
      $$invalidate(3, component);
    });
  }
  const mouseenter_handler = () => $$invalidate(4, showMenu = true);
  const mouseleave_handler = () => $$invalidate(4, showMenu = false);
  const cancel_handler = () => $$invalidate(6, sourceEditMode = false);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
  };
  return [
    node,
    level,
    title,
    component,
    showMenu,
    menuActive,
    sourceEditMode,
    $node,
    editSource,
    getRect2,
    saveSource,
    click_handler2,
    open_handler,
    close_handler,
    div2_binding,
    mouseenter_handler,
    mouseleave_handler,
    cancel_handler
  ];
}
class SectionHeader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$s, safe_not_equal, { node: 0, level: 1, title: 2 });
  }
}
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  child_ctx[19] = i;
  return child_ctx;
}
function create_summary_slot$8(ctx) {
  let t0_value = getSummary(ctx[17]) + "";
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t0_value !== (t0_value = getSummary(ctx2[17]) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot_5$1(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_4$1(ctx) {
  let t;
  return {
    c() {
      t = text("Add Clause Before");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let t;
  return {
    c() {
      t = text("Add Clause After");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$4(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[10]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 2097152) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_2$4(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step Before");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$a(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[11]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 2097152) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_1$7(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step After");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$g(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$a(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuitem2;
  let t2;
  let t3;
  let t4;
  let menuitem3;
  let t5;
  let current;
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", function() {
    if (is_function(ctx[20]))
      ctx[20].apply(this, arguments);
  });
  function click_handler2() {
    return ctx[8](ctx[19]);
  }
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", click_handler2);
  function click_handler_1() {
    return ctx[9](ctx[19]);
  }
  menuitem2 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx }
    }
  });
  menuitem2.$on("click", click_handler_1);
  let if_block0 = ctx[19] === 0 && create_if_block_1$4(ctx);
  let if_block1 = ctx[19] === ctx[3].clauses.length - 1 && create_if_block$a(ctx);
  function click_handler_4() {
    return ctx[12](ctx[19]);
  }
  menuitem3 = new MenuItem({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    }
  });
  menuitem3.$on("click", click_handler_4);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuitem2.$$.fragment);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      create_component(menuitem3.$$.fragment);
      t5 = space();
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitem2, target, anchor);
      insert(target, t2, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t4, anchor);
      mount_component(menuitem3, target, anchor);
      insert(target, t5, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem0_changes = {};
      if (dirty & 2097152) {
        menuitem0_changes.$$scope = { dirty, ctx };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 2097152) {
        menuitem1_changes.$$scope = { dirty, ctx };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & 2097152) {
        menuitem2_changes.$$scope = { dirty, ctx };
      }
      menuitem2.$set(menuitem2_changes);
      if (ctx[19] === 0) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$4(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t3.parentNode, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx[19] === ctx[3].clauses.length - 1) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$a(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t4.parentNode, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const menuitem3_changes = {};
      if (dirty & 2097152) {
        menuitem3_changes.$$scope = { dirty, ctx };
      }
      menuitem3.$set(menuitem3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(menuitem3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(menuitem3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitem2, detaching);
      if (detaching)
        detach(t2);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t4);
      destroy_component(menuitem3, detaching);
      if (detaching)
        detach(t5);
    }
  };
}
function create_children_slot$7(ctx) {
  let sectionheader;
  let t0;
  let div;
  let condition;
  let t1;
  let switch_instance;
  let t2;
  let current;
  sectionheader = new SectionHeader({
    props: {
      node: ctx[17].condition,
      level: ctx[2] + 1,
      title: "Condition"
    }
  });
  condition = new Condition({
    props: {
      node: ctx[17].condition,
      level: ctx[2]
    }
  });
  var switch_value = getComponent(ctx[17].body);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[17].body,
        level: ctx2[2] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      create_component(sectionheader.$$.fragment);
      t0 = space();
      div = element("div");
      create_component(condition.$$.fragment);
      t1 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t2 = space();
      attr(div, "class", "bbx-rounded");
      set_style(div, "border-color", "var(--bbx-color-menu-bg)");
      set_style(div, "margin-left", "calc(var(--bbx-gap)*2 * " + (ctx[2] + 1) + ")");
    },
    m(target, anchor) {
      mount_component(sectionheader, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      mount_component(condition, div, null);
      insert(target, t1, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sectionheader_changes = {};
      if (dirty & 8)
        sectionheader_changes.node = ctx2[17].condition;
      if (dirty & 4)
        sectionheader_changes.level = ctx2[2] + 1;
      sectionheader.$set(sectionheader_changes);
      const condition_changes = {};
      if (dirty & 8)
        condition_changes.node = ctx2[17].condition;
      if (dirty & 4)
        condition_changes.level = ctx2[2];
      condition.$set(condition_changes);
      if (!current || dirty & 4) {
        set_style(div, "margin-left", "calc(var(--bbx-gap)*2 * " + (ctx2[2] + 1) + ")");
      }
      const switch_instance_changes = {};
      if (dirty & 8)
        switch_instance_changes.node = ctx2[17].body;
      if (dirty & 4)
        switch_instance_changes.level = ctx2[2] + 1;
      if (dirty & 8 && switch_value !== (switch_value = getComponent(ctx2[17].body))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t2.parentNode, t2);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sectionheader.$$.fragment, local);
      transition_in(condition.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sectionheader.$$.fragment, local);
      transition_out(condition.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sectionheader, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      destroy_component(condition);
      if (detaching)
        detach(t1);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block$4(key_1, ctx) {
  var _a;
  let first;
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[17],
      level: ctx[2],
      isExpandable: true,
      keepExpanded: ctx[17].body === ((_a = ctx[4]) == null ? void 0 : _a.block),
      replaceable: false,
      highlight: ctx[1],
      title: ctx[19] > 0 ? "Else..If" : "If",
      $$slots: {
        children: [create_children_slot$7],
        "menu-items": [
          create_menu_items_slot$a,
          ({ editSource }) => ({ 20: editSource }),
          ({ editSource }) => editSource ? 1048576 : 0
        ],
        summary: [create_summary_slot$8]
      },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(expression.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(expression, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      const expression_changes = {};
      if (dirty & 8)
        expression_changes.node = ctx[17];
      if (dirty & 4)
        expression_changes.level = ctx[2];
      if (dirty & 24)
        expression_changes.keepExpanded = ctx[17].body === ((_a2 = ctx[4]) == null ? void 0 : _a2.block);
      if (dirty & 2)
        expression_changes.highlight = ctx[1];
      if (dirty & 8)
        expression_changes.title = ctx[19] > 0 ? "Else..If" : "If";
      if (dirty & 3145740) {
        expression_changes.$$scope = { dirty, ctx };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(expression, detaching);
    }
  };
}
function create_fragment$r(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[3].clauses;
  const get_key = (ctx2) => ctx2[17];
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 1048798) {
        each_value = ctx2[3].clauses;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$4, each_1_anchor, get_each_context$4);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function deleteNode$2(node, index) {
  if (node.clauses.length === 1) {
    node.parent.remove(node);
  } else {
    node.remove(node.clauses[index]);
  }
}
function instance$r($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(3, $node = $$value)), node);
  let $curRecPos;
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node } = $$props;
  $$subscribe_node();
  let { highlight = false } = $$props;
  let { level = 0 } = $$props;
  const curRecPos = getContext("curRecPos");
  component_subscribe($$self, curRecPos, (value) => $$invalidate(4, $curRecPos = value));
  const mode = getContext("mode");
  const tagList = getContext("tagList");
  const ctx = getContext("expressionCtx");
  if (!ctx) {
    throw new Error("expressionCtx not defined in context");
  }
  let defaultStep = ctx.replace.defaultStep;
  async function insertBefore(node2) {
    let index = node2.parent.nodes.indexOf(node2);
    if (index === -1)
      return;
    insertAt(node2.parent, index, { mode, tagList, defaultStep });
  }
  async function insertAfter(node2) {
    let index = node2.parent.nodes.indexOf(node2);
    if (index === -1)
      return;
    insertAt(node2.parent, index + 1, { mode, tagList, defaultStep });
  }
  const click_handler2 = (i) => $node.insertAt(i);
  const click_handler_1 = (i) => $node.insertAt(i + 1);
  const click_handler_2 = () => insertBefore($node);
  const click_handler_3 = () => insertAfter($node);
  const click_handler_4 = (i) => deleteNode$2($node, i);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("highlight" in $$props2)
      $$invalidate(1, highlight = $$props2.highlight);
    if ("level" in $$props2)
      $$invalidate(2, level = $$props2.level);
  };
  return [
    node,
    highlight,
    level,
    $node,
    $curRecPos,
    curRecPos,
    insertBefore,
    insertAfter,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4
  ];
}
class IfElse extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$r, safe_not_equal, { node: 0, highlight: 1, level: 2 });
  }
}
function create_summary_slot$7(ctx) {
  let t_value = getSummary(ctx[0]) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = getSummary(ctx2[0]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$2(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$3(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step Before");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$6(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step After");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$f(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$9(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuitem2;
  let t2;
  let menuitem3;
  let current;
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", function() {
    if (is_function(ctx[15]))
      ctx[15].apply(this, arguments);
  });
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", ctx[8]);
  menuitem2 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$6] },
      $$scope: { ctx }
    }
  });
  menuitem2.$on("click", ctx[9]);
  menuitem3 = new MenuItem({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    }
  });
  menuitem3.$on("click", ctx[10]);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuitem2.$$.fragment);
      t2 = space();
      create_component(menuitem3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitem2, target, anchor);
      insert(target, t2, anchor);
      mount_component(menuitem3, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem0_changes = {};
      if (dirty & 65536) {
        menuitem0_changes.$$scope = { dirty, ctx };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 65536) {
        menuitem1_changes.$$scope = { dirty, ctx };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & 65536) {
        menuitem2_changes.$$scope = { dirty, ctx };
      }
      menuitem2.$set(menuitem2_changes);
      const menuitem3_changes = {};
      if (dirty & 65536) {
        menuitem3_changes.$$scope = { dirty, ctx };
      }
      menuitem3.$set(menuitem3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      transition_in(menuitem3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      transition_out(menuitem3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitem2, detaching);
      if (detaching)
        detach(t2);
      destroy_component(menuitem3, detaching);
    }
  };
}
function create_children_slot$6(ctx) {
  let sectionheader;
  let t0;
  let div;
  let condition;
  let t1;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  sectionheader = new SectionHeader({
    props: {
      node: ctx[0].condition,
      level: ctx[2] + 1,
      title: "Condition"
    }
  });
  condition = new Condition({
    props: {
      node: ctx[0].condition,
      level: ctx[2]
    }
  });
  var switch_value = getComponent(ctx[0].body);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[0].body,
        level: ctx2[2] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      create_component(sectionheader.$$.fragment);
      t0 = space();
      div = element("div");
      create_component(condition.$$.fragment);
      t1 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      attr(div, "class", "bbx-rounded");
      set_style(div, "border-color", "var(--bbx-color-menu-bg)");
      set_style(div, "margin-left", "calc(var(--bbx-gap)*2 * " + (ctx[2] + 1) + ")");
    },
    m(target, anchor) {
      mount_component(sectionheader, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      mount_component(condition, div, null);
      insert(target, t1, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sectionheader_changes = {};
      if (dirty & 1)
        sectionheader_changes.node = ctx2[0].condition;
      if (dirty & 4)
        sectionheader_changes.level = ctx2[2] + 1;
      sectionheader.$set(sectionheader_changes);
      const condition_changes = {};
      if (dirty & 1)
        condition_changes.node = ctx2[0].condition;
      if (dirty & 4)
        condition_changes.level = ctx2[2];
      condition.$set(condition_changes);
      if (!current || dirty & 4) {
        set_style(div, "margin-left", "calc(var(--bbx-gap)*2 * " + (ctx2[2] + 1) + ")");
      }
      const switch_instance_changes = {};
      if (dirty & 1)
        switch_instance_changes.node = ctx2[0].body;
      if (dirty & 4)
        switch_instance_changes.level = ctx2[2] + 1;
      if (dirty & 1 && switch_value !== (switch_value = getComponent(ctx2[0].body))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sectionheader.$$.fragment, local);
      transition_in(condition.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sectionheader.$$.fragment, local);
      transition_out(condition.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sectionheader, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      destroy_component(condition);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$q(ctx) {
  var _a;
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[2],
      isExpandable: true,
      keepExpanded: ctx[0].body === ((_a = ctx[3]) == null ? void 0 : _a.block),
      replaceable: false,
      highlight: ctx[1],
      title: "while",
      $$slots: {
        children: [create_children_slot$6],
        "menu-items": [
          create_menu_items_slot$9,
          ({ editSource }) => ({ 15: editSource }),
          ({ editSource }) => editSource ? 32768 : 0
        ],
        summary: [create_summary_slot$7]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 4)
        expression_changes.level = ctx2[2];
      if (dirty & 9)
        expression_changes.keepExpanded = ctx2[0].body === ((_a2 = ctx2[3]) == null ? void 0 : _a2.block);
      if (dirty & 2)
        expression_changes.highlight = ctx2[1];
      if (dirty & 98325) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function deleteNode$1(node) {
  node.parent.remove(node);
}
function instance$q($$self, $$props, $$invalidate) {
  let $curRecPos;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(4, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node } = $$props;
  $$subscribe_node();
  let { highlight = false } = $$props;
  let { level = 0 } = $$props;
  const curRecPos = getContext("curRecPos");
  component_subscribe($$self, curRecPos, (value) => $$invalidate(3, $curRecPos = value));
  const mode = getContext("mode");
  const tagList = getContext("tagList");
  const ctx = getContext("expressionCtx");
  if (!ctx) {
    throw new Error("expressionCtx not defined in context");
  }
  let defaultStep = ctx.replace.defaultStep;
  async function insertBefore(node2) {
    let index = node2.parent.nodes.indexOf(node2);
    if (index === -1)
      return;
    insertAt(node2.parent, index, { mode, tagList, defaultStep });
  }
  async function insertAfter(node2) {
    let index = node2.parent.nodes.indexOf(node2);
    if (index === -1)
      return;
    insertAt(node2.parent, index + 1, { mode, tagList, defaultStep });
  }
  const click_handler2 = () => insertBefore($node);
  const click_handler_1 = () => insertAfter($node);
  const click_handler_2 = () => deleteNode$1($node);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("highlight" in $$props2)
      $$invalidate(1, highlight = $$props2.highlight);
    if ("level" in $$props2)
      $$invalidate(2, level = $$props2.level);
  };
  return [
    node,
    highlight,
    level,
    $curRecPos,
    $node,
    curRecPos,
    insertBefore,
    insertAfter,
    click_handler2,
    click_handler_1,
    click_handler_2
  ];
}
class While extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$q, safe_not_equal, { node: 0, highlight: 1, level: 2 });
  }
}
function create_else_block$5(ctx) {
  let div;
  let t0;
  let iconbtn0;
  let t1;
  let iconbtn1;
  let current;
  let mounted;
  let dispose;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[1] === "string" || ctx2[1] === "secret")
      return create_if_block_1$3;
    if (ctx2[1] === "int" || ctx2[1] === "float")
      return create_if_block_2$2;
    if (ctx2[1] === "boolean")
      return create_if_block_3$1;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  iconbtn0 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  iconbtn0.$on("click", ctx[8]);
  iconbtn1 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx }
    }
  });
  iconbtn1.$on("click", ctx[9]);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      create_component(iconbtn0.$$.fragment);
      t1 = space();
      create_component(iconbtn1.$$.fragment);
      attr(div, "class", "bbx-flex bbx-gap bbx-align-center bbx-flex-grow");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t0);
      mount_component(iconbtn0, div, null);
      append(div, t1);
      mount_component(iconbtn1, div, null);
      ctx[16](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(clickOutside.call(null, div)),
          listen(div, "outclick", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, t0);
        }
      }
      const iconbtn0_changes = {};
      if (dirty & 262144) {
        iconbtn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn0.$set(iconbtn0_changes);
      const iconbtn1_changes = {};
      if (dirty & 262144) {
        iconbtn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn1.$set(iconbtn1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbtn0.$$.fragment, local);
      transition_in(iconbtn1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbtn0.$$.fragment, local);
      transition_out(iconbtn1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block) {
        if_block.d();
      }
      destroy_component(iconbtn0);
      destroy_component(iconbtn1);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$9(ctx) {
  let div;
  let t;
  let div_class_value;
  return {
    c() {
      div = element("div");
      t = text(ctx[2]);
      attr(div, "class", div_class_value = "bbx-pointer " + ctx[4]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
      if (dirty & 16 && div_class_value !== (div_class_value = "bbx-pointer " + ctx2[4])) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3$1(ctx) {
  let select2;
  let option0;
  let option1;
  let mounted;
  let dispose;
  return {
    c() {
      select2 = element("select");
      option0 = element("option");
      option0.textContent = "true";
      option1 = element("option");
      option1.textContent = "false";
      option0.__value = "true";
      option0.value = option0.__value;
      option1.__value = "false";
      option1.value = option1.__value;
    },
    m(target, anchor) {
      insert(target, select2, anchor);
      append(select2, option0);
      append(select2, option1);
      select_option(select2, ctx[6]);
      if (!mounted) {
        dispose = listen(select2, "change", ctx[15]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 64) {
        select_option(select2, ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select2);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$2(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "number");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[6]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[13]),
          listen(input, "input", ctx[14]),
          listen(input, "keydown", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 64 && to_number(input.value) !== ctx2[6]) {
        set_input_value(input, ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$3(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "class", "bbx-flex-grow");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[6]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[12]),
          listen(input, "input", ctx[11]),
          listen(input, "keydown", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 64 && input.value !== ctx2[6]) {
        set_input_value(input, ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_1$5(ctx) {
  let cross;
  let current;
  cross = new Cross$1({ props: { strokeColor: "red" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_default_slot$e(ctx) {
  let tick_1;
  let current;
  tick_1 = new Tick({ props: { strokeColor: "blue" } });
  return {
    c() {
      create_component(tick_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tick_1, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(tick_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tick_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tick_1, detaching);
    }
  };
}
function create_fragment$p(ctx) {
  var _a, _b;
  let div;
  let current_block_type_index;
  let if_block;
  let t;
  let validationtooltip;
  let current;
  const if_block_creators = [create_if_block$9, create_else_block$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  validationtooltip = new ValidationTooltip({
    props: {
      message: ctx[3],
      rect: {
        top: (_a = ctx[5]) == null ? void 0 : _a.getBoundingClientRect().bottom,
        left: (_b = ctx[5]) == null ? void 0 : _b.getBoundingClientRect().left
      }
    }
  });
  return {
    c() {
      div = element("div");
      if_block.c();
      t = space();
      create_component(validationtooltip.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      insert(target, t, anchor);
      mount_component(validationtooltip, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      const validationtooltip_changes = {};
      if (dirty & 8)
        validationtooltip_changes.message = ctx2[3];
      if (dirty & 32)
        validationtooltip_changes.rect = {
          top: (_a2 = ctx2[5]) == null ? void 0 : _a2.getBoundingClientRect().bottom,
          left: (_b2 = ctx2[5]) == null ? void 0 : _b2.getBoundingClientRect().left
        };
      validationtooltip.$set(validationtooltip_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(validationtooltip.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(validationtooltip.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (detaching)
        detach(t);
      destroy_component(validationtooltip, detaching);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { editMode = false } = $$props;
  let { type = "string" } = $$props;
  let { value } = $$props;
  let { validationMessage = void 0 } = $$props;
  let { class: clazz = "" } = $$props;
  let editorComponent;
  let editableValue = value;
  if (type === "boolean") {
    editableValue = editableValue ? "true" : "false";
  }
  function onKeydown(e) {
    if (e.key === "Enter") {
      onSave();
    } else if (e.key === "Escape") {
      dispatch("cancel", value);
    }
  }
  function onCancel() {
    dispatch("cancel", value);
  }
  function onSave() {
    const value2 = type === "boolean" ? editableValue === "true" : editableValue;
    dispatch("save", value2);
  }
  function handleInput(e, type2) {
    const value2 = e.target.value;
    if (type2 === "int") {
      $$invalidate(6, editableValue = parseInt(value2));
    } else if (type2 === "float") {
      $$invalidate(6, editableValue = parseFloat(value2));
    }
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    editableValue = this.value;
    $$invalidate(6, editableValue);
  }
  function input_input_handler_1() {
    editableValue = to_number(this.value);
    $$invalidate(6, editableValue);
  }
  const input_handler_1 = (e) => handleInput(e, type);
  const change_handler = (e) => $$invalidate(6, editableValue = e.target.value);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      editorComponent = $$value;
      $$invalidate(5, editorComponent);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("editMode" in $$props2)
      $$invalidate(0, editMode = $$props2.editMode);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("validationMessage" in $$props2)
      $$invalidate(3, validationMessage = $$props2.validationMessage);
    if ("class" in $$props2)
      $$invalidate(4, clazz = $$props2.class);
  };
  return [
    editMode,
    type,
    value,
    validationMessage,
    clazz,
    editorComponent,
    editableValue,
    onKeydown,
    onCancel,
    onSave,
    handleInput,
    input_handler,
    input_input_handler,
    input_input_handler_1,
    input_handler_1,
    change_handler,
    div_binding
  ];
}
class Text extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$p, safe_not_equal, {
      editMode: 0,
      type: 1,
      value: 2,
      validationMessage: 3,
      class: 4
    });
  }
}
function create_summary_slot$6(ctx) {
  let t_value = getSummary(ctx[4]) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = getSummary(ctx2[4]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$1(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step Before");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step After");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$d(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$8(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuitem2;
  let t2;
  let menuitem3;
  let current;
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", function() {
    if (is_function(ctx[15]))
      ctx[15].apply(this, arguments);
  });
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", ctx[8]);
  menuitem2 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    }
  });
  menuitem2.$on("click", ctx[9]);
  menuitem3 = new MenuItem({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx }
    }
  });
  menuitem3.$on("click", ctx[10]);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuitem2.$$.fragment);
      t2 = space();
      create_component(menuitem3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitem2, target, anchor);
      insert(target, t2, anchor);
      mount_component(menuitem3, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem0_changes = {};
      if (dirty & 65536) {
        menuitem0_changes.$$scope = { dirty, ctx };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 65536) {
        menuitem1_changes.$$scope = { dirty, ctx };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & 65536) {
        menuitem2_changes.$$scope = { dirty, ctx };
      }
      menuitem2.$set(menuitem2_changes);
      const menuitem3_changes = {};
      if (dirty & 65536) {
        menuitem3_changes.$$scope = { dirty, ctx };
      }
      menuitem3.$set(menuitem3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      transition_in(menuitem3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      transition_out(menuitem3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitem2, detaching);
      if (detaching)
        detach(t2);
      destroy_component(menuitem3, detaching);
    }
  };
}
function create_children_slot$5(ctx) {
  let switch_instance0;
  let t0;
  let switch_instance1;
  let t1;
  let switch_instance2;
  let switch_instance2_anchor;
  let current;
  var switch_value = getComponent(ctx[0].itemVar);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[0].itemVar,
        level: ctx2[2] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
  }
  var switch_value_1 = getComponent(ctx[0].iterable);
  function switch_props_1(ctx2) {
    return {
      props: {
        node: ctx2[0].iterable,
        level: ctx2[2] + 1
      }
    };
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
  }
  var switch_value_2 = getComponent(ctx[0].body);
  function switch_props_2(ctx2) {
    return {
      props: {
        node: ctx2[0].body,
        level: ctx2[2] + 1
      }
    };
  }
  if (switch_value_2) {
    switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2(ctx));
  }
  return {
    c() {
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t0 = space();
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      t1 = space();
      if (switch_instance2)
        create_component(switch_instance2.$$.fragment);
      switch_instance2_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance0)
        mount_component(switch_instance0, target, anchor);
      insert(target, t0, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, target, anchor);
      insert(target, t1, anchor);
      if (switch_instance2)
        mount_component(switch_instance2, target, anchor);
      insert(target, switch_instance2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance0_changes = {};
      if (dirty & 1)
        switch_instance0_changes.node = ctx2[0].itemVar;
      if (dirty & 4)
        switch_instance0_changes.level = ctx2[2] + 1;
      if (dirty & 1 && switch_value !== (switch_value = getComponent(ctx2[0].itemVar))) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, t0.parentNode, t0);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
        switch_instance0.$set(switch_instance0_changes);
      }
      const switch_instance1_changes = {};
      if (dirty & 1)
        switch_instance1_changes.node = ctx2[0].iterable;
      if (dirty & 4)
        switch_instance1_changes.level = ctx2[2] + 1;
      if (dirty & 1 && switch_value_1 !== (switch_value_1 = getComponent(ctx2[0].iterable))) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx2));
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, t1.parentNode, t1);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        switch_instance1.$set(switch_instance1_changes);
      }
      const switch_instance2_changes = {};
      if (dirty & 1)
        switch_instance2_changes.node = ctx2[0].body;
      if (dirty & 4)
        switch_instance2_changes.level = ctx2[2] + 1;
      if (dirty & 1 && switch_value_2 !== (switch_value_2 = getComponent(ctx2[0].body))) {
        if (switch_instance2) {
          group_outros();
          const old_component = switch_instance2;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_2) {
          switch_instance2 = construct_svelte_component(switch_value_2, switch_props_2(ctx2));
          create_component(switch_instance2.$$.fragment);
          transition_in(switch_instance2.$$.fragment, 1);
          mount_component(switch_instance2, switch_instance2_anchor.parentNode, switch_instance2_anchor);
        } else {
          switch_instance2 = null;
        }
      } else if (switch_value_2) {
        switch_instance2.$set(switch_instance2_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_in(switch_instance2.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      if (switch_instance2)
        transition_out(switch_instance2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (switch_instance0)
        destroy_component(switch_instance0, detaching);
      if (detaching)
        detach(t0);
      if (switch_instance1)
        destroy_component(switch_instance1, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(switch_instance2_anchor);
      if (switch_instance2)
        destroy_component(switch_instance2, detaching);
    }
  };
}
function create_fragment$o(ctx) {
  var _a;
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[2],
      isExpandable: true,
      keepExpanded: ctx[0].body === ((_a = ctx[3]) == null ? void 0 : _a.block),
      highlight: ctx[1],
      title: "for",
      $$slots: {
        children: [create_children_slot$5],
        "menu-items": [
          create_menu_items_slot$8,
          ({ editSource }) => ({ 15: editSource }),
          ({ editSource }) => editSource ? 32768 : 0
        ],
        summary: [create_summary_slot$6]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 4)
        expression_changes.level = ctx2[2];
      if (dirty & 9)
        expression_changes.keepExpanded = ctx2[0].body === ((_a2 = ctx2[3]) == null ? void 0 : _a2.block);
      if (dirty & 2)
        expression_changes.highlight = ctx2[1];
      if (dirty & 98325) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function deleteNode(node) {
  node.parent.remove(node);
}
function instance$o($$self, $$props, $$invalidate) {
  let $curRecPos;
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(4, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { node } = $$props;
  $$subscribe_node();
  let { highlight = false } = $$props;
  let { level = 0 } = $$props;
  const curRecPos = getContext("curRecPos");
  component_subscribe($$self, curRecPos, (value) => $$invalidate(3, $curRecPos = value));
  const mode = getContext("mode");
  const tagList = getContext("tagList");
  const ctx = getContext("expressionCtx");
  if (!ctx) {
    throw new Error("expressionCtx not defined in context");
  }
  let defaultStep = ctx.replace.defaultStep;
  async function insertBefore(node2) {
    let index = node2.parent.nodes.indexOf(node2);
    if (index === -1)
      return;
    insertAt(node2.parent, index, { mode, tagList, defaultStep });
  }
  async function insertAfter(node2) {
    let index = node2.parent.nodes.indexOf(node2) + 1;
    if (index === -1)
      return;
    insertAt(node2.parent, index + 1, { mode, tagList, defaultStep });
  }
  const click_handler2 = () => insertBefore($node);
  const click_handler_1 = () => insertAfter($node);
  const click_handler_2 = () => deleteNode($node);
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("highlight" in $$props2)
      $$invalidate(1, highlight = $$props2.highlight);
    if ("level" in $$props2)
      $$invalidate(2, level = $$props2.level);
  };
  return [
    node,
    highlight,
    level,
    $curRecPos,
    $node,
    curRecPos,
    insertBefore,
    insertAfter,
    click_handler2,
    click_handler_1,
    click_handler_2
  ];
}
class For extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$o, safe_not_equal, { node: 0, highlight: 1, level: 2 });
  }
}
function create_fragment$n(ctx) {
  let svg;
  let g2;
  let g1;
  let g0;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g2 = svg_element("g");
      g1 = svg_element("g");
      g0 = svg_element("g");
      path = svg_element("path");
      attr(path, "d", "M338,3689 C338,3691.209 336.209,3693 334,3693 C331.791,3693 330,3691.209 330,3689 C330,3686.791 331.791,3685 334,3685 C336.209,3685 338,3686.791 338,3689 M334,3697 C329.589,3697 326,3693.411 326,3689 C326,3684.589 329.589,3681 334,3681 C338.411,3681 342,3684.589 342,3689 C342,3693.411 338.411,3697 334,3697 M334,3679 C328.477,3679 324,3683.477 324,3689 C324,3694.523 328.477,3699 334,3699 C339.523,3699 344,3694.523 344,3689 C344,3683.477 339.523,3679 334,3679");
      attr(g0, "transform", "translate(56.000000, 160.000000)");
      attr(g1, "transform", "translate(-380.000000, -3839.000000)");
      attr(g1, "fill", ctx[0]);
      attr(g2, "stroke", "none");
      attr(g2, "stroke-width", "1");
      attr(g2, "fill", "none");
      attr(g2, "fill-rule", "evenodd");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "version", "1.1");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g2);
      append(g2, g1);
      append(g1, g0);
      append(g0, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(g1, "fill", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let { strokeColor = "var(--bs-danger)" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
  };
  return [strokeColor];
}
class Record extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$n, safe_not_equal, { strokeColor: 0 });
  }
}
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[44] = list[i];
  return child_ctx;
}
const get_steps_menu_l_slot_changes = (dirty) => ({});
const get_steps_menu_l_slot_context = (ctx) => ({});
function create_else_block_2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Block";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_11(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Body";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_10(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Steps";
      attr(div, "class", "fw-bolder fs-6");
      set_style(div, "color", "var(--bs-gray)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_8(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_9, create_else_block_1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[6])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_1(ctx) {
  let editabletext;
  let current;
  editabletext = new Text({
    props: {
      value: ctx[11].name,
      validationMessage: ctx[5],
      editMode: true
    }
  });
  editabletext.$on("cancel", ctx[17]);
  editabletext.$on("save", ctx[26]);
  return {
    c() {
      create_component(editabletext.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editabletext, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editabletext_changes = {};
      if (dirty[0] & 2048)
        editabletext_changes.value = ctx2[11].name;
      if (dirty[0] & 32)
        editabletext_changes.validationMessage = ctx2[5];
      editabletext.$set(editabletext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editabletext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editabletext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editabletext, detaching);
    }
  };
}
function create_if_block_9(ctx) {
  let button;
  let t_value = ctx[11].name + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", "btn btn-small btn-outline-secondary py-0 px-1");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[28]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048 && t_value !== (t_value = ctx2[11].name + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_7(ctx) {
  var _a;
  let div;
  let recordicon;
  let current;
  recordicon = new Record({
    props: {
      strokeColor: ((_a = ctx[12]) == null ? void 0 : _a.isRecording) ? "var(--bs-danger)" : "var(--bs-gray)"
    }
  });
  return {
    c() {
      div = element("div");
      create_component(recordicon.$$.fragment);
      set_style(div, "width", "0.8rem");
      set_style(div, "height", "0.8rem");
      attr(div, "class", "d-flex align-items-center");
      attr(div, "data-toggle", "tooltip");
      attr(div, "title", "Steps will be recorded in this block");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(recordicon, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const recordicon_changes = {};
      if (dirty[0] & 4096)
        recordicon_changes.strokeColor = ((_a2 = ctx2[12]) == null ? void 0 : _a2.isRecording) ? "var(--bs-danger)" : "var(--bs-gray)";
      recordicon.$set(recordicon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recordicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recordicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(recordicon);
    }
  };
}
function create_default_slot_8(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_6(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[20]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty[1] & 1024) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_7(ctx) {
  let t;
  return {
    c() {
      t = text("Record in this Block");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_5(ctx) {
  let menuitem0;
  let t;
  let menuitem1;
  let current;
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", ctx[23]);
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", ctx[24]);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t = space();
      create_component(menuitem1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t, anchor);
      mount_component(menuitem1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty[1] & 1024) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty[1] & 1024) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t);
      destroy_component(menuitem1, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step Before");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step After");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_4(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[27]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty[1] & 1024) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  let t;
  return {
    c() {
      t = text("Reset Steps");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[25]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty[1] & 1024) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_items_slot(ctx) {
  let menuitem;
  let t0;
  let t1;
  let t2;
  let t3;
  let if_block3_anchor;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[19]);
  let if_block0 = ctx[12] && create_if_block_6(ctx);
  let if_block1 = ctx[11].parent instanceof Block && create_if_block_5(ctx);
  let if_block2 = !ctx[15] && create_if_block_4(ctx);
  let if_block3 = ctx[11].parent instanceof Block && create_if_block_3(ctx);
  return {
    c() {
      create_component(menuitem.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty[1] & 1024) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
      if (ctx2[12]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[11].parent instanceof Block) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_5(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!ctx2[15])
        if_block2.p(ctx2, dirty);
      if (ctx2[11].parent instanceof Block) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 2048) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_3(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(if_block3_anchor);
    }
  };
}
function create_if_block_1$2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$1, create_else_block$4];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[11].children.length > 0)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$4(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = "Add Statement";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-outline-secondary w-100 border-0");
      attr(div, "class", "bbx-flex bbx-center rounded-2");
      set_style(div, "margin-left", "calc(var(--bbx-gap) * 2 * " + (ctx[11].parent instanceof Block ? ctx[1] + 1 : ctx[1]) + ")");
      set_style(div, "background-color", "var(--bbx-color-menu-bg)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[40]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2050) {
        set_style(div, "margin-left", "calc(var(--bbx-gap) * 2 * " + (ctx2[11].parent instanceof Block ? ctx2[1] + 1 : ctx2[1]) + ")");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$1(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[11].children;
  const get_key = (ctx2) => ctx2[44];
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 6555666) {
        each_value = ctx2[11].children;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$3, each_1_anchor, get_each_context$3);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step Before");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$3(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Step After");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$c(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_parent_context_menu_slot(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuitem2;
  let t2;
  let current;
  function click_handler2() {
    return ctx[37](ctx[44]);
  }
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", click_handler2);
  function click_handler_1() {
    return ctx[38](ctx[44]);
  }
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", click_handler_1);
  function click_handler_2() {
    return ctx[39](ctx[44]);
  }
  menuitem2 = new MenuItem({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx }
    }
  });
  menuitem2.$on("click", click_handler_2);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuitem2.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitem2, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem0_changes = {};
      if (dirty[1] & 1024) {
        menuitem0_changes.$$scope = { dirty, ctx };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty[1] & 1024) {
        menuitem1_changes.$$scope = { dirty, ctx };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty[1] & 1024) {
        menuitem2_changes.$$scope = { dirty, ctx };
      }
      menuitem2.$set(menuitem2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitem2, detaching);
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block$3(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = getComponent(ctx[44]);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[44],
        level: ctx2[11].parent instanceof Block ? ctx2[1] + 1 : ctx2[1],
        highlight: ctx2[4] === ctx2[44],
        $$slots: {
          "parent-context-menu": [create_parent_context_menu_slot]
        },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[0] & 2048)
        switch_instance_changes.node = ctx[44];
      if (dirty[0] & 2050)
        switch_instance_changes.level = ctx[11].parent instanceof Block ? ctx[1] + 1 : ctx[1];
      if (dirty[0] & 2064)
        switch_instance_changes.highlight = ctx[4] === ctx[44];
      if (dirty[0] & 2048 | dirty[1] & 1024) {
        switch_instance_changes.$$scope = { dirty, ctx };
      }
      if (dirty[0] & 2048 && switch_value !== (switch_value = getComponent(ctx[44]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block$8(ctx) {
  let sourceeditor;
  let current;
  sourceeditor = new SourceEditor({
    props: {
      errorMessage: ctx[10],
      source: ctx[11].toJSON(),
      rect: ctx[32]()
    }
  });
  sourceeditor.$on("cancel", ctx[30]);
  sourceeditor.$on("save", ctx[31]);
  return {
    c() {
      create_component(sourceeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sourceeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sourceeditor_changes = {};
      if (dirty[0] & 1024)
        sourceeditor_changes.errorMessage = ctx2[10];
      if (dirty[0] & 2048)
        sourceeditor_changes.source = ctx2[11].toJSON();
      sourceeditor.$set(sourceeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sourceeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sourceeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sourceeditor, detaching);
    }
  };
}
function create_fragment$m(ctx) {
  var _a, _b, _c;
  let div2;
  let button;
  let angleright;
  let t0;
  let t1;
  let t2;
  let t3;
  let div1;
  let t4;
  let div0;
  let menubtn;
  let t5;
  let t6;
  let if_block4_anchor;
  let current;
  let mounted;
  let dispose;
  angleright = new AngleRight({
    props: {
      strokeColor: "var(--bbx-color-gray)",
      class: ctx[3] ? "bbx-rotate-90" : ""
    }
  });
  function select_block_type(ctx2, dirty) {
    if (ctx2[15])
      return create_if_block_10;
    if (ctx2[11].parent instanceof Clause)
      return create_if_block_11;
    return create_else_block_2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = !ctx[15] && ((_b = (_a = ctx[11].root) == null ? void 0 : _a.allowNamedBlocks) != null ? _b : false) && create_if_block_8(ctx);
  let if_block2 = ((_c = ctx[12]) == null ? void 0 : _c.expressionBlock) === ctx[11] && create_if_block_7(ctx);
  const steps_menu_l_slot_template = ctx[33]["steps-menu-l"];
  const steps_menu_l_slot = create_slot(steps_menu_l_slot_template, ctx, ctx[41], get_steps_menu_l_slot_context);
  menubtn = new MenuBtn({
    props: {
      $$slots: { items: [create_items_slot] },
      $$scope: { ctx }
    }
  });
  let if_block3 = ctx[3] && create_if_block_1$2(ctx);
  let if_block4 = ctx[8] && create_if_block$8(ctx);
  return {
    c() {
      div2 = element("div");
      button = element("button");
      create_component(angleright.$$.fragment);
      t0 = space();
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      div1 = element("div");
      if (steps_menu_l_slot)
        steps_menu_l_slot.c();
      t4 = space();
      div0 = element("div");
      create_component(menubtn.$$.fragment);
      t5 = space();
      if (if_block3)
        if_block3.c();
      t6 = space();
      if (if_block4)
        if_block4.c();
      if_block4_anchor = empty();
      attr(button, "class", "btn btn-link d-flex justify-content-center align-items-center p-0 pt-1 shadow-none");
      set_style(button, "width", "1rem");
      set_style(button, "height", "1rem");
      set_style(button, "padding-top", "0.25rem");
      set_style(div0, "visibility", ctx[7] || ctx[15] ? "visible" : "hidden");
      attr(div0, "class", "");
      set_style(div1, "margin-left", "auto");
      attr(div1, "class", "d-flex align-items-center");
      attr(div2, "class", "d-flex gap-2 align-items-center fw-bold");
      set_style(div2, "margin-left", "calc(var(--bbx-gap) * 2 * " + ctx[1] + ")");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, button);
      mount_component(angleright, button, null);
      append(div2, t0);
      if_block0.m(div2, null);
      append(div2, t1);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      append(div2, t3);
      append(div2, div1);
      if (steps_menu_l_slot) {
        steps_menu_l_slot.m(div1, null);
      }
      append(div1, t4);
      append(div1, div0);
      mount_component(menubtn, div0, null);
      ctx[34](div0);
      insert(target, t5, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, t6, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert(target, if_block4_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", ctx[29]),
          listen(div2, "mouseenter", ctx[35]),
          listen(div2, "mouseleave", ctx[36])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      const angleright_changes = {};
      if (dirty[0] & 8)
        angleright_changes.class = ctx2[3] ? "bbx-rotate-90" : "";
      angleright.$set(angleright_changes);
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div2, t1);
        }
      }
      if (!ctx2[15] && ((_b2 = (_a2 = ctx2[11].root) == null ? void 0 : _a2.allowNamedBlocks) != null ? _b2 : false)) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_8(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (((_c2 = ctx2[12]) == null ? void 0 : _c2.expressionBlock) === ctx2[11]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 6144) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_7(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (steps_menu_l_slot) {
        if (steps_menu_l_slot.p && (!current || dirty[1] & 1024)) {
          update_slot_base(
            steps_menu_l_slot,
            steps_menu_l_slot_template,
            ctx2,
            ctx2[41],
            !current ? get_all_dirty_from_scope(ctx2[41]) : get_slot_changes(steps_menu_l_slot_template, ctx2[41], dirty, get_steps_menu_l_slot_changes),
            get_steps_menu_l_slot_context
          );
        }
      }
      const menubtn_changes = {};
      if (dirty[0] & 6144 | dirty[1] & 1024) {
        menubtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menubtn.$set(menubtn_changes);
      if (!current || dirty[0] & 128) {
        set_style(div0, "visibility", ctx2[7] || ctx2[15] ? "visible" : "hidden");
      }
      if (!current || dirty[0] & 2) {
        set_style(div2, "margin-left", "calc(var(--bbx-gap) * 2 * " + ctx2[1] + ")");
      }
      if (ctx2[3]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 8) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$2(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t6.parentNode, t6);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[8]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & 256) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block$8(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(angleright.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(steps_menu_l_slot, local);
      transition_in(menubtn.$$.fragment, local);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(angleright.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(steps_menu_l_slot, local);
      transition_out(menubtn.$$.fragment, local);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(angleright);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (steps_menu_l_slot)
        steps_menu_l_slot.d(detaching);
      destroy_component(menubtn);
      ctx[34](null);
      if (detaching)
        detach(t5);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(t6);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach(if_block4_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(11, $node = $$value)), node);
  let $recorder;
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  const recorder2 = getContext("recorder");
  component_subscribe($$self, recorder2, (value) => $$invalidate(12, $recorder = value));
  const mode = getContext("mode");
  const tagList = getContext("tagList");
  const ctx = getContext("expressionCtx");
  if (!ctx) {
    throw new Error("expressionCtx not defined in context");
  }
  let parentIsRoot = $node.parent instanceof Root;
  let expanded = parentIsRoot || $node.parent instanceof Clause;
  let newChild;
  let renameError = void 0;
  let renameMode = false;
  let showBlockMenu = false;
  let defaultStep = ctx.replace.defaultStep || ctx.replace.stepNames[0] || "click";
  let sourceEditMode = false;
  let menuComponent;
  let sourceEditError;
  function cancelRenameMode() {
    $$invalidate(5, renameError = void 0);
    $$invalidate(6, renameMode = false);
  }
  function deleteChild(child) {
    const index = $node.nodes.indexOf(child);
    $node.remove(child);
    if ($recorder && $node === $recorder.expressionBlock && index < $recorder.cursor) {
      $$invalidate(2, recorder2.cursor -= 1, recorder2);
    }
  }
  function editSource() {
    $$invalidate(8, sourceEditMode = true);
  }
  function recordInThisBlock() {
    if (!$recorder)
      return;
    $$invalidate(2, recorder2.expressionBlock = node, recorder2);
  }
  function setNewChild(child) {
    $$invalidate(4, newChild = child);
  }
  $node.on("child_addition", setNewChild);
  function insertBefore(child) {
    let index = $node.nodes.indexOf(child);
    if (index === -1)
      return;
    insertAt($node, index, { mode, tagList, defaultStep });
    if ($recorder && $node === $recorder.expressionBlock && index <= $recorder.cursor) {
      $$invalidate(2, recorder2.cursor += 1, recorder2);
    }
  }
  function insertAfter(child) {
    let index = $node.nodes.indexOf(child);
    if (index === -1)
      return;
    insertAt($node, index + 1, { mode, tagList, defaultStep });
    if ($recorder && $node === $recorder.expressionBlock && index <= $recorder.cursor) {
      $$invalidate(2, recorder2.cursor += 1, recorder2);
    }
  }
  function insertBeforeNamedBlock() {
    let parent2 = $node.parent;
    let index = parent2.nodes.indexOf($node);
    insertAt(parent2, index, { mode, tagList, defaultStep });
    if ($recorder && parent2 === $recorder.expressionBlock && index <= $recorder.cursor) {
      $$invalidate(2, recorder2.cursor += 1, recorder2);
    }
  }
  function insertAfterNamedBlock() {
    let parent2 = $node.parent;
    let index = parent2.nodes.indexOf($node);
    insertAt(parent2, index + 1, { mode, tagList, defaultStep });
    if ($recorder && parent2 === $recorder.expressionBlock && index <= $recorder.cursor) {
      $$invalidate(2, recorder2.cursor += 1, recorder2);
    }
  }
  function deleteNamedBlock() {
    let parent2 = $node.parent;
    if ($recorder && $recorder.expressionBlock === $node) {
      $$invalidate(2, recorder2.expressionBlock = parent2, recorder2);
    }
    parent2.remove($node);
  }
  function rename({ detail }) {
    $$invalidate(5, renameError = void 0);
    try {
      let _node = $node;
      _node.name = detail;
      $$invalidate(6, renameMode = false);
    } catch (e) {
      console.error(e);
      $$invalidate(5, renameError = `Unable to rename the block to "${detail}"`);
    }
  }
  function removeAllSteps() {
    $node.clear();
  }
  function setRenameMode() {
    $$invalidate(6, renameMode = true);
    $$invalidate(5, renameError = void 0);
  }
  function toggleExpand() {
    $$invalidate(3, expanded = !expanded);
  }
  function cancelSourceEdit() {
    $$invalidate(8, sourceEditMode = false);
  }
  function saveSource({ detail }) {
    try {
      node.parent.replace(detail);
    } catch (e) {
      console.error(e);
      $$invalidate(10, sourceEditError = e.message);
      return;
    }
    $$invalidate(10, sourceEditError = void 0);
    $$invalidate(8, sourceEditMode = false);
  }
  function getRect2() {
    let { left, top, right } = menuComponent.getBoundingClientRect();
    return {
      left: left - 10,
      top: top - 10,
      right: right - 10
    };
  }
  onDestroy(() => {
    $node.off("child_addition", setNewChild);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      menuComponent = $$value;
      $$invalidate(9, menuComponent);
    });
  }
  const mouseenter_handler = () => $$invalidate(7, showBlockMenu = true);
  const mouseleave_handler = () => $$invalidate(7, showBlockMenu = false);
  const click_handler2 = (child) => insertBefore(child);
  const click_handler_1 = (child) => insertAfter(child);
  const click_handler_2 = (child) => deleteChild(child);
  const click_handler_3 = () => insertAt($node, 0, { mode, tagList, defaultStep });
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("$$scope" in $$props2)
      $$invalidate(41, $$scope = $$props2.$$scope);
  };
  return [
    node,
    level,
    recorder2,
    expanded,
    newChild,
    renameError,
    renameMode,
    showBlockMenu,
    sourceEditMode,
    menuComponent,
    sourceEditError,
    $node,
    $recorder,
    mode,
    tagList,
    parentIsRoot,
    defaultStep,
    cancelRenameMode,
    deleteChild,
    editSource,
    recordInThisBlock,
    insertBefore,
    insertAfter,
    insertBeforeNamedBlock,
    insertAfterNamedBlock,
    deleteNamedBlock,
    rename,
    removeAllSteps,
    setRenameMode,
    toggleExpand,
    cancelSourceEdit,
    saveSource,
    getRect2,
    slots,
    div0_binding,
    mouseenter_handler,
    mouseleave_handler,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    $$scope
  ];
}
class Block_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$m, safe_not_equal, { node: 0, level: 1 }, null, [-1, -1]);
  }
}
const get_parent_context_menu_slot_changes$7 = (dirty) => ({ getRect: dirty & 128 });
const get_parent_context_menu_slot_context$7 = (ctx) => ({ getRect: ctx[7] });
function create_summary_slot$5(ctx) {
  let t_value = `${getSummary(ctx[4].reference)} = ${getSummary(ctx[4].value)}`;
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = `${getSummary(ctx2[4].reference)} = ${getSummary(ctx2[4].value)}`))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$b(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$7(ctx) {
  let menuitem;
  let t;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", function() {
    if (is_function(ctx[9]))
      ctx[9].apply(this, arguments);
  });
  const parent_context_menu_slot_template = ctx[5]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[6], get_parent_context_menu_slot_context$7);
  return {
    c() {
      create_component(menuitem.$$.fragment);
      t = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      insert(target, t, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 64) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 192)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[6],
            !current ? get_all_dirty_from_scope(ctx[6]) : get_slot_changes(parent_context_menu_slot_template, ctx[6], dirty, get_parent_context_menu_slot_changes$7),
            get_parent_context_menu_slot_context$7
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_children_slot$4(ctx) {
  let switch_instance0;
  let t;
  let switch_instance1;
  let switch_instance1_anchor;
  let current;
  var switch_value = getComponent(ctx[4].reference);
  function switch_props(ctx2) {
    return {
      props: {
        label: "variable",
        node: ctx2[4].reference,
        level: ctx2[1] + 1,
        compact: ctx2[2]
      }
    };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
  }
  var switch_value_1 = getComponent(ctx[4].value);
  function switch_props_1(ctx2) {
    return {
      props: {
        label: "value",
        node: ctx2[4].value,
        level: ctx2[1] + 1,
        compact: ctx2[2]
      }
    };
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
  }
  return {
    c() {
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t = space();
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      switch_instance1_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance0)
        mount_component(switch_instance0, target, anchor);
      insert(target, t, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, target, anchor);
      insert(target, switch_instance1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance0_changes = {};
      if (dirty & 16)
        switch_instance0_changes.node = ctx2[4].reference;
      if (dirty & 2)
        switch_instance0_changes.level = ctx2[1] + 1;
      if (dirty & 4)
        switch_instance0_changes.compact = ctx2[2];
      if (dirty & 16 && switch_value !== (switch_value = getComponent(ctx2[4].reference))) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, t.parentNode, t);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
        switch_instance0.$set(switch_instance0_changes);
      }
      const switch_instance1_changes = {};
      if (dirty & 16)
        switch_instance1_changes.node = ctx2[4].value;
      if (dirty & 2)
        switch_instance1_changes.level = ctx2[1] + 1;
      if (dirty & 4)
        switch_instance1_changes.compact = ctx2[2];
      if (dirty & 16 && switch_value_1 !== (switch_value_1 = getComponent(ctx2[4].value))) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx2));
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, switch_instance1_anchor.parentNode, switch_instance1_anchor);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        switch_instance1.$set(switch_instance1_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (switch_instance0)
        destroy_component(switch_instance0, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(switch_instance1_anchor);
      if (switch_instance1)
        destroy_component(switch_instance1, detaching);
    }
  };
}
function create_fragment$l(ctx) {
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[1],
      compact: ctx[2],
      highlight: ctx[3],
      title: "Assign",
      $$slots: {
        children: [create_children_slot$4],
        "menu-items": [
          create_menu_items_slot$7,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            7: getRect2,
            8: replaceNode2,
            9: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 128 : 0) | (replaceNode2 ? 256 : 0) | (editSource ? 512 : 0)
        ],
        summary: [create_summary_slot$5]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 2)
        expression_changes.level = ctx2[1];
      if (dirty & 4)
        expression_changes.compact = ctx2[2];
      if (dirty & 8)
        expression_changes.highlight = ctx2[3];
      if (dirty & 726) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(4, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { compact = false } = $$props;
  let { highlight = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("compact" in $$props2)
      $$invalidate(2, compact = $$props2.compact);
    if ("highlight" in $$props2)
      $$invalidate(3, highlight = $$props2.highlight);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [node, level, compact, highlight, $node, slots, $$scope];
}
class Assignment extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$l, safe_not_equal, {
      node: 0,
      level: 1,
      compact: 2,
      highlight: 3
    });
  }
}
const get_parent_context_menu_slot_changes$6 = (dirty) => ({ getRect: dirty & 131072 });
const get_parent_context_menu_slot_context$6 = (ctx) => ({ getRect: ctx[17] });
function create_label_slot$7(ctx) {
  var _a;
  let t_value = ((_a = ctx[2]) != null ? _a : ctx[5].name) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 36 && t_value !== (t_value = ((_a2 = ctx2[2]) != null ? _a2 : ctx2[5].name) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$2(ctx) {
  let t;
  return {
    c() {
      t = text("Replace");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$a(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$6(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let current;
  function click_handler2() {
    return ctx[7](ctx[18]);
  }
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", click_handler2);
  function click_handler_1() {
    return ctx[8](ctx[19]);
  }
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", click_handler_1);
  const parent_context_menu_slot_template = ctx[6]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[9], get_parent_context_menu_slot_context$6);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem0_changes = {};
      if (dirty & 512) {
        menuitem0_changes.$$scope = { dirty, ctx };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 512) {
        menuitem1_changes.$$scope = { dirty, ctx };
      }
      menuitem1.$set(menuitem1_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 131584)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[9],
            !current ? get_all_dirty_from_scope(ctx[9]) : get_slot_changes(parent_context_menu_slot_template, ctx[9], dirty, get_parent_context_menu_slot_changes$6),
            get_parent_context_menu_slot_context$6
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_fragment$k(ctx) {
  let expressioncomponent;
  let current;
  expressioncomponent = new Expression({
    props: {
      node: ctx[0],
      level: ctx[1],
      compact: ctx[4],
      highlight: ctx[3],
      hideSummaryRow: true,
      title: ctx[5].value,
      $$slots: {
        "menu-items": [
          create_menu_items_slot$6,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            17: getRect2,
            18: replaceNode2,
            19: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 131072 : 0) | (replaceNode2 ? 262144 : 0) | (editSource ? 524288 : 0)
        ],
        label: [create_label_slot$7]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expressioncomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expressioncomponent, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expressioncomponent_changes = {};
      if (dirty & 1)
        expressioncomponent_changes.node = ctx2[0];
      if (dirty & 2)
        expressioncomponent_changes.level = ctx2[1];
      if (dirty & 16)
        expressioncomponent_changes.compact = ctx2[4];
      if (dirty & 8)
        expressioncomponent_changes.highlight = ctx2[3];
      if (dirty & 32)
        expressioncomponent_changes.title = ctx2[5].value;
      if (dirty & 918052) {
        expressioncomponent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expressioncomponent.$set(expressioncomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expressioncomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expressioncomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expressioncomponent, detaching);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(5, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label = void 0 } = $$props;
  let { highlight = false } = $$props;
  let { compact = false } = $$props;
  getContext("mode");
  getContext("tagList");
  getContext("browserView");
  const click_handler2 = (replaceNode2) => replaceNode2();
  const click_handler_1 = (editSource) => editSource();
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("highlight" in $$props2)
      $$invalidate(3, highlight = $$props2.highlight);
    if ("compact" in $$props2)
      $$invalidate(4, compact = $$props2.compact);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    node,
    level,
    label,
    highlight,
    compact,
    $node,
    slots,
    click_handler2,
    click_handler_1,
    $$scope
  ];
}
class Enum extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$k, safe_not_equal, {
      node: 0,
      level: 1,
      label: 2,
      highlight: 3,
      compact: 4
    });
  }
}
const get_parent_context_menu_slot_changes$5 = (dirty) => ({ getRect: dirty & 128 });
const get_parent_context_menu_slot_context$5 = (ctx) => ({ getRect: ctx[7] });
function create_summary_slot$4(ctx) {
  let div;
  let t_value = ctx[4].code + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = ctx2[4].code + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$9(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$5(ctx) {
  let menuitem;
  let t;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", function() {
    if (is_function(ctx[9]))
      ctx[9].apply(this, arguments);
  });
  const parent_context_menu_slot_template = ctx[5]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[6], get_parent_context_menu_slot_context$5);
  return {
    c() {
      create_component(menuitem.$$.fragment);
      t = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      insert(target, t, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 64) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 192)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[6],
            !current ? get_all_dirty_from_scope(ctx[6]) : get_slot_changes(parent_context_menu_slot_template, ctx[6], dirty, get_parent_context_menu_slot_changes$5),
            get_parent_context_menu_slot_context$5
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_error_slot$1(ctx) {
  var _a;
  let div;
  let t_value = ((_a = ctx[4].description) != null ? _a : "") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 16 && t_value !== (t_value = ((_a2 = ctx2[4].description) != null ? _a2 : "") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$j(ctx) {
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[1],
      compact: ctx[3],
      highlight: ctx[2],
      title: "Error",
      $$slots: {
        error: [create_error_slot$1],
        "menu-items": [
          create_menu_items_slot$5,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            7: getRect2,
            8: replaceNode2,
            9: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 128 : 0) | (replaceNode2 ? 256 : 0) | (editSource ? 512 : 0)
        ],
        summary: [create_summary_slot$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 2)
        expression_changes.level = ctx2[1];
      if (dirty & 8)
        expression_changes.compact = ctx2[3];
      if (dirty & 4)
        expression_changes.highlight = ctx2[2];
      if (dirty & 720) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(4, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { highlight = false } = $$props;
  let { compact = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("highlight" in $$props2)
      $$invalidate(2, highlight = $$props2.highlight);
    if ("compact" in $$props2)
      $$invalidate(3, compact = $$props2.compact);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [node, level, highlight, compact, $node, slots, $$scope];
}
class Error$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$j, safe_not_equal, {
      node: 0,
      level: 1,
      highlight: 2,
      compact: 3
    });
  }
}
const get_parent_context_menu_slot_changes$4 = (dirty) => ({ getRect: dirty & 2048 });
const get_parent_context_menu_slot_context$4 = (ctx) => ({ getRect: ctx[11] });
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  child_ctx[10] = i;
  return child_ctx;
}
function create_label_slot$6(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_summary_slot$3(ctx) {
  let div;
  let t_value = getSummary(ctx[5]) + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = getSummary(ctx2[5]) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$8(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$4(ctx) {
  let menuitem;
  let t;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", function() {
    if (is_function(ctx[13]))
      ctx[13].apply(this, arguments);
  });
  const parent_context_menu_slot_template = ctx[6]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[7], get_parent_context_menu_slot_context$4);
  return {
    c() {
      create_component(menuitem.$$.fragment);
      t = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      insert(target, t, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 128) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 2176)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[7],
            !current ? get_all_dirty_from_scope(ctx[7]) : get_slot_changes(parent_context_menu_slot_template, ctx[7], dirty, get_parent_context_menu_slot_changes$4),
            get_parent_context_menu_slot_context$4
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_each_block$2(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = getComponent(ctx[8]);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[8],
        level: ctx2[1] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty & 32)
        switch_instance_changes.node = ctx[8];
      if (dirty & 2)
        switch_instance_changes.level = ctx[1] + 1;
      if (dirty & 32 && switch_value !== (switch_value = getComponent(ctx[8]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_children_slot$3(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[5].children;
  const get_key = (ctx2) => ctx2[8];
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 34) {
        each_value = ctx2[5].children;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$2, each_1_anchor, get_each_context$2);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment$i(ctx) {
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[1],
      compact: ctx[4],
      highlight: ctx[3],
      title: "Array",
      $$slots: {
        children: [create_children_slot$3],
        "menu-items": [
          create_menu_items_slot$4,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            11: getRect2,
            12: replaceNode2,
            13: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 2048 : 0) | (replaceNode2 ? 4096 : 0) | (editSource ? 8192 : 0)
        ],
        summary: [create_summary_slot$3],
        label: [create_label_slot$6]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 2)
        expression_changes.level = ctx2[1];
      if (dirty & 16)
        expression_changes.compact = ctx2[4];
      if (dirty & 8)
        expression_changes.highlight = ctx2[3];
      if (dirty & 10406) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(5, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label = void 0 } = $$props;
  let { highlight = false } = $$props;
  let { compact = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("highlight" in $$props2)
      $$invalidate(3, highlight = $$props2.highlight);
    if ("compact" in $$props2)
      $$invalidate(4, compact = $$props2.compact);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  return [node, level, label, highlight, compact, $node, slots, $$scope];
}
class Array$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$i, safe_not_equal, {
      node: 0,
      level: 1,
      label: 2,
      highlight: 3,
      compact: 4
    });
  }
}
const get_parent_context_menu_slot_changes$3 = (dirty) => ({ getRect: dirty & 256 });
const get_parent_context_menu_slot_context$3 = (ctx) => ({ getRect: ctx[8] });
function create_default_slot$7(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$3(ctx) {
  let menuitem;
  let t;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", function() {
    if (is_function(ctx[10]))
      ctx[10].apply(this, arguments);
  });
  const parent_context_menu_slot_template = ctx[6]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[7], get_parent_context_menu_slot_context$3);
  return {
    c() {
      create_component(menuitem.$$.fragment);
      t = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      insert(target, t, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 128) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 384)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[7],
            !current ? get_all_dirty_from_scope(ctx[7]) : get_slot_changes(parent_context_menu_slot_template, ctx[7], dirty, get_parent_context_menu_slot_changes$3),
            get_parent_context_menu_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_else_block$3(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<a href="javascript:void(0)">Set return value</a>`;
      attr(div0, "class", "bbx-expand-angle bbx-pad");
      attr(div1, "class", "bbx-pad-y");
      attr(div2, "class", "bbx-flex bbx-center bbx-border bbx-rounded");
      set_style(div2, "margin-left", "calc(var(--bbx-gap) * 2 * " + ctx[2] + ")");
      set_style(div2, "background-color", "var(--bbx-color-menu-bg)");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t0);
      append(div2, div1);
      if (!mounted) {
        dispose = listen(div1, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        set_style(div2, "margin-left", "calc(var(--bbx-gap) * 2 * " + ctx2[2] + ")");
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$7(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = getComponent(ctx[4].value);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[4].value,
        level: ctx2[2] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 16)
        switch_instance_changes.node = ctx2[4].value;
      if (dirty & 4)
        switch_instance_changes.level = ctx2[2] + 1;
      if (dirty & 16 && switch_value !== (switch_value = getComponent(ctx2[4].value))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_children_slot$2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$7, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4].value)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$h(ctx) {
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[2],
      compact: ctx[3],
      highlight: ctx[1],
      title: "return",
      $$slots: {
        children: [create_children_slot$2],
        "menu-items": [
          create_menu_items_slot$3,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            8: getRect2,
            9: replaceNode2,
            10: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 256 : 0) | (replaceNode2 ? 512 : 0) | (editSource ? 1024 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 4)
        expression_changes.level = ctx2[2];
      if (dirty & 8)
        expression_changes.compact = ctx2[3];
      if (dirty & 2)
        expression_changes.highlight = ctx2[1];
      if (dirty & 1428) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(4, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { highlight = false } = $$props;
  let { level = 0 } = $$props;
  let { compact = false } = $$props;
  function setNodeValue() {
    node.replace(void 0, "returnValue");
  }
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("highlight" in $$props2)
      $$invalidate(1, highlight = $$props2.highlight);
    if ("level" in $$props2)
      $$invalidate(2, level = $$props2.level);
    if ("compact" in $$props2)
      $$invalidate(3, compact = $$props2.compact);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  return [node, highlight, level, compact, $node, setNodeValue, slots, $$scope];
}
class Return extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$h, safe_not_equal, {
      node: 0,
      highlight: 1,
      level: 2,
      compact: 3
    });
  }
}
const get_parent_context_menu_slot_changes$2 = (dirty) => ({ getRect: dirty & 1024 });
const get_parent_context_menu_slot_context$2 = (ctx) => ({ getRect: ctx[10] });
function create_if_block_2(ctx) {
  let span;
  let t;
  let tooltip_action;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
      if (!mounted) {
        dispose = action_destroyer(tooltip_action = tooltip.call(null, span, ctx[5].join(" | ")));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
      if (tooltip_action && is_function(tooltip_action.update) && dirty & 32)
        tooltip_action.update.call(null, ctx2[5].join(" | "));
    },
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_label_slot$5(ctx) {
  let if_block_anchor;
  let if_block = ctx[2] && create_if_block_2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_summary_slot$2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = inlineByType(ctx[6]);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[0],
        label: ctx2[2]
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 1)
        switch_instance_changes.node = ctx2[0];
      if (dirty & 4)
        switch_instance_changes.label = ctx2[2];
      if (dirty & 64 && switch_value !== (switch_value = inlineByType(ctx2[6]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block$6(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_1$1, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[7])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "d-flex bbx-error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_else_block$2(ctx) {
  let span;
  let t_value = ctx[13].message + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8192 && t_value !== (t_value = ctx2[13].message + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_1$1(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[7];
  function switch_props(ctx2) {
    return { props: { error: ctx2[13] } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 8192)
        switch_instance_changes.error = ctx2[13];
      if (switch_value !== (switch_value = ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_error_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[13] && create_if_block$6(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[13]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8192) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot$6(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$2(ctx) {
  let menuitem;
  let t;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", function() {
    if (is_function(ctx[12]))
      ctx[12].apply(this, arguments);
  });
  const parent_context_menu_slot_template = ctx[8]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[9], get_parent_context_menu_slot_context$2);
  return {
    c() {
      create_component(menuitem.$$.fragment);
      t = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      insert(target, t, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 512) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 1536)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[9],
            !current ? get_all_dirty_from_scope(ctx[9]) : get_slot_changes(parent_context_menu_slot_template, ctx[9], dirty, get_parent_context_menu_slot_changes$2),
            get_parent_context_menu_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_children_slot$1(ctx) {
  let div;
  let condition;
  let current;
  condition = new Condition({
    props: {
      node: ctx[0],
      level: ctx[1] + 1,
      highlight: ctx[4]
    }
  });
  return {
    c() {
      div = element("div");
      create_component(condition.$$.fragment);
      attr(div, "class", "bbx-rounded");
      set_style(div, "border-color", "var(--bbx-color-menu-bg)");
      set_style(div, "margin-left", "calc(var(--bbx-gap)*2 * " + (ctx[1] + 1) + ")");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(condition, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const condition_changes = {};
      if (dirty & 1)
        condition_changes.node = ctx2[0];
      if (dirty & 2)
        condition_changes.level = ctx2[1] + 1;
      if (dirty & 16)
        condition_changes.highlight = ctx2[4];
      condition.$set(condition_changes);
      if (!current || dirty & 2) {
        set_style(div, "margin-left", "calc(var(--bbx-gap)*2 * " + (ctx2[1] + 1) + ")");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(condition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(condition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(condition);
    }
  };
}
function create_fragment$g(ctx) {
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[1],
      compact: ctx[3],
      highlight: ctx[4],
      title: ctx[0].name,
      $$slots: {
        children: [create_children_slot$1],
        "menu-items": [
          create_menu_items_slot$2,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            10: getRect2,
            11: replaceNode2,
            12: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 1024 : 0) | (replaceNode2 ? 2048 : 0) | (editSource ? 4096 : 0)
        ],
        error: [
          create_error_slot,
          ({ error }) => ({ 13: error }),
          ({ error }) => error ? 8192 : 0
        ],
        summary: [create_summary_slot$2],
        label: [create_label_slot$5]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 2)
        expression_changes.level = ctx2[1];
      if (dirty & 8)
        expression_changes.compact = ctx2[3];
      if (dirty & 16)
        expression_changes.highlight = ctx2[4];
      if (dirty & 1)
        expression_changes.title = ctx2[0].name;
      if (dirty & 13943) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(6, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  const errorMessageComponent = getContext("errorMessageComponent");
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label = void 0 } = $$props;
  let { compact = false } = $$props;
  let { highlight = false } = $$props;
  let { types: types2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("compact" in $$props2)
      $$invalidate(3, compact = $$props2.compact);
    if ("highlight" in $$props2)
      $$invalidate(4, highlight = $$props2.highlight);
    if ("types" in $$props2)
      $$invalidate(5, types2 = $$props2.types);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    node,
    level,
    label,
    compact,
    highlight,
    types2,
    $node,
    errorMessageComponent,
    slots,
    $$scope
  ];
}
class AndOrNot extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$g, safe_not_equal, {
      node: 0,
      level: 1,
      label: 2,
      compact: 3,
      highlight: 4,
      types: 5
    });
  }
}
const get_parent_context_menu_slot_changes$1 = (dirty) => ({ getRect: dirty & 1024 });
const get_parent_context_menu_slot_context$1 = (ctx) => ({ getRect: ctx[10] });
function create_label_slot$4(ctx) {
  let t;
  return {
    c() {
      t = text("field");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_label_post_slot(ctx) {
  let angleright;
  let current;
  angleright = new AngleRight({
    props: {
      class: "bbx-rotate-90",
      size: "8",
      strokeColor: "#999"
    }
  });
  return {
    c() {
      create_component(angleright.$$.fragment);
    },
    m(target, anchor) {
      mount_component(angleright, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(angleright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(angleright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(angleright, detaching);
    }
  };
}
function create_summary_slot$1(ctx) {
  let searchselect;
  let current;
  searchselect = new SearchSelect({
    props: {
      dropDownStyle: "font-size: 0.7rem;",
      style: "width: fit-content;",
      actionClass: "bbx-step__header bbx-flex bbx-align-center bbx-h-1 bbx-gap bbx-not-link",
      value: getSummary(ctx[0]),
      defaultActionLabel: getSummary(ctx[0]),
      options: ctx[4],
      $$slots: { "label-post": [create_label_post_slot] },
      $$scope: { ctx }
    }
  });
  searchselect.$on("open", ctx[5]);
  searchselect.$on("select", ctx[6]);
  return {
    c() {
      create_component(searchselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const searchselect_changes = {};
      if (dirty & 1)
        searchselect_changes.value = getSummary(ctx2[0]);
      if (dirty & 1)
        searchselect_changes.defaultActionLabel = getSummary(ctx2[0]);
      if (dirty & 16)
        searchselect_changes.options = ctx2[4];
      if (dirty & 256) {
        searchselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      searchselect.$set(searchselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchselect, detaching);
    }
  };
}
function create_default_slot$5(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot$1(ctx) {
  let menuitem;
  let t;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", function() {
    if (is_function(ctx[12]))
      ctx[12].apply(this, arguments);
  });
  const parent_context_menu_slot_template = ctx[7]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[8], get_parent_context_menu_slot_context$1);
  return {
    c() {
      create_component(menuitem.$$.fragment);
      t = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      insert(target, t, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 256) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 1280)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[8],
            !current ? get_all_dirty_from_scope(ctx[8]) : get_slot_changes(parent_context_menu_slot_template, ctx[8], dirty, get_parent_context_menu_slot_changes$1),
            get_parent_context_menu_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_fragment$f(ctx) {
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[1],
      compact: ctx[3],
      highlight: ctx[2],
      hideSummaryRow: ctx[0].returnType === "boolean",
      title: "string",
      $$slots: {
        "menu-items": [
          create_menu_items_slot$1,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            10: getRect2,
            11: replaceNode2,
            12: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 1024 : 0) | (replaceNode2 ? 2048 : 0) | (editSource ? 4096 : 0)
        ],
        summary: [create_summary_slot$1],
        label: [create_label_slot$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 2)
        expression_changes.level = ctx2[1];
      if (dirty & 8)
        expression_changes.compact = ctx2[3];
      if (dirty & 4)
        expression_changes.highlight = ctx2[2];
      if (dirty & 1)
        expression_changes.hideSummaryRow = ctx2[0].returnType === "boolean";
      if (dirty & 5393) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(9, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { highlight = false } = $$props;
  let { compact = false } = $$props;
  let matchingFields = [];
  function onOpen() {
    const structName = $node.parent.operands[0].returnType;
    const structDef = node.scope.getStruct(structName);
    const replacementTypes = getReplacementTypes(node.parent);
    $$invalidate(4, matchingFields = []);
    for (const [fieldName, fieldDef] of Object.entries(structDef.fields)) {
      if (replacementTypes.includes(fieldDef.types[0])) {
        matchingFields.push(fieldName);
      }
    }
  }
  function replaceField({ detail: fieldName }) {
    $node.parent.replace($node, fieldName);
  }
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("highlight" in $$props2)
      $$invalidate(2, highlight = $$props2.highlight);
    if ("compact" in $$props2)
      $$invalidate(3, compact = $$props2.compact);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [
    node,
    level,
    highlight,
    compact,
    matchingFields,
    onOpen,
    replaceField,
    slots,
    $$scope
  ];
}
class AccessorField extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$f, safe_not_equal, {
      node: 0,
      level: 1,
      highlight: 2,
      compact: 3
    });
  }
}
const get_parent_context_menu_slot_changes = (dirty) => ({ getRect: dirty & 256 });
const get_parent_context_menu_slot_context = (ctx) => ({ getRect: ctx[8] });
function create_label_slot$3(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_summary_slot(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = inlineByType(ctx[5]);
  function switch_props(ctx2) {
    return { props: { node: ctx2[0] } };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 1)
        switch_instance_changes.node = ctx2[0];
      if (dirty & 32 && switch_value !== (switch_value = inlineByType(ctx2[5]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot$4(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_menu_items_slot(ctx) {
  let menuitem;
  let t;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", function() {
    if (is_function(ctx[10]))
      ctx[10].apply(this, arguments);
  });
  const parent_context_menu_slot_template = ctx[6]["parent-context-menu"];
  const parent_context_menu_slot = create_slot(parent_context_menu_slot_template, ctx, ctx[7], get_parent_context_menu_slot_context);
  return {
    c() {
      create_component(menuitem.$$.fragment);
      t = space();
      if (parent_context_menu_slot)
        parent_context_menu_slot.c();
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      insert(target, t, anchor);
      if (parent_context_menu_slot) {
        parent_context_menu_slot.m(target, anchor);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 128) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
      if (parent_context_menu_slot) {
        if (parent_context_menu_slot.p && (!current || dirty & 384)) {
          update_slot_base(
            parent_context_menu_slot,
            parent_context_menu_slot_template,
            ctx,
            ctx[7],
            !current ? get_all_dirty_from_scope(ctx[7]) : get_slot_changes(parent_context_menu_slot_template, ctx[7], dirty, get_parent_context_menu_slot_changes),
            get_parent_context_menu_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      transition_in(parent_context_menu_slot, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      transition_out(parent_context_menu_slot, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
      if (detaching)
        detach(t);
      if (parent_context_menu_slot)
        parent_context_menu_slot.d(detaching);
    }
  };
}
function create_children_slot(ctx) {
  let switch_instance;
  let t;
  let accessorfield;
  let current;
  var switch_value = getComponent(ctx[5].operands[0]);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[5].operands[0],
        label: "struct",
        level: ctx2[1] + 1
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  accessorfield = new AccessorField({
    props: {
      node: ctx[5].operands[1],
      level: ctx[1] + 1
    }
  });
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      create_component(accessorfield.$$.fragment);
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, t, anchor);
      mount_component(accessorfield, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 32)
        switch_instance_changes.node = ctx2[5].operands[0];
      if (dirty & 2)
        switch_instance_changes.level = ctx2[1] + 1;
      if (dirty & 32 && switch_value !== (switch_value = getComponent(ctx2[5].operands[0]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      const accessorfield_changes = {};
      if (dirty & 32)
        accessorfield_changes.node = ctx2[5].operands[1];
      if (dirty & 2)
        accessorfield_changes.level = ctx2[1] + 1;
      accessorfield.$set(accessorfield_changes);
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(accessorfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(accessorfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      if (detaching)
        detach(t);
      destroy_component(accessorfield, detaching);
    }
  };
}
function create_fragment$e(ctx) {
  let expression;
  let current;
  expression = new Expression({
    props: {
      node: ctx[0],
      level: ctx[1],
      compact: ctx[4],
      highlight: ctx[3],
      title: "<access>",
      $$slots: {
        children: [create_children_slot],
        "menu-items": [
          create_menu_items_slot,
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => ({
            8: getRect2,
            9: replaceNode2,
            10: editSource
          }),
          ({ getRect: getRect2, replaceNode: replaceNode2, editSource }) => (getRect2 ? 256 : 0) | (replaceNode2 ? 512 : 0) | (editSource ? 1024 : 0)
        ],
        summary: [create_summary_slot],
        label: [create_label_slot$3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(expression.$$.fragment);
    },
    m(target, anchor) {
      mount_component(expression, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const expression_changes = {};
      if (dirty & 1)
        expression_changes.node = ctx2[0];
      if (dirty & 2)
        expression_changes.level = ctx2[1];
      if (dirty & 16)
        expression_changes.compact = ctx2[4];
      if (dirty & 8)
        expression_changes.highlight = ctx2[3];
      if (dirty & 1447) {
        expression_changes.$$scope = { dirty, ctx: ctx2 };
      }
      expression.$set(expression_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(expression, detaching);
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let $node, $$unsubscribe_node = noop, $$subscribe_node = () => ($$unsubscribe_node(), $$unsubscribe_node = subscribe$1(node, ($$value) => $$invalidate(5, $node = $$value)), node);
  $$self.$$.on_destroy.push(() => $$unsubscribe_node());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { node } = $$props;
  $$subscribe_node();
  let { level = 0 } = $$props;
  let { label = void 0 } = $$props;
  let { highlight = false } = $$props;
  let { compact = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$subscribe_node($$invalidate(0, node = $$props2.node));
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("label" in $$props2)
      $$invalidate(2, label = $$props2.label);
    if ("highlight" in $$props2)
      $$invalidate(3, highlight = $$props2.highlight);
    if ("compact" in $$props2)
      $$invalidate(4, compact = $$props2.compact);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  return [node, level, label, highlight, compact, $node, slots, $$scope];
}
class Accessor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$e, safe_not_equal, {
      node: 0,
      level: 1,
      label: 2,
      highlight: 3,
      compact: 4
    });
  }
}
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function debounce(callback, time) {
  let interval;
  return (...args) => {
    if (interval) {
      clearTimeout(interval);
    }
    interval = setTimeout(() => {
      interval = null;
      callback(...args);
    }, time);
  };
}
function hasIntersection(items1, items2) {
  if (!items1) {
    return false;
  }
  for (let l1 of items1) {
    for (let l2 of items2) {
      if (l2 === l1) {
        return true;
      }
    }
  }
  return false;
}
const ID = function(x) {
  return function() {
    return x++;
  };
}(1);
function getAllControls(node, defaultExprs) {
  var _a;
  let defaultCondition = defaultExprs["if..else"] || ["cond"];
  let controls = {
    "if..else": defaultCondition
  };
  if ((_a = node.root) == null ? void 0 : _a.allowNamedBlocks) {
    controls["block"] = ["block"];
  }
  controls["while loop"] = defaultExprs["while loop"];
  controls["for loop"] = defaultExprs["for loop"];
  return controls;
}
function getAllSteps(funcDefs, opts) {
  let { stepNames, defaultExprs, labels } = opts;
  if (!labels) {
    labels = ["action"];
  }
  let steps = {};
  for (let [funcName, funcDef] of funcDefs.entries()) {
    if (stepNames.includes(funcName) && hasIntersection(funcDef.labels, labels)) {
      steps[funcName] = getDefaultExpression(funcName, defaultExprs);
    }
  }
  return steps;
}
function getVarDecs(node) {
  let vars = node.scope.getAllVars();
  let decs = {
    "declaration": ["var", "variable_" + ID(), "string"]
  };
  if (vars.size > 0) {
    let [firstVar] = vars.keys();
    decs["assignment"] = ["=", `$${firstVar}`, ""];
  }
  return decs;
}
function getReturnDecs() {
  return {
    "return": ["return"]
  };
}
function getAlternateExpressions(node, opts) {
  let parentType = node.parent.type;
  switch (parentType) {
    case C.CLAUSE:
      return { ...getMatchingExpressions(node, [C.BOOLEAN], opts.defaultExprs) };
    case C.RETURN:
      let types2 = [...node.scope.basicTypes, ...node.scope.getAllStructs().keys(), ...node.scope.getAllEnums().keys()];
      let funcs = { ...getMatchingExpressions(node, types2, opts.defaultExprs) };
      return funcs;
    case C.BLOCK:
      let expressions = getAllSteps(node.scope.getAllFuncs(), opts);
      if (!opts.skipControl) {
        expressions = { ...expressions, ...getAllControls(node, opts.defaultExprs) };
      }
      if (opts.allowVarDecs) {
        expressions = { ...expressions, ...getVarDecs(node) };
      }
      expressions = { ...expressions, ...getReturnDecs() };
      return expressions;
    case C.OPERATOR:
      if (["and", "or", "not"].includes(node.parent.name)) {
        return { ...getMatchingExpressions(node, [C.BOOLEAN], opts.defaultExprs) };
      }
      if (node.parent instanceof Accessor$2) {
        const index = node.parent.children.indexOf(node);
        if (index == 0) {
          const exprs = {};
          for (const [label, exp] of Object.entries(getMatchingAccessors(node.parent, getReplacementTypes(node.parent), opts.defaultExprs))) {
            const lhs = label.substring(0, label.indexOf("->"));
            exprs[lhs] = lhs;
          }
          return exprs;
        }
      }
    case C.FUNCTION_CALL:
    case C.STRUCT:
      return { ...getMatchingExpressions(node, getReplacementTypes(node), opts.defaultExprs) };
    case C.ARRAY_NODE:
    case C.VARIABLE_DECLARATION:
      return { ...getMatchingExpressions(node, getReplacementTypes(node), opts.defaultExprs) };
    case C.ASSIGNMENT:
      let [variableReference, assignmentExpr] = node.parent.children;
      if (node === variableReference) {
        let exprs = [];
        for (let [key, varDec] of node.scope.getAllVars().entries()) {
          exprs["$" + key] = "$" + key;
        }
        return exprs;
      } else {
        return { ...getMatchingExpressions(node, [variableReference.returnType], opts.defaultExprs) };
      }
    case C.FOR:
      if (node instanceof VariableDeclaration$1) {
        return { ...getMatchingExpressions(node, getReplacementTypes(node), opts.defaultExprs) };
      }
      const iteratorTypes = ["selector", C.ARRAY, C.ITERABLE, ...getIteratorTypes(node)];
      return { ...getMatchingExpressions(node, iteratorTypes, opts.defaultExprs) };
    default:
      throw new Error(`Unhandled parent type ${parentType}`);
  }
}
function getDefaultExpression(name, defaultExprs) {
  if (defaultExprs.hasOwnProperty(name)) {
    return defaultExprs[name];
  } else {
    return [name];
  }
}
function getComponent(node) {
  switch (node.type) {
    case "OPERATOR":
      if (node instanceof LogicalOperator) {
        return AndOrNot;
      } else if (node instanceof Accessor$2) {
        return Accessor;
      } else {
        throw new Error("Unknown operator type:" + node.toJSON());
      }
    case "FUNCTION_CALL":
      return FunctionCall;
    case "STRUCT":
      return Struct;
    case "LITERAL":
      return Literal;
    case "VARIABLE_DECLARATION":
      return VariableDeclaration;
    case "VARIABLE_REFERENCE":
      return VariableReference;
    case "COND":
      return IfElse;
    case "WHILE":
      return While;
    case "FOR":
      return For;
    case "BLOCK":
      return Block_1;
    case "ASSIGNMENT":
      return Assignment;
    case "ENUM":
      return Enum;
    case "ARRAY_NODE":
      return Array$1;
    case "ERROR":
      return Error$1;
    case "RETURN":
      return Return;
    default:
      throw new Error("Unknown node type:" + node.type);
  }
}
function getDefault(type) {
  switch (type) {
    case "int":
      return 0;
    case "float":
      return 0;
    case "string":
      return "";
    case "boolean":
      return false;
    case "selector":
      return {
        value: "",
        type: "css",
        meta: {}
      };
    case "position":
      return { x: 0, y: 0 };
    case "keycode":
      return "Enter";
    default:
      return "";
  }
}
function getSummary(node) {
  if (node instanceof Struct$2) {
    if (node.name === "selector") {
      if (node.fields.get("value") instanceof Literal$3) {
        return node.fields.get("value").value;
      } else {
        return `{selector: ${getSummary(node.children[0])}}`;
      }
    } else if (node.name === "position") {
      return `(${getSummary(node.children[0])}, ${getSummary(node.children[1])})`;
    } else {
      return node.name;
    }
  }
  if (node instanceof Enum$2) {
    return node.value;
  }
  if (node instanceof Literal$3) {
    if (node.returnType === "json") {
      return JSON.stringify(node.value);
    }
    if (node.returnType === "array") {
      return JSON.stringify(node.value);
    }
    if (node.returnType === "int") {
      return Math.round(node.value * 100) / 100;
    }
    if (node.returnType === "secret") {
      return "*".repeat(node.value.length || 1);
    }
    if (node.value === "") {
      return '""';
    }
    return node.value;
  }
  if (node instanceof Conditional) {
    const clausesLen = node.clauses.length;
    return clausesLen.toString() + " clause" + (clausesLen === 1 ? "" : "s");
  }
  if (node instanceof Clause) {
    return getSummary(node.condition);
  }
  if (node instanceof LogicalOperator) {
    const operands = node.operands.map((arg) => getSummary(arg)).join(", ");
    const summary = `${node.name}(${operands})`;
    return summary;
  }
  if (node instanceof Accessor$2) {
    node.operands.map((op2) => getSummary(op2));
    return `${getSummary(node.operands[0])} -> ${getSummary(node.operands[1])}`;
  }
  if (node instanceof FunctionCall$2) {
    let optionals = Object.values(node.scope.getFunc(node.name).args).map((arg) => {
      var _a;
      return (_a = arg.optional) != null ? _a : false;
    });
    return node.name + "(" + node.argList.filter((_2, i) => !optionals[i]).map((arg) => getSummary(arg)).join(", ") + ")";
  }
  if (node instanceof Block) {
    let len = node.nodes.length;
    return len.toString() + " step" + (len === 1 ? "" : "s");
  }
  if (node instanceof VariableReference$1) {
    return "$" + node.name;
  }
  if (node instanceof ArrayExp) {
    return `Array<${node._elementType}>[${node.children.length}]`;
  }
  if (node instanceof ErrorExp) {
    return node.code;
  }
  if (node instanceof For$1) {
    return `var ${node.itemVar.name} of ${getSummary(node.iterable)}`;
  }
  if (node instanceof While$1) {
    return getSummary(node.condition);
  }
  return node.type;
}
function getMatchingExpressions(node, types2, defaultExprs) {
  const scope = node.scope;
  let matchingExpressions = {};
  for (let [key, varDec] of scope.getAllVars().entries()) {
    if (matchAnyType(types2, varDec.dataType)) {
      matchingExpressions["$" + key] = "$" + key;
    }
  }
  if (matchAnyType(types2, C.BOOLEAN)) {
    matchingExpressions["and"] = getDefaultExpression("and", defaultExprs);
    matchingExpressions["or"] = getDefaultExpression("or", defaultExprs);
    matchingExpressions["not"] = getDefaultExpression("not", defaultExprs);
  }
  for (let [key, funcDef] of scope.getAllFuncs().entries()) {
    if (matchAnyType(types2, funcDef.returnType)) {
      matchingExpressions[key] = getDefaultExpression(key, defaultExprs);
    }
  }
  for (let [structName, def] of scope.getAllStructs()) {
    if (matchAnyType(types2, structName)) {
      matchingExpressions[structName] = [structName];
    }
  }
  for (let [key, def] of scope.getAllEnums().entries()) {
    if (matchAnyType(types2, key)) {
      def.values.forEach((value) => matchingExpressions[value] = [def.name, value]);
    }
  }
  for (let type of ["string", "int", "float"]) {
    if (matchAnyType(types2, type)) {
      matchingExpressions[`<${type}>`] = getDefault(type);
    }
  }
  if (matchingExpressions.hasOwnProperty("<float>")) {
    delete matchingExpressions["<int>"];
  }
  if (matchAnyType(types2, "boolean")) {
    matchingExpressions["true"] = true;
    matchingExpressions["false"] = false;
  }
  matchingExpressions = { ...matchingExpressions, ...getMatchingAccessors(node, types2, defaultExprs) };
  return matchingExpressions;
}
function getMatchingAccessors(node, types2, defaultExprs) {
  const structSet = /* @__PURE__ */ new Set();
  const varsHavingStruct = [];
  for (const { name: varName, dataType } of node.root.declarations.list) {
    if (node.scope.hasStruct(dataType)) {
      varsHavingStruct.push([varName, dataType]);
      structSet.add(dataType);
    }
  }
  const funcsReturningStruct = [];
  for (const [funcName, funcDef] of node.scope.getAllFuncs()) {
    if (node.scope.hasStruct(funcDef.returnType)) {
      funcsReturningStruct.push([funcName, funcDef.returnType]);
      structSet.add(funcDef.returnType);
    }
  }
  const structFields = /* @__PURE__ */ new Map();
  for (const struct of structSet) {
    const structDef = node.scope.getStruct(struct);
    for (const [fieldName, fieldDef] of Object.entries(structDef.fields)) {
      if (matchAnyType(types2, fieldDef.types[0])) {
        if (!structFields.has(struct)) {
          structFields.set(struct, [fieldName]);
        } else {
          structFields.get(struct).push(fieldName);
        }
      }
    }
  }
  const matchingAccessors = {};
  for (const [v, struct] of varsHavingStruct) {
    if (!structFields.has(struct)) {
      continue;
    }
    for (const field of structFields.get(struct)) {
      matchingAccessors[`$${v} -> ${field}`] = ["->", `$${v}`, field];
    }
  }
  for (const [funcName, struct] of funcsReturningStruct) {
    if (!structFields.has(struct)) {
      continue;
    }
    for (const field of structFields.get(struct)) {
      matchingAccessors[`${funcName}() -> ${field}`] = ["->", getDefaultExpression(funcName, defaultExprs), field];
    }
  }
  return matchingAccessors;
}
const matchAnyType = (types2, type) => {
  return types2.some((t) => matchType(t, type));
};
const matchType = (type1, type2) => {
  if (type1 === C.ARRAY)
    return isArrayType(type2);
  if (type1 === C.ITERABLE)
    return isIterableType(type2);
  if (type1 === C.FLOAT && type2 === C.INT)
    return true;
  return type1 === type2;
};
const getIteratorTypes = (node) => {
  const iteratorTypes = [];
  const scope = node.scope;
  for (let [key, typeDef] of scope.getAllStructs().entries()) {
    if (typeDef.iterator !== void 0) {
      iteratorTypes.push(key);
    }
  }
  for (let [key, typeDef] of scope.getAllEnums().entries()) {
    if (typeDef.iterator !== void 0) {
      iteratorTypes.push(key);
    }
  }
  return iteratorTypes;
};
function getReplacementTypes(node) {
  let parent2 = node.parent;
  if (parent2.type === C.FUNCTION_CALL) {
    let fCall = parent2;
    let index = fCall.argList.indexOf(node);
    let funcDef = fCall.scope.getFunc(fCall.name);
    return Object.values(funcDef.args)[index].types;
  } else if (parent2.type === C.STRUCT) {
    let struct = parent2;
    let index = [...struct.fields.values()].indexOf(node);
    let structDef = struct.scope.getStruct(struct.name);
    return Object.values(structDef.fields)[index].types;
  } else if (parent2.type === C.VARIABLE_DECLARATION || parent2.type === C.ARRAY_NODE || node.parent instanceof Accessor$2) {
    return [node.returnType];
  } else {
    throw new Error(`Unhandled parent type ${parent2.type}`);
  }
}
function insertAt(node, index, opts) {
  if ((opts == null ? void 0 : opts.mode) === "workflow") {
    if (!opts.tagList) {
      throw new Error("tagList required for workflow mode");
    }
    insertAt$1(node, index, opts.tagList);
  } else {
    node.insertAt(index, [opts.defaultStep]);
  }
}
function isReplaceable(expression) {
  return ![C.BLOCK, C.CLAUSE].includes(expression.type) && !(expression instanceof VariableDeclaration$1 && expression.declarationOnly) && !(expression.parent instanceof Accessor$2 && expression.parent.children.indexOf(expression) === 1);
}
function getSelectorNode(n) {
  let selector;
  for (let subtree of n.children) {
    if (subtree instanceof Struct$2 && subtree.name === "selector") {
      selector = subtree;
      break;
    }
  }
  return selector;
}
function setFrame(n, frame) {
  let optsNode;
  for (let subtree of n.children) {
    if (subtree instanceof Struct$2 && (subtree.name === "default_opts" || subtree.name === "click_opts")) {
      optsNode = subtree;
      break;
    }
  }
  if (!optsNode) {
    let funcDef = n.scope.getFunc(n.name);
    for (let i = 0; i < Object.keys(funcDef.args).length; i++) {
      let argName = Object.keys(funcDef.args)[i];
      if (funcDef.args[argName].types.includes("click_opts") && !n.argList.some((arg) => arg instanceof Struct$2 && arg.name === "click_opts")) {
        n.setAllOptional();
        break;
      } else if (funcDef.args[argName].types.includes("default_opts") && !n.argList.some((arg) => arg instanceof Struct$2 && arg.name === "default_opts")) {
        n.setAllOptional();
        break;
      }
    }
  }
  if (optsNode) {
    optsNode.set("frame", frame);
  }
}
function getFrameIndex(n) {
  let frameIndex = 0;
  for (let arg of n.argList) {
    if (arg instanceof Struct$2 && (arg.name === "default_opts" || arg.name === "click_opts") && arg.fields.has("frame")) {
      let frame = arg.fields.get("frame");
      if (frame.type === "LITERAL") {
        frameIndex = frame.value;
      } else if (frame instanceof Struct$2 && frame.name === "frame_locator") {
        frameIndex = frame.fields.get("index").value;
      }
      break;
    }
  }
  return frameIndex;
}
function hasOptionals(node) {
  if (node instanceof FunctionCall$2) {
    let funcDef = node.scope.getFunc(node.name);
    return Object.values(funcDef.args).some((argDef) => argDef.optional);
  } else if (node instanceof Struct$2) {
    let structDef = node.scope.getStruct(node.name);
    return Object.values(structDef.fields).some((fieldDef) => fieldDef.optional);
  } else if (node instanceof Return$1) {
    return true;
  } else if (node instanceof LogicalOperator && [C.OP_AND, C.OP_OR].includes(node.name)) {
    return true;
  } else {
    return false;
  }
}
function isOptionalNode(node) {
  if (node.parent instanceof Root) {
    return false;
  } else if (node.parent instanceof Struct$2) {
    let parent2 = node.parent;
    let fields = parent2.scope.getStruct(parent2.name).fields;
    let key;
    for (let [k, v] of parent2.fields.entries()) {
      if (v === node)
        key = k;
    }
    if (key) {
      return fields[key].optional;
    }
  } else if (node.parent instanceof FunctionCall$2) {
    let parent2 = node.parent;
    let funcDef = parent2.scope.getFunc(parent2.name);
    let index = parent2.argList.indexOf(node);
    return Object.values(funcDef.args)[index].optional;
  }
  return false;
}
function inlineByType(node) {
  switch (node.type) {
    case C.STRUCT:
      return Struct$1;
    case C.ENUM:
      return Enum$1;
    case C.LITERAL:
      return Literal$1;
    case C.FUNCTION_CALL:
      return FunctionCall$1;
    case C.OPERATOR:
      if (node instanceof Accessor$2) {
        return Accessor$1;
      }
    default:
      return Default;
  }
}
function create_fragment$d(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { fill: "none" },
    { viewBox: "0 0 24 24" },
    { stroke: "currentColor" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "2");
      attr(path, "d", "M6 18L18 6M6 6l12 12");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        { viewBox: "0 0 24 24" },
        { stroke: "currentColor" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Cross extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$d, safe_not_equal, {});
  }
}
function verifyXPath(val) {
  if (!Types.xpath.isValid(val, null)) {
    return "Invalid XPath selector";
  }
}
function verifyCSS(val) {
  if (!Types.css.isValid(val, null)) {
    return "Invalid CSS selector";
  }
}
function verifyJS(val) {
  if (!Types.js.isValid(val, null)) {
    return "Invalid Javascript selector";
  }
}
class SelectorType extends TYPES.string {
}
__publicField(SelectorType, "validators", []);
const selectorValidators = {
  "xpath": verifyXPath,
  "css": verifyCSS,
  "js": verifyJS
};
register("selector", SelectorType);
function create_fragment$c(ctx) {
  let div1;
  let div0;
  let inputedit0;
  let t;
  let inputedit1;
  let current;
  inputedit0 = new InputEdit({
    props: {
      field: ctx[0],
      placeholder: "regular expression"
    }
  });
  inputedit1 = new InputEdit({
    props: {
      field: ctx[1],
      placeholder: "flags"
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(inputedit0.$$.fragment);
      t = space();
      create_component(inputedit1.$$.fragment);
      attr(div0, "class", "input-group");
      attr(div1, "class", "d-flex flex-column");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(inputedit0, div0, null);
      append(div0, t);
      mount_component(inputedit1, div0, null);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(inputedit0.$$.fragment, local);
      transition_in(inputedit1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit0.$$.fragment, local);
      transition_out(inputedit1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(inputedit0);
      destroy_component(inputedit1);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  var _a;
  let $flags;
  let $expr;
  let { model } = $$props;
  let regexp = (_a = model.get("regexp")) != null ? _a : { expr: "", flags: "gim" };
  let expr = createFieldStore({ type: "string" }, regexp.expr);
  component_subscribe($$self, expr, (value) => $$invalidate(4, $expr = value));
  let flags = createFieldStore({ type: "string" }, regexp.flags);
  component_subscribe($$self, flags, (value) => $$invalidate(3, $flags = value));
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(2, model = $$props2.model);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 28) {
      {
        model.set("regexp", { expr: $expr, flags: $flags });
      }
    }
  };
  return [expr, flags, model, $flags, $expr];
}
class RegexEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$c, safe_not_equal, { model: 2 });
  }
}
const get_subheader_slot_changes = (dirty) => ({});
const get_subheader_slot_context = (ctx) => ({});
const get_header_slot_changes = (dirty) => ({});
const get_header_slot_context = (ctx) => ({});
function create_fragment$b(ctx) {
  let div5;
  let div4;
  let h5;
  let button;
  let div1;
  let t0;
  let div0;
  let t1;
  let t2;
  let div3;
  let div2;
  let div5_class_value;
  let current;
  const header_slot_template = ctx[6].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[5], get_header_slot_context);
  const subheader_slot_template = ctx[6].subheader;
  const subheader_slot = create_slot(subheader_slot_template, ctx, ctx[5], get_subheader_slot_context);
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      h5 = element("h5");
      button = element("button");
      div1 = element("div");
      if (header_slot)
        header_slot.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      if (subheader_slot)
        subheader_slot.c();
      t2 = space();
      div3 = element("div");
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "flex-grow-1");
      attr(div1, "class", "d-flex small ms-3 w-100");
      attr(button, "class", "accordion-button");
      attr(button, "data-bs-toggle", "collapse");
      attr(button, "data-bs-target", "#" + ctx[3]);
      toggle_class(button, "collapsed", !ctx[0]);
      attr(h5, "class", "accordion-header");
      attr(div2, "class", "accordion-body");
      set_style(div2, "--bs-accordion-body-padding-x", "0");
      set_style(div2, "--bs-accordion-body-padding-y", "0");
      attr(div3, "id", ctx[3]);
      attr(div3, "class", "accordion-collapse collapse");
      attr(div3, "data-bs-parent", "#" + ctx[2]);
      toggle_class(div3, "show", ctx[0]);
      attr(div4, "class", "accordion-item");
      attr(div5, "class", div5_class_value = "accordion xaccordion-arrow-left " + ctx[1]);
      attr(div5, "id", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, h5);
      append(h5, button);
      append(button, div1);
      if (header_slot) {
        header_slot.m(div1, null);
      }
      append(div1, t0);
      append(div1, div0);
      append(div1, t1);
      if (subheader_slot) {
        subheader_slot.m(div1, null);
      }
      append(div4, t2);
      append(div4, div3);
      append(div3, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(header_slot_template, ctx2[5], dirty, get_header_slot_changes),
            get_header_slot_context
          );
        }
      }
      if (subheader_slot) {
        if (subheader_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            subheader_slot,
            subheader_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(subheader_slot_template, ctx2[5], dirty, get_subheader_slot_changes),
            get_subheader_slot_context
          );
        }
      }
      if (!current || dirty & 1) {
        toggle_class(button, "collapsed", !ctx2[0]);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1) {
        toggle_class(div3, "show", ctx2[0]);
      }
      if (!current || dirty & 2 && div5_class_value !== (div5_class_value = "accordion xaccordion-arrow-left " + ctx2[1])) {
        attr(div5, "class", div5_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(subheader_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(subheader_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (header_slot)
        header_slot.d(detaching);
      if (subheader_slot)
        subheader_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id } = $$props;
  let { show = false } = $$props;
  let { class: clazz = "" } = $$props;
  const accordionId = "accordion-" + id;
  const collapseId = "collapse-" + id;
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(4, id = $$props2.id);
    if ("show" in $$props2)
      $$invalidate(0, show = $$props2.show);
    if ("class" in $$props2)
      $$invalidate(1, clazz = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [show, clazz, accordionId, collapseId, id, $$scope, slots];
}
class Accordion extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$b, safe_not_equal, { id: 4, show: 0, class: 1 });
  }
}
function create_default_slot$3(ctx) {
  let regexedit;
  let current;
  regexedit = new RegexEdit({ props: { model: ctx[2] } });
  return {
    c() {
      create_component(regexedit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(regexedit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const regexedit_changes = {};
      if (dirty & 4)
        regexedit_changes.model = ctx2[2];
      regexedit.$set(regexedit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(regexedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(regexedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(regexedit, detaching);
    }
  };
}
function create_else_block$1(ctx) {
  let t;
  return {
    c() {
      t = text("- <not set>");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$5(ctx) {
  var _a;
  let t0;
  let t1_value = ((_a = ctx[3].regexp) == null ? void 0 : _a.expr) + "";
  let t1;
  return {
    c() {
      t0 = text("- ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 8 && t1_value !== (t1_value = ((_a2 = ctx2[3].regexp) == null ? void 0 : _a2.expr) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_header_slot$1(ctx) {
  let div;
  let t;
  function select_block_type(ctx2, dirty) {
    var _a;
    if ((_a = ctx2[3].regexp) == null ? void 0 : _a.expr)
      return create_if_block$5;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      t = text("Regex Text Filter \n    ");
      if_block.c();
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_fragment$a(ctx) {
  let accordion;
  let current;
  accordion = new Accordion({
    props: {
      id: ctx[0],
      show: ctx[1],
      $$slots: {
        header: [create_header_slot$1],
        default: [create_default_slot$3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(accordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const accordion_changes = {};
      if (dirty & 1)
        accordion_changes.id = ctx2[0];
      if (dirty & 2)
        accordion_changes.show = ctx2[1];
      if (dirty & 28) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordion, detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let $config, $$unsubscribe_config = noop, $$subscribe_config = () => ($$unsubscribe_config(), $$unsubscribe_config = subscribe$1(config, ($$value) => $$invalidate(3, $config = $$value)), config);
  $$self.$$.on_destroy.push(() => $$unsubscribe_config());
  let { id } = $$props;
  let { show } = $$props;
  let { config } = $$props;
  $$subscribe_config();
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("show" in $$props2)
      $$invalidate(1, show = $$props2.show);
    if ("config" in $$props2)
      $$subscribe_config($$invalidate(2, config = $$props2.config));
  };
  return [id, show, config, $config];
}
class RegexWrapper extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$a, safe_not_equal, { id: 0, show: 1, config: 2 });
  }
}
function create_default_slot$2(ctx) {
  let textarea;
  let textarea_class_value;
  let mounted;
  let dispose;
  let textarea_levels = [
    {
      class: textarea_class_value = ctx[5] + " w-100"
    },
    { rows: "1" },
    ctx[2]
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  return {
    c() {
      textarea = element("textarea");
      set_attributes(textarea, textarea_data);
      toggle_class(textarea, "is-invalid", ctx[7]);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      if (!mounted) {
        dispose = [
          action_destroyer(ctx[6].call(null, textarea)),
          listen(textarea, "blur", ctx[3]),
          listen(textarea, "focus", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty & 32 && textarea_class_value !== (textarea_class_value = ctx2[5] + " w-100") && { class: textarea_class_value },
        { rows: "1" },
        dirty & 4 && ctx2[2]
      ]));
      toggle_class(textarea, "is-invalid", ctx2[7]);
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$4(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element("p");
      t = text(ctx[1]);
      attr(p, "class", "help");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_fragment$9(ctx) {
  let div;
  let fieldwrapper;
  let t;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[0],
      $$slots: {
        default: [
          create_default_slot$2,
          ({ inputClasses, action, showError }) => ({ 5: inputClasses, 6: action, 7: showError }),
          ({ inputClasses, action, showError }) => (inputClasses ? 32 : 0) | (action ? 64 : 0) | (showError ? 128 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = !!ctx[1] && create_if_block$4(ctx);
  return {
    c() {
      div = element("div");
      create_component(fieldwrapper.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "flex flex-column flex-grow-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(fieldwrapper, div, null);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 1)
        fieldwrapper_changes.field = ctx2[0];
      if (dirty & 420) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
      if (!!ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(fieldwrapper);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  const omit_props_names = ["field", "help"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { field } = $$props;
  let { help = void 0 } = $$props;
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("field" in $$new_props)
      $$invalidate(0, field = $$new_props.field);
    if ("help" in $$new_props)
      $$invalidate(1, help = $$new_props.help);
  };
  return [field, help, $$restProps, blur_handler, focus_handler];
}
class MultilineInputEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$9, safe_not_equal, { field: 0, help: 1 });
  }
}
const get_icon_slot_changes = (dirty) => ({});
const get_icon_slot_context = (ctx) => ({});
const get_label_slot_changes = (dirty) => ({});
const get_label_slot_context = (ctx) => ({});
const get_top_slot_changes = (dirty) => ({});
const get_top_slot_context = (ctx) => ({});
const get_bottom_slot_changes = (dirty) => ({});
const get_bottom_slot_context = (ctx) => ({});
function create_icon_slot(ctx) {
  let current;
  const icon_slot_template = ctx[7].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[13], get_icon_slot_context);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(icon_slot_template, ctx2[13], dirty, get_icon_slot_changes),
            get_icon_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_label_slot$2(ctx) {
  let current;
  const label_slot_template = ctx[7].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[13], get_label_slot_context);
  return {
    c() {
      if (label_slot)
        label_slot.c();
    },
    m(target, anchor) {
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(label_slot_template, ctx2[13], dirty, get_label_slot_changes),
            get_label_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_top_slot$1(ctx) {
  let li;
  let div;
  let input_1;
  let t;
  let current;
  let mounted;
  let dispose;
  const top_slot_template = ctx[7].top;
  const top_slot = create_slot(top_slot_template, ctx, ctx[13], get_top_slot_context);
  return {
    c() {
      li = element("li");
      div = element("div");
      input_1 = element("input");
      t = space();
      if (top_slot)
        top_slot.c();
      attr(input_1, "type", "text");
      attr(input_1, "class", "mx-2 form-control");
      set_style(input_1, "width", "min-content");
      attr(input_1, "placeholder", ctx[0]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div);
      append(div, input_1);
      ctx[9](input_1);
      insert(target, t, anchor);
      if (top_slot) {
        top_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(input_1, "input", ctx[10]),
          listen(div, "click", prevent_default(ctx[8]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & 1) {
        attr(input_1, "placeholder", ctx2[0]);
      }
      if (top_slot) {
        if (top_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            top_slot,
            top_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(top_slot_template, ctx2[13], dirty, get_top_slot_changes),
            get_top_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(top_slot, local);
      current = true;
    },
    o(local) {
      transition_out(top_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      ctx[9](null);
      if (detaching)
        detach(t);
      if (top_slot)
        top_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_bottom_slot$1(ctx) {
  let current;
  const bottom_slot_template = ctx[7].bottom;
  const bottom_slot = create_slot(bottom_slot_template, ctx, ctx[13], get_bottom_slot_context);
  return {
    c() {
      if (bottom_slot)
        bottom_slot.c();
    },
    m(target, anchor) {
      if (bottom_slot) {
        bottom_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (bottom_slot) {
        if (bottom_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            bottom_slot,
            bottom_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(bottom_slot_template, ctx2[13], dirty, get_bottom_slot_changes),
            get_bottom_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (bottom_slot)
        bottom_slot.d(detaching);
    }
  };
}
function create_fragment$8(ctx) {
  let multiselectmenu;
  let current;
  const multiselectmenu_spread_levels = [{ items: ctx[1] }, { ids: ctx[2] }, ctx[6]];
  let multiselectmenu_props = {
    $$slots: {
      bottom: [create_bottom_slot$1],
      top: [create_top_slot$1],
      label: [create_label_slot$2],
      icon: [create_icon_slot]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < multiselectmenu_spread_levels.length; i += 1) {
    multiselectmenu_props = assign(multiselectmenu_props, multiselectmenu_spread_levels[i]);
  }
  multiselectmenu = new MultiSelectMenu({ props: multiselectmenu_props });
  multiselectmenu.$on("open", ctx[5]);
  multiselectmenu.$on("change", ctx[11]);
  multiselectmenu.$on("close", ctx[12]);
  return {
    c() {
      create_component(multiselectmenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(multiselectmenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const multiselectmenu_changes = dirty & 70 ? get_spread_update(multiselectmenu_spread_levels, [
        dirty & 2 && { items: ctx2[1] },
        dirty & 4 && { ids: ctx2[2] },
        dirty & 64 && get_spread_object(ctx2[6])
      ]) : {};
      if (dirty & 8201) {
        multiselectmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      multiselectmenu.$set(multiselectmenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(multiselectmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(multiselectmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(multiselectmenu, detaching);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  const omit_props_names = ["placeHolder", "items", "ids"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { placeHolder = "Search" } = $$props;
  let { items } = $$props;
  let { ids } = $$props;
  let input;
  const dispatch = createEventDispatcher();
  function focus() {
    setTimeout(() => input == null ? void 0 : input.focus(), 100);
  }
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(3, input);
    });
  }
  const input_handler = (e) => dispatch("search", e.target.value.trim());
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("placeHolder" in $$new_props)
      $$invalidate(0, placeHolder = $$new_props.placeHolder);
    if ("items" in $$new_props)
      $$invalidate(1, items = $$new_props.items);
    if ("ids" in $$new_props)
      $$invalidate(2, ids = $$new_props.ids);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  return [
    placeHolder,
    items,
    ids,
    input,
    dispatch,
    focus,
    $$restProps,
    slots,
    click_handler2,
    input_1_binding,
    input_handler,
    change_handler,
    close_handler,
    $$scope
  ];
}
class SearchableMultiSelectMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$8, safe_not_equal, { placeHolder: 0, items: 1, ids: 2 });
  }
}
const _$1 = window._;
const FieldOption = base.Model.extend({
  defaults: {
    "show": true
  },
  initialize: function(options) {
    FieldOption.__super__.initialize.call(this, options);
    this.set("id", `${this.get("type")}-${this.get("name")}`);
  },
  blacklistedJSONFields: ["id", "show", "selected"],
  toJSON: function(options) {
    return _$1.omit(_$1.clone(this.attributes), this.blacklistedJSONFields);
  }
});
const FieldOptions = base.Collection.extend({
  model: FieldOption
});
function create_label_slot$1(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[3]);
      attr(div, "class", "truncate mw5-m mr1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$3(ctx) {
  let menuitem0;
  let t;
  let menuitem1;
  let current;
  menuitem0 = new MenuItem$1({
    props: {
      selected: false,
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", ctx[14]);
  menuitem1 = new MenuItem$1({
    props: {
      selected: false,
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", ctx[15]);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t = space();
      create_component(menuitem1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t, anchor);
      mount_component(menuitem1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & 1048580) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 1048580) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t);
      destroy_component(menuitem1, detaching);
    }
  };
}
function create_default_slot_1$1(ctx) {
  let t0;
  let t1;
  return {
    c() {
      t0 = text("Use attribute ");
      t1 = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t1, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot$1(ctx) {
  let t0;
  let t1;
  return {
    c() {
      t0 = text("Use property ");
      t1 = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t1, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_top_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[2] && create_if_block$3(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_bottom_slot(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      attr(li, "class", "divider");
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_fragment$7(ctx) {
  let searchablemultiselectmenu;
  let current;
  const searchablemultiselectmenu_spread_levels = [
    { getSectionName },
    { ids: ctx[1] },
    { placeHolder: "Search fields to monitor" },
    { items: ctx[4] },
    { class: "h-100" },
    { allowNull: false },
    { placement: "bottom-end" },
    ctx[9],
    { dropDownClass: ctx[0] }
  ];
  let searchablemultiselectmenu_props = {
    $$slots: {
      bottom: [create_bottom_slot],
      top: [create_top_slot],
      label: [create_label_slot$1]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < searchablemultiselectmenu_spread_levels.length; i += 1) {
    searchablemultiselectmenu_props = assign(searchablemultiselectmenu_props, searchablemultiselectmenu_spread_levels[i]);
  }
  searchablemultiselectmenu = new SearchableMultiSelectMenu({ props: searchablemultiselectmenu_props });
  searchablemultiselectmenu.$on("search", ctx[5]);
  searchablemultiselectmenu.$on("change", ctx[7]);
  searchablemultiselectmenu.$on("close", ctx[8]);
  return {
    c() {
      create_component(searchablemultiselectmenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemultiselectmenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchablemultiselectmenu_changes = dirty & 531 ? get_spread_update(searchablemultiselectmenu_spread_levels, [
        dirty & 0 && { getSectionName },
        dirty & 2 && { ids: ctx2[1] },
        searchablemultiselectmenu_spread_levels[2],
        dirty & 16 && { items: ctx2[4] },
        searchablemultiselectmenu_spread_levels[4],
        searchablemultiselectmenu_spread_levels[5],
        searchablemultiselectmenu_spread_levels[6],
        dirty & 512 && get_spread_object(ctx2[9]),
        dirty & 1 && { dropDownClass: ctx2[0] }
      ]) : {};
      if (dirty & 1048588) {
        searchablemultiselectmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      searchablemultiselectmenu.$set(searchablemultiselectmenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemultiselectmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemultiselectmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemultiselectmenu, detaching);
    }
  };
}
function getSectionName(item) {
  return item.get("type");
}
function instance$7($$self, $$props, $$invalidate) {
  const omit_props_names = ["selectorID", "allFields", "onChange", "fields", "dropDownClass"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { selectorID } = $$props;
  let { allFields } = $$props;
  let { onChange } = $$props;
  let { fields } = $$props;
  let { dropDownClass = "max-w-[400px] overflow-x-scroll dropdown-menu-end" } = $$props;
  let ids = [];
  let createField;
  let label;
  let allItems = new FieldOptions();
  let items = allItems.models;
  function initializeItems() {
    if (!allFields) {
      return;
    }
    const pushSelectedFields = (sf) => {
      const item = allItems.get(`${sf.type}-${sf.name}`);
      if (!item) {
        allItems.push(new FieldOption({ type: sf.type, name: sf.name }));
      }
      ids.push(`${sf.type}-${sf.name}`);
    };
    allItems.reset();
    allItems.push(new FieldOption({ name: "text", type: `builtin` }));
    fields == null ? void 0 : fields.filter((si) => si.type === "builtin").forEach(pushSelectedFields);
    allFields.filter((f) => f.type === "attribute").forEach((f) => {
      allItems.push(new FieldOption({ type: f.type, name: f.name }));
    });
    fields == null ? void 0 : fields.filter((si) => si.type === "attribute").forEach(pushSelectedFields);
    allFields.filter((f) => f.type === "property").forEach((f) => {
      allItems.push(new FieldOption({ type: f.type, name: f.name }));
    });
    fields == null ? void 0 : fields.filter((si) => si.type === "property").forEach(pushSelectedFields);
    if (!fields) {
      allItems.at(0).set("selected", true);
      $$invalidate(4, items = allItems.models);
      notify();
    } else {
      $$invalidate(4, items = allItems.models);
      updateLabel();
    }
  }
  function onSearch(e) {
    let phrase = e.detail.toLowerCase().trim();
    $$invalidate(2, createField = "");
    $$invalidate(4, items = allItems.filter((ai) => {
      return ai.get("name").toLowerCase().includes(phrase);
    }));
    if (items.length === 0 && phrase) {
      $$invalidate(2, createField = phrase);
    }
  }
  function createNewField(fieldType) {
    let newFieldOption = new FieldOptions();
    newFieldOption = new FieldOption({ name: createField, type: fieldType });
    const lastIndex = allItems.models.findLastIndex((item) => item.get("type") === fieldType);
    allItems.models.splice(lastIndex + 1, 0, newFieldOption);
    items.push(newFieldOption);
    const newIndex = lastIndex + 1;
    const createdFieldId = allItems.at(newIndex).get("id");
    ids.push(createdFieldId);
    $$invalidate(2, createField = "");
    notify();
  }
  function onItemChange(e) {
    $$invalidate(1, ids = e.detail);
    notify();
  }
  function notify() {
    if (ids.length === 0) {
      $$invalidate(1, ids = [allItems.at(0).get("id")]);
    }
    onChange(
      allItems.filter((i) => {
        return ids.includes(i.get("id"));
      }).map((i) => {
        return i.toJSON();
      }),
      selectorID
    );
    updateLabel();
  }
  function updateLabel() {
    const selectedItems = allItems.filter((item) => ids.includes(item.get("id"))).map((item) => item.get("name"));
    $$invalidate(3, label = selectedItems ? selectedItems.join(", ") : "<None>");
  }
  function onClose() {
    onSearch({ detail: "" });
  }
  const click_handler2 = () => createNewField("attribute");
  const click_handler_1 = () => createNewField("property");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selectorID" in $$new_props)
      $$invalidate(10, selectorID = $$new_props.selectorID);
    if ("allFields" in $$new_props)
      $$invalidate(11, allFields = $$new_props.allFields);
    if ("onChange" in $$new_props)
      $$invalidate(12, onChange = $$new_props.onChange);
    if ("fields" in $$new_props)
      $$invalidate(13, fields = $$new_props.fields);
    if ("dropDownClass" in $$new_props)
      $$invalidate(0, dropDownClass = $$new_props.dropDownClass);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2048) {
      allFields && initializeItems();
    }
  };
  return [
    dropDownClass,
    ids,
    createField,
    label,
    items,
    onSearch,
    createNewField,
    onItemChange,
    onClose,
    $$restProps,
    selectorID,
    allFields,
    onChange,
    fields,
    click_handler2,
    click_handler_1
  ];
}
class FieldSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$7, safe_not_equal, {
      selectorID: 10,
      allFields: 11,
      onChange: 12,
      fields: 13,
      dropDownClass: 0
    });
  }
}
function create_if_block_1(ctx) {
  let fieldselector;
  let current;
  fieldselector = new FieldSelector({
    props: {
      class: "h-100 rounded-start-0",
      allFields: ctx[5],
      fields: ctx[6],
      onChange: ctx[16]
    }
  });
  return {
    c() {
      create_component(fieldselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fieldselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const fieldselector_changes = {};
      if (dirty & 32)
        fieldselector_changes.allFields = ctx2[5];
      if (dirty & 64)
        fieldselector_changes.fields = ctx2[6];
      if (dirty & 1)
        fieldselector_changes.onChange = ctx2[16];
      fieldselector.$set(fieldselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldselector, detaching);
    }
  };
}
function create_if_block$2(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${ctx[11].js.help}`;
      attr(p, "class", "help");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_fragment$6(ctx) {
  let div2;
  let div1;
  let div0;
  let menu;
  let t0;
  let switch_instance;
  let t1;
  let span;
  let t2_value = (ctx[7].matchedElementCount === void 0 ? "..." : ctx[7].matchedElementCount) + "";
  let t2;
  let t3;
  let t4_value = ctx[7].matchedElementCount > 2 ? " elements" : " element";
  let t4;
  let t5;
  let t6;
  let button;
  let cross;
  let t7;
  let current;
  let mounted;
  let dispose;
  menu = new Menu$1({
    props: {
      allowNull: false,
      id: ctx[7].type,
      items: Object.entries(ctx[11]).map(func),
      actionClass: "btn btn-default w-100 rounded-end-0",
      style: "width: 140px"
    }
  });
  menu.$on("select", ctx[12]);
  var switch_value = ctx[11][ctx[4]].input;
  function switch_props(ctx2) {
    return {
      props: {
        field: ctx2[9],
        class: "flex-grow",
        inputClasses: "rounded-0",
        placeholder: ctx2[11][ctx2[4]].label
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    switch_instance.$on("focus", ctx[14]);
    switch_instance.$on("blur", ctx[14]);
  }
  let if_block0 = ctx[1] == "INCLUDE" && create_if_block_1(ctx);
  cross = new Cross({ props: { style: "width: 16px" } });
  let if_block1 = ctx[4] == "js" && create_if_block$2(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(menu.$$.fragment);
      t0 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      button = element("button");
      create_component(cross.$$.fragment);
      t7 = space();
      if (if_block1)
        if_block1.c();
      attr(span, "class", "rounded border pe-1 ps-1 bg-white align-self-baseline");
      set_style(span, "margin-left", "-8em");
      set_style(span, "width", "8em");
      set_style(span, "z-index", "999");
      set_style(span, "font-size", "x-small");
      set_style(span, "opacity", ctx[3] ? 0.5 : 1);
      attr(span, "title", "No of elements matched");
      toggle_class(span, "d-none", ctx[2] || ctx[8]);
      attr(div0, "class", "input-group");
      attr(button, "class", "btn btn-outline-danger border-0 ms-1 rounded-1");
      set_style(button, "box-shadow", "none");
      attr(div1, "class", "d-flex flex-row");
      attr(div2, "class", "d-flex flex-column flex-grow-1");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      mount_component(menu, div0, null);
      append(div0, t0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      append(div0, t1);
      append(div0, span);
      append(span, t2);
      append(span, t3);
      append(span, t4);
      append(div0, t5);
      if (if_block0)
        if_block0.m(div0, null);
      append(div1, t6);
      append(div1, button);
      mount_component(cross, button, null);
      append(div2, t7);
      if (if_block1)
        if_block1.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(ctx[13]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 128)
        menu_changes.id = ctx2[7].type;
      menu.$set(menu_changes);
      const switch_instance_changes = {};
      if (dirty & 16)
        switch_instance_changes.placeholder = ctx2[11][ctx2[4]].label;
      if (dirty & 16 && switch_value !== (switch_value = ctx2[11][ctx2[4]].input)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          switch_instance.$on("focus", ctx2[14]);
          switch_instance.$on("blur", ctx2[14]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, t1);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if ((!current || dirty & 128) && t2_value !== (t2_value = (ctx2[7].matchedElementCount === void 0 ? "..." : ctx2[7].matchedElementCount) + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & 128) && t4_value !== (t4_value = ctx2[7].matchedElementCount > 2 ? " elements" : " element"))
        set_data(t4, t4_value);
      if (!current || dirty & 8) {
        set_style(span, "opacity", ctx2[3] ? 0.5 : 1);
      }
      if (!current || dirty & 260) {
        toggle_class(span, "d-none", ctx2[2] || ctx2[8]);
      }
      if (ctx2[1] == "INCLUDE") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[4] == "js") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$2(ctx2);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(if_block0);
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(if_block0);
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(menu);
      if (switch_instance)
        destroy_component(switch_instance);
      if (if_block0)
        if_block0.d();
      destroy_component(cross);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
const func = ([id, def]) => ({ id, name: def.label });
function instance$6($$self, $$props, $$invalidate) {
  let $model, $$unsubscribe_model = noop, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe$1(model, ($$value) => $$invalidate(7, $model = $$value)), model);
  let $expression;
  let $showError;
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  let { model } = $$props;
  $$subscribe_model();
  let { op } = $$props;
  let { sieveOptionsPage } = $$props;
  let isInputActive = false;
  let CMD = getContext("CMD");
  let type = model.get("type");
  const expression = createFieldStore(
    {
      type: "selector",
      required: true,
      validators: [
        (value) => {
          return selectorValidators[$model.type](value);
        }
      ]
    },
    model.get("expr")
  );
  component_subscribe($$self, expression, (value) => $$invalidate(15, $expression = value));
  const { showError } = expression;
  component_subscribe($$self, showError, (value) => $$invalidate(8, $showError = value));
  const locatorDef = {
    css: {
      label: TXT("l_css_selector"),
      input: InputEdit
    },
    js: {
      label: TXT("l_js"),
      help: TXT("h_js"),
      input: MultilineInputEdit
    },
    xpath: { label: TXT("l_xpath"), input: InputEdit }
  };
  let allFields = model.get("allFields");
  let fields = model.get("fields");
  model.on("change:allFields", updateAllFields);
  model.on("change:fields", updateFields);
  model.on("change:expr", updateExpression);
  onDestroy(() => {
    model.off("change:allFields", updateAllFields);
    model.off("change:fields", updateFields);
    model.off("change:expr", updateExpression);
  });
  function onTypeChange(e) {
    CMD.setType(model, e.detail);
    $$invalidate(4, type = e.detail);
    const err = expression.validate($model.expr);
    if (err) {
      expression.setTouched(true);
    }
  }
  function updateExpression() {
    const expr = $model.expr;
    if ($expression !== expr) {
      expression.set(expr);
    }
  }
  function updateModel(expr) {
    if ($model.expr !== expr) {
      CMD.setExpr(model, expr);
    }
  }
  function updateAllFields() {
    $$invalidate(5, allFields = model.get("allFields"));
  }
  function updateFields() {
    $$invalidate(6, fields = model.get("fields"));
  }
  function removeLocator() {
    CMD.del(model);
  }
  function handleInputFocusBlur(event) {
    $$invalidate(3, isInputActive = event.type === "focus");
  }
  const func_12 = (fields2) => {
    model.set("fields", fields2);
  };
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$subscribe_model($$invalidate(0, model = $$props2.model));
    if ("op" in $$props2)
      $$invalidate(1, op = $$props2.op);
    if ("sieveOptionsPage" in $$props2)
      $$invalidate(2, sieveOptionsPage = $$props2.sieveOptionsPage);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32768) {
      updateModel($expression);
    }
  };
  return [
    model,
    op,
    sieveOptionsPage,
    isInputActive,
    type,
    allFields,
    fields,
    $model,
    $showError,
    expression,
    showError,
    locatorDef,
    onTypeChange,
    removeLocator,
    handleInputFocusBlur,
    $expression,
    func_12
  ];
}
class SieveLocator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$6, safe_not_equal, { model: 0, op: 1, sieveOptionsPage: 2 });
  }
}
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_if_block$1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${TXT("l_none")}`;
      attr(div, "class", "info");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$1(key_1, ctx) {
  let first;
  let sievelocator;
  let current;
  sievelocator = new SieveLocator({
    props: {
      model: ctx[7],
      op: ctx[1],
      sieveOptionsPage: ctx[2]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(sievelocator.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(sievelocator, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const sievelocator_changes = {};
      if (dirty & 8)
        sievelocator_changes.model = ctx[7];
      if (dirty & 2)
        sievelocator_changes.op = ctx[1];
      if (dirty & 4)
        sievelocator_changes.sieveOptionsPage = ctx[2];
      sievelocator.$set(sievelocator_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sievelocator.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievelocator.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(sievelocator, detaching);
    }
  };
}
function create_fragment$5(ctx) {
  let t0;
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div0;
  let button;
  let cross;
  let t2;
  let t3_value = TXT("a_add") + "";
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[3].length && create_if_block$1();
  let each_value = ctx[3].models;
  const get_key = (ctx2) => ctx2[7].cid;
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$1(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
  }
  cross = new Cross({
    props: {
      style: "width: 12px; transform: rotate(45deg)"
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div0 = element("div");
      button = element("button");
      create_component(cross.$$.fragment);
      t2 = space();
      t3 = text(t3_value);
      attr(button, "class", "btn btn-default btn-sm w-[100px]");
      set_style(button, "--bs-btn-padding-y", ".1rem");
      attr(div1, "class", "d-flex flex-column pa2 gap-2");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      append(div1, t1);
      append(div1, div0);
      append(div0, button);
      mount_component(cross, button, null);
      append(button, t2);
      append(button, t3);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(ctx[4]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!ctx2[3].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1();
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 14) {
        each_value = ctx2[3].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$1, t1, get_each_context$1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      destroy_component(cross);
      mounted = false;
      dispose();
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let $locators, $$unsubscribe_locators = noop, $$subscribe_locators = () => ($$unsubscribe_locators(), $$unsubscribe_locators = subscribe$1(locators, ($$value) => $$invalidate(3, $locators = $$value)), locators);
  $$self.$$.on_destroy.push(() => $$unsubscribe_locators());
  let { locators } = $$props;
  $$subscribe_locators();
  let { index } = $$props;
  let { op } = $$props;
  let { sieveOptionsPage } = $$props;
  let CMD = getContext("CMD");
  function onAdd() {
    CMD.add(index, op, locators);
  }
  $$self.$$set = ($$props2) => {
    if ("locators" in $$props2)
      $$subscribe_locators($$invalidate(0, locators = $$props2.locators));
    if ("index" in $$props2)
      $$invalidate(5, index = $$props2.index);
    if ("op" in $$props2)
      $$invalidate(1, op = $$props2.op);
    if ("sieveOptionsPage" in $$props2)
      $$invalidate(2, sieveOptionsPage = $$props2.sieveOptionsPage);
  };
  return [locators, op, sieveOptionsPage, $locators, onAdd, index];
}
class SieveLocators extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, {
      locators: 0,
      index: 5,
      op: 1,
      sieveOptionsPage: 2
    });
  }
}
function create_else_block(ctx) {
  let input;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      t = text(" secs");
      attr(input, "type", "number");
      attr(input, "min", min);
      attr(input, "max", max);
      input.disabled = ctx[5];
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      insert(target, t, anchor);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[8]),
          listen(input, "input", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32) {
        input.disabled = ctx2[5];
      }
      if (dirty & 1 && to_number(input.value) !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
      attr(input, "id", input_id_value = "input-" + ctx[1]);
      input.disabled = ctx[5];
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = ctx[0];
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[7]),
          listen(input, "change", function() {
            if (is_function(ctx[3]))
              ctx[3].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && input_id_value !== (input_id_value = "input-" + ctx[1])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & 32) {
        input.disabled = ctx[5];
      }
      if (dirty & 1) {
        input.checked = ctx[0];
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$4(ctx) {
  let div;
  let label_1;
  let t0;
  let t1;
  let i;
  let label_1_for_value;
  let t2;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      label_1 = element("label");
      t0 = text(ctx[1]);
      t1 = space();
      i = element("i");
      t2 = space();
      if_block.c();
      attr(i, "class", "fa fa-info-circle text-secondary");
      attr(i, "title", ctx[2]);
      set_style(label_1, "min-width", "150px");
      attr(label_1, "for", label_1_for_value = "input-" + ctx[1]);
      attr(div, "class", "pa2 gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label_1);
      append(label_1, t0);
      append(label_1, t1);
      append(label_1, i);
      append(div, t2);
      if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t0, ctx2[1]);
      if (dirty & 4) {
        attr(i, "title", ctx2[2]);
      }
      if (dirty & 2 && label_1_for_value !== (label_1_for_value = "input-" + ctx2[1])) {
        attr(label_1, "for", label_1_for_value);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
let min = 0;
let max = 30;
function instance$4($$self, $$props, $$invalidate) {
  let { label } = $$props;
  let { value } = $$props;
  let { info } = $$props;
  let { handleChange } = $$props;
  let { isCheckbox = false } = $$props;
  let { isDisabled = false } = $$props;
  function handleInput(event) {
    let newValue = parseInt(event.target.value) || 0;
    $$invalidate(0, value = Math.min(Math.max(newValue, min), max));
    handleChange(value);
  }
  function input_change_handler() {
    value = this.checked;
    $$invalidate(0, value);
  }
  function input_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("info" in $$props2)
      $$invalidate(2, info = $$props2.info);
    if ("handleChange" in $$props2)
      $$invalidate(3, handleChange = $$props2.handleChange);
    if ("isCheckbox" in $$props2)
      $$invalidate(4, isCheckbox = $$props2.isCheckbox);
    if ("isDisabled" in $$props2)
      $$invalidate(5, isDisabled = $$props2.isDisabled);
  };
  return [
    value,
    label,
    info,
    handleChange,
    isCheckbox,
    isDisabled,
    handleInput,
    input_change_handler,
    input_input_handler
  ];
}
class PageOptions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, {
      label: 1,
      value: 0,
      info: 2,
      handleChange: 3,
      isCheckbox: 4,
      isDisabled: 5
    });
  }
}
function create_fragment$3(ctx) {
  let pageoptions0;
  let updating_value;
  let t0;
  let pageoptions1;
  let updating_value_1;
  let t1;
  let pageoptions2;
  let updating_value_2;
  let t2;
  let pageoptions3;
  let updating_value_3;
  let t3;
  let pageoptions4;
  let updating_value_4;
  let current;
  function pageoptions0_value_binding(value) {
    ctx[15](value);
  }
  let pageoptions0_props = {
    label: TXT("l_delay"),
    info: TXT("l_delay_info"),
    handleChange: ctx[10]
  };
  if (ctx[5] !== void 0) {
    pageoptions0_props.value = ctx[5];
  }
  pageoptions0 = new PageOptions({ props: pageoptions0_props });
  binding_callbacks.push(() => bind(pageoptions0, "value", pageoptions0_value_binding));
  function pageoptions1_value_binding(value) {
    ctx[16](value);
  }
  let pageoptions1_props = {
    label: TXT("l_dynamic"),
    info: TXT("l_dynamic_info"),
    handleChange: ctx[8],
    isCheckbox: true
  };
  if (ctx[3] !== void 0) {
    pageoptions1_props.value = ctx[3];
  }
  pageoptions1 = new PageOptions({ props: pageoptions1_props });
  binding_callbacks.push(() => bind(pageoptions1, "value", pageoptions1_value_binding));
  function pageoptions2_value_binding(value) {
    ctx[17](value);
  }
  let pageoptions2_props = {
    label: TXT("l_incognito"),
    info: TXT("l_incognito_info"),
    handleChange: ctx[9],
    isCheckbox: true,
    isDisabled: !ctx[2]
  };
  if (ctx[4] !== void 0) {
    pageoptions2_props.value = ctx[4];
  }
  pageoptions2 = new PageOptions({ props: pageoptions2_props });
  binding_callbacks.push(() => bind(pageoptions2, "value", pageoptions2_value_binding));
  function pageoptions3_value_binding(value) {
    ctx[18](value);
  }
  let pageoptions3_props = {
    label: TXT("l_include_style"),
    info: TXT("l_include_style_info"),
    handleChange: ctx[11],
    isCheckbox: true
  };
  if (ctx[6] !== void 0) {
    pageoptions3_props.value = ctx[6];
  }
  pageoptions3 = new PageOptions({ props: pageoptions3_props });
  binding_callbacks.push(() => bind(pageoptions3, "value", pageoptions3_value_binding));
  function pageoptions4_value_binding(value) {
    ctx[19](value);
  }
  let pageoptions4_props = {
    label: TXT("l_adblocker"),
    info: TXT("l_adblocker_info"),
    handleChange: ctx[12],
    isCheckbox: true,
    isDisabled: !ctx[1]
  };
  if (ctx[7] !== void 0) {
    pageoptions4_props.value = ctx[7];
  }
  pageoptions4 = new PageOptions({ props: pageoptions4_props });
  binding_callbacks.push(() => bind(pageoptions4, "value", pageoptions4_value_binding));
  return {
    c() {
      create_component(pageoptions0.$$.fragment);
      t0 = space();
      create_component(pageoptions1.$$.fragment);
      t1 = space();
      create_component(pageoptions2.$$.fragment);
      t2 = space();
      create_component(pageoptions3.$$.fragment);
      t3 = space();
      create_component(pageoptions4.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pageoptions0, target, anchor);
      insert(target, t0, anchor);
      mount_component(pageoptions1, target, anchor);
      insert(target, t1, anchor);
      mount_component(pageoptions2, target, anchor);
      insert(target, t2, anchor);
      mount_component(pageoptions3, target, anchor);
      insert(target, t3, anchor);
      mount_component(pageoptions4, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const pageoptions0_changes = {};
      if (!updating_value && dirty & 32) {
        updating_value = true;
        pageoptions0_changes.value = ctx2[5];
        add_flush_callback(() => updating_value = false);
      }
      pageoptions0.$set(pageoptions0_changes);
      const pageoptions1_changes = {};
      if (!updating_value_1 && dirty & 8) {
        updating_value_1 = true;
        pageoptions1_changes.value = ctx2[3];
        add_flush_callback(() => updating_value_1 = false);
      }
      pageoptions1.$set(pageoptions1_changes);
      const pageoptions2_changes = {};
      if (dirty & 4)
        pageoptions2_changes.isDisabled = !ctx2[2];
      if (!updating_value_2 && dirty & 16) {
        updating_value_2 = true;
        pageoptions2_changes.value = ctx2[4];
        add_flush_callback(() => updating_value_2 = false);
      }
      pageoptions2.$set(pageoptions2_changes);
      const pageoptions3_changes = {};
      if (!updating_value_3 && dirty & 64) {
        updating_value_3 = true;
        pageoptions3_changes.value = ctx2[6];
        add_flush_callback(() => updating_value_3 = false);
      }
      pageoptions3.$set(pageoptions3_changes);
      const pageoptions4_changes = {};
      if (dirty & 2)
        pageoptions4_changes.isDisabled = !ctx2[1];
      if (!updating_value_4 && dirty & 128) {
        updating_value_4 = true;
        pageoptions4_changes.value = ctx2[7];
        add_flush_callback(() => updating_value_4 = false);
      }
      pageoptions4.$set(pageoptions4_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pageoptions0.$$.fragment, local);
      transition_in(pageoptions1.$$.fragment, local);
      transition_in(pageoptions2.$$.fragment, local);
      transition_in(pageoptions3.$$.fragment, local);
      transition_in(pageoptions4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pageoptions0.$$.fragment, local);
      transition_out(pageoptions1.$$.fragment, local);
      transition_out(pageoptions2.$$.fragment, local);
      transition_out(pageoptions3.$$.fragment, local);
      transition_out(pageoptions4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pageoptions0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(pageoptions1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(pageoptions2, detaching);
      if (detaching)
        detach(t2);
      destroy_component(pageoptions3, detaching);
      if (detaching)
        detach(t3);
      destroy_component(pageoptions4, detaching);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $config, $$unsubscribe_config = noop, $$subscribe_config = () => ($$unsubscribe_config(), $$unsubscribe_config = subscribe$1(config, ($$value) => $$invalidate(14, $config = $$value)), config);
  $$self.$$.on_destroy.push(() => $$unsubscribe_config());
  let { config } = $$props;
  $$subscribe_config();
  let { selections } = $$props;
  let model = getContext("bbModel");
  let isCloudMonitor = model.isDeviceWeb();
  let isElectronMonitor = model.isDeviceElectron();
  let dynamic = selections.get("dynamic");
  let incognito = config.get("incognito");
  let delay = selections.get("delay");
  let includeStyle = config.get("includeStyle");
  let oldDelay = delay;
  let isAdblockerEnabled = config.isAdblockerEnabled();
  function updateClientTypeFlags() {
    $$invalidate(2, isElectronMonitor = model.isDeviceElectron());
    $$invalidate(1, isCloudMonitor = model.isDeviceWeb());
  }
  model.on("change", updateClientTypeFlags);
  onDestroy(() => {
    model.off("change", updateClientTypeFlags);
  });
  function updateAdblockerState() {
    $$invalidate(7, isAdblockerEnabled = config.isAdblockerEnabled());
  }
  function handleDynamicChange(event) {
    const isDynamic = event.target.checked;
    selections.set({
      dynamic: isDynamic,
      delay: isDynamic ? 0 : oldDelay
    });
    $$invalidate(5, delay = isDynamic ? 0 : oldDelay);
  }
  function handleIncognitoChange() {
    config.set({ incognito });
  }
  function handleDelayChange(value) {
    selections.set({ delay: parseInt(value) || 0 });
  }
  function handleIncludeStyleChange(event) {
    config.set({ includeStyle: event.target.checked });
  }
  function handleExtChange() {
    config.setAdblockerEnabled(isAdblockerEnabled);
  }
  function pageoptions0_value_binding(value) {
    delay = value;
    $$invalidate(5, delay);
  }
  function pageoptions1_value_binding(value) {
    dynamic = value;
    $$invalidate(3, dynamic);
  }
  function pageoptions2_value_binding(value) {
    incognito = value;
    $$invalidate(4, incognito);
  }
  function pageoptions3_value_binding(value) {
    includeStyle = value;
    $$invalidate(6, includeStyle);
  }
  function pageoptions4_value_binding(value) {
    isAdblockerEnabled = value;
    $$invalidate(7, isAdblockerEnabled);
  }
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$subscribe_config($$invalidate(0, config = $$props2.config));
    if ("selections" in $$props2)
      $$invalidate(13, selections = $$props2.selections);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16384) {
      updateAdblockerState();
    }
  };
  return [
    config,
    isCloudMonitor,
    isElectronMonitor,
    dynamic,
    incognito,
    delay,
    includeStyle,
    isAdblockerEnabled,
    handleDynamicChange,
    handleIncognitoChange,
    handleDelayChange,
    handleIncludeStyleChange,
    handleExtChange,
    selections,
    $config,
    pageoptions0_value_binding,
    pageoptions1_value_binding,
    pageoptions2_value_binding,
    pageoptions3_value_binding,
    pageoptions4_value_binding
  ];
}
class SieveConfigOptions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, { config: 0, selections: 13 });
  }
}
function create_default_slot_2(ctx) {
  let sieveconfigoptions;
  let current;
  sieveconfigoptions = new SieveConfigOptions({
    props: {
      selections: ctx[2],
      config: ctx[1]
    }
  });
  return {
    c() {
      create_component(sieveconfigoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveconfigoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveconfigoptions_changes = {};
      if (dirty & 4)
        sieveconfigoptions_changes.selections = ctx2[2];
      if (dirty & 2)
        sieveconfigoptions_changes.config = ctx2[1];
      sieveconfigoptions.$set(sieveconfigoptions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveconfigoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveconfigoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveconfigoptions, detaching);
    }
  };
}
function create_header_slot_2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${TXT("l_page_options")}`;
      attr(div, "slot", "header");
      attr(div, "class", "d-flex items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot_1(ctx) {
  let sievelocators;
  let current;
  sievelocators = new SieveLocators({
    props: {
      locators: ctx[6],
      index: ctx[5],
      op: "INCLUDE",
      sieveOptionsPage: ctx[8]
    }
  });
  return {
    c() {
      create_component(sievelocators.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sievelocators, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(sievelocators.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievelocators.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sievelocators, detaching);
    }
  };
}
function create_header_slot_1(ctx) {
  let div;
  let t0_value = TXT("l_el_selected") + "";
  let t0;
  let t1;
  let span;
  let t2_value = ctx[3].length + "";
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
      attr(span, "class", "badge rounded-pill text-bg-primary");
      attr(div, "slot", "header");
      attr(div, "class", "d-flex items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t2_value !== (t2_value = ctx2[3].length + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_subheader_slot_1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `frame: ${ctx[5]}`;
      attr(div, "slot", "subheader");
      attr(div, "class", "d-flex items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot(ctx) {
  let sievelocators;
  let current;
  sievelocators = new SieveLocators({
    props: {
      locators: ctx[7],
      index: ctx[5],
      op: "EXCLUDE",
      sieveOptionsPage: ctx[8]
    }
  });
  return {
    c() {
      create_component(sievelocators.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sievelocators, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(sievelocators.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievelocators.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sievelocators, detaching);
    }
  };
}
function create_header_slot(ctx) {
  let div;
  let t0_value = TXT("l_el_deselected") + "";
  let t0;
  let t1;
  let span;
  let t2_value = ctx[4].length + "";
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
      attr(span, "class", "badge rounded-pill text-bg-danger");
      attr(div, "slot", "header");
      attr(div, "class", "d-flex items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t2_value !== (t2_value = ctx2[4].length + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_subheader_slot(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `frame: ${ctx[5]}`;
      attr(div, "slot", "subheader");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$2(ctx) {
  let accordion0;
  let t0;
  let accordion1;
  let t1;
  let accordion2;
  let t2;
  let div;
  let current;
  accordion0 = new Accordion({
    props: {
      id: "config-" + ctx[5],
      show: ctx[8],
      $$slots: {
        header: [create_header_slot_2],
        default: [create_default_slot_2]
      },
      $$scope: { ctx }
    }
  });
  accordion1 = new Accordion({
    props: {
      id: "locator-include-" + ctx[5],
      show: true,
      $$slots: {
        subheader: [create_subheader_slot_1],
        header: [create_header_slot_1],
        default: [create_default_slot_1]
      },
      $$scope: { ctx }
    }
  });
  accordion2 = new Accordion({
    props: {
      id: "locator-exclude-" + ctx[5],
      $$slots: {
        subheader: [create_subheader_slot],
        header: [create_header_slot],
        default: [create_default_slot]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(accordion0.$$.fragment);
      t0 = space();
      create_component(accordion1.$$.fragment);
      t1 = space();
      create_component(accordion2.$$.fragment);
      t2 = space();
      div = element("div");
      attr(div, "class", "mt-3");
    },
    m(target, anchor) {
      mount_component(accordion0, target, anchor);
      insert(target, t0, anchor);
      mount_component(accordion1, target, anchor);
      insert(target, t1, anchor);
      mount_component(accordion2, target, anchor);
      insert(target, t2, anchor);
      insert(target, div, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const accordion0_changes = {};
      if (dirty & 16390) {
        accordion0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion0.$set(accordion0_changes);
      const accordion1_changes = {};
      if (dirty & 16392) {
        accordion1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion1.$set(accordion1_changes);
      const accordion2_changes = {};
      if (dirty & 16400) {
        accordion2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion2.$set(accordion2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion0.$$.fragment, local);
      transition_in(accordion1.$$.fragment, local);
      transition_in(accordion2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion0.$$.fragment, local);
      transition_out(accordion1.$$.fragment, local);
      transition_out(accordion2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordion0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(accordion1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(accordion2, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let $model, $$unsubscribe_model = noop, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe$1(model, ($$value) => $$invalidate(9, $model = $$value)), model);
  let $includes;
  let $excludes;
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  let { model } = $$props;
  $$subscribe_model();
  let { config } = $$props;
  let { selections } = $$props;
  const { index, includes, excludes } = $model;
  component_subscribe($$self, includes, (value) => $$invalidate(3, $includes = value));
  component_subscribe($$self, excludes, (value) => $$invalidate(4, $excludes = value));
  const { module, team, prefix } = get_store_value(route);
  const base2 = `/w/${team}/${module}/${prefix}`;
  let sieveOptionsPage = [`/w/${team}/sieve/edit`, `/w/${team}/sieve/add`, `/w/${team}/sieve/dup`].includes(base2);
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$subscribe_model($$invalidate(0, model = $$props2.model));
    if ("config" in $$props2)
      $$invalidate(1, config = $$props2.config);
    if ("selections" in $$props2)
      $$invalidate(2, selections = $$props2.selections);
  };
  return [
    model,
    config,
    selections,
    $includes,
    $excludes,
    index,
    includes,
    excludes,
    sieveOptionsPage
  ];
}
class SieveConfigFrame extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, { model: 0, config: 1, selections: 2 });
  }
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let sieveconfigframe;
  let current;
  sieveconfigframe = new SieveConfigFrame({
    props: {
      model: ctx[5],
      config: ctx[1],
      selections: ctx[0]
    }
  });
  return {
    c() {
      create_component(sieveconfigframe.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveconfigframe, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveconfigframe_changes = {};
      if (dirty & 4)
        sieveconfigframe_changes.model = ctx2[5];
      if (dirty & 2)
        sieveconfigframe_changes.config = ctx2[1];
      if (dirty & 1)
        sieveconfigframe_changes.selections = ctx2[0];
      sieveconfigframe.$set(sieveconfigframe_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveconfigframe.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveconfigframe.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveconfigframe, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let div;
  let current;
  let each_value = ctx[2].models;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let div_levels = [ctx[4]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = ctx2[2].models;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 16 && ctx2[4]]));
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  const omit_props_names = ["model", "config"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $frames;
  let { model } = $$props;
  let { config } = $$props;
  let frames = model.get("frames");
  component_subscribe($$self, frames, (value) => $$invalidate(2, $frames = value));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("model" in $$new_props)
      $$invalidate(0, model = $$new_props.model);
    if ("config" in $$new_props)
      $$invalidate(1, config = $$new_props.config);
  };
  return [model, config, $frames, frames, $$restProps];
}
class SieveConfigPage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { model: 0, config: 1 });
  }
}
function createNode(obj, jqSelectors) {
  sanitize(obj, ParsedPropertyName);
  let count = 0;
  const context = {
    generateId: () => count++
  };
  const root = jsonToNode(obj, "Properties", null, context);
  checkInitial(root, jqSelectors);
  return root;
}
function checkInitial(root, jqSelectors) {
  if (_.isEqual(jqSelectors, ["."])) {
    root.checkAll(CheckState.selected);
    return;
  }
  for (const selector of jqSelectors) {
    const filterParts = selector.replace(/^\./, "").replace(/"/g, "").replace(/\[\]?\??/g, "").split(".");
    let node = root;
    for (const filterPart of filterParts) {
      for (const child of node.children) {
        if (child.key === filterPart) {
          node = child;
        }
      }
    }
    if (node.parent) {
      node.checkAll(CheckState.selected);
    }
  }
}
function getJQSelectors(root) {
  if (root.checkState === CheckState.selected) {
    return ["."];
  }
  const selectors = [];
  (function populateSelectors(node, partialJqSelector) {
    const checkState = node.getCheckState();
    if (checkState === CheckState.none) {
      return;
    }
    if (!node.isRoot()) {
      partialJqSelector = partialJqSelector + `.${node.key}`;
    }
    if (checkState === CheckState.selected) {
      selectors.push(partialJqSelector);
      return;
    }
    if (checkState === CheckState.indeterminate) {
      if (node.type === types.ARRAY_OF_OBJECTS) {
        partialJqSelector += "[]?";
      }
      for (const child of node.children) {
        populateSelectors(child, partialJqSelector);
      }
    }
  })(root, "");
  return selectors;
}
class Node$1 extends BaseNode {
  constructor({
    id,
    label,
    parent: parent2 = null,
    type = null,
    key = null,
    checkable = true,
    disabled = false
  }) {
    super(id, label, parent2);
    this.checkable = checkable;
    this.selectable = false;
    this.disabled = disabled;
    this._expanded = true;
    this.type = type;
    this.key = key;
  }
  isSelectable() {
    return false;
  }
}
function jsonToNode(json, label, parent2, ctx) {
  let type = json.type;
  let newNode;
  delete json.value;
  switch (type) {
    case types.ARRAY_OF_OBJECTS:
      newNode = new Node$1({
        id: ctx.generateId(),
        label: `${label}`,
        parent: parent2,
        type,
        key: label
      });
      newNode.children = Object.keys(json.schema.schema).map(
        (key) => jsonToNode(json.schema.schema[key], key, newNode, ctx)
      );
      break;
    case types.OBJECT:
      newNode = new Node$1({
        id: ctx.generateId(),
        label: `${label}`,
        parent: parent2,
        type,
        key: label
      });
      newNode.children = Object.keys(json.schema).map((key) => jsonToNode(json.schema[key], key, newNode, ctx));
      break;
    case types.UNKNOWN:
      newNode = new Node$1({
        id: ctx.generateId(),
        label: `${label}`,
        parent: parent2,
        type,
        key: label
      });
      break;
    case types.NUMBER:
    case types.BOOLEAN:
    case types.STRING:
    case types.PRIMITIVE:
    case types.ARRAY:
    default:
      newNode = new Node$1({
        id: ctx.generateId(),
        label: `${label}`,
        parent: parent2,
        type,
        key: label
      });
      break;
  }
  return newNode;
}
function create_label_slot(ctx) {
  let label;
  let t_value = ctx[10].label + "";
  let t;
  let label_title_value;
  let mounted;
  let dispose;
  function click_handler2() {
    return ctx[9](ctx[10]);
  }
  return {
    c() {
      label = element("label");
      t = text(t_value);
      attr(label, "slot", "label");
      attr(label, "role", "button");
      attr(label, "title", label_title_value = ctx[10].label);
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, t);
      if (!mounted) {
        dispose = listen(label, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1024 && t_value !== (t_value = ctx[10].label + ""))
        set_data(t, t_value);
      if (dirty & 1024 && label_title_value !== (label_title_value = ctx[10].label)) {
        attr(label, "title", label_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(label);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let div;
  let treeview;
  let div_class_value;
  let current;
  const treeview_spread_levels = [
    { root: ctx[0] },
    {
      class: "tree-view bg-white min-w-min " + ctx[3]
    },
    { showRoot: false },
    { showMeta: false },
    { showIcon: false },
    ctx[6]
  ];
  let treeview_props = {
    $$slots: {
      label: [
        create_label_slot,
        ({ node }) => ({ 10: node }),
        ({ node }) => node ? 1024 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < treeview_spread_levels.length; i += 1) {
    treeview_props = assign(treeview_props, treeview_spread_levels[i]);
  }
  treeview = new TreeView({ props: treeview_props });
  treeview.$on("check", ctx[4]);
  return {
    c() {
      div = element("div");
      create_component(treeview.$$.fragment);
      attr(div, "class", div_class_value = "overflow-auto " + (ctx[2] ? "bb bl br border-bootstrap-border" : ""));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(treeview, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const treeview_changes = dirty & 73 ? get_spread_update(treeview_spread_levels, [
        dirty & 1 && { root: ctx2[0] },
        dirty & 8 && {
          class: "tree-view bg-white min-w-min " + ctx2[3]
        },
        treeview_spread_levels[2],
        treeview_spread_levels[3],
        treeview_spread_levels[4],
        dirty & 64 && get_spread_object(ctx2[6])
      ]) : {};
      if (dirty & 3072) {
        treeview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeview.$set(treeview_changes);
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "overflow-auto " + (ctx2[2] ? "bb bl br border-bootstrap-border" : ""))) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(treeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(treeview);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["obj", "includedJson", "root", "showOuterBorder", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $includedJson, $$unsubscribe_includedJson = noop, $$subscribe_includedJson = () => ($$unsubscribe_includedJson(), $$unsubscribe_includedJson = subscribe$1(includedJson, ($$value) => $$invalidate(8, $includedJson = $$value)), includedJson);
  $$self.$$.on_destroy.push(() => $$unsubscribe_includedJson());
  let { obj } = $$props;
  let { includedJson } = $$props;
  $$subscribe_includedJson();
  let { root } = $$props;
  let { showOuterBorder = true } = $$props;
  let { class: clazz = "" } = $$props;
  function onCheck() {
    const jqSelectors = getJQSelectors(root);
    includedJson.set(jqSelectors);
  }
  function onLabelClick(node) {
    const checkState = node.getCheckState();
    const newState = checkState === CheckState.none ? CheckState.selected : CheckState.none;
    node.checkAll(newState);
    onCheck();
  }
  const click_handler2 = (node) => onLabelClick(node);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("obj" in $$new_props)
      $$invalidate(7, obj = $$new_props.obj);
    if ("includedJson" in $$new_props)
      $$subscribe_includedJson($$invalidate(1, includedJson = $$new_props.includedJson));
    if ("root" in $$new_props)
      $$invalidate(0, root = $$new_props.root);
    if ("showOuterBorder" in $$new_props)
      $$invalidate(2, showOuterBorder = $$new_props.showOuterBorder);
    if ("class" in $$new_props)
      $$invalidate(3, clazz = $$new_props.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 384) {
      $$invalidate(0, root = createNode(obj, $includedJson));
    }
  };
  return [
    root,
    includedJson,
    showOuterBorder,
    clazz,
    onCheck,
    onLabelClick,
    $$restProps,
    obj,
    $includedJson,
    click_handler2
  ];
}
class SchemaKeyTree extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      obj: 7,
      includedJson: 1,
      root: 0,
      showOuterBorder: 2,
      class: 3
    });
  }
}
export { MenuItem as $, C as A, BBXErrorEvent as B, Clause as C, structDefs as D, EventEmitter$1 as E, FieldWrapper as F, enumDefs as G, HOOK_EVENT as H, InputEdit as I, BrowserWrapper as J, MenuItem$1 as K, Loader as L, Menu$1 as M, isArrayType as N, OPS as O, ParamsEditor as P, BaseError as Q, Root as R, StackedError as S, TreeView as T, getXPATH$1 as U, FunctionCall$2 as V, escapeDollar as W, isLocatorExpression as X, Literal$3 as Y, Enum$2 as Z, MenuBtn as _, MultiSelectMenu as a, Declarations as a0, getDefault as a1, Text as a2, AngleRight as a3, Menu as a4, debounce as a5, wait as a6, CSSSelector as a7, getCSS$1 as a8, XPathSelector as a9, Expandable as aA, While$1 as aB, ExpressionStatus as aC, getSummary as aD, setupParams as aE, getXpath as aa, isValidName as ab, select as ac, getCSS as ad, getXPATH as ae, IconBtn as af, clickOutside as ag, Cross$1 as ah, Tick as ai, SearchSelect as aj, SourceEditor as ak, PageOverlay as al, CanvasFrameOverlay as am, Target as an, ListenerManager as ao, getNewTagName as ap, SieveConfigPage as aq, RegexWrapper as ar, Accordion as as, SchemaKeyTree as at, MultilineInputEdit as au, tooltip$1 as av, Tooltip as aw, DashedCircle as ax, TickCircle as ay, Loading as az, EventNames as b, clickOutside$1 as c, Feature as d, BrowserView as e, EventEmitter as f, ErrorCodes as g, ErrorExp as h, isOfType as i, RejectablePromise as j, RESERVED as k, isValidType as l, matchesDataType as m, Block as n, Conditional as o, portal as p, Registry as q, getComponent as r, parseSteps as s, toDOM as t, MenuList as u, Cross as v, BaseNode as w, CheckState as x, getConditionDefs as y, getStepDefs as z };
