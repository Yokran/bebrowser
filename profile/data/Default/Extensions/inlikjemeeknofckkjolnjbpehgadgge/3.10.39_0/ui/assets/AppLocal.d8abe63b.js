var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { S as SvelteComponent, i as init, s as safe_not_equal, a as assign, c as create_component, m as mount_component, g as get_spread_update, b as get_spread_object, t as transition_in, d as transition_out, e as destroy_component, f as compute_rest_props, h as getContext, j as component_subscribe, k as exclude_internal_props, l as create_slot, u as update_slot_base, n as get_all_dirty_from_scope, o as get_slot_changes, p as element, q as space, r as text, v as attr, w as src_url_equal, x as set_style, y as insert, z as append, A as listen, B as prevent_default, C as detach, D as is_function, E as noop$1, F as destroy_each, G as set_data, H as group_outros, I as check_outros, J as compute_slots, K as subscribe, L as run_all, M as createEventDispatcher, N as set_attributes, O as toggle_class, P as action_destroyer, Q as bubble, R as handle_promise, T as update_await_block_branch, U as empty, V as binding_callbacks, W as bind$1, X as add_flush_callback, Y as onMount, Z as get_binding_group_value, _ as init_binding_group, $ as construct_svelte_component, a0 as onDestroy, a1 as set_input_value, a2 as set_store_value, a3 as to_number, a4 as add_render_callback, a5 as select_option, a6 as select_value, a7 as update_keyed_each, a8 as outro_and_destroy_block, a9 as stop_propagation, aa as setContext, ab as destroy_block, ac as afterUpdate, ad as globals, ae as get_store_value, af as svg_element, ag as flush, ah as tick, ai as null_to_empty, aj as HtmlTag, ak as set_svg_attributes, al as set_custom_element_data, am as identity$1, an as create_out_transition } from "./index.21aef151.js";
import { S as Supports, A as Api, T as TXT, u as urlCfg, p as params, d as directive, N as NodePart, c as createMarker, r as reparentNodes, a as removeNodes, V as View, E as Editor, M as Model$2, C as C$1, b as Msg, e as createFieldStore, F as FormModel, f as TYPES, g as FieldList, h as register, i as derived, j as ModelClient, k as i18n, l as AttrModel, m as route, w as writable, n as SieveActionDescList, o as isQuotaAvailable, I as ID, q as cannotBeLessThan, R as Router, s as base, t as formatTime, v as toISOString, x as isStaticDatasource, y as types$1, z as format, B as querystring, D as push$1, G as Base$2, H as html, J as getVar, K as getDef, L as defs, O as And, P as Or, Q as SingleRule, U as hasNumeric, W as RuleToTypeMap, X as formatInterval, Y as getShortDisplayText, Z as Macros$1, _ as render, $ as qs, a0 as Macro$1, a1 as formatTimeV2, a2 as location$1, a3 as trackEvent, a4 as PHEvents, a5 as jsonType$1, a6 as isArrayOfObject, a7 as ParsedPropertyName, a8 as sanitize, a9 as isPrimitiveType$1, aa as isPrimitive$1, ab as isArrayOfPrimitives, ac as initStores, ad as jsonParser$1, ae as getInterval$1, af as _typeof, ag as getUTCWeekYear, ah as startOfUTCWeek, ai as startOfUTCISOWeek, aj as requiredArgs, ak as toDate, al as getUTCWeek, am as toInteger, an as getUTCISOWeek, ao as getDefaultOptions, ap as defaultLocale, aq as longFormatters, ar as isProtectedWeekYearToken, as as throwProtectedError, at as isProtectedDayOfYearToken, au as subMilliseconds, av as getTimezoneOffsetInMilliseconds, aw as assign$1, ax as isValid, ay as getNameFromURL, az as EXT_ID_PROPS, aA as ADBLOCKER_ID, aB as V1$1, aC as V2$1, aD as formatLogTime, aE as SieveDataCollection, aF as getCurrentRoute, aG as PHEventCategories, aH as mustMatchRegex, aI as verifyEnum, aJ as SieveFormModel, aK as CrawlerJob, aL as Crawler$2, aM as JSONEdit, aN as getBasePath, aO as pop, aP as Crawlers, aQ as JobStates, aR as getDuration, aS as CrawlerJobs, aT as replace, aU as Self, aV as Core, aW as identifyUser, aX as updateTeam, aY as updateRoute, aZ as loadLang } from "./json-parser.7cb2f04e.js";
import { S as SPRINTF, a as SearchForm, b as Selector$3, c as checkSieveConstraint, i as instance$5s, M as ModelLabel, d as Message } from "./Message.fcbba7db.js";
import { s as serviceProxy, _ as __vitePreload } from "./service.04a32097.js";
import { M as Menu, F as FieldWrapper, a as MultiSelectMenu, I as InputEdit, p as portal, c as clickOutside, L as Loader, P as ParamsEditor, T as TreeView$1, B as BBXErrorEvent, E as EventEmitter, b as EventNames, O as OPS, d as Feature, e as BrowserView, t as toDOM, f as EventEmitter$1, R as Root, g as ErrorCodes, S as StackedError, m as matchesDataType, i as isOfType, h as ErrorExp, H as HOOK_EVENT, j as RejectablePromise, k as RESERVED, l as isValidType, n as Block, C as Clause, o as Conditional, q as Registry, r as getComponent, s as parseSteps$4, u as MenuList, v as Cross, w as BaseNode$1, x as CheckState$1, y as getConditionDefs, z as getStepDefs, A as C$2, D as structDefs, G as enumDefs, J as BrowserWrapper, K as MenuItem, N as isArrayType, Q as BaseError, U as getXPATH, V as FunctionCall, W as escapeDollar, X as isLocatorExpression, Y as Literal, Z as Enum, _ as MenuBtn, $ as MenuItem$1, a0 as Declarations, a1 as getDefault, a2 as Text, a3 as AngleRight, a4 as Menu$1, a5 as debounce$1, a6 as wait$3, a7 as CSSSelector, a8 as getCSS, a9 as XPathSelector, aa as getXpath, ab as isValidName, ac as select, ad as getCSS$1, ae as getXPATH$1, af as IconBtn, ag as clickOutside$1, ah as Cross$1, ai as Tick, aj as SearchSelect, ak as SourceEditor$1, al as PageOverlay, am as CanvasFrameOverlay, an as Target$1, ao as ListenerManager, ap as getNewTagName, aq as SieveConfigPage, ar as RegexWrapper, as as Accordion, at as SchemaKeyTree, au as tooltip, av as MultilineInputEdit } from "./SchemaKeyTree.96209fd8.js";
import { C as Card } from "./Card.0607fce4.js";
var inbox = "";
var langs = [{
  locale: "en-US",
  label: "English (US)"
}, {
  locale: "de",
  label: "Deutsch"
}, {
  locale: "fr",
  label: "Fran\xE7ais"
}, {
  locale: "ru",
  label: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439"
}, {
  locale: "ja",
  label: "\u65E5\u672C\u8A9E"
}, {
  locale: "zh",
  label: "\u7B80\u4F53\u4E2D\u6587"
}, {
  locale: "es",
  label: "Espa\xF1ol"
}, {
  locale: "it",
  label: "Italiano"
}, {
  locale: "pl",
  label: "Polskie"
}, {
  locale: "pt",
  label: "Portugu\xEAs do Brasil"
}, {
  locale: "sr",
  label: "\u0421\u0440\u043F\u0441\u043A\u0438"
}];
const get_action_slot_changes$3 = (dirty) => ({ onClick: dirty & 128 });
const get_action_slot_context$3 = (ctx) => ({
  slot: "action",
  onClick: ctx[7]
});
function create_action_slot$g(ctx) {
  let current;
  const action_slot_template = ctx[5].action;
  const action_slot = create_slot(action_slot_template, ctx, ctx[6], get_action_slot_context$3);
  return {
    c() {
      if (action_slot)
        action_slot.c();
    },
    m(target, anchor) {
      if (action_slot) {
        action_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (action_slot) {
        if (action_slot.p && (!current || dirty & 192)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(action_slot_template, ctx2[6], dirty, get_action_slot_changes$3),
            get_action_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(action_slot, local);
      current = true;
    },
    o(local) {
      transition_out(action_slot, local);
      current = false;
    },
    d(detaching) {
      if (action_slot)
        action_slot.d(detaching);
    }
  };
}
function create_fragment$5C(ctx) {
  let menu;
  let current;
  const menu_spread_levels = [
    { items: ctx[2] },
    { allowNull: false },
    { placement: "right-end" },
    { id: ctx[0].locale },
    ctx[4]
  ];
  let menu_props = {
    $$slots: {
      action: [
        create_action_slot$g,
        ({ onClick }) => ({ 7: onClick }),
        ({ onClick }) => onClick ? 128 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < menu_spread_levels.length; i2 += 1) {
    menu_props = assign(menu_props, menu_spread_levels[i2]);
  }
  menu = new Menu({ props: menu_props });
  menu.$on("select", ctx[3]);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = dirty & 21 ? get_spread_update(menu_spread_levels, [
        dirty & 4 && { items: ctx2[2] },
        menu_spread_levels[1],
        menu_spread_levels[2],
        dirty & 1 && { id: ctx2[0].locale },
        dirty & 16 && get_spread_object(ctx2[4])
      ]) : {};
      if (dirty & 192) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$5r($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $user;
  let { $$slots: slots = {}, $$scope } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(0, $user = value));
  const langItems = langs.map(({ locale: id2, label: name }) => ({ id: id2, name }));
  async function setLocale(e) {
    const locale = e.detail;
    if (Supports.agents.local) {
      const id2 = await serviceProxy.auth.getId();
      await serviceProxy.store.Prefs.set("locale", locale);
      if (id2) {
        await Api.api("/users", "PUT", { id: id2, locale });
        await serviceProxy.SyncMan._syncStore(serviceProxy.store.UserStore);
      }
      location.reload();
    } else {
      if (USER) {
        await Api.api("/users", "PUT", { locale });
        location.reload();
      }
    }
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  return [$user, user, langItems, setLocale, $$restProps, slots, $$scope];
}
class LocaleSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5r, create_fragment$5C, safe_not_equal, {});
  }
}
function get_each_context_1$g(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  return child_ctx;
}
function create_else_block_1$m(ctx) {
  let div;
  let a;
  let t0;
  let ul;
  let li;
  let t2;
  let each_value_1 = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$g(get_each_context_1$g(ctx, each_value_1, i2));
  }
  return {
    c() {
      div = element("div");
      a = element("a");
      a.innerHTML = `<i class="fa fa-list" aria-hidden="true"></i>`;
      t0 = space();
      ul = element("ul");
      li = element("li");
      li.textContent = "Watchlists";
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(a, "data-bs-toggle", "dropdown");
      attr(a, "href", "#");
      attr(li, "class", "dropdown-header uppercase");
      attr(ul, "class", "dropdown-menu");
      attr(ul, "role", "menu");
      attr(div, "class", "dropend");
      attr(div, "title", "Watchlist");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(div, t0);
      append(div, ul);
      append(ul, li);
      append(ul, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        each_value_1 = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$g(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$g(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ul, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_4$B(ctx) {
  let a;
  let i2;
  return {
    c() {
      a = element("a");
      i2 = element("i");
      attr(i2, "class", "fa fa-list");
      attr(i2, "aria-hidden", "true");
      attr(a, "title", "Watchlist");
      attr(a, "href", urlCfg.watchlist);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i2);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_each_block_1$g(ctx) {
  let li;
  let a;
  let t0_value = ctx[15].name + "";
  let t0;
  let a_href_value;
  let t1;
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "class", "dropdown-item");
      attr(a, "href", a_href_value = ctx[15].href);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t0_value !== (t0_value = ctx2[15].name + ""))
        set_data(t0, t0_value);
      if (dirty & 4 && a_href_value !== (a_href_value = ctx2[15].href)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_action_slot$f(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.innerHTML = `<i class="fa fa-language" aria-hidden="true"></i>`;
      attr(a, "class", "");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(function() {
          if (is_function(ctx[11]))
            ctx[11].apply(this, arguments);
        }));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$1F(ctx) {
  let a;
  let t;
  return {
    c() {
      a = element("a");
      t = text("Sign In");
      attr(a, "role", "menuitem");
      attr(a, "class", "dropdown-item");
      attr(a, "href", urlCfg.login);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block_2$1c(ctx) {
  let a;
  let t0;
  let em;
  let t1_value = ctx[0].name + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t0 = text("Sign Out (");
      em = element("em");
      t1 = text(t1_value);
      t2 = text(")");
      attr(a, "role", "menuitem");
      attr(a, "class", "dropdown-item");
      attr(a, "href", urlCfg.logout);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, em);
      append(em, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[0].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$1V(ctx) {
  let li;
  let a;
  let t_value = TXT("l_billing") + "";
  let t;
  return {
    c() {
      li = element("li");
      a = element("a");
      t = text(t_value);
      attr(a, "href", urlCfg.billing);
      attr(a, "class", "dropdown-item");
      attr(a, "target", "_blank");
      attr(a, "role", "menuitem");
      attr(li, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_if_block$39(ctx) {
  let li;
  let a;
  let t_value = TXT("l_admin") + "";
  let t;
  return {
    c() {
      li = element("li");
      a = element("a");
      t = text(t_value);
      attr(a, "href", urlCfg.admin);
      attr(a, "class", "dropdown-item");
      attr(a, "role", "menuitem");
      attr(a, "target", "_blank");
      attr(li, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_fragment$5B(ctx) {
  let div3;
  let a0;
  let img;
  let img_src_value;
  let t0;
  let t1;
  let a1;
  let i0;
  let a1_href_value;
  let a1_data_team_id_value;
  let t2;
  let a2;
  let i1;
  let t3;
  let a3;
  let i2;
  let t4;
  let i3;
  let t5;
  let a4;
  let t6;
  let div1;
  let a5;
  let i5;
  let t7;
  let div0;
  let t8;
  let t9;
  let localeselector;
  let t10;
  let div2;
  let a6;
  let t11;
  let ul;
  let li0;
  let t12;
  let li1;
  let t13;
  let li2;
  let a7;
  let t15;
  let li3;
  let a8;
  let t16_value = TXT("l_settings") + "";
  let t16;
  let t17;
  let t18;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].length == 1)
      return create_if_block_4$B;
    return create_else_block_1$m;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  localeselector = new LocaleSelector({
    props: {
      $$slots: {
        action: [
          create_action_slot$f,
          ({ onClick }) => ({ 11: onClick }),
          ({ onClick }) => onClick ? 2048 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[4].isLoggedIn())
      return create_if_block_2$1c;
    return create_else_block$1F;
  }
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block2 = current_block_type_1(ctx);
  let if_block3 = !ctx[0].account_id && create_if_block_1$1V();
  let if_block4 = ctx[0].role == "admin" && create_if_block$39();
  return {
    c() {
      var _a, _b;
      div3 = element("div");
      a0 = element("a");
      img = element("img");
      t0 = space();
      if_block0.c();
      t1 = space();
      a1 = element("a");
      i0 = element("i");
      t2 = space();
      a2 = element("a");
      i1 = element("i");
      t3 = space();
      a3 = element("a");
      i2 = element("i");
      t4 = space();
      i3 = element("i");
      t5 = space();
      a4 = element("a");
      a4.innerHTML = `<i class="fa fa-rocket" aria-hidden="true"></i>`;
      t6 = space();
      div1 = element("div");
      a5 = element("a");
      i5 = element("i");
      t7 = space();
      div0 = element("div");
      t8 = space();
      t9 = space();
      create_component(localeselector.$$.fragment);
      t10 = space();
      div2 = element("div");
      a6 = element("a");
      a6.innerHTML = `<i class="fa fa-cog" aria-hidden="true"></i>`;
      t11 = space();
      ul = element("ul");
      li0 = element("li");
      if_block2.c();
      t12 = space();
      li1 = element("li");
      t13 = space();
      li2 = element("li");
      a7 = element("a");
      a7.textContent = `${TXT("l_support")}`;
      t15 = space();
      li3 = element("li");
      a8 = element("a");
      t16 = text(t16_value);
      t17 = space();
      if (if_block3)
        if_block3.c();
      t18 = space();
      if (if_block4)
        if_block4.c();
      attr(img, "height", "38");
      attr(img, "alt", "distill-logo");
      if (!src_url_equal(img.src, img_src_value = "./img/distill_logo_inverted.svg"))
        attr(img, "src", img_src_value);
      attr(a0, "class", "xside-logo");
      attr(a0, "target", "_blank");
      attr(a0, "rel", "noopener");
      attr(a0, "title", "Distill.io");
      attr(a0, "href", urlCfg.website);
      attr(i0, "class", "fa fa-bar-chart-o");
      attr(i0, "aria-hidden", "true");
      attr(a1, "title", "Usage");
      attr(a1, "href", a1_href_value = urlCfg.usageAvailabilityForTeam(((_a = ctx[3]) == null ? void 0 : _a.team) || 0));
      attr(a1, "data-team-id", a1_data_team_id_value = ((_b = ctx[3]) == null ? void 0 : _b.team) || 0);
      attr(i1, "class", "fa fa-users");
      attr(i1, "aria-hidden", "true");
      attr(a2, "href", urlCfg.groups);
      attr(a2, "title", "Manage Teams");
      attr(i2, "class", "fa fa-book");
      attr(i2, "aria-hidden", "true");
      attr(a3, "href", urlCfg.website + "/changelog/" + (Supports.agents.local ? `#${serviceProxy.CFG.VERSION}` : ""));
      attr(a3, "title", "Changelog");
      attr(a3, "target", "_blank");
      set_style(i3, "flex", "1");
      attr(a4, "class", "dropdown-toggle");
      attr(a4, "href", "#");
      attr(a4, "data-toggle", "dropdown");
      attr(a4, "title", "What's new");
      a4.hidden = true;
      attr(i5, "class", "fa fa-comment");
      attr(i5, "aria-hidden", "true");
      attr(a5, "class", "ripple");
      attr(a5, "href", urlCfg.forums);
      attr(a5, "title", "Forums");
      attr(a5, "target", "_blank");
      attr(div0, "id", "feedPop");
      attr(a6, "data-bs-toggle", "dropdown");
      attr(a6, "href", "#");
      attr(li0, "role", "presentation");
      attr(li1, "class", "divider");
      attr(a7, "target", "_blank");
      attr(a7, "rel", "noopener");
      attr(a7, "class", "dropdown-item");
      attr(a7, "href", "https://distill.io/docs/web-monitor/");
      attr(a8, "class", "dropdown-item");
      attr(a8, "role", "menuitem");
      attr(a8, "href", urlCfg.settings);
      attr(li3, "role", "presentation");
      attr(ul, "class", "dropdown-menu");
      attr(ul, "role", "menu");
      attr(div2, "class", "dropend");
      attr(div2, "title", "Settings");
      attr(div3, "class", "vbar h-full");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, a0);
      append(a0, img);
      append(div3, t0);
      if_block0.m(div3, null);
      append(div3, t1);
      append(div3, a1);
      append(a1, i0);
      append(div3, t2);
      append(div3, a2);
      append(a2, i1);
      append(div3, t3);
      append(div3, a3);
      append(a3, i2);
      append(div3, t4);
      append(div3, i3);
      append(div3, t5);
      append(div3, a4);
      append(div3, t6);
      append(div3, div1);
      append(div1, a5);
      append(a5, i5);
      append(div1, t7);
      append(div1, div0);
      append(div3, t8);
      append(div3, t9);
      mount_component(localeselector, div3, null);
      append(div3, t10);
      append(div3, div2);
      append(div2, a6);
      append(div2, t11);
      append(div2, ul);
      append(ul, li0);
      if_block2.m(li0, null);
      append(ul, t12);
      append(ul, li1);
      append(ul, t13);
      append(ul, li2);
      append(li2, a7);
      append(ul, t15);
      append(ul, li3);
      append(li3, a8);
      append(a8, t16);
      append(ul, t17);
      if (if_block3)
        if_block3.m(ul, null);
      append(ul, t18);
      if (if_block4)
        if_block4.m(ul, null);
      current = true;
      if (!mounted) {
        dispose = listen(a4, "click", prevent_default(ctx[5]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a, _b;
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div3, t1);
        }
      }
      if (!current || dirty & 8 && a1_href_value !== (a1_href_value = urlCfg.usageAvailabilityForTeam(((_a = ctx2[3]) == null ? void 0 : _a.team) || 0))) {
        attr(a1, "href", a1_href_value);
      }
      if (!current || dirty & 8 && a1_data_team_id_value !== (a1_data_team_id_value = ((_b = ctx2[3]) == null ? void 0 : _b.team) || 0)) {
        attr(a1, "data-team-id", a1_data_team_id_value);
      }
      const localeselector_changes = {};
      if (dirty & 264192) {
        localeselector_changes.$$scope = { dirty, ctx: ctx2 };
      }
      localeselector.$set(localeselector_changes);
      if_block2.p(ctx2, dirty);
      if (!ctx2[0].account_id) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_1$1V();
          if_block3.c();
          if_block3.m(ul, t18);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (ctx2[0].role == "admin") {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block$39();
          if_block4.c();
          if_block4.m(ul, null);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(localeselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(localeselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block0.d();
      destroy_component(localeselector);
      if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$5q($$self, $$props, $$invalidate) {
  let $user;
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(3, $params = $$value));
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(0, $user = value));
  let currentTheme = window.App.store.get("theme");
  let groups = $user.groups || [];
  let watchlists = [];
  function openReleaseMenu() {
  }
  async function onSignOut(e) {
    if (Supports.agents.local) {
      e.preventDefault();
      await serviceProxy.auth.logout();
      location.href = urlCfg.logout;
    }
  }
  function setTheme(theme) {
    if (theme != "light" && theme != "dark") {
      return;
    }
    document.documentElement.setAttribute("data-bs-theme", theme);
    window.App.store.set("theme", theme);
    $$invalidate(1, currentTheme = theme);
  }
  const click_handler = (theme) => {
    setTheme(theme.name);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        $$invalidate(2, watchlists = [
          {
            name: `${$user.name} (personal)`,
            href: "#/w/0/list/all/"
          },
          ...groups.map((g) => ({
            name: g.name,
            href: `#/w/${g.id}/list/all/`
          }))
        ]);
      }
    }
  };
  return [
    $user,
    currentTheme,
    watchlists,
    $params,
    user,
    openReleaseMenu,
    onSignOut,
    setTheme,
    click_handler
  ];
}
class VBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5q, create_fragment$5B, safe_not_equal, {});
  }
}
var Layout_svelte_svelte_type_style_lang = "";
const get_topbar_slot_changes = (dirty) => ({});
const get_topbar_slot_context = (ctx) => ({});
const get_sidebar_slot_changes = (dirty) => ({});
const get_sidebar_slot_context = (ctx) => ({});
function fallback_block$f(ctx) {
  let div;
  let vbar;
  let current;
  vbar = new VBar({ props: { class: "h-100" } });
  return {
    c() {
      div = element("div");
      create_component(vbar.$$.fragment);
      attr(div, "class", "xsidebar");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(vbar, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(vbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(vbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(vbar);
    }
  };
}
function create_if_block$38(ctx) {
  let div;
  let current;
  const topbar_slot_template = ctx[3].topbar;
  const topbar_slot = create_slot(topbar_slot_template, ctx, ctx[2], get_topbar_slot_context);
  return {
    c() {
      div = element("div");
      if (topbar_slot)
        topbar_slot.c();
      attr(div, "class", "xheader");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (topbar_slot) {
        topbar_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (topbar_slot) {
        if (topbar_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            topbar_slot,
            topbar_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(topbar_slot_template, ctx2[2], dirty, get_topbar_slot_changes),
            get_topbar_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar_slot, local);
      current = true;
    },
    o(local) {
      transition_out(topbar_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (topbar_slot)
        topbar_slot.d(detaching);
    }
  };
}
function create_fragment$5A(ctx) {
  let div1;
  let t0;
  let t1;
  let div0;
  let div1_style_value;
  let current;
  const sidebar_slot_template = ctx[3].sidebar;
  const sidebar_slot = create_slot(sidebar_slot_template, ctx, ctx[2], get_sidebar_slot_context);
  const sidebar_slot_or_fallback = sidebar_slot || fallback_block$f();
  let if_block = ctx[1].topbar && create_if_block$38(ctx);
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      div1 = element("div");
      if (sidebar_slot_or_fallback)
        sidebar_slot_or_fallback.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "xcontent");
      attr(div1, "class", "xgrid h-screen w-screen");
      attr(div1, "style", div1_style_value = "grid-template-rows: auto minmax(1px,1fr);grid-template-columns: auto 1fr; " + (ctx[0].style || ""));
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (sidebar_slot_or_fallback) {
        sidebar_slot_or_fallback.m(div1, null);
      }
      append(div1, t0);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t1);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (sidebar_slot) {
        if (sidebar_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            sidebar_slot,
            sidebar_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(sidebar_slot_template, ctx2[2], dirty, get_sidebar_slot_changes),
            get_sidebar_slot_context
          );
        }
      }
      if (ctx2[1].topbar) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$38(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1 && div1_style_value !== (div1_style_value = "grid-template-rows: auto minmax(1px,1fr);grid-template-columns: auto 1fr; " + (ctx2[0].style || ""))) {
        attr(div1, "style", div1_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar_slot_or_fallback, local);
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar_slot_or_fallback, local);
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (sidebar_slot_or_fallback)
        sidebar_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$5p($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  return [$$restProps, $$slots, $$scope, slots];
}
class Layout$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5p, create_fragment$5A, safe_not_equal, {});
  }
}
function create_if_block_1$1U(ctx) {
  let div;
  let t_value = ctx[1].account.name + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "pr-8 fw4 f4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].account.name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_else_block$1E(ctx) {
  let a;
  let t;
  return {
    c() {
      a = element("a");
      t = text("Sign In");
      attr(a, "href", urlCfg.login);
      attr(a, "class", "xnav-a");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block$37(ctx) {
  let a;
  let t_value = ctx[1].name + "";
  let t;
  return {
    c() {
      a = element("a");
      t = text(t_value);
      attr(a, "href", "#/settings/profile/");
      attr(a, "class", "fw3 xnav-a");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_fragment$5z(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let a;
  let t4;
  let t5;
  let if_block0 = ctx[1].account && create_if_block_1$1U(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].id)
      return create_if_block$37;
    return create_else_block$1E;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(ctx[0]);
      t1 = space();
      div1 = element("div");
      t2 = space();
      a = element("a");
      a.textContent = "Get Help";
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      if_block1.c();
      attr(div0, "class", "title-header ttu fw4 f3");
      attr(div1, "class", "flex-grow");
      attr(a, "class", "btn btn-primary btn-sm xbtn-default mr-2");
      attr(a, "href", "https://distill.io/docs/contact-us/");
      attr(a, "target", "_blank");
      attr(div2, "id", "topbar");
      attr(div2, "class", "flex items-center mt1 bb b--light-gray");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div2, t2);
      append(div2, a);
      append(div2, t4);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t5);
      if_block1.m(div2, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t0, ctx2[0]);
      if (ctx2[1].account) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$1U(ctx2);
          if_block0.c();
          if_block0.m(div2, t5);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div2, null);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if_block1.d();
    }
  };
}
function instance$5o($$self, $$props, $$invalidate) {
  let $user;
  let { title = "Distill" } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(1, $user = value));
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
  };
  return [title, $user, user];
}
class Topbar$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5o, create_fragment$5z, safe_not_equal, { title: 0 });
  }
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const createAndInsertPart = (containerPart, beforePart) => {
  const container = containerPart.startNode.parentNode;
  const beforeNode = beforePart === void 0 ? containerPart.endNode : beforePart.startNode;
  const startNode = container.insertBefore(createMarker(), beforeNode);
  container.insertBefore(createMarker(), beforeNode);
  const newPart = new NodePart(containerPart.options);
  newPart.insertAfterNode(startNode);
  return newPart;
};
const updatePart = (part, value) => {
  part.setValue(value);
  part.commit();
  return part;
};
const insertPartBefore = (containerPart, part, ref) => {
  const container = containerPart.startNode.parentNode;
  const beforeNode = ref ? ref.startNode : containerPart.endNode;
  const endNode = part.endNode.nextSibling;
  if (endNode !== beforeNode) {
    reparentNodes(container, part.startNode, endNode, beforeNode);
  }
};
const removePart = (part) => {
  removeNodes(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);
};
const generateMap = (list, start, end) => {
  const map2 = /* @__PURE__ */ new Map();
  for (let i2 = start; i2 <= end; i2++) {
    map2.set(list[i2], i2);
  }
  return map2;
};
const partListCache = /* @__PURE__ */ new WeakMap();
const keyListCache = /* @__PURE__ */ new WeakMap();
const repeat = directive((items, keyFnOrTemplate, template2) => {
  let keyFn;
  if (template2 === void 0) {
    template2 = keyFnOrTemplate;
  } else if (keyFnOrTemplate !== void 0) {
    keyFn = keyFnOrTemplate;
  }
  return (containerPart) => {
    if (!(containerPart instanceof NodePart)) {
      throw new Error("repeat can only be used in text bindings");
    }
    const oldParts = partListCache.get(containerPart) || [];
    const oldKeys = keyListCache.get(containerPart) || [];
    const newParts = [];
    const newValues = [];
    const newKeys = [];
    let index2 = 0;
    for (const item of items) {
      newKeys[index2] = keyFn ? keyFn(item, index2) : index2;
      newValues[index2] = template2(item, index2);
      index2++;
    }
    let newKeyToIndexMap;
    let oldKeyToIndexMap;
    let oldHead = 0;
    let oldTail = oldParts.length - 1;
    let newHead = 0;
    let newTail = newValues.length - 1;
    while (oldHead <= oldTail && newHead <= newTail) {
      if (oldParts[oldHead] === null) {
        oldHead++;
      } else if (oldParts[oldTail] === null) {
        oldTail--;
      } else if (oldKeys[oldHead] === newKeys[newHead]) {
        newParts[newHead] = updatePart(oldParts[oldHead], newValues[newHead]);
        oldHead++;
        newHead++;
      } else if (oldKeys[oldTail] === newKeys[newTail]) {
        newParts[newTail] = updatePart(oldParts[oldTail], newValues[newTail]);
        oldTail--;
        newTail--;
      } else if (oldKeys[oldHead] === newKeys[newTail]) {
        newParts[newTail] = updatePart(oldParts[oldHead], newValues[newTail]);
        insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);
        oldHead++;
        newTail--;
      } else if (oldKeys[oldTail] === newKeys[newHead]) {
        newParts[newHead] = updatePart(oldParts[oldTail], newValues[newHead]);
        insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);
        oldTail--;
        newHead++;
      } else {
        if (newKeyToIndexMap === void 0) {
          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
        }
        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
          removePart(oldParts[oldHead]);
          oldHead++;
        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
          removePart(oldParts[oldTail]);
          oldTail--;
        } else {
          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
          const oldPart = oldIndex !== void 0 ? oldParts[oldIndex] : null;
          if (oldPart === null) {
            const newPart = createAndInsertPart(containerPart, oldParts[oldHead]);
            updatePart(newPart, newValues[newHead]);
            newParts[newHead] = newPart;
          } else {
            newParts[newHead] = updatePart(oldPart, newValues[newHead]);
            insertPartBefore(containerPart, oldPart, oldParts[oldHead]);
            oldParts[oldIndex] = null;
          }
          newHead++;
        }
      }
    }
    while (newHead <= newTail) {
      const newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);
      updatePart(newPart, newValues[newHead]);
      newParts[newHead++] = newPart;
    }
    while (oldHead <= oldTail) {
      const oldPart = oldParts[oldHead++];
      if (oldPart !== null) {
        removePart(oldPart);
      }
    }
    partListCache.set(containerPart, newParts);
    keyListCache.set(containerPart, newKeys);
  };
});
let KVStore = serviceProxy.store.KVStore;
const $$3 = window.jQuery;
if (!$$3) {
  throw new Error("ADD jQuery");
}
const _$5 = window._;
if (!_$5) {
  throw new Error("ADD _");
}
const domo$2 = window.domo;
if (!domo$2) {
  throw new Error("ADD domo");
}
const Backbone$4 = window.Backbone;
if (!Backbone$4) {
  throw new Error("ADD Backbone");
}
const Common = View.Base.extend({
  name: "actions$Common",
  events: {
    "change": "event_change"
  },
  event_change: function() {
    this.saveValues();
  },
  render: function() {
    this.$el.attr({
      "id": "common",
      "class": "card panel-default"
    }).append(
      HEADER(
        { "class": "card-header" },
        H3(TXT("l_actions"))
      ),
      DIV(
        { "class": "card-body" },
        DIV(
          { "class": "checkbox" },
          LABEL(
            INPUT({ type: "checkbox", name: "actions.popup" }),
            TXT("l_action_local_popup")
          )
        ),
        DIV(
          { "class": "checkbox" },
          LABEL(
            INPUT({ type: "checkbox", name: "actions.audio" }),
            TXT("l_action_local_audio")
          )
        ),
        DIV(
          { "class": "form-group" },
          TXT("m_firefox_only"),
          " - ",
          TXT("m_autohide_popup"),
          ": ",
          SELECT(
            { "name": "actions.popup.autohide", "style": "width:auto" },
            OPTION({ value: 0 }, TXT("l_never")),
            OPTION({ value: 5 }, "5s"),
            OPTION({ value: 10 }, "10s"),
            OPTION({ value: 20 }, "20s"),
            OPTION({ value: 60 }, "1m"),
            OPTION({ value: 120 }, "2m"),
            OPTION({ value: 300 }, "5m")
          )
        ),
        DIV(
          { "class": "alert alert-info" },
          A({ href: "https://distill.io/settings/actions" }, TXT("Change email action settings from web app!"))
        )
      )
    );
    this.setValues();
    return this;
  },
  saveValues: function() {
    this.$el.find("input,select").each(function() {
      const el2 = this;
      if (el2.type == "checkbox") {
        serviceProxy.store.Prefs.set(el2.name, el2.checked);
      } else {
        serviceProxy.store.Prefs.set(el2.name, el2.value);
      }
    });
  },
  setValues: function() {
    this.$el.find("input,select").each(async function() {
      const el2 = this;
      if (el2.type == "checkbox") {
        el2.checked = await serviceProxy.store.Prefs.get(el2.name);
      } else {
        el2.value = await serviceProxy.store.Prefs.get(el2.name);
      }
    });
  }
});
const Tone = View.Base.extend({
  name: "Tone",
  className: "form-group",
  events: {
    "click button.xdel": "event_del",
    "click button.xplay": "event_play"
  },
  event_del: function() {
    this.model.collection.remove(this.model);
  },
  event_play: function() {
    if (this.model.get("type") == "file") {
      this.playFile();
    } else {
      this.playSrc(this.input.getValue());
    }
  },
  getDefaultName: function(path) {
    const parts = path.split(/(\/|\\)/);
    return parts.pop() || "New File";
  },
  onInputChange: function() {
    const value = this.input.getValue();
    if (_$5.isEmpty(this.label.getValue())) {
      this.label.setValue(this.getDefaultName(value));
    }
  },
  playFile: function() {
    if (this.input.field.files) {
      this.playSelectedFile();
    } else {
      this.playSavedFile();
    }
  },
  playSavedFile: async function() {
    const ref = this.model.get("value");
    try {
      let doc = await KVStore.findOne(ref);
      this.playSrc(doc.value);
    } catch (err) {
      console.error("Error while playing saved file", err);
    }
  },
  async playSelectedFile() {
    const file = this.input.field.files[0];
    if (file) {
      this.playSrc(await readFile$2(file));
    } else {
      alert("Please select an audio file before playing it.");
    }
  },
  playSrc(src) {
    AUDIO({ src }).play();
  },
  postInit: function() {
    this.label = Editor.create({
      model: this.model,
      param: {
        label: "l_name",
        name: "label",
        type: "text"
      },
      parent: this
    });
    this.input = Editor.create({
      model: this.model,
      param: this.model.get("type") == "url" ? {
        label: "l_url",
        type: "url",
        name: "value"
      } : this.model.get("value") != null ? {
        type: "static",
        name: "value"
      } : {
        label: "l_file",
        type: "file",
        name: "value"
      },
      parent: this
    });
    this.listenTo(this.input, "change", this.onInputChange);
  },
  render: function() {
    this.$el.append(
      DIV(
        { "class": "col-md-3" },
        this.label.render().el
      ),
      DIV(
        { "class": "col-md-6" },
        this.input.render().el
      ),
      DIV(
        { "class": "col-md-3" },
        BUTTON({ "class": "btn btn-default xplay" }, TXT("a_play")),
        " ",
        BUTTON({ "class": "btn btn-default xdel" }, I({ "class": "fa fa-times" }))
      )
    );
    if (this.model.get("type") == "file" && this.model.get("value") == null) {
      this.input.field.click();
    }
    return this;
  }
});
const ErrorSect = View.Base.extend({
  name: "actions$errorSect",
  events: {
    "change": "event_change"
  },
  event_change: function() {
    this.saveValues();
  },
  render: function() {
    const sounds = _$5.findWhere(Model$2.SieveActionDescList, { type: C$1.ACTION_LOCAL_AUDIO })["params"][0].list;
    this.$el.attr({
      "id": "errorSect",
      "class": "card panel-default"
    }).append(
      HEADER(
        { "class": "card-header" },
        H3(TXT("Error Actions"))
      ),
      DIV(
        { "class": "card-body" },
        DIV(
          { "class": "checkbox" },
          LABEL(
            INPUT({ type: "checkbox", name: "errorAction.enabled" }),
            TXT("Trigger notifications")
          )
        ),
        DIV(
          { "class": "form-group" },
          TXT("l_notification_sound"),
          ": ",
          SELECT(
            { "name": "errorAction.sound", "style": "width:auto" },
            sounds.map(function(sound, index2) {
              return OPTION({ value: sound.value }, TXT(sound.label));
            })
          )
        ),
        DIV(
          { "class": "form-group" },
          TXT("Minimum time interval between notifications (in minutes): "),
          INPUT({ "type": "number", "style": "width: 60px;", "name": "errorAction.interval", "min": "1" })
        ),
        DIV(
          { "class": "form-group" },
          TXT("No. of consecutive errors to trigger notifications"),
          ": ",
          SELECT(
            { "name": "errorAction.minCount", "style": "width:auto" },
            OPTION({ value: 1 }, "1"),
            OPTION({ value: 2 }, "2"),
            OPTION({ value: 3 }, "3"),
            OPTION({ value: 4 }, "4"),
            OPTION({ value: 5 }, "5"),
            OPTION({ value: 6 }, "6"),
            OPTION({ value: 7 }, "7"),
            OPTION({ value: 8 }, "8"),
            OPTION({ value: 9 }, "9"),
            OPTION({ value: 10 }, "10")
          )
        ),
        DIV(
          { "class": "alert alert-info" },
          TXT("h_error_notif_desc")
        )
      )
    );
    this.setValues();
    return this;
  },
  saveValues: function() {
    this.$el.find("input,select").each(function() {
      const el2 = this;
      if (el2.type == "checkbox") {
        serviceProxy.store.Prefs.set(el2.name, el2.checked);
      } else {
        serviceProxy.store.Prefs.set(el2.name, el2.value);
      }
    });
  },
  setValues: function() {
    this.$el.find("input,select").each(async function() {
      const el2 = this;
      if (el2.type == "checkbox") {
        el2.checked = await serviceProxy.store.Prefs.get(el2.name);
      } else {
        el2.value = await serviceProxy.store.Prefs.get(el2.name);
      }
    });
  }
});
const Tones$1 = View.Collection.extend({
  name: "actions$Tones",
  actions: {
    "tones add file": { fn: "action_add_file" },
    "tones add url": { fn: "action_add_url" },
    "tones save": { fn: "action_save" }
  },
  action_add_file: function() {
    const model = new Backbone$4.Model({ type: "file" });
    this.collection.add(model);
  },
  action_add_url: function() {
    const model = new Backbone$4.Model({ type: "url" });
    this.collection.add(model);
  },
  async action_save() {
    let file;
    Msg.start("save", "l_loading");
    let tones = [];
    for (let view of _$5.values(this.views)) {
      const files2 = view.input.field.files;
      const model = view.model;
      const json = model.toJSON();
      const isNewFile = !!files2;
      if (isNewFile && (file = files2[0])) {
        let dataURI = await readFile$2(file);
        const id2 = "tone:" + await sha1$1(dataURI);
        await KVStore.create({ id: id2, value: dataURI });
        json.value = id2;
      }
      tones.push(json);
    }
    const value = JSON.stringify(tones);
    let res = await KVStore.update("tones", { value });
    if (res._count === 0) {
      await KVStore.create({ id: "tones", value });
    }
    const oldFileRefs = files(this.oldTones);
    const savedFileRefs = files(tones);
    const removedFiles = _$5.difference(oldFileRefs, savedFileRefs);
    for (let file2 of removedFiles) {
      await KVStore.destroy(file2);
    }
    Msg.reset();
    this.load();
    function files(tones2) {
      return tones2.filter((tone) => tone.type == "file").map((tone) => tone.value);
    }
  },
  addOne: function(model) {
    const view = new Tone({ parent: this, model }).render();
    this.$list.append(view.el);
    return view;
  },
  initCollection: function() {
    this.oldTones = [];
    this.collection = new Backbone$4.Collection();
  },
  load: async function() {
    let doc = await KVStore.findOne("tones");
    if (doc) {
      this.oldTones = JSON.parse(doc.value);
      this.collection.reset(this.oldTones);
    }
  },
  renderBase: function() {
    this.$el.attr({
      "id": "tones",
      "class": "card panel-default"
    }).append(
      HEADER(
        { "class": "card-header clearfix" },
        H3({ "class": "pull-left" }, "Tones"),
        DIV(
          { "class": "right" },
          BUTTON(
            { "class": "btn btn-default btn-sm", "data-action": "tones add file" },
            TXT("a_add_file")
          ),
          BUTTON(
            { "class": "btn btn-default btn-sm", "data-action": "tones add url" },
            TXT("a_add_url")
          )
        )
      ),
      DIV(
        { "class": "card-body" },
        DIV({ "class": "xlist" })
      ),
      DIV(
        { "class": "card-footer" },
        BUTTON(
          { "class": "btn btn-primary", "data-action": "tones save" },
          TXT("a_save")
        )
      )
    );
    this.$list = this.$el.find(".xlist");
  }
});
View.ActionProvider.extend({
  name: "SettingsActions",
  load: function(callback) {
    this.tones.load(callback);
  },
  postInit: function() {
    this.common = new Common({ parent: this });
    this.errorSect = new ErrorSect({ parent: this });
    this.tones = new Tones$1({ parent: this });
  },
  render: function() {
    this.$el.append(
      this.common.render().el,
      this.errorSect.render().el,
      this.tones.render().el
    );
    return this;
  }
});
async function sha1$1(dataURI) {
  let encoder = new TextEncoder();
  let hashBuf = await crypto.subtle.digest("SHA-1", encoder.encode(dataURI));
  let hashArrBuf = Array.from(new Uint8Array(hashBuf));
  let hashHex = hashArrBuf.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
function readFile$2(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = function(e) {
      resolve(e.target.result);
    };
    reader.readAsDataURL(file);
  });
}
function create_fragment$5y(ctx) {
  let label;
  let input;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      label = element("label");
      input = element("input");
      t = space();
      if (default_slot)
        default_slot.c();
      attr(input, "class", "me-2");
      attr(input, "type", "checkbox");
      attr(label, "class", "d-flex align-items-center");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input);
      input.checked = ctx[1];
      append(label, t);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        input.checked = ctx2[1];
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(label);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$5n($$self, $$props, $$invalidate) {
  let $field, $$unsubscribe_field = noop$1, $$subscribe_field = () => ($$unsubscribe_field(), $$unsubscribe_field = subscribe(field, ($$value) => $$invalidate(1, $field = $$value)), field);
  $$self.$$.on_destroy.push(() => $$unsubscribe_field());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { field } = $$props;
  $$subscribe_field();
  function input_change_handler() {
    $field = this.checked;
    field.set($field);
  }
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$subscribe_field($$invalidate(0, field = $$props2.field));
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [field, $field, $$scope, slots, input_change_handler];
}
class Checkbox extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5n, create_fragment$5y, safe_not_equal, { field: 0 });
  }
}
function create_else_block$1D(ctx) {
  let div;
  let t_value = ctx[0].value + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "flex align-items-center h-100");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].value + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$36(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "file");
      attr(input, "placeholder", "File");
      attr(input, "class", "form-control form-control-sm");
      attr(div, "class", "xtext xeditor control-group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      if (!mounted) {
        dispose = listen(input, "change", ctx[3]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5x(ctx) {
  let div4;
  let div1;
  let div0;
  let input;
  let input_value_value;
  let t0;
  let div2;
  let t1;
  let div3;
  let button0;
  let t3;
  let button1;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].new)
      return create_if_block$36;
    return create_else_block$1D;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      div2 = element("div");
      if_block.c();
      t1 = space();
      div3 = element("div");
      button0 = element("button");
      button0.textContent = "Play";
      t3 = space();
      button1 = element("button");
      button1.innerHTML = `<i class="fa fa-times"></i>`;
      input.value = input_value_value = ctx[0].label;
      attr(input, "placeholder", "Name");
      attr(input, "type", "text");
      attr(input, "class", "form-control xform-control-sm inline");
      attr(div0, "class", "xtext xeditor control-group");
      attr(div1, "class", "col-md-3");
      attr(div2, "class", "col-md-6");
      attr(button0, "class", "btn btn-default xplay");
      attr(button1, "class", "btn btn-default xdel");
      attr(div3, "class", "col-md-3");
      attr(div4, "class", "row form-group m-2");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, div0);
      append(div0, input);
      append(div4, t0);
      append(div4, div2);
      if_block.m(div2, null);
      append(div4, t1);
      append(div4, div3);
      append(div3, button0);
      append(div3, t3);
      append(div3, button1);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[2]),
          listen(button0, "click", ctx[4]),
          listen(button1, "click", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input_value_value !== (input_value_value = ctx2[0].label) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div2, null);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div4);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function readFile$1(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = function(e) {
      resolve(e.target.result);
    };
    reader.readAsDataURL(file);
  });
}
function getDefaultName$1(path) {
  const parts = path.split(/(\/|\\)/);
  return parts.pop() || "New File";
}
function instance$5m($$self, $$props, $$invalidate) {
  let { tone } = $$props;
  let { id: id2 } = $$props;
  const KVStore2 = serviceProxy.store.KVStore;
  const dispatch = createEventDispatcher();
  let audioSrc;
  let audioPlayer;
  function onDelete() {
    if (audioPlayer && !audioPlayer.paused) {
      audioPlayer.pause();
    }
    dispatch("delete", { id: id2 });
  }
  function updateLabel(e) {
    $$invalidate(0, tone.label = e.target.value, tone);
  }
  function onFileChange(e) {
    $$invalidate(0, tone.value = e.target.files[0], tone);
    if (!tone.label) {
      $$invalidate(0, tone.label = getDefaultName$1(e.target.value), tone);
    }
  }
  async function onPlay() {
    const file = tone.value;
    if (!file) {
      alert("Please select an audio file before playing it.");
      return;
    }
    if (!audioPlayer) {
      audioPlayer = new Audio();
    }
    if (tone.new) {
      audioSrc = await readFile$1(file);
    } else {
      try {
        let doc = await KVStore2.findOne(file);
        audioSrc = doc.value;
      } catch (e) {
        console.error("Error while playing saved file", e);
      }
    }
    audioPlayer.src = audioSrc;
    audioPlayer.load();
    audioPlayer.play();
  }
  $$self.$$set = ($$props2) => {
    if ("tone" in $$props2)
      $$invalidate(0, tone = $$props2.tone);
    if ("id" in $$props2)
      $$invalidate(5, id2 = $$props2.id);
  };
  return [tone, onDelete, updateLabel, onFileChange, onPlay, id2];
}
class ToneFile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5m, create_fragment$5x, safe_not_equal, { tone: 0, id: 5 });
  }
}
function create_default_slot$1H(ctx) {
  let input;
  let input_class_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "text" },
    {
      class: input_class_value = ctx[4]
    },
    ctx[2]
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign(input_data, input_levels[i2]);
  }
  return {
    c() {
      input = element("input");
      set_attributes(input, input_data);
      toggle_class(input, "is-invalid", ctx[6]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus)
        input.focus();
      if (!mounted) {
        dispose = [
          action_destroyer(ctx[5].call(null, input)),
          listen(input, "input", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        dirty & 16 && input_class_value !== (input_class_value = ctx2[4]) && { class: input_class_value },
        dirty & 4 && ctx2[2]
      ]));
      toggle_class(input, "is-invalid", ctx2[6]);
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$5w(ctx) {
  let fieldwrapper;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[0],
      inputClasses: ctx[1],
      class: "form-control input-group p-0",
      $$slots: {
        default: [
          create_default_slot$1H,
          ({ inputClasses: wrapperInputClasses, action, showError }) => ({
            4: wrapperInputClasses,
            5: action,
            6: showError
          }),
          ({ inputClasses: wrapperInputClasses, action, showError }) => (wrapperInputClasses ? 16 : 0) | (action ? 32 : 0) | (showError ? 64 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(fieldwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fieldwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 1)
        fieldwrapper_changes.field = ctx2[0];
      if (dirty & 2)
        fieldwrapper_changes.inputClasses = ctx2[1];
      if (dirty & 212) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldwrapper, detaching);
    }
  };
}
function instance$5l($$self, $$props, $$invalidate) {
  const omit_props_names = ["field", "inputClasses"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { field } = $$props;
  let { inputClasses = "" } = $$props;
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("field" in $$new_props)
      $$invalidate(0, field = $$new_props.field);
    if ("inputClasses" in $$new_props)
      $$invalidate(1, inputClasses = $$new_props.inputClasses);
  };
  return [field, inputClasses, $$restProps, input_handler];
}
class UrlEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5l, create_fragment$5w, safe_not_equal, { field: 0, inputClasses: 1 });
  }
}
function create_fragment$5v(ctx) {
  let div5;
  let div1;
  let div0;
  let input;
  let input_value_value;
  let t0;
  let div3;
  let div2;
  let urledit;
  let t1;
  let div4;
  let button0;
  let t3;
  let button1;
  let current;
  let mounted;
  let dispose;
  urledit = new UrlEdit({ props: { field: ctx[1] } });
  return {
    c() {
      div5 = element("div");
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(urledit.$$.fragment);
      t1 = space();
      div4 = element("div");
      button0 = element("button");
      button0.textContent = "Play";
      t3 = space();
      button1 = element("button");
      button1.innerHTML = `<i class="fa fa-times"></i>`;
      input.value = input_value_value = ctx[0].label;
      attr(input, "placeholder", "Name");
      attr(input, "type", "text");
      attr(input, "class", "form-control xform-control-sm inline");
      attr(div0, "class", "xtext xeditor control-group");
      attr(div1, "class", "col-md-3");
      attr(div2, "class", "xurl flex items-stretch xeditor control-group");
      attr(div3, "class", "col-md-6");
      attr(button0, "class", "btn btn-default xplay");
      attr(button1, "class", "btn btn-default xdel");
      attr(div4, "class", "col-md-3");
      attr(div5, "class", "row form-group");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div1);
      append(div1, div0);
      append(div0, input);
      append(div5, t0);
      append(div5, div3);
      append(div3, div2);
      mount_component(urledit, div2, null);
      append(div5, t1);
      append(div5, div4);
      append(div4, button0);
      append(div4, t3);
      append(div4, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[4]),
          listen(button0, "click", ctx[2]),
          listen(button1, "click", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1 && input_value_value !== (input_value_value = ctx2[0].label) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(urledit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urledit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(urledit);
      mounted = false;
      run_all(dispose);
    }
  };
}
function getDefaultName(path) {
  const parts = path.split(/(\/|\\)/);
  return parts.pop() || "New URL";
}
function instance$5k($$self, $$props, $$invalidate) {
  let $url;
  let { id: id2 } = $$props;
  let { tone } = $$props;
  const dispatch = createEventDispatcher();
  const url = createFieldStore({ type: "url" }, tone.value);
  component_subscribe($$self, url, (value) => $$invalidate(6, $url = value));
  let audioPlayer;
  async function onPlay() {
    if (!audioPlayer) {
      audioPlayer = new Audio();
    }
    audioPlayer.src = $url;
    audioPlayer.load();
    audioPlayer.play();
  }
  function onDelete() {
    if (audioPlayer && !audioPlayer.paused) {
      audioPlayer.pause();
    }
    dispatch("delete", { id: id2 });
  }
  function updateLabel(e) {
    $$invalidate(0, tone.label = e.target.value, tone);
  }
  function onUrlChange() {
    $$invalidate(0, tone.value = $url, tone);
    if (!tone.label) {
      $$invalidate(0, tone.label = getDefaultName(url.toJSON()), tone);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(5, id2 = $$props2.id);
    if ("tone" in $$props2)
      $$invalidate(0, tone = $$props2.tone);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      if ($url) {
        onUrlChange();
      }
    }
  };
  return [tone, url, onPlay, onDelete, updateLabel, id2, $url];
}
class ToneUrl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5k, create_fragment$5v, safe_not_equal, { id: 5, tone: 0 });
  }
}
function get_each_context$1q(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[13] = i2;
  return child_ctx;
}
function create_catch_block$J(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$J(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1q(get_each_context$1q(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 33) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1q(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1q(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_else_block$1C(ctx) {
  let toneurl;
  let current;
  toneurl = new ToneUrl({
    props: {
      id: ctx[13],
      tone: ctx[11]
    }
  });
  toneurl.$on("delete", ctx[5]);
  return {
    c() {
      create_component(toneurl.$$.fragment);
    },
    m(target, anchor) {
      mount_component(toneurl, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toneurl_changes = {};
      if (dirty & 1)
        toneurl_changes.tone = ctx2[11];
      toneurl.$set(toneurl_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toneurl.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toneurl.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toneurl, detaching);
    }
  };
}
function create_if_block$35(ctx) {
  let tonefile;
  let current;
  tonefile = new ToneFile({
    props: {
      id: ctx[13],
      tone: ctx[11]
    }
  });
  tonefile.$on("delete", ctx[5]);
  return {
    c() {
      create_component(tonefile.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tonefile, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tonefile_changes = {};
      if (dirty & 1)
        tonefile_changes.tone = ctx2[11];
      tonefile.$set(tonefile_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tonefile.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tonefile.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tonefile, detaching);
    }
  };
}
function create_each_block$1q(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$35, create_else_block$1C];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[11].type === "file")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_pending_block$J(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_fragment$5u(ctx) {
  let div3;
  let header;
  let h3;
  let t1;
  let div0;
  let button0;
  let t3;
  let button1;
  let t5;
  let t6;
  let div1;
  let t7;
  let div2;
  let button2;
  let current;
  let mounted;
  let dispose;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$J,
    then: create_then_block$J,
    catch: create_catch_block$J,
    value: 10,
    blocks: [, , ,]
  };
  handle_promise(ctx[1], info);
  return {
    c() {
      div3 = element("div");
      header = element("header");
      h3 = element("h3");
      h3.textContent = "Tones";
      t1 = space();
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Add file";
      t3 = space();
      button1 = element("button");
      button1.textContent = "Add url";
      t5 = space();
      info.block.c();
      t6 = space();
      div1 = element("div");
      t7 = space();
      div2 = element("div");
      button2 = element("button");
      button2.textContent = "Save";
      attr(h3, "class", "pull-left");
      attr(button0, "class", "btn btn-default btn-sm");
      attr(button1, "class", "btn btn-default btn-sm");
      attr(div0, "class", "right");
      attr(header, "class", "card-header clearfix");
      attr(div1, "class", "card-body");
      attr(button2, "class", "btn btn-primary");
      attr(div2, "class", "card-footer");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, header);
      append(header, h3);
      append(header, t1);
      append(header, div0);
      append(div0, button0);
      append(div0, t3);
      append(div0, button1);
      append(div3, t5);
      info.block.m(div3, info.anchor = null);
      info.mount = () => div3;
      info.anchor = t6;
      append(div3, t6);
      append(div3, div1);
      append(div3, t7);
      append(div3, div2);
      append(div2, button2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[2]),
          listen(button1, "click", ctx[3]),
          listen(button2, "click", ctx[4])
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      info.block.d();
      info.token = null;
      info = null;
      mounted = false;
      run_all(dispose);
    }
  };
}
function readFile(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = function(e) {
      resolve(e.target.result);
    };
    reader.readAsDataURL(file);
  });
}
async function sha1(dataURI) {
  let encoder = new TextEncoder();
  let hashBuf = await crypto.subtle.digest("SHA-1", encoder.encode(dataURI));
  let hashArrBuf = Array.from(new Uint8Array(hashBuf));
  let hashHex = hashArrBuf.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
function instance$5j($$self, $$props, $$invalidate) {
  const KVStore2 = serviceProxy.store.KVStore;
  const DEFAULTS = {
    FILE: {
      type: "file",
      value: "",
      label: "",
      new: true
    },
    URL: { type: "url", value: "", label: "" }
  };
  let tones = [];
  let removedTones = [];
  let loadPromise = loadTones();
  function addFileInput() {
    $$invalidate(0, tones = [...tones, structuredClone(DEFAULTS.FILE)]);
  }
  function addURLInput() {
    $$invalidate(0, tones = [...tones, structuredClone(DEFAULTS.URL)]);
  }
  async function saveTones() {
    Msg.start("save", "l_loading");
    for (let tone of tones) {
      if (tone.type === "file" && tone.new) {
        let dataURI = await readFile(tone.value);
        const id2 = "tone:" + await sha1(dataURI);
        await KVStore2.create({ id: id2, value: dataURI });
        tone.value = id2;
        delete tone.new;
      }
    }
    const saveTones2 = tones.filter((tone) => tone.value);
    const value = JSON.stringify(saveTones2);
    let res = await KVStore2.update("tones", { value });
    if (res._count === 0) {
      await KVStore2.create({ id: "tones", value });
    }
    if (removedTones.length) {
      const removedFiles = removedTones.filter((tone) => tone.type === "file" && !tone.new).map((file) => file.value);
      for (let file of removedFiles) {
        await KVStore2.destroy(file);
      }
      removedTones = [];
    }
    Msg.reset();
    await loadTones();
  }
  function onDelete(e) {
    let delIdx = e.detail.id;
    removedTones.push(tones[delIdx]);
    $$invalidate(0, tones = tones.filter((_2, index2) => index2 !== delIdx));
  }
  async function loadTones() {
    let doc = await KVStore2.findOne("tones");
    if (doc) {
      $$invalidate(0, tones = JSON.parse(doc.value));
    }
  }
  return [tones, loadPromise, addFileInput, addURLInput, saveTones, onDelete];
}
class Tones extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5j, create_fragment$5u, safe_not_equal, {});
  }
}
function create_default_slot_1$t(ctx) {
  let t_value = TXT("l_action_local_popup") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$1G(ctx) {
  let t_value = TXT("l_action_local_audio") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$5t(ctx) {
  let div7;
  let div6;
  let header;
  let h3;
  let t1;
  let div5;
  let div4;
  let div0;
  let checkbox0;
  let t2;
  let div1;
  let checkbox1;
  let t3;
  let div2;
  let span;
  let t8;
  let menu;
  let updating_id;
  let t9;
  let div3;
  let a;
  let t10;
  let t11;
  let tones;
  let current;
  checkbox0 = new Checkbox({
    props: {
      field: ctx[2].fields.popup,
      $$slots: { default: [create_default_slot_1$t] },
      $$scope: { ctx }
    }
  });
  checkbox1 = new Checkbox({
    props: {
      field: ctx[2].fields.audio,
      $$slots: { default: [create_default_slot$1G] },
      $$scope: { ctx }
    }
  });
  function menu_id_binding(value) {
    ctx[4](value);
  }
  let menu_props = {
    actionClass: "btn btn-default btn-sm",
    allowNull: false,
    items: ctx[1].autohide.options
  };
  if (ctx[0] !== void 0) {
    menu_props.id = ctx[0];
  }
  menu = new Menu({ props: menu_props });
  binding_callbacks.push(() => bind$1(menu, "id", menu_id_binding));
  tones = new Tones({});
  return {
    c() {
      div7 = element("div");
      div6 = element("div");
      header = element("header");
      h3 = element("h3");
      h3.textContent = `${TXT("l_actions")}`;
      t1 = space();
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      create_component(checkbox0.$$.fragment);
      t2 = space();
      div1 = element("div");
      create_component(checkbox1.$$.fragment);
      t3 = space();
      div2 = element("div");
      span = element("span");
      span.textContent = `${TXT("m_firefox_only")} - ${TXT("m_autohide_popup")}:\xA0`;
      t8 = space();
      create_component(menu.$$.fragment);
      t9 = space();
      div3 = element("div");
      a = element("a");
      t10 = text("Change email action settings from web app!");
      t11 = space();
      create_component(tones.$$.fragment);
      attr(header, "class", "card-header");
      attr(div0, "class", "d-flex align-items-center gap-2");
      attr(div1, "class", "d-flex align-items-center gap-2");
      attr(div2, "class", "d-flex align-items-center gap-2");
      attr(a, "href", urlCfg.app + "/#/settings/actions");
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener");
      attr(div3, "class", "alert alert-info");
      attr(div4, "class", "d-flex flex-column gap-1");
      attr(div5, "class", "card-body");
      attr(div6, "class", "card panel-default");
      attr(div7, "class", "d-flex flex-column gap-3");
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div6);
      append(div6, header);
      append(header, h3);
      append(div6, t1);
      append(div6, div5);
      append(div5, div4);
      append(div4, div0);
      mount_component(checkbox0, div0, null);
      append(div4, t2);
      append(div4, div1);
      mount_component(checkbox1, div1, null);
      append(div4, t3);
      append(div4, div2);
      append(div2, span);
      append(div2, t8);
      mount_component(menu, div2, null);
      append(div4, t9);
      append(div4, div3);
      append(div3, a);
      append(a, t10);
      append(div7, t11);
      mount_component(tones, div7, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkbox0_changes = {};
      if (dirty & 256) {
        checkbox0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox0.$set(checkbox0_changes);
      const checkbox1_changes = {};
      if (dirty & 256) {
        checkbox1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox1.$set(checkbox1_changes);
      const menu_changes = {};
      if (!updating_id && dirty & 1) {
        updating_id = true;
        menu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox0.$$.fragment, local);
      transition_in(checkbox1.$$.fragment, local);
      transition_in(menu.$$.fragment, local);
      transition_in(tones.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkbox0.$$.fragment, local);
      transition_out(checkbox1.$$.fragment, local);
      transition_out(menu.$$.fragment, local);
      transition_out(tones.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div7);
      destroy_component(checkbox0);
      destroy_component(checkbox1);
      destroy_component(menu);
      destroy_component(tones);
    }
  };
}
function instance$5i($$self, $$props, $$invalidate) {
  let $autohideField;
  const commonActionsDef = {
    popup: {
      pref_id: "actions.popup",
      required: false,
      type: "boolean",
      default: false
    },
    audio: {
      pref_id: "actions.audio",
      required: false,
      type: "boolean",
      default: false
    },
    autohide: {
      pref_id: "actions.popup.autohide",
      required: false,
      type: "enum",
      multi: false,
      options: [0, 5, 10, 20, 60, 120, 300].map((v) => {
        const option = {};
        if (!v) {
          option.name = "never";
        } else if (v < 60) {
          option.name = `${v}s`;
        } else if (v >= 60 && v <= 3600) {
          option.name = `${v / 60}m`;
        } else {
          option.name = `${v / 3600}h`;
        }
        option.id = v;
        return option;
      })
    }
  };
  const commonActionsModel = new FormModel(commonActionsDef);
  const autohideField = commonActionsModel.fields.autohide;
  component_subscribe($$self, autohideField, (value) => $$invalidate(0, $autohideField = value));
  const errorActionsDef = {
    trigger: {
      pref_id: "errorAction.enabled",
      required: false,
      type: "boolean",
      default: false
    },
    sound: {
      pref_id: "errorAction.sound",
      required: false,
      type: "enum",
      multi: false,
      options: [
        {
          id: "/skin/media/bell_strike.ogg",
          name: TXT("l_bell_strike")
        },
        {
          id: "/skin/media/asian_koel.ogg",
          name: TXT("l_asian_koel")
        },
        {
          id: "/skin/media/ding_dong.ogg",
          name: TXT("l_ding_dong")
        },
        {
          id: "/skin/media/buzzer.ogg",
          name: TXT("l_buzzer")
        }
      ]
    },
    interval: {
      pref_id: "errorAction.interval",
      required: false,
      type: "int",
      default: 15
    },
    count: {
      pref_id: "errorAction.minCount",
      required: false,
      type: "int",
      default: 5
    }
  };
  const errorActionsModel = new FormModel(errorActionsDef);
  errorActionsModel.fields.sound;
  onMount(async () => {
    const init2 = async (formDef, formModel) => {
      for (let key in formDef) {
        const pref = await serviceProxy.store.Prefs.get(formDef[key].pref_id);
        formModel.fields[key].set(pref);
        formModel.fields[key].subscribe((change) => {
          serviceProxy.store.Prefs.set(formDef[key].pref_id, change);
        });
      }
    };
    await init2(commonActionsDef, commonActionsModel);
    await init2(errorActionsDef, errorActionsModel);
  });
  function menu_id_binding(value) {
    $autohideField = value;
    autohideField.set($autohideField);
  }
  return [
    $autohideField,
    commonActionsDef,
    commonActionsModel,
    autohideField,
    menu_id_binding
  ];
}
class ActionsExt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5i, create_fragment$5t, safe_not_equal, {});
  }
}
function verifyRangedInt(value, def) {
  const min2 = def.range[0];
  const max2 = def.range[1];
  if (value < min2 || value > max2) {
    return `Must be between ${min2} and ${max2}`;
  }
}
function verifyTime(value) {
  if (!/^([01]\d|2[0-3]):([0-5]\d)$/.test(value)) {
    return "Invalid time";
  }
}
class RangedInt extends TYPES.int {
}
__publicField(RangedInt, "validators", [verifyRangedInt]);
class time extends TYPES.base {
}
__publicField(time, "validators", [verifyTime]);
function create_default_slot$1F(ctx) {
  let input;
  let input_class_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "time" },
    {
      class: input_class_value = ctx[5]
    },
    ctx[3]
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign(input_data, input_levels[i2]);
  }
  return {
    c() {
      input = element("input");
      set_attributes(input, input_data);
      toggle_class(input, "is-invalid", ctx[7]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus)
        input.focus();
      if (!mounted) {
        dispose = [
          action_destroyer(ctx[6].call(null, input)),
          listen(input, "input", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "time" },
        dirty & 32 && input_class_value !== (input_class_value = ctx2[5]) && { class: input_class_value },
        dirty & 8 && ctx2[3]
      ]));
      toggle_class(input, "is-invalid", ctx2[7]);
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$34(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element("p");
      t = text(ctx[2]);
      attr(p, "class", "help");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_fragment$5s(ctx) {
  let fieldwrapper;
  let t;
  let if_block_anchor;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[0],
      inputClasses: ctx[1],
      $$slots: {
        default: [
          create_default_slot$1F,
          ({ inputClasses: wrapperInputClasses, action, showError }) => ({
            5: wrapperInputClasses,
            6: action,
            7: showError
          }),
          ({ inputClasses: wrapperInputClasses, action, showError }) => (wrapperInputClasses ? 32 : 0) | (action ? 64 : 0) | (showError ? 128 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = !!ctx[2] && create_if_block$34(ctx);
  return {
    c() {
      create_component(fieldwrapper.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(fieldwrapper, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 1)
        fieldwrapper_changes.field = ctx2[0];
      if (dirty & 2)
        fieldwrapper_changes.inputClasses = ctx2[1];
      if (dirty & 424) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
      if (!!ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$34(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldwrapper, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$5h($$self, $$props, $$invalidate) {
  const omit_props_names = ["field", "inputClasses", "help"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { field } = $$props;
  let { inputClasses = "" } = $$props;
  let { help = "" } = $$props;
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("field" in $$new_props)
      $$invalidate(0, field = $$new_props.field);
    if ("inputClasses" in $$new_props)
      $$invalidate(1, inputClasses = $$new_props.inputClasses);
    if ("help" in $$new_props)
      $$invalidate(2, help = $$new_props.help);
  };
  return [field, inputClasses, help, $$restProps, input_handler];
}
class TimeEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5h, create_fragment$5s, safe_not_equal, { field: 0, inputClasses: 1, help: 2 });
  }
}
function create_label_slot$4(ctx) {
  let div;
  let t_value = (ctx[0].length > 0 ? ctx[0].map(ctx[2]).join(",") : "None") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "truncate mw5-m mr1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = (ctx2[0].length > 0 ? ctx2[0].map(ctx2[2]).join(",") : "None") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$5r(ctx) {
  let multiselectmenu;
  let updating_items;
  let updating_ids;
  let current;
  function multiselectmenu_items_binding(value) {
    ctx[4](value);
  }
  function multiselectmenu_ids_binding(value) {
    ctx[5](value);
  }
  let multiselectmenu_props = {
    $$slots: { label: [create_label_slot$4] },
    $$scope: { ctx }
  };
  if (ctx[1].fields !== void 0) {
    multiselectmenu_props.items = ctx[1].fields;
  }
  if (ctx[0] !== void 0) {
    multiselectmenu_props.ids = ctx[0];
  }
  multiselectmenu = new MultiSelectMenu({ props: multiselectmenu_props });
  binding_callbacks.push(() => bind$1(multiselectmenu, "items", multiselectmenu_items_binding));
  binding_callbacks.push(() => bind$1(multiselectmenu, "ids", multiselectmenu_ids_binding));
  multiselectmenu.$on("change", ctx[6]);
  return {
    c() {
      create_component(multiselectmenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(multiselectmenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const multiselectmenu_changes = {};
      if (dirty & 513) {
        multiselectmenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_items && dirty & 2) {
        updating_items = true;
        multiselectmenu_changes.items = ctx2[1].fields;
        add_flush_callback(() => updating_items = false);
      }
      if (!updating_ids && dirty & 1) {
        updating_ids = true;
        multiselectmenu_changes.ids = ctx2[0];
        add_flush_callback(() => updating_ids = false);
      }
      multiselectmenu.$set(multiselectmenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(multiselectmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(multiselectmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(multiselectmenu, detaching);
    }
  };
}
function instance$5g($$self, $$props, $$invalidate) {
  createEventDispatcher();
  class SelectableList extends FieldList {
    constructor(values2) {
      super({ type: "json" }, values2);
    }
  }
  let { items } = $$props;
  let { ids = [] } = $$props;
  let listItems = new SelectableList(items);
  function getLabel(id2) {
    const item = items.find((item2) => item2.id == id2);
    return item ? item.label || item.name : "NA";
  }
  function multiselectmenu_items_binding(value) {
    if ($$self.$$.not_equal(listItems.fields, value)) {
      listItems.fields = value;
      $$invalidate(1, listItems);
    }
  }
  function multiselectmenu_ids_binding(value) {
    ids = value;
    $$invalidate(0, ids);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(3, items = $$props2.items);
    if ("ids" in $$props2)
      $$invalidate(0, ids = $$props2.ids);
  };
  return [
    ids,
    listItems,
    getLabel,
    items,
    multiselectmenu_items_binding,
    multiselectmenu_ids_binding,
    change_handler
  ];
}
class SelectableMenuWrapper extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5g, create_fragment$5r, safe_not_equal, { items: 3, ids: 0 });
  }
}
function get_each_context_2$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2].id;
  child_ctx[12] = list[i2].label;
  return child_ctx;
}
function get_each_context_1$f(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2].id;
  child_ctx[12] = list[i2].label;
  return child_ctx;
}
function get_each_context$1p(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2].id;
  child_ctx[12] = list[i2].label;
  return child_ctx;
}
function create_else_block_1$l(ctx) {
  let each_1_anchor;
  let each_value_2 = ctx[0].options;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 9) {
        each_value_2 = ctx2[0].options;
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$3(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_2$3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_2$1b(ctx) {
  let select2;
  let mounted;
  let dispose;
  let each_value_1 = ctx[0].options;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$f(get_each_context_1$f(ctx, each_value_1, i2));
  }
  return {
    c() {
      select2 = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(select2, "name", "module");
      attr(select2, "id", "module");
      attr(select2, "class", "form-select");
      select2.disabled = ctx[2];
    },
    m(target, anchor) {
      insert(target, select2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      if (!mounted) {
        dispose = listen(select2, "change", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 9) {
        each_value_1 = ctx2[0].options;
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$f(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$f(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & 4) {
        select2.disabled = ctx2[2];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(select2);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$33(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$1T, create_else_block$1B];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[0].dropdown)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_each_block_2$3(ctx) {
  let div;
  let label;
  let input;
  let input_id_value;
  let input_name_value;
  let input_value_value;
  let value_has_changed = false;
  let t0;
  let t1_value = ctx[12] + "";
  let t1;
  let label_for_value;
  let t2;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(ctx[8][0]);
  return {
    c() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "radio");
      attr(input, "id", input_id_value = ctx[11]);
      attr(input, "name", input_name_value = ctx[0].name);
      input.__value = input_value_value = ctx[11];
      input.value = input.__value;
      attr(label, "class", "font-normal");
      attr(label, "for", label_for_value = ctx[11]);
      attr(div, "class", "flex items-center");
      binding_group.p(input);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, input);
      input.checked = input.__value === ctx[3];
      append(label, t0);
      append(label, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(input, "change", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input_id_value !== (input_id_value = ctx2[11])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & 1 && input_name_value !== (input_name_value = ctx2[0].name)) {
        attr(input, "name", input_name_value);
      }
      if (dirty & 1 && input_value_value !== (input_value_value = ctx2[11])) {
        input.__value = input_value_value;
        input.value = input.__value;
        value_has_changed = true;
      }
      if (value_has_changed || dirty & 9) {
        input.checked = input.__value === ctx2[3];
      }
      if (dirty & 1 && t1_value !== (t1_value = ctx2[12] + ""))
        set_data(t1, t1_value);
      if (dirty & 1 && label_for_value !== (label_for_value = ctx2[11])) {
        attr(label, "for", label_for_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      binding_group.r();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1$f(ctx) {
  let option;
  let t_value = ctx[12] + "";
  let t;
  let option_id_value;
  let option_value_value;
  let option_selected_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      attr(option, "id", option_id_value = ctx[11]);
      option.__value = option_value_value = ctx[11];
      option.value = option.__value;
      option.selected = option_selected_value = ctx[3].includes(ctx[11]);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[12] + ""))
        set_data(t, t_value);
      if (dirty & 1 && option_id_value !== (option_id_value = ctx2[11])) {
        attr(option, "id", option_id_value);
      }
      if (dirty & 1 && option_value_value !== (option_value_value = ctx2[11])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
      if (dirty & 9 && option_selected_value !== (option_selected_value = ctx2[3].includes(ctx2[11]))) {
        option.selected = option_selected_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_else_block$1B(ctx) {
  let each_1_anchor;
  let each_value = ctx[0].options;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1p(get_each_context$1p(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 13) {
        each_value = ctx2[0].options;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1p(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$1p(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$1T(ctx) {
  let selectablemenuwrapper;
  let current;
  const selectablemenuwrapper_spread_levels = [{ items: ctx[0].options }, ctx[5]];
  let selectablemenuwrapper_props = {};
  for (let i2 = 0; i2 < selectablemenuwrapper_spread_levels.length; i2 += 1) {
    selectablemenuwrapper_props = assign(selectablemenuwrapper_props, selectablemenuwrapper_spread_levels[i2]);
  }
  selectablemenuwrapper = new SelectableMenuWrapper({ props: selectablemenuwrapper_props });
  selectablemenuwrapper.$on("change", ctx[6]);
  return {
    c() {
      create_component(selectablemenuwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectablemenuwrapper, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectablemenuwrapper_changes = dirty & 33 ? get_spread_update(selectablemenuwrapper_spread_levels, [
        dirty & 1 && { items: ctx2[0].options },
        dirty & 32 && get_spread_object(ctx2[5])
      ]) : {};
      selectablemenuwrapper.$set(selectablemenuwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectablemenuwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectablemenuwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectablemenuwrapper, detaching);
    }
  };
}
function create_each_block$1p(ctx) {
  let div;
  let label;
  let input;
  let input_name_value;
  let input_value_value;
  let value_has_changed = false;
  let input_id_value;
  let t0;
  let t1_value = ctx[12] + "";
  let t1;
  let label_for_value;
  let t2;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(ctx[8][0]);
  return {
    c() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "checkbox");
      attr(input, "name", input_name_value = ctx[0].name);
      input.__value = input_value_value = ctx[11];
      input.value = input.__value;
      attr(input, "id", input_id_value = ctx[11]);
      input.disabled = ctx[2];
      attr(label, "class", "font-normal");
      attr(label, "for", label_for_value = ctx[11]);
      attr(div, "class", "flex");
      binding_group.p(input);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, input);
      input.checked = ~(ctx[3] || []).indexOf(input.__value);
      append(label, t0);
      append(label, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(input, "change", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input_name_value !== (input_name_value = ctx2[0].name)) {
        attr(input, "name", input_name_value);
      }
      if (dirty & 1 && input_value_value !== (input_value_value = ctx2[11])) {
        input.__value = input_value_value;
        input.value = input.__value;
        value_has_changed = true;
      }
      if (dirty & 1 && input_id_value !== (input_id_value = ctx2[11])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & 4) {
        input.disabled = ctx2[2];
      }
      if (value_has_changed || dirty & 9) {
        input.checked = ~(ctx2[3] || []).indexOf(input.__value);
      }
      if (dirty & 1 && t1_value !== (t1_value = ctx2[12] + ""))
        set_data(t1, t1_value);
      if (dirty & 1 && label_for_value !== (label_for_value = ctx2[11])) {
        attr(label, "for", label_for_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      binding_group.r();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5q(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$33, create_if_block_2$1b, create_else_block_1$l];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].multi)
      return 0;
    if (ctx2[0].dropdown)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$5f($$self, $$props, $$invalidate) {
  const omit_props_names = ["def", "field", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $field, $$unsubscribe_field = noop$1, $$subscribe_field = () => ($$unsubscribe_field(), $$unsubscribe_field = subscribe(field, ($$value) => $$invalidate(3, $field = $$value)), field);
  $$self.$$.on_destroy.push(() => $$unsubscribe_field());
  let { def } = $$props;
  let { field } = $$props;
  $$subscribe_field();
  let { disabled = false } = $$props;
  function setEnum(value) {
    field.set(value);
  }
  const $$binding_groups = [[]];
  const change_handler = (e) => setEnum(e.detail);
  function input_change_handler() {
    $field = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
    field.set($field);
  }
  const change_handler_1 = (e) => setEnum(e.target.value);
  function input_change_handler_1() {
    $field = this.__value;
    field.set($field);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("def" in $$new_props)
      $$invalidate(0, def = $$new_props.def);
    if ("field" in $$new_props)
      $$subscribe_field($$invalidate(1, field = $$new_props.field));
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
  };
  return [
    def,
    field,
    disabled,
    $field,
    setEnum,
    $$restProps,
    change_handler,
    input_change_handler,
    $$binding_groups,
    change_handler_1,
    input_change_handler_1
  ];
}
class EnumGroup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5f, create_fragment$5q, safe_not_equal, { def: 0, field: 1, disabled: 2 });
  }
}
function create_if_block_2$1a(ctx) {
  let div0;
  let span0;
  let t2;
  let menu;
  let updating_id;
  let t3;
  let div2;
  let span1;
  let t6;
  let div1;
  let inputedit;
  let t7;
  let div3;
  let current;
  function menu_id_binding(value) {
    ctx[15](value);
  }
  let menu_props = {
    items: ctx[6].frameload.options,
    allowNull: false,
    actionClass: "btn btn-default"
  };
  if (ctx[2] !== void 0) {
    menu_props.id = ctx[2];
  }
  menu = new Menu({ props: menu_props });
  binding_callbacks.push(() => bind$1(menu, "id", menu_id_binding));
  inputedit = new InputEdit({
    props: {
      field: ctx[7].fields.timeout,
      inputClasses: "text-end w-50"
    }
  });
  return {
    c() {
      div0 = element("div");
      span0 = element("span");
      span0.textContent = `${TXT("m_load_page_options")}:\xA0`;
      t2 = space();
      create_component(menu.$$.fragment);
      t3 = space();
      div2 = element("div");
      span1 = element("span");
      span1.textContent = `${TXT("m_sticky_window_timeout")}:\xA0`;
      t6 = space();
      div1 = element("div");
      create_component(inputedit.$$.fragment);
      t7 = space();
      div3 = element("div");
      div3.textContent = `${TXT("m_sticky_window_warning")}`;
      attr(div0, "class", "d-flex align-items-center gap-2");
      attr(div1, "class", "d-inline-flex");
      attr(div2, "class", "d-flex align-items-center gap-2");
      attr(div3, "class", "alert alert-info");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, span0);
      append(div0, t2);
      mount_component(menu, div0, null);
      insert(target, t3, anchor);
      insert(target, div2, anchor);
      append(div2, span1);
      append(div2, t6);
      append(div2, div1);
      mount_component(inputedit, div1, null);
      insert(target, t7, anchor);
      insert(target, div3, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menu_changes = {};
      if (!updating_id && dirty & 4) {
        updating_id = true;
        menu_changes.id = ctx2[2];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(menu);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div2);
      destroy_component(inputedit);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(div3);
    }
  };
}
function create_else_block$1A(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${TXT("m_premium_only")}`;
      attr(div, "class", "alert alert-info");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$32(ctx) {
  let div1;
  let div0;
  let checkbox;
  let t;
  let current;
  checkbox = new Checkbox({
    props: {
      field: ctx[10].fields.enable,
      $$slots: { default: [create_default_slot$1E] },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[3] && create_if_block_1$1S(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(checkbox.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "d-flex align-items-center gap-2 mb-2");
      attr(div1, "class", "d-flex flex-column gap-1");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(checkbox, div0, null);
      append(div1, t);
      if (if_block)
        if_block.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const checkbox_changes = {};
      if (dirty & 131072) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$1S(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(checkbox);
      if (if_block)
        if_block.d();
    }
  };
}
function create_default_slot$1E(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${TXT("l_time_slots_enabled")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_1$1S(ctx) {
  var _a;
  let div5;
  let div1;
  let span0;
  let t2;
  let div0;
  let timeedit0;
  let t3;
  let div3;
  let span1;
  let t6;
  let div2;
  let timeedit1;
  let t7;
  let div4;
  let span2;
  let t10;
  let enumgroup;
  let current;
  timeedit0 = new TimeEdit({
    props: {
      field: ctx[10].fields.start
    }
  });
  timeedit1 = new TimeEdit({
    props: {
      field: ctx[10].fields.end
    }
  });
  enumgroup = new EnumGroup({
    props: {
      def: ctx[9].days,
      field: ctx[10].fields.days,
      ids: (_a = ctx[4]) != null ? _a : []
    }
  });
  return {
    c() {
      div5 = element("div");
      div1 = element("div");
      span0 = element("span");
      span0.textContent = `${TXT("l_time_slots_start")}:`;
      t2 = space();
      div0 = element("div");
      create_component(timeedit0.$$.fragment);
      t3 = space();
      div3 = element("div");
      span1 = element("span");
      span1.textContent = `${TXT("l_time_slots_end")}:`;
      t6 = space();
      div2 = element("div");
      create_component(timeedit1.$$.fragment);
      t7 = space();
      div4 = element("div");
      span2 = element("span");
      span2.textContent = `${TXT("l_time_slots_day")}:`;
      t10 = space();
      create_component(enumgroup.$$.fragment);
      attr(div0, "class", "d-inline-flex");
      attr(div1, "class", "d-flex align-items-center gap-2");
      attr(div2, "class", "d-inline-flex");
      attr(div3, "class", "d-flex align-items-center gap-2");
      attr(div4, "class", "d-flex align-items-center gap-2");
      attr(div5, "class", "d-flex gap-4");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div1);
      append(div1, span0);
      append(div1, t2);
      append(div1, div0);
      mount_component(timeedit0, div0, null);
      append(div5, t3);
      append(div5, div3);
      append(div3, span1);
      append(div3, t6);
      append(div3, div2);
      mount_component(timeedit1, div2, null);
      append(div5, t7);
      append(div5, div4);
      append(div4, span2);
      append(div4, t10);
      mount_component(enumgroup, div4, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const enumgroup_changes = {};
      if (dirty & 16)
        enumgroup_changes.ids = (_a2 = ctx2[4]) != null ? _a2 : [];
      enumgroup.$set(enumgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(timeedit0.$$.fragment, local);
      transition_in(timeedit1.$$.fragment, local);
      transition_in(enumgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(timeedit0.$$.fragment, local);
      transition_out(timeedit1.$$.fragment, local);
      transition_out(enumgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(timeedit0);
      destroy_component(timeedit1);
      destroy_component(enumgroup);
    }
  };
}
function create_fragment$5p(ctx) {
  let div7;
  let div4;
  let header0;
  let h30;
  let t1;
  let div3;
  let div2;
  let div1;
  let div0;
  let inputedit;
  let t2;
  let span;
  let t4;
  let t5;
  let switch_instance;
  let t6;
  let div6;
  let header1;
  let h31;
  let t8;
  let div5;
  let current_block_type_index;
  let if_block1;
  let current;
  inputedit = new InputEdit({
    props: {
      field: ctx[7].fields.workers
    }
  });
  let if_block0 = !ctx[13] && create_if_block_2$1a(ctx);
  var switch_value = ctx[1];
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  const if_block_creators = [create_if_block$32, create_else_block$1A];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[5].isFree())
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div7 = element("div");
      div4 = element("div");
      header0 = element("header");
      h30 = element("h3");
      h30.textContent = `${TXT("l_advanced")}`;
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(inputedit.$$.fragment);
      t2 = space();
      span = element("span");
      span.textContent = `${TXT("m_max_workers")}`;
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t6 = space();
      div6 = element("div");
      header1 = element("header");
      h31 = element("h3");
      h31.textContent = `${TXT("l_time_slots")}`;
      t8 = space();
      div5 = element("div");
      if_block1.c();
      attr(header0, "class", "card-header");
      attr(div0, "class", "d-inline-flex align-content-center w-[10%]");
      attr(div1, "class", "d-flex align-items-center gap-2");
      attr(div2, "class", "d-flex flex-column gap-1");
      attr(div3, "class", "card-body");
      attr(div4, "class", "card panel-default");
      attr(header1, "class", "card-header");
      attr(div5, "class", "card-body");
      attr(div6, "class", "card panel-default");
      attr(div7, "class", "d-flex flex-column gap-3");
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div4);
      append(div4, header0);
      append(header0, h30);
      append(div4, t1);
      append(div4, div3);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      mount_component(inputedit, div0, null);
      append(div1, t2);
      append(div1, span);
      append(div2, t4);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t5);
      if (switch_instance)
        mount_component(switch_instance, div2, null);
      append(div7, t6);
      append(div7, div6);
      append(div6, header1);
      append(header1, h31);
      append(div6, t8);
      append(div6, div5);
      if_blocks[current_block_type_index].m(div5, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!ctx2[13])
        if_block0.p(ctx2, dirty);
      if (dirty & 2 && switch_value !== (switch_value = ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div2, null);
        } else {
          switch_instance = null;
        }
      }
      if_block1.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      transition_in(if_block0);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      transition_out(if_block0);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div7);
      destroy_component(inputedit);
      if (if_block0)
        if_block0.d();
      if (switch_instance)
        destroy_component(switch_instance);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$5e($$self, $$props, $$invalidate) {
  let $derivedStore, $$unsubscribe_derivedStore = noop$1, $$subscribe_derivedStore = () => ($$unsubscribe_derivedStore(), $$unsubscribe_derivedStore = subscribe(derivedStore, ($$value) => $$invalidate(14, $derivedStore = $$value)), derivedStore);
  let $frameloadField;
  let $timeSlotsEnabled;
  let $daysField;
  $$self.$$.on_destroy.push(() => $$unsubscribe_derivedStore());
  if (!TYPES["ranged:int"]) {
    register("ranged:int", RangedInt);
  }
  if (!TYPES["time"]) {
    register("time", time);
  }
  const user = getContext("user");
  const advancedActionsDef = {
    workers: {
      pref_id: "nworkers",
      required: false,
      type: "ranged:int",
      range: [1, 10]
    },
    frameload: {
      pref_id: "x-frame-load-in",
      required: false,
      type: "enum",
      multi: false,
      options: [
        { id: "tab", name: TXT("l_opt_bgtab") },
        {
          id: "window",
          name: TXT("l_opt_bgwindow")
        },
        { id: "bg", name: TXT("l_opt_force_bg") },
        {
          id: "sticky_window",
          name: TXT("l_opt_sticky_window")
        }
      ]
    },
    timeout: {
      pref_id: "sticky-window-timeout",
      required: false,
      type: "ranged:int",
      range: [1, 1e4]
    }
  };
  const advancedActionsModel = new FormModel(advancedActionsDef);
  const frameloadField = advancedActionsModel.fields.frameload;
  component_subscribe($$self, frameloadField, (value) => $$invalidate(2, $frameloadField = value));
  const timeSlotsDef = {
    enable: {
      pref_id: "sieve-slot.enabled",
      required: false,
      type: "boolean"
    },
    start: {
      pref_id: "sieve-slot.start",
      required: false,
      type: "time"
    },
    end: {
      pref_id: "sieve-slot.end",
      required: false,
      type: "time"
    },
    days: {
      pref_id: "time-slot-map",
      required: false,
      type: "enum",
      multi: true,
      dropdown: true,
      options: [
        { id: 1, name: TXT("l_monday") },
        { id: 2, name: TXT("l_tuesday") },
        { id: 3, name: TXT("l_wednesday") },
        { id: 4, name: TXT("l_thursday") },
        { id: 5, name: TXT("l_friday") },
        { id: 6, name: TXT("l_saturday") },
        { id: 0, name: TXT("l_sunday") }
      ]
    }
  };
  const timeSlotsModel = new FormModel(timeSlotsDef);
  const daysField = timeSlotsModel.fields.days;
  component_subscribe($$self, daysField, (value) => $$invalidate(4, $daysField = value));
  const timeSlotsEnabled = timeSlotsModel.fields.enable;
  component_subscribe($$self, timeSlotsEnabled, (value) => $$invalidate(3, $timeSlotsEnabled = value));
  const isElectron = serviceProxy.CFG.CLIENT.TYPE === C$1.CLIENT_ELECTRON;
  let derivedStore;
  let ElectronSettings;
  onMount(async () => {
    if (isElectron) {
      $$invalidate(1, ElectronSettings = (await __vitePreload(() => import("./ElectronSettings.6ab40986.js"), true ? ["assets/ElectronSettings.6ab40986.js","assets/index.21aef151.js","assets/json-parser.7cb2f04e.js","assets/json-parser.f1628d7e.css","assets/service.04a32097.js","assets/Message.fcbba7db.js","assets/SchemaKeyTree.96209fd8.js","assets/SchemaKeyTree.9a96e0c5.css","assets/Card.0607fce4.js"] : void 0)).default);
    }
    const init2 = async (formDef, formModel) => {
      for (let key in formDef) {
        let pref2 = await serviceProxy.store.Prefs.get(formDef[key].pref_id);
        formModel.fields[key].set(pref2);
        formModel.fields[key].subscribe((change) => {
          serviceProxy.store.Prefs.set(formDef[key].pref_id, change);
        });
      }
    };
    await init2(advancedActionsDef, advancedActionsModel);
    await init2(_.omit(timeSlotsDef, "days"), timeSlotsModel);
    let pref = await serviceProxy.store.Prefs.get(timeSlotsDef.days.pref_id);
    pref = Object.keys(pref).map((id2) => parseInt(id2));
    daysField.set(pref);
    $$subscribe_derivedStore($$invalidate(0, derivedStore = derived(Object.values(_.pick(timeSlotsModel.fields, "start", "end", "days")), (...a) => a)));
  });
  function updateTimeSlotMap() {
    var _a;
    const value = (_a = timeSlotsModel.fields.days.get()) == null ? void 0 : _a.reduce(
      (acc, id2) => {
        acc[id2] = [
          {
            start: timeSlotsModel.fields.start.get(),
            end: timeSlotsModel.fields.end.get()
          }
        ];
        return acc;
      },
      {}
    );
    serviceProxy.store.Prefs.set(timeSlotsDef.days.pref_id, value);
  }
  function menu_id_binding(value) {
    $frameloadField = value;
    frameloadField.set($frameloadField);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16385) {
      if (derivedStore && $derivedStore) {
        updateTimeSlotMap();
      }
    }
  };
  return [
    derivedStore,
    ElectronSettings,
    $frameloadField,
    $timeSlotsEnabled,
    $daysField,
    user,
    advancedActionsDef,
    advancedActionsModel,
    frameloadField,
    timeSlotsDef,
    timeSlotsModel,
    daysField,
    timeSlotsEnabled,
    isElectron,
    $derivedStore,
    menu_id_binding
  ];
}
class AdvancedExt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5e, create_fragment$5p, safe_not_equal, {});
  }
}
var ConfirmBtn_svelte_svelte_type_style_lang = "";
function create_if_block$31(ctx) {
  let t0;
  let li0;
  let a0;
  let t1;
  let t2;
  let li1;
  let a1;
  let t3;
  let mounted;
  let dispose;
  let if_block = ctx[2] && create_if_block_1$1R(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      li0 = element("li");
      a0 = element("a");
      t1 = text("No");
      t2 = space();
      li1 = element("li");
      a1 = element("a");
      t3 = text("Yes");
      attr(a0, "class", "dropdown-item");
      attr(a0, "href", href$2);
      attr(a1, "class", "dropdown-item del svelte-wvb0dh");
      attr(a1, "href", href$2);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, li0, anchor);
      append(li0, a0);
      append(a0, t1);
      insert(target, t2, anchor);
      insert(target, li1, anchor);
      append(li1, a1);
      append(a1, t3);
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[6]),
          listen(a1, "click", ctx[11]),
          listen(a1, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1R(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(li1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$1R(ctx) {
  let li;
  let t;
  return {
    c() {
      li = element("li");
      t = text(ctx[2]);
      attr(li, "class", "dropdown-header");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_fragment$5o(ctx) {
  let div;
  let button;
  let button_class_value;
  let t;
  let ul;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let if_block = ctx[4] && create_if_block$31(ctx);
  return {
    c() {
      div = element("div");
      button = element("button");
      if (default_slot)
        default_slot.c();
      t = space();
      ul = element("ul");
      if (if_block)
        if_block.c();
      attr(button, "class", button_class_value = "btn btn-default " + ctx[1] + " svelte-wvb0dh");
      attr(button, "data-bs-toggle", "dropdown");
      button.disabled = ctx[4];
      attr(ul, "class", "dropdown-menu");
      toggle_class(ul, "dropdown-menu-right", ctx[0]);
      attr(div, "class", "dropdown open inline");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (default_slot) {
        default_slot.m(button, null);
      }
      append(div, t);
      append(div, ul);
      if (if_block)
        if_block.m(ul, null);
      ctx[12](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window, "keydown", ctx[7]),
          listen(window, "mousedown", ctx[8]),
          listen(button, "click", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2 && button_class_value !== (button_class_value = "btn btn-default " + ctx2[1] + " svelte-wvb0dh")) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & 16) {
        button.disabled = ctx2[4];
      }
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$31(ctx2);
          if_block.c();
          if_block.m(ul, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 1) {
        toggle_class(ul, "dropdown-menu-right", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[12](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
let href$2 = "#";
function instance$5d($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { alignRight = false } = $$props;
  let { class: clazz = "" } = $$props;
  let { msg = "" } = $$props;
  let el2;
  let confirm2 = false;
  function onConfirm(e) {
    $$invalidate(4, confirm2 = true);
    e.preventDefault();
  }
  function onAClick(e) {
    e.preventDefault();
    $$invalidate(4, confirm2 = false);
  }
  function onKeydown(e) {
    if (e.key === "Escape") {
      $$invalidate(4, confirm2 = false);
    }
  }
  function onMouseDown(e) {
    if (!el2.contains(e.target)) {
      $$invalidate(4, confirm2 = false);
    }
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el2 = $$value;
      $$invalidate(3, el2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("alignRight" in $$props2)
      $$invalidate(0, alignRight = $$props2.alignRight);
    if ("class" in $$props2)
      $$invalidate(1, clazz = $$props2.class);
    if ("msg" in $$props2)
      $$invalidate(2, msg = $$props2.msg);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    alignRight,
    clazz,
    msg,
    el2,
    confirm2,
    onConfirm,
    onAClick,
    onKeydown,
    onMouseDown,
    $$scope,
    slots,
    click_handler,
    div_binding
  ];
}
class ConfirmBtn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5d, create_fragment$5o, safe_not_equal, { alignRight: 0, class: 1, msg: 2 });
  }
}
function create_else_block$1z(ctx) {
  let div1;
  let div0;
  let t0_value = ctx[6].info + "";
  let t0;
  let t1_value = ctx[10](ctx[0].id) ? " (" + TXT("l_device_this") + ")" : "";
  let t1;
  let t2;
  let div0_class_value;
  let t3;
  let small0;
  let t4_value = moment(ctx[6].ts).format(" (YYYY-MM-DD)") + "";
  let t4;
  let t5;
  let small1;
  let t6;
  let t7_value = ctx[6].name + "";
  let t7;
  let if_block = ctx[5] && create_if_block_2$19(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      small0 = element("small");
      t4 = text(t4_value);
      t5 = space();
      small1 = element("small");
      t6 = text("- ");
      t7 = text(t7_value);
      attr(div0, "class", div0_class_value = ctx[10](ctx[0].id) ? "fw-bold" : "");
      attr(small1, "class", "help");
      attr(div1, "class", "ms-2 me-auto");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      append(div0, t2);
      if (if_block)
        if_block.m(div0, null);
      append(div1, t3);
      append(div1, small0);
      append(small0, t4);
      append(small0, t5);
      append(div1, small1);
      append(small1, t6);
      append(small1, t7);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t0_value !== (t0_value = ctx2[6].info + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t1_value !== (t1_value = ctx2[10](ctx2[0].id) ? " (" + TXT("l_device_this") + ")" : ""))
        set_data(t1, t1_value);
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$19(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 1 && div0_class_value !== (div0_class_value = ctx2[10](ctx2[0].id) ? "fw-bold" : "")) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty & 64 && t4_value !== (t4_value = moment(ctx2[6].ts).format(" (YYYY-MM-DD)") + ""))
        set_data(t4, t4_value);
      if (dirty & 64 && t7_value !== (t7_value = ctx2[6].name + ""))
        set_data(t7, t7_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$1Q(ctx) {
  let div;
  let inputedit;
  let t0;
  let button0;
  let i0;
  let t1;
  let button1;
  let current;
  let mounted;
  let dispose;
  inputedit = new InputEdit({ props: { field: ctx[2] } });
  return {
    c() {
      div = element("div");
      create_component(inputedit.$$.fragment);
      t0 = space();
      button0 = element("button");
      i0 = element("i");
      t1 = space();
      button1 = element("button");
      button1.innerHTML = `<i class="fa fa-times"></i>`;
      attr(i0, "class", "fa fa-check");
      attr(button0, "type", "button");
      attr(button0, "class", "btn btn-default btn-sm");
      button0.disabled = ctx[7];
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-default btn-sm");
      attr(div, "class", "d-flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(inputedit, div, null);
      append(div, t0);
      append(div, button0);
      append(button0, i0);
      append(div, t1);
      append(div, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", prevent_default(ctx[12])),
          listen(button1, "click", prevent_default(ctx[13]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const inputedit_changes = {};
      if (dirty & 4)
        inputedit_changes.field = ctx2[2];
      inputedit.$set(inputedit_changes);
      if (!current || dirty & 128) {
        button0.disabled = ctx2[7];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(inputedit);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$19(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.innerHTML = `<i class="fa fa-pencil"></i>`;
      attr(a, "href", "#");
      attr(a, "class", "text-decoration-none");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[14]));
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$30(ctx) {
  let div;
  let confirmbtn;
  let current;
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot$1D] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[15]);
  return {
    c() {
      div = element("div");
      create_component(confirmbtn.$$.fragment);
      attr(div, "class", "flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(confirmbtn, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const confirmbtn_changes = {};
      if (dirty & 524288) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(confirmbtn);
    }
  };
}
function create_default_slot$1D(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-trash-o text-danger");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_fragment$5n(ctx) {
  let li;
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let show_if = !(ctx[0].id === ctx[1]) && !ctx[0].isWeb();
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$1Q, create_else_block$1z];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = show_if && create_if_block$30(ctx);
  return {
    c() {
      li = element("li");
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(li, "class", "list-group-item list-group-item-action d-flex justify-content-between align-items-start align-items-center");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div);
      if_blocks[current_block_type_index].m(div, null);
      append(li, t);
      if (if_block1)
        if_block1.m(li, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(li, "mouseenter", ctx[16]),
          listen(li, "mouseleave", ctx[17])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, null);
      }
      if (dirty & 3)
        show_if = !(ctx2[0].id === ctx2[1]) && !ctx2[0].isWeb();
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 3) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$30(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(li, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$5c($$self, $$props, $$invalidate) {
  let $client, $$unsubscribe_client = noop$1, $$subscribe_client = () => ($$unsubscribe_client(), $$unsubscribe_client = subscribe(client, ($$value) => $$invalidate(6, $client = $$value)), client);
  let $error, $$unsubscribe_error = noop$1, $$subscribe_error = () => ($$unsubscribe_error(), $$unsubscribe_error = subscribe(error2, ($$value) => $$invalidate(7, $error = $$value)), error2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_client());
  $$self.$$.on_destroy.push(() => $$unsubscribe_error());
  let { client } = $$props;
  $$subscribe_client();
  let { defaultId } = $$props;
  const dispatch = createEventDispatcher();
  let field;
  let error2;
  let showEditInput = false;
  let showEditButton = false;
  function onEditName() {
    $$invalidate(4, showEditInput = !showEditInput);
    if (showEditInput) {
      $$invalidate(2, field = createFieldStore({ type: "string", required: true }, $client.info));
      $$subscribe_error($$invalidate(3, error2 = field.error));
    }
  }
  function onSaveName() {
    client.save({ info: field.toJSON() }, { patch: true });
    $$invalidate(4, showEditInput = false);
  }
  function isThisClient(id2) {
    return defaultId === id2;
  }
  function onRemoveClient(id2) {
    dispatch("remove", id2);
  }
  const click_handler = () => onSaveName();
  const click_handler_1 = () => $$invalidate(4, showEditInput = false);
  const click_handler_2 = () => onEditName();
  const click_handler_3 = () => onRemoveClient(client);
  const mouseenter_handler = () => $$invalidate(5, showEditButton = true);
  const mouseleave_handler = () => $$invalidate(5, showEditButton = false);
  $$self.$$set = ($$props2) => {
    if ("client" in $$props2)
      $$subscribe_client($$invalidate(0, client = $$props2.client));
    if ("defaultId" in $$props2)
      $$invalidate(1, defaultId = $$props2.defaultId);
  };
  return [
    client,
    defaultId,
    field,
    error2,
    showEditInput,
    showEditButton,
    $client,
    $error,
    onEditName,
    onSaveName,
    isThisClient,
    onRemoveClient,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    mouseenter_handler,
    mouseleave_handler
  ];
}
class ClientInfo extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5c, create_fragment$5n, safe_not_equal, { client: 0, defaultId: 1 });
  }
}
function get_each_context$1o(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_if_block$2$(ctx) {
  let clientinfo;
  let current;
  clientinfo = new ClientInfo({
    props: {
      client: ctx[4],
      defaultId: ctx[0].defaultId
    }
  });
  clientinfo.$on("remove", ctx[2]);
  return {
    c() {
      create_component(clientinfo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clientinfo, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const clientinfo_changes = {};
      if (dirty & 2)
        clientinfo_changes.client = ctx2[4];
      if (dirty & 1)
        clientinfo_changes.defaultId = ctx2[0].defaultId;
      clientinfo.$set(clientinfo_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(clientinfo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientinfo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clientinfo, detaching);
    }
  };
}
function create_each_block$1o(ctx) {
  let show_if = ctx[4].toJSON().type > 3;
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block$2$(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        show_if = ctx2[4].toJSON().type > 3;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2$(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$5m(ctx) {
  let ul;
  let current;
  let each_value = ctx[1].models;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1o(get_each_context$1o(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", "list-group list-group-flush");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = ctx2[1].models;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1o(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1o(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(ul, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$5b($$self, $$props, $$invalidate) {
  let $clients, $$unsubscribe_clients = noop$1, $$subscribe_clients = () => ($$unsubscribe_clients(), $$unsubscribe_clients = subscribe(clients, ($$value) => $$invalidate(1, $clients = $$value)), clients);
  $$self.$$.on_destroy.push(() => $$unsubscribe_clients());
  let { clients } = $$props;
  $$subscribe_clients();
  const dispatch = createEventDispatcher();
  async function removeClient(e) {
    let id2 = e.detail;
    let client = clients.get(id2);
    await client.save({ state: 90 });
    clients.remove(client);
    dispatch("remove", id2);
  }
  $$self.$$set = ($$props2) => {
    if ("clients" in $$props2)
      $$subscribe_clients($$invalidate(0, clients = $$props2.clients));
  };
  return [clients, $clients, removeClient];
}
class ClientList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5b, create_fragment$5m, safe_not_equal, { clients: 0 });
  }
}
const get_message_slot_changes = (dirty) => ({});
const get_message_slot_context = (ctx) => ({});
const get_action_slot_changes$2 = (dirty) => ({});
const get_action_slot_context$2 = (ctx) => ({});
function create_fragment$5l(ctx) {
  let div2;
  let div1;
  let div0;
  let h3;
  let t1;
  let t2;
  let small;
  let t4;
  let t5;
  let clientlist;
  let current;
  const action_slot_template = ctx[2].action;
  const action_slot = create_slot(action_slot_template, ctx, ctx[1], get_action_slot_context$2);
  const message_slot_template = ctx[2].message;
  const message_slot = create_slot(message_slot_template, ctx, ctx[1], get_message_slot_context);
  clientlist = new ClientList({ props: { clients: ctx[0] } });
  clientlist.$on("remove", ctx[3]);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = "Manage Devices";
      t1 = space();
      if (action_slot)
        action_slot.c();
      t2 = space();
      small = element("small");
      small.textContent = "Rename devices or remove unused ones";
      t4 = space();
      if (message_slot)
        message_slot.c();
      t5 = space();
      create_component(clientlist.$$.fragment);
      attr(h3, "class", "card-title");
      attr(div0, "class", "d-flex justify-content-between mt-2");
      attr(small, "class", "fs-6 text");
      attr(div1, "class", "card-header");
      attr(div2, "class", "card");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, h3);
      append(div0, t1);
      if (action_slot) {
        action_slot.m(div0, null);
      }
      append(div1, t2);
      append(div1, small);
      append(div1, t4);
      if (message_slot) {
        message_slot.m(div1, null);
      }
      append(div2, t5);
      mount_component(clientlist, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (action_slot) {
        if (action_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(action_slot_template, ctx2[1], dirty, get_action_slot_changes$2),
            get_action_slot_context$2
          );
        }
      }
      if (message_slot) {
        if (message_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            message_slot,
            message_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(message_slot_template, ctx2[1], dirty, get_message_slot_changes),
            get_message_slot_context
          );
        }
      }
      const clientlist_changes = {};
      if (dirty & 1)
        clientlist_changes.clients = ctx2[0];
      clientlist.$set(clientlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(action_slot, local);
      transition_in(message_slot, local);
      transition_in(clientlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(action_slot, local);
      transition_out(message_slot, local);
      transition_out(clientlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (action_slot)
        action_slot.d(detaching);
      if (message_slot)
        message_slot.d(detaching);
      destroy_component(clientlist);
    }
  };
}
function instance$5a($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { clients = new ModelClient.Clients() } = $$props;
  onMount(async () => {
    await clients.fetch({
      data: {
        "state.in": [0, 30],
        "_opt": { order: ["ts"] }
      }
    });
  });
  function remove_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("clients" in $$props2)
      $$invalidate(0, clients = $$props2.clients);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [clients, $$scope, slots, remove_handler];
}
class Devices extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5a, create_fragment$5l, safe_not_equal, { clients: 0 });
  }
}
const $$2 = window.jQuery;
if (!$$2) {
  throw new Error("ADD jQuery");
}
const _$4 = window._;
if (!_$4) {
  throw new Error("ADD _");
}
const Backbone$3 = window.Backbone;
if (!Backbone$3) {
  throw new Error("ADD Backbone");
}
var General = View.ActionProvider.extend({
  name: "SettingsGeneral",
  actions: {
    "settings signout": { fn: "action_signout" },
    "settings close": { fn: "closeLoginForm" }
  },
  events: {
    "change": "event_change",
    "click .xclose": "closeLoginForm"
  },
  closeLoginForm: function() {
    this.loginView.remove();
    $$2(this.elLoginCt).remove();
    this.updateUser();
  },
  action_signout: async function() {
    await serviceProxy.auth.logout();
    location.href = serviceProxy.CFG.URL.ROOT + "/logout";
  },
  event_change: function() {
    this.saveValues();
  },
  load: function() {
    this.setValues();
  },
  render: function() {
    this.$el.append(
      DIV(
        { "class": "card panel-default" },
        HEADER({ "class": "card-header" }, H3("General")),
        DIV(
          { "class": "card-body" },
          DIV(
            { "class": "form-group" },
            H4(TXT("l_account")),
            A({ "class": "btn btn-primary", "href": `${serviceProxy.CFG.URL.ROOT}/service-login?redirect=app://ui/inbox.html#inbox`, "data-action": "settings signin" }),
            BUTTON({ "class": "btn btn-default", "style": "margin-left: 20px;", "data-action": "settings signout" }, TXT("a_signout"))
          ),
          DIV(TXT("m_ext_signin"))
        )
      )
    );
    this.elSignIn = this.$('[data-action="settings signin"]');
    this.elSyncInfo = this.$(".alert");
    return this;
  },
  saveValues: function() {
    this.$el.find("input,select").each(async function() {
      const el2 = this;
      if (el2.type == "checkbox") {
        await serviceProxy.store.Prefs.set(el2.name, el2.checked);
      } else {
        await serviceProxy.store.Prefs.set(el2.name, el2.value);
      }
    });
  },
  setValues: function() {
    this.$el.find("input,select").each(async function() {
      const el2 = this;
      if (el2.type == "checkbox") {
        el2.checked = await serviceProxy.store.Prefs.get(el2.name);
      } else {
        el2.value = await serviceProxy.store.Prefs.get(el2.name);
      }
    });
    this.showCred();
  },
  showCred: function() {
    if (USER.name) {
      this.elSignIn.text(SPRINTF("l_signed_in_as", `${USER.name} (${USER.email})`));
    } else {
      this.elSignIn.text(TXT("a_signin"));
    }
  },
  updateUser: async function() {
    let user = await serviceProxy.auth.getUser();
    _$4.extend(USER, user);
    this.showCred();
  }
});
function create_else_block$1y(ctx) {
  let div;
  let small;
  return {
    c() {
      div = element("div");
      small = element("small");
      small.textContent = `${TXT("m_ext_signin")}`;
      attr(small, "class", "help");
      attr(div, "class", "mt-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, small);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$2_(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${TXT("a_signout")}`;
      attr(button, "class", "btn btn-default");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[3]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5k(ctx) {
  let div3;
  let div0;
  let t1;
  let div2;
  let div1;
  let h4;
  let t3;
  let a;
  let t4_value = (ctx[0].name ? SPRINTF("l_signed_in_as", `${ctx[0].name} (${ctx[0].email})`) : TXT("a_signin")) + "";
  let t4;
  let t5;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block$2_;
    return create_else_block$1y;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3>General</h3>`;
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      h4 = element("h4");
      h4.textContent = `${TXT("l_account")}`;
      t3 = space();
      a = element("a");
      t4 = text(t4_value);
      t5 = space();
      if_block.c();
      attr(div0, "class", "card-header");
      attr(a, "class", "btn btn-primary");
      attr(a, "href", serviceProxy.CFG.URL.ROOT + "/service-login?redirect=app://ui/inbox.html#inbox");
      attr(div1, "class", "form-group");
      attr(div2, "class", "card-body");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div3, t1);
      append(div3, div2);
      append(div2, div1);
      append(div1, h4);
      append(div1, t3);
      append(div1, a);
      append(a, t4);
      append(div1, t5);
      if_block.m(div1, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && t4_value !== (t4_value = (ctx2[0].name ? SPRINTF("l_signed_in_as", `${ctx2[0].name} (${ctx2[0].email})`) : TXT("a_signin")) + ""))
        set_data(t4, t4_value);
      if_block.p(ctx2, dirty);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block.d();
    }
  };
}
function instance$59($$self, $$props, $$invalidate) {
  let $user;
  const parent2 = getContext("view:root");
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(0, $user = value));
  let isSignedIn = $user.name ? true : false;
  let view = new General({ parent: parent2 }).render();
  view.load();
  async function signOut() {
    await serviceProxy.auth.logout();
    location.href = serviceProxy.CFG.URL.ROOT + "/logout";
  }
  return [$user, user, isSignedIn, signOut];
}
class GeneralExt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$59, create_fragment$5k, safe_not_equal, {});
  }
}
const get_hiddenLabel_slot_changes = (dirty) => ({});
const get_hiddenLabel_slot_context = (ctx) => ({});
const get_label_slot_changes = (dirty) => ({});
const get_label_slot_context = (ctx) => ({});
const get_action_slot_changes$1 = (dirty) => ({});
const get_action_slot_context$1 = (ctx) => ({});
function create_else_block$1x(ctx) {
  let button;
  let span;
  let t;
  let div;
  let button_data_bs_target_value;
  let button_class_value;
  let current;
  const label_slot_template = ctx[8].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[7], get_label_slot_context);
  const label_slot_or_fallback = label_slot || fallback_block_1$3(ctx);
  const hiddenLabel_slot_template = ctx[8].hiddenLabel;
  const hiddenLabel_slot = create_slot(hiddenLabel_slot_template, ctx, ctx[7], get_hiddenLabel_slot_context);
  const hiddenLabel_slot_or_fallback = hiddenLabel_slot || fallback_block$e(ctx);
  return {
    c() {
      button = element("button");
      span = element("span");
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      t = space();
      div = element("div");
      if (hiddenLabel_slot_or_fallback)
        hiddenLabel_slot_or_fallback.c();
      attr(button, "type", "button");
      attr(button, "data-bs-toggle", "collapse");
      attr(button, "data-bs-target", button_data_bs_target_value = "." + ctx[2]);
      attr(button, "class", button_class_value = "btn btn-primary btn-text collapsed " + ctx[3]);
      toggle_class(button, "collapsed", ctx[5]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(span, null);
      }
      append(button, t);
      append(button, div);
      if (hiddenLabel_slot_or_fallback) {
        hiddenLabel_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(label_slot_template, ctx2[7], dirty, get_label_slot_changes),
            get_label_slot_context
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & 1)) {
          label_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (hiddenLabel_slot) {
        if (hiddenLabel_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            hiddenLabel_slot,
            hiddenLabel_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(hiddenLabel_slot_template, ctx2[7], dirty, get_hiddenLabel_slot_changes),
            get_hiddenLabel_slot_context
          );
        }
      } else {
        if (hiddenLabel_slot_or_fallback && hiddenLabel_slot_or_fallback.p && (!current || dirty & 2)) {
          hiddenLabel_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 4 && button_data_bs_target_value !== (button_data_bs_target_value = "." + ctx2[2])) {
        attr(button, "data-bs-target", button_data_bs_target_value);
      }
      if (!current || dirty & 8 && button_class_value !== (button_class_value = "btn btn-primary btn-text collapsed " + ctx2[3])) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & 40) {
        toggle_class(button, "collapsed", ctx2[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      transition_in(hiddenLabel_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot_or_fallback, local);
      transition_out(hiddenLabel_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
      if (hiddenLabel_slot_or_fallback)
        hiddenLabel_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block$2Z(ctx) {
  let current;
  const action_slot_template = ctx[8].action;
  const action_slot = create_slot(action_slot_template, ctx, ctx[7], get_action_slot_context$1);
  return {
    c() {
      if (action_slot)
        action_slot.c();
    },
    m(target, anchor) {
      if (action_slot) {
        action_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (action_slot) {
        if (action_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(action_slot_template, ctx2[7], dirty, get_action_slot_changes$1),
            get_action_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(action_slot, local);
      current = true;
    },
    o(local) {
      transition_out(action_slot, local);
      current = false;
    },
    d(detaching) {
      if (action_slot)
        action_slot.d(detaching);
    }
  };
}
function fallback_block_1$3(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function fallback_block$e(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[1]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$5j(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let div;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block$2Z, create_else_block$1x];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6].action)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  return {
    c() {
      if_block.c();
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", div_class_value = "collapse " + ctx[4] + " " + ctx[2]);
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 20 && div_class_value !== (div_class_value = "collapse " + ctx2[4] + " " + ctx2[2])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$58($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { label = "Show Navigation" } = $$props;
  let { hiddenLabel = "Hide Navigation" } = $$props;
  let { targetClass = `collapse-${Date.now()}` } = $$props;
  let { actionClass = "" } = $$props;
  let { collapseClass = "" } = $$props;
  let { collapsed = true } = $$props;
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("hiddenLabel" in $$props2)
      $$invalidate(1, hiddenLabel = $$props2.hiddenLabel);
    if ("targetClass" in $$props2)
      $$invalidate(2, targetClass = $$props2.targetClass);
    if ("actionClass" in $$props2)
      $$invalidate(3, actionClass = $$props2.actionClass);
    if ("collapseClass" in $$props2)
      $$invalidate(4, collapseClass = $$props2.collapseClass);
    if ("collapsed" in $$props2)
      $$invalidate(5, collapsed = $$props2.collapsed);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  return [
    label,
    hiddenLabel,
    targetClass,
    actionClass,
    collapseClass,
    collapsed,
    $$slots,
    $$scope,
    slots
  ];
}
class Collapse extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$58, create_fragment$5j, safe_not_equal, {
      label: 0,
      hiddenLabel: 1,
      targetClass: 2,
      actionClass: 3,
      collapseClass: 4,
      collapsed: 5
    });
  }
}
function autofocus(node) {
  setTimeout(() => {
    if (node.tagName === "INPUT" || node.tagName === "TEXTAREA") {
      node.focus();
    } else {
      if (document.activeElement && node.contains(document.activeElement)) {
        return;
      }
      const autofocusElement = node.querySelector("[autofocus]");
      if (autofocusElement && document.activeElement !== autofocusElement) {
        autofocusElement.focus();
        return;
      }
      const input = node.querySelector("input:not([disabled]), textarea:not([disabled])");
      if (input) {
        input.focus();
      } else {
        node.focus();
      }
    }
  }, 10);
}
var Modal_svelte_svelte_type_style_lang$1 = "";
const get_links_slot_changes$1 = (dirty) => ({});
const get_links_slot_context$1 = (ctx) => ({});
const get_buttons_slot_changes$3 = (dirty) => ({});
const get_buttons_slot_context$3 = (ctx) => ({});
const get_sub_header_slot_changes$1 = (dirty) => ({});
const get_sub_header_slot_context$1 = (ctx) => ({});
const get_header_slot_changes$5 = (dirty) => ({});
const get_header_slot_context$5 = (ctx) => ({});
const get_content_slot_changes$1 = (dirty) => ({});
const get_content_slot_context$1 = (ctx) => ({});
function fallback_block_2(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function fallback_block$d(ctx) {
  let div5;
  let div4;
  let div1;
  let div0;
  let h4;
  let t0;
  let t1;
  let button0;
  let t2;
  let div2;
  let t3;
  let div3;
  let t4;
  let button1;
  let t5;
  let t6;
  let div5_class_value;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = ctx[11].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[10], get_header_slot_context$5);
  const header_slot_or_fallback = header_slot || fallback_block_2(ctx);
  const sub_header_slot_template = ctx[11]["sub-header"];
  const sub_header_slot = create_slot(sub_header_slot_template, ctx, ctx[10], get_sub_header_slot_context$1);
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  const buttons_slot_template = ctx[11].buttons;
  const buttons_slot = create_slot(buttons_slot_template, ctx, ctx[10], get_buttons_slot_context$3);
  const links_slot_template = ctx[11].links;
  const links_slot = create_slot(links_slot_template, ctx, ctx[10], get_links_slot_context$1);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      h4 = element("h4");
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
      t0 = space();
      if (sub_header_slot)
        sub_header_slot.c();
      t1 = space();
      button0 = element("button");
      t2 = space();
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      t3 = space();
      div3 = element("div");
      if (buttons_slot)
        buttons_slot.c();
      t4 = space();
      button1 = element("button");
      t5 = text(ctx[3]);
      t6 = space();
      if (links_slot)
        links_slot.c();
      attr(h4, "class", "mb-0");
      attr(div0, "class", "modal-title");
      attr(button0, "type", "button");
      attr(button0, "class", "btn-close");
      attr(button0, "data-dismiss", "modal");
      attr(button0, "aria-label", "Close");
      attr(div1, "class", "modal-header");
      attr(div2, "class", "modal-body");
      attr(div2, "style", ctx[1]);
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-secondary");
      attr(div3, "class", "modal-footer justify-content-start");
      attr(div4, "class", "modal-content");
      attr(div5, "class", div5_class_value = "modal-dialog " + ctx[0] + " svelte-zjo7te");
      attr(div5, "role", "document");
      toggle_class(div5, "modal-dialog-scrollable", ctx[4]);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div1);
      append(div1, div0);
      append(div0, h4);
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(h4, null);
      }
      append(div0, t0);
      if (sub_header_slot) {
        sub_header_slot.m(div0, null);
      }
      append(div1, t1);
      append(div1, button0);
      append(div4, t2);
      append(div4, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append(div4, t3);
      append(div4, div3);
      if (buttons_slot) {
        buttons_slot.m(div3, null);
      }
      append(div3, t4);
      append(div3, button1);
      append(button1, t5);
      append(div3, t6);
      if (links_slot) {
        links_slot.m(div3, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[6]),
          listen(button1, "click", ctx[6]),
          action_destroyer(clickOutside.call(null, div5)),
          listen(div5, "outclick", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(header_slot_template, ctx2[10], dirty, get_header_slot_changes$5),
            get_header_slot_context$5
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty & 4)) {
          header_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (sub_header_slot) {
        if (sub_header_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            sub_header_slot,
            sub_header_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(sub_header_slot_template, ctx2[10], dirty, get_sub_header_slot_changes$1),
            get_sub_header_slot_context$1
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2) {
        attr(div2, "style", ctx2[1]);
      }
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(buttons_slot_template, ctx2[10], dirty, get_buttons_slot_changes$3),
            get_buttons_slot_context$3
          );
        }
      }
      if (!current || dirty & 8)
        set_data(t5, ctx2[3]);
      if (links_slot) {
        if (links_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            links_slot,
            links_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(links_slot_template, ctx2[10], dirty, get_links_slot_changes$1),
            get_links_slot_context$1
          );
        }
      }
      if (!current || dirty & 1 && div5_class_value !== (div5_class_value = "modal-dialog " + ctx2[0] + " svelte-zjo7te")) {
        attr(div5, "class", div5_class_value);
      }
      if (!current || dirty & 17) {
        toggle_class(div5, "modal-dialog-scrollable", ctx2[4]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      transition_in(sub_header_slot, local);
      transition_in(default_slot, local);
      transition_in(buttons_slot, local);
      transition_in(links_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot_or_fallback, local);
      transition_out(sub_header_slot, local);
      transition_out(default_slot, local);
      transition_out(buttons_slot, local);
      transition_out(links_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
      if (sub_header_slot)
        sub_header_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (buttons_slot)
        buttons_slot.d(detaching);
      if (links_slot)
        links_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$5i(ctx) {
  let div0;
  let t;
  let div1;
  let current;
  let mounted;
  let dispose;
  const content_slot_template = ctx[11].content;
  const content_slot = create_slot(content_slot_template, ctx, ctx[10], get_content_slot_context$1);
  const content_slot_or_fallback = content_slot || fallback_block$d(ctx);
  return {
    c() {
      div0 = element("div");
      if (content_slot_or_fallback)
        content_slot_or_fallback.c();
      t = space();
      div1 = element("div");
      attr(div0, "class", "modal fade show");
      attr(div0, "tabindex", "-1");
      attr(div0, "role", "dialog");
      set_style(div0, "display", "block");
      attr(div1, "class", "modal-backdrop fade show");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      if (content_slot_or_fallback) {
        content_slot_or_fallback.m(div0, null);
      }
      ctx[12](div0);
      insert(target, t, anchor);
      insert(target, div1, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window, "keydown", ctx[7]),
          action_destroyer(portal.call(null, div0)),
          action_destroyer(autofocus.call(null, div0))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (content_slot) {
        if (content_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(content_slot_template, ctx2[10], dirty, get_content_slot_changes$1),
            get_content_slot_context$1
          );
        }
      } else {
        if (content_slot_or_fallback && content_slot_or_fallback.p && (!current || dirty & 1055)) {
          content_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(content_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(content_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (content_slot_or_fallback)
        content_slot_or_fallback.d(detaching);
      ctx[12](null);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$57($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { closeOnClickOut = false } = $$props;
  let { modalDialogClasses = "modal-lg" } = $$props;
  let { bodyStyle = "" } = $$props;
  let { title = "" } = $$props;
  let { labelClose = TXT("a_cancel") } = $$props;
  let { scrollable = false } = $$props;
  const dispatch = createEventDispatcher();
  const onClose = () => dispatch("close");
  let modal;
  const onKeydown = (e) => {
    if (e.key === "Escape") {
      onClose();
      return;
    }
    if (e.key === "Tab") {
      const nodes = modal.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter((n) => n.tabIndex >= 0);
      let index2 = tabbable.indexOf(document.activeElement);
      if (index2 === -1 && e.shiftKey)
        index2 = 0;
      index2 += tabbable.length + (e.shiftKey ? -1 : 1);
      index2 %= tabbable.length;
      tabbable[index2].focus();
      e.preventDefault();
    }
  };
  const lastFocused = document.activeElement;
  if (lastFocused) {
    onDestroy(() => {
      lastFocused.focus();
    });
  }
  function outClickClose() {
    if (closeOnClickOut) {
      onClose();
    }
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modal = $$value;
      $$invalidate(5, modal);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("closeOnClickOut" in $$props2)
      $$invalidate(9, closeOnClickOut = $$props2.closeOnClickOut);
    if ("modalDialogClasses" in $$props2)
      $$invalidate(0, modalDialogClasses = $$props2.modalDialogClasses);
    if ("bodyStyle" in $$props2)
      $$invalidate(1, bodyStyle = $$props2.bodyStyle);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("labelClose" in $$props2)
      $$invalidate(3, labelClose = $$props2.labelClose);
    if ("scrollable" in $$props2)
      $$invalidate(4, scrollable = $$props2.scrollable);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  return [
    modalDialogClasses,
    bodyStyle,
    title,
    labelClose,
    scrollable,
    modal,
    onClose,
    onKeydown,
    outClickClose,
    closeOnClickOut,
    $$scope,
    slots,
    div0_binding
  ];
}
class Modal$2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$57, create_fragment$5i, safe_not_equal, {
      closeOnClickOut: 9,
      modalDialogClasses: 0,
      bodyStyle: 1,
      title: 2,
      labelClose: 3,
      scrollable: 4
    });
  }
}
const get_header_slot_changes$4 = (dirty) => ({});
const get_header_slot_context$4 = (ctx) => ({ slot: "header" });
const get_sub_header_slot_changes = (dirty) => ({});
const get_sub_header_slot_context = (ctx) => ({ slot: "sub-header" });
function create_if_block$2Y(ctx) {
  let div;
  let t0;
  let t1_value = (ctx[4].message || JSON.stringify(ctx[4])) + "";
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text("Please try again later. Error: ");
      t1 = text(t1_value);
      t2 = text(".");
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t1_value !== (t1_value = (ctx2[4].message || JSON.stringify(ctx2[4])) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$1C(ctx) {
  let t;
  let if_block_anchor;
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[10], null);
  let if_block = ctx[4] && create_if_block$2Y(ctx);
  return {
    c() {
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(default_slot_template, ctx2[10], dirty, null),
            null
          );
        }
      }
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$2Y(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function fallback_block$c(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_header_slot$v(ctx) {
  let current;
  const header_slot_template = ctx[8].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[10], get_header_slot_context$4);
  const header_slot_or_fallback = header_slot || fallback_block$c(ctx);
  return {
    c() {
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(header_slot_template, ctx2[10], dirty, get_header_slot_changes$4),
            get_header_slot_context$4
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty & 1)) {
          header_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
    }
  };
}
function create_sub_header_slot$4(ctx) {
  let current;
  const sub_header_slot_template = ctx[8]["sub-header"];
  const sub_header_slot = create_slot(sub_header_slot_template, ctx, ctx[10], get_sub_header_slot_context);
  return {
    c() {
      if (sub_header_slot)
        sub_header_slot.c();
    },
    m(target, anchor) {
      if (sub_header_slot) {
        sub_header_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (sub_header_slot) {
        if (sub_header_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            sub_header_slot,
            sub_header_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(sub_header_slot_template, ctx2[10], dirty, get_sub_header_slot_changes),
            get_sub_header_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sub_header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(sub_header_slot, local);
      current = false;
    },
    d(detaching) {
      if (sub_header_slot)
        sub_header_slot.d(detaching);
    }
  };
}
function create_buttons_slot$a(ctx) {
  let div;
  let button;
  let t_value = TXT(ctx[3] ? "l_loading" : ctx[1]) + "";
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      t = text(t_value);
      attr(button, "type", "button");
      attr(button, "class", "btn btn-primary");
      set_style(button, "width", "100px");
      button.disabled = button_disabled_value = ctx[2] || ctx[3];
      attr(div, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 10 && t_value !== (t_value = TXT(ctx2[3] ? "l_loading" : ctx2[1]) + ""))
        set_data(t, t_value);
      if (dirty & 12 && button_disabled_value !== (button_disabled_value = ctx2[2] || ctx2[3])) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5h(ctx) {
  let modal;
  let current;
  const modal_spread_levels = [ctx[6]];
  let modal_props = {
    $$slots: {
      buttons: [create_buttons_slot$a],
      "sub-header": [create_sub_header_slot$4],
      header: [create_header_slot$v],
      default: [create_default_slot$1C]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < modal_spread_levels.length; i2 += 1) {
    modal_props = assign(modal_props, modal_spread_levels[i2]);
  }
  modal = new Modal$2({ props: modal_props });
  modal.$on("close", ctx[9]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = dirty & 64 ? get_spread_update(modal_spread_levels, [get_spread_object(ctx2[6])]) : {};
      if (dirty & 1055) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$56($$self, $$props, $$invalidate) {
  const omit_props_names = ["title", "saveLabel", "disableSave", "onSave"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title = "Edit" } = $$props;
  let { saveLabel = "a_save" } = $$props;
  let { disableSave = false } = $$props;
  let { onSave } = $$props;
  const dispatch = createEventDispatcher();
  let saving = false;
  let error2 = null;
  async function onSaveClick() {
    $$invalidate(3, saving = true);
    $$invalidate(4, error2 = null);
    try {
      await onSave();
      dispatch("save");
    } catch (e) {
      console.error("onSave error:", e);
      $$invalidate(4, error2 = e);
    }
    $$invalidate(3, saving = false);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("title" in $$new_props)
      $$invalidate(0, title = $$new_props.title);
    if ("saveLabel" in $$new_props)
      $$invalidate(1, saveLabel = $$new_props.saveLabel);
    if ("disableSave" in $$new_props)
      $$invalidate(2, disableSave = $$new_props.disableSave);
    if ("onSave" in $$new_props)
      $$invalidate(7, onSave = $$new_props.onSave);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  return [
    title,
    saveLabel,
    disableSave,
    saving,
    error2,
    onSaveClick,
    $$restProps,
    onSave,
    slots,
    close_handler,
    $$scope
  ];
}
class SaveModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$56, create_fragment$5h, safe_not_equal, {
      title: 0,
      saveLabel: 1,
      disableSave: 2,
      onSave: 7
    });
  }
}
function verifyPhoneWithCountryCode(value, def) {
  if (!/^\+\d{1,4}\d{6,15}$/.test(value)) {
    return "Invalid phone number";
  }
}
class Phone extends TYPES.base {
}
__publicField(Phone, "default", "");
__publicField(Phone, "validators", [verifyPhoneWithCountryCode]);
register("phone", Phone);
const get_header_slot_changes$3 = (dirty) => ({});
const get_header_slot_context$3 = (ctx) => ({ slot: "header" });
const get_buttons_slot_changes$2 = (dirty) => ({});
const get_buttons_slot_context$2 = (ctx) => ({ slot: "buttons" });
const get_links_slot_changes = (dirty) => ({});
const get_links_slot_context = (ctx) => ({ slot: "links" });
function create_default_slot$1B(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function fallback_block_1$2(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_header_slot$u(ctx) {
  let current;
  const header_slot_template = ctx[1].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[4], get_header_slot_context$3);
  const header_slot_or_fallback = header_slot || fallback_block_1$2(ctx);
  return {
    c() {
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(header_slot_template, ctx2[4], dirty, get_header_slot_changes$3),
            get_header_slot_context$3
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty & 1)) {
          header_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block$b(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${TXT("a_confirm")}`;
      attr(button, "type", "button");
      attr(button, "class", "btn btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_buttons_slot$9(ctx) {
  let current;
  const buttons_slot_template = ctx[1].buttons;
  const buttons_slot = create_slot(buttons_slot_template, ctx, ctx[4], get_buttons_slot_context$2);
  const buttons_slot_or_fallback = buttons_slot || fallback_block$b(ctx);
  return {
    c() {
      if (buttons_slot_or_fallback)
        buttons_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (buttons_slot_or_fallback) {
        buttons_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(buttons_slot_template, ctx2[4], dirty, get_buttons_slot_changes$2),
            get_buttons_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(buttons_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(buttons_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (buttons_slot_or_fallback)
        buttons_slot_or_fallback.d(detaching);
    }
  };
}
function create_links_slot$1(ctx) {
  let current;
  const links_slot_template = ctx[1].links;
  const links_slot = create_slot(links_slot_template, ctx, ctx[4], get_links_slot_context);
  return {
    c() {
      if (links_slot)
        links_slot.c();
    },
    m(target, anchor) {
      if (links_slot) {
        links_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (links_slot) {
        if (links_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            links_slot,
            links_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(links_slot_template, ctx2[4], dirty, get_links_slot_changes),
            get_links_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(links_slot, local);
      current = true;
    },
    o(local) {
      transition_out(links_slot, local);
      current = false;
    },
    d(detaching) {
      if (links_slot)
        links_slot.d(detaching);
    }
  };
}
function create_fragment$5g(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      $$slots: {
        links: [create_links_slot$1],
        buttons: [create_buttons_slot$9],
        header: [create_header_slot$u],
        default: [create_default_slot$1B]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[3]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 17) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$55($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title = "Confirm" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  return [title, slots, click_handler, close_handler, $$scope];
}
class ConfirmModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$55, create_fragment$5g, safe_not_equal, { title: 0 });
  }
}
const get_msg_slot_changes = (dirty) => ({});
const get_msg_slot_context = (ctx) => ({});
function create_default_slot$1A(ctx) {
  let div;
  let t;
  let inputedit;
  let current;
  const msg_slot_template = ctx[8].msg;
  const msg_slot = create_slot(msg_slot_template, ctx, ctx[10], get_msg_slot_context);
  inputedit = new InputEdit({ props: { field: ctx[1] } });
  return {
    c() {
      div = element("div");
      if (msg_slot)
        msg_slot.c();
      t = space();
      create_component(inputedit.$$.fragment);
      attr(div, "class", "d-flex flex-column");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (msg_slot) {
        msg_slot.m(div, null);
      }
      append(div, t);
      mount_component(inputedit, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (msg_slot) {
        if (msg_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            msg_slot,
            msg_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(msg_slot_template, ctx2[10], dirty, get_msg_slot_changes),
            get_msg_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(msg_slot, local);
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(msg_slot, local);
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (msg_slot)
        msg_slot.d(detaching);
      destroy_component(inputedit);
    }
  };
}
function create_header_slot$t(ctx) {
  let t_value = TXT("l_verification_req") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_buttons_slot$8(ctx) {
  let button;
  let t_value = TXT("a_verify") + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", "btn btn-primary");
      button.disabled = ctx[0];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        button.disabled = ctx2[0];
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5f(ctx) {
  let confirmmodal;
  let current;
  confirmmodal = new ConfirmModal({
    props: {
      $$slots: {
        buttons: [create_buttons_slot$8],
        header: [create_header_slot$t],
        default: [create_default_slot$1A]
      },
      $$scope: { ctx }
    }
  });
  confirmmodal.$on("close", ctx[9]);
  return {
    c() {
      create_component(confirmmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmmodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const confirmmodal_changes = {};
      if (dirty & 1025) {
        confirmmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmmodal.$set(confirmmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmmodal, detaching);
    }
  };
}
function instance$54($$self, $$props, $$invalidate) {
  let disableVerify;
  let $field;
  let $showError;
  let $dirty;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id: id2 } = $$props;
  const dispatch = createEventDispatcher();
  const field = createFieldStore({ required: false, type: "string" });
  component_subscribe($$self, field, (value) => $$invalidate(11, $field = value));
  const dirty = field.dirty;
  component_subscribe($$self, dirty, (value) => $$invalidate(7, $dirty = value));
  const showError = field.showError;
  component_subscribe($$self, showError, (value) => $$invalidate(6, $showError = value));
  async function verify() {
    try {
      await Api.api(`/users/verify/${id2}/${$field}`, "POST");
      dispatch("verified", id2);
    } catch (err) {
      console.log("error while verifying the otp", err);
      const message = `Verification failed! ${typeof err == "object" ? err.msg : err}`;
      field.error.set({ message });
      Msg.error(message);
      setTimeout(() => Msg.stop(), 2e3);
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(5, id2 = $$props2.id);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 192) {
      $$invalidate(0, disableVerify = !$dirty || $dirty && $showError);
    }
  };
  return [
    disableVerify,
    field,
    dirty,
    showError,
    verify,
    id2,
    $showError,
    $dirty,
    slots,
    close_handler,
    $$scope
  ];
}
class OTPModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$54, create_fragment$5f, safe_not_equal, { id: 5 });
  }
}
function create_if_block_5$s(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "Primary";
      attr(small, "class", "badge bg-primary");
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_if_block_4$A(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${TXT("a_make_primary")}`;
      attr(button, "class", "btn btn-sm btn-default");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[13]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$18(ctx) {
  let small;
  let t1;
  let if_block_anchor;
  let if_block = !ctx[2] && create_if_block_3$S(ctx);
  return {
    c() {
      small = element("small");
      small.textContent = `${TXT("l_unverified")}`;
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(small, "class", "badge bg-light text-dark");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (!ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$S(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(small);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3$S(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${TXT("a_resend_verification_msg")}`;
      attr(button, "class", "btn btn-sm btn-default");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[12]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$1P(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${TXT("a_del")}`;
      attr(button, "class", "btn btn-sm btn-default");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[14]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$2X(ctx) {
  let otpmodal;
  let current;
  otpmodal = new OTPModal({
    props: {
      id: ctx[4],
      $$slots: { msg: [create_msg_slot] },
      $$scope: { ctx }
    }
  });
  otpmodal.$on("close", ctx[15]);
  otpmodal.$on("verified", ctx[16]);
  return {
    c() {
      create_component(otpmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(otpmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const otpmodal_changes = {};
      if (dirty & 16)
        otpmodal_changes.id = ctx2[4];
      if (dirty & 262144) {
        otpmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      otpmodal.$set(otpmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(otpmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(otpmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(otpmodal, detaching);
    }
  };
}
function create_msg_slot(ctx) {
  let t_value = i18n.sprintf(TXT("m_verification_code"), "phone") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$5e(ctx) {
  let li;
  let div0;
  let t0_value = ctx[0].get("value") + "";
  let t0;
  let t1;
  let div1;
  let t2;
  let show_if_3 = ctx[0].get("value") == ctx[5].email;
  let t3;
  let show_if_1;
  let show_if_2;
  let t4;
  let show_if = !ctx[0].isPrimary();
  let t5;
  let if_block3_anchor;
  let current;
  let if_block0 = show_if_3 && create_if_block_5$s();
  function select_block_type(ctx2, dirty) {
    if (dirty & 1)
      show_if_1 = null;
    if (dirty & 69)
      show_if_2 = null;
    if (show_if_1 == null)
      show_if_1 = !!!ctx2[0].isVerified();
    if (show_if_1)
      return create_if_block_2$18;
    if (show_if_2 == null)
      show_if_2 = !!(!ctx2[2] && ctx2[6].name == "email" && !ctx2[0].isPrimary());
    if (show_if_2)
      return create_if_block_4$A;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type && current_block_type(ctx);
  let if_block2 = show_if && create_if_block_1$1P(ctx);
  let if_block3 = ctx[3] && create_if_block$2X(ctx);
  return {
    c() {
      li = element("li");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      attr(div0, "class", "code");
      attr(div1, "class", "flex-1");
      attr(li, "class", "list-group-item border-start-0 border-end-0 flex items-center gap-2");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div0);
      append(div0, t0);
      append(li, t1);
      append(li, div1);
      append(li, t2);
      if (if_block0)
        if_block0.m(li, null);
      append(li, t3);
      if (if_block1)
        if_block1.m(li, null);
      append(li, t4);
      if (if_block2)
        if_block2.m(li, null);
      insert(target, t5, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].get("value") + ""))
        set_data(t0, t0_value);
      if (dirty & 33)
        show_if_3 = ctx2[0].get("value") == ctx2[5].email;
      if (show_if_3) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_5$s();
          if_block0.c();
          if_block0.m(li, t3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(li, t4);
        }
      }
      if (dirty & 1)
        show_if = !ctx2[0].isPrimary();
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$1P(ctx2);
          if_block2.c();
          if_block2.m(li, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (ctx2[3]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$2X(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach(t5);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(if_block3_anchor);
    }
  };
}
function instance$53($$self, $$props, $$invalidate) {
  let $user;
  let $attr, $$unsubscribe_attr = noop$1, $$subscribe_attr = () => ($$unsubscribe_attr(), $$unsubscribe_attr = subscribe(attr2, ($$value) => $$invalidate(6, $attr = $$value)), attr2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_attr());
  let { type } = $$props;
  let { attr: attr2 } = $$props;
  $$subscribe_attr();
  let { attrs } = $$props;
  let { onSieveOptions } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(5, $user = value));
  const askOTP = type == "phone";
  let showOTPModal = false;
  let idToVerify = null;
  async function setPrimary(id2) {
    Msg.info("l_loading");
    try {
      await Api.api("/users/change-primary/", "PATCH", { id: id2 });
      Msg.info("m_saved");
      await user.fetch();
      await attrs.fetch();
      setTimeout(() => Msg.stop(), 1e3);
    } catch (err) {
      if (err.message === "Password verification expired") {
        window.location.href = `${window.URL_AUTH}/verify-password?redirect=${urlCfg.app}${encodeURIComponent("/#/settings/emails_phones/")}`;
      } else {
        Msg.error(err.message || "An error occurred while updating primary email");
        console.error("An error occurred while updating primary email: ", err);
      }
    }
  }
  function remove(id2) {
    attr2.destroy();
  }
  function verify(id2) {
    Msg.info("l_loading");
    Api.api("/users/attrs/" + id2 + "/send_verification", "POST", function(err, res) {
      if (err) {
        Msg.error(res.msg);
      } else {
        Msg.info("m_sent_verify");
      }
    });
    setTimeout(() => Msg.stop(), 1e3);
    if (askOTP) {
      $$invalidate(4, idToVerify = id2);
      $$invalidate(3, showOTPModal = true);
    }
  }
  const click_handler = () => verify(attr2.id);
  const click_handler_1 = () => setPrimary(attr2.id);
  const click_handler_2 = () => remove(attr2.id);
  const close_handler = () => {
    $$invalidate(3, showOTPModal = false), $$invalidate(4, idToVerify = null);
  };
  const verified_handler = () => {
    attrs.fetch(), $$invalidate(4, idToVerify = null);
  };
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(11, type = $$props2.type);
    if ("attr" in $$props2)
      $$subscribe_attr($$invalidate(0, attr2 = $$props2.attr));
    if ("attrs" in $$props2)
      $$invalidate(1, attrs = $$props2.attrs);
    if ("onSieveOptions" in $$props2)
      $$invalidate(2, onSieveOptions = $$props2.onSieveOptions);
  };
  return [
    attr2,
    attrs,
    onSieveOptions,
    showOTPModal,
    idToVerify,
    $user,
    $attr,
    user,
    setPrimary,
    remove,
    verify,
    type,
    click_handler,
    click_handler_1,
    click_handler_2,
    close_handler,
    verified_handler
  ];
}
class Attr extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$53, create_fragment$5e, safe_not_equal, {
      type: 11,
      attr: 0,
      attrs: 1,
      onSieveOptions: 2
    });
  }
}
const get_input_field_help_slot_changes = (dirty) => ({});
const get_input_field_help_slot_context = (ctx) => ({});
const get_input_field_label_slot_changes = (dirty) => ({});
const get_input_field_label_slot_context = (ctx) => ({});
function get_each_context$1n(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  return child_ctx;
}
function create_catch_block$I(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$I(ctx) {
  let ul;
  let t0;
  let li;
  let t1;
  let div2;
  let div0;
  let inputedit;
  let t2;
  let t3;
  let t4;
  let div1;
  let button;
  let t5_value = TXT("a_add") + "";
  let t5;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[3].models;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1n(get_each_context$1n(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  const input_field_label_slot_template = ctx[15]["input-field-label"];
  const input_field_label_slot = create_slot(input_field_label_slot_template, ctx, ctx[14], get_input_field_label_slot_context);
  inputedit = new InputEdit({ props: { field: ctx[7] } });
  const input_field_help_slot_template = ctx[15]["input-field-help"];
  const input_field_help_slot = create_slot(input_field_help_slot_template, ctx, ctx[14], get_input_field_help_slot_context);
  let if_block = !ctx[4] && create_if_block$2W(ctx);
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      li = element("li");
      if (input_field_label_slot)
        input_field_label_slot.c();
      t1 = space();
      div2 = element("div");
      div0 = element("div");
      create_component(inputedit.$$.fragment);
      t2 = space();
      if (input_field_help_slot)
        input_field_help_slot.c();
      t3 = space();
      if (if_block)
        if_block.c();
      t4 = space();
      div1 = element("div");
      button = element("button");
      t5 = text(t5_value);
      attr(div0, "class", "col-md-6");
      set_style(button, "margin-bottom", "10px");
      attr(button, "class", "btn btn-primary right");
      button.disabled = ctx[2];
      attr(div1, "class", "col-md-1");
      attr(div2, "class", "d-flex xadd");
      attr(li, "class", "list-group-item last-row border-0");
      attr(ul, "class", "border-0 list-group");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      append(ul, t0);
      append(ul, li);
      if (input_field_label_slot) {
        input_field_label_slot.m(li, null);
      }
      append(li, t1);
      append(li, div2);
      append(div2, div0);
      mount_component(inputedit, div0, null);
      append(div0, t2);
      if (input_field_help_slot) {
        input_field_help_slot.m(div0, null);
      }
      append(div0, t3);
      if (if_block)
        if_block.m(div0, null);
      append(div2, t4);
      append(div2, div1);
      append(div1, button);
      append(button, t5);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[16]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 75) {
        each_value = ctx2[3].models;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1n(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1n(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(ul, t0);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (input_field_label_slot) {
        if (input_field_label_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            input_field_label_slot,
            input_field_label_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(input_field_label_slot_template, ctx2[14], dirty, get_input_field_label_slot_changes),
            get_input_field_label_slot_context
          );
        }
      }
      if (input_field_help_slot) {
        if (input_field_help_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            input_field_help_slot,
            input_field_help_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(input_field_help_slot_template, ctx2[14], dirty, get_input_field_help_slot_changes),
            get_input_field_help_slot_context
          );
        }
      }
      if (!ctx2[4])
        if_block.p(ctx2, dirty);
      if (!current || dirty & 4) {
        button.disabled = ctx2[2];
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(input_field_label_slot, local);
      transition_in(inputedit.$$.fragment, local);
      transition_in(input_field_help_slot, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(input_field_label_slot, local);
      transition_out(inputedit.$$.fragment, local);
      transition_out(input_field_help_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      destroy_each(each_blocks, detaching);
      if (input_field_label_slot)
        input_field_label_slot.d(detaching);
      destroy_component(inputedit);
      if (input_field_help_slot)
        input_field_help_slot.d(detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$1n(ctx) {
  let attr_1;
  let current;
  attr_1 = new Attr({
    props: {
      type: ctx[0],
      attr: ctx[21],
      attrs: ctx[6],
      onSieveOptions: ctx[1]
    }
  });
  return {
    c() {
      create_component(attr_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(attr_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const attr_1_changes = {};
      if (dirty & 1)
        attr_1_changes.type = ctx2[0];
      if (dirty & 8)
        attr_1_changes.attr = ctx2[21];
      if (dirty & 2)
        attr_1_changes.onSieveOptions = ctx2[1];
      attr_1.$set(attr_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attr_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attr_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(attr_1, detaching);
    }
  };
}
function create_if_block$2W(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${ctx[5]}`;
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_pending_block$I(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$5d(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$I,
    then: create_then_block$I,
    catch: create_catch_block$I,
    value: 20,
    blocks: [, , ,]
  };
  handle_promise(ctx[10](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$52($$self, $$props, $$invalidate) {
  let disableAdd;
  let $field;
  let $showError;
  let $touched;
  let $attrs;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { type } = $$props;
  let { onSieveOptions = false } = $$props;
  const user = getContext("user");
  const constraint = user.get("constraint");
  const canAddMore = type == "email" && constraint["email"] > 101 || type == "phone" && constraint["sms"] > 0;
  const cantAddErrorMsg = `Premium subscription is required to add additional ${type}.`;
  const attrs = new AttrModel.UserAttrs();
  component_subscribe($$self, attrs, (value) => $$invalidate(3, $attrs = value));
  attrs.setQuery({ "name": type, "state.in": [10, 40] });
  attrs.setOpt({ order: ["ts"] });
  const field = createFieldStore({
    required: false,
    type,
    validators: [
      (value) => {
        if (attrs.find((attr2) => attr2.get("value") == value)) {
          return TXT("e_value_exists");
        }
      }
    ]
  });
  component_subscribe($$self, field, (value) => $$invalidate(17, $field = value));
  const touched = field.touched;
  component_subscribe($$self, touched, (value) => $$invalidate(13, $touched = value));
  const showError = field.showError;
  component_subscribe($$self, showError, (value) => $$invalidate(12, $showError = value));
  function fetch2() {
    return attrs.fetch();
  }
  function add() {
    if (!canAddMore) {
      field.error.set({ message: cantAddErrorMsg });
      return;
    }
    attrs.create({ name: type, value: $field });
  }
  const click_handler = () => add();
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("onSieveOptions" in $$props2)
      $$invalidate(1, onSieveOptions = $$props2.onSieveOptions);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12288) {
      $$invalidate(2, disableAdd = !$touched || $touched && $showError);
    }
  };
  return [
    type,
    onSieveOptions,
    disableAdd,
    $attrs,
    canAddMore,
    cantAddErrorMsg,
    attrs,
    field,
    touched,
    showError,
    fetch2,
    add,
    $showError,
    $touched,
    $$scope,
    slots,
    click_handler
  ];
}
class AttrList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$52, create_fragment$5d, safe_not_equal, { type: 0, onSieveOptions: 1 });
  }
}
function create_input_field_label_slot$1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Add email address";
      attr(div, "class", "col-md-4 fw6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$5c(ctx) {
  let attrlist;
  let current;
  const attrlist_spread_levels = [{ type: "email" }, ctx[0]];
  let attrlist_props = {
    $$slots: {
      "input-field-label": [create_input_field_label_slot$1]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < attrlist_spread_levels.length; i2 += 1) {
    attrlist_props = assign(attrlist_props, attrlist_spread_levels[i2]);
  }
  attrlist = new AttrList({ props: attrlist_props });
  return {
    c() {
      create_component(attrlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(attrlist, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const attrlist_changes = dirty & 1 ? get_spread_update(attrlist_spread_levels, [attrlist_spread_levels[0], get_spread_object(ctx2[0])]) : {};
      if (dirty & 2) {
        attrlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      attrlist.$set(attrlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attrlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attrlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(attrlist, detaching);
    }
  };
}
function instance$51($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Emails extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$51, create_fragment$5c, safe_not_equal, {});
  }
}
function create_header_slot$s(ctx) {
  let t;
  return {
    c() {
      t = text("Manage Emails");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$1z(ctx) {
  let emails;
  let current;
  emails = new Emails({ props: { onSieveOptions: true } });
  return {
    c() {
      create_component(emails.$$.fragment);
    },
    m(target, anchor) {
      mount_component(emails, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(emails.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(emails.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(emails, detaching);
    }
  };
}
function create_fragment$5b(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      bodyStyle: "--bs-modal-padding:0",
      $$slots: {
        default: [create_default_slot$1z],
        header: [create_header_slot$s]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[0]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 2) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$50($$self) {
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  return [close_handler];
}
class ManageEmailModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$50, create_fragment$5b, safe_not_equal, {});
  }
}
function create_input_field_label_slot(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Add phone number";
      attr(div, "class", "col-md-4 fw6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_input_field_help_slot(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "Number including ISD code: +19999999999";
      attr(small, "class", "help-block");
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment$5a(ctx) {
  let attrlist;
  let current;
  const attrlist_spread_levels = [{ type: "phone" }, ctx[0]];
  let attrlist_props = {
    $$slots: {
      "input-field-help": [create_input_field_help_slot],
      "input-field-label": [create_input_field_label_slot]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < attrlist_spread_levels.length; i2 += 1) {
    attrlist_props = assign(attrlist_props, attrlist_spread_levels[i2]);
  }
  attrlist = new AttrList({ props: attrlist_props });
  return {
    c() {
      create_component(attrlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(attrlist, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const attrlist_changes = dirty & 1 ? get_spread_update(attrlist_spread_levels, [attrlist_spread_levels[0], get_spread_object(ctx2[0])]) : {};
      if (dirty & 2) {
        attrlist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      attrlist.$set(attrlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(attrlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(attrlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(attrlist, detaching);
    }
  };
}
function instance$4$($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Phones extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4$, create_fragment$5a, safe_not_equal, {});
  }
}
function create_header_slot$r(ctx) {
  let t;
  return {
    c() {
      t = text("Manage Phones");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$1y(ctx) {
  let phones;
  let current;
  phones = new Phones({ props: { onSieveOptions: true } });
  return {
    c() {
      create_component(phones.$$.fragment);
    },
    m(target, anchor) {
      mount_component(phones, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(phones.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(phones.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(phones, detaching);
    }
  };
}
function create_fragment$59(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      bodyStyle: "--bs-modal-padding:0",
      $$slots: {
        default: [create_default_slot$1y],
        header: [create_header_slot$r]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[0]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 2) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$4_($$self) {
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  return [close_handler];
}
class ManagePhonesModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4_, create_fragment$59, safe_not_equal, {});
  }
}
const get_icon_slot_changes = (dirty) => ({});
const get_icon_slot_context = (ctx) => ({ slot: "icon" });
const get_label_pre_slot_changes$1 = (dirty) => ({});
const get_label_pre_slot_context$1 = (ctx) => ({ slot: "label-pre" });
const get_item_right_slot_changes = (dirty) => ({ item: dirty & 8388608 });
const get_item_right_slot_context = (ctx) => ({
  slot: "item-right",
  item: ctx[23]
});
const get_item_icon_slot_changes = (dirty) => ({ item: dirty & 8388608 });
const get_item_icon_slot_context = (ctx) => ({
  slot: "item-icon",
  item: ctx[23]
});
const get_item_bottom_slot_changes = (dirty) => ({ item: dirty & 8388608 });
const get_item_bottom_slot_context = (ctx) => ({
  slot: "item-bottom",
  item: ctx[23]
});
const get_bottom_slot_changes$1 = (dirty) => ({});
const get_bottom_slot_context$1 = (ctx) => ({ slot: "bottom" });
function create_icon_slot$4(ctx) {
  let current;
  const icon_slot_template = ctx[13].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[21], get_icon_slot_context);
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(icon_slot_template, ctx2[21], dirty, get_icon_slot_changes),
            get_icon_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_label_pre_slot$5(ctx) {
  let current;
  const label_pre_slot_template = ctx[13]["label-pre"];
  const label_pre_slot = create_slot(label_pre_slot_template, ctx, ctx[21], get_label_pre_slot_context$1);
  return {
    c() {
      if (label_pre_slot)
        label_pre_slot.c();
    },
    m(target, anchor) {
      if (label_pre_slot) {
        label_pre_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_pre_slot) {
        if (label_pre_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            label_pre_slot,
            label_pre_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(label_pre_slot_template, ctx2[21], dirty, get_label_pre_slot_changes$1),
            get_label_pre_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_pre_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_pre_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_pre_slot)
        label_pre_slot.d(detaching);
    }
  };
}
function create_top_slot$3(ctx) {
  let li;
  let div;
  let input_1;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      div = element("div");
      input_1 = element("input");
      attr(input_1, "type", "text");
      attr(input_1, "class", "mx-2 my-2 flex-grow-1 form-control");
      attr(input_1, "placeholder", "Search");
      attr(div, "class", "d-flex");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div);
      append(div, input_1);
      ctx[15](input_1);
      if (!mounted) {
        dispose = [
          listen(input_1, "input", ctx[16]),
          listen(div, "click", prevent_default(ctx[14]))
        ];
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li);
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_item_right_slot$4(ctx) {
  let current;
  const item_right_slot_template = ctx[13]["item-right"];
  const item_right_slot = create_slot(item_right_slot_template, ctx, ctx[21], get_item_right_slot_context);
  return {
    c() {
      if (item_right_slot)
        item_right_slot.c();
    },
    m(target, anchor) {
      if (item_right_slot) {
        item_right_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (item_right_slot) {
        if (item_right_slot.p && (!current || dirty & 10485760)) {
          update_slot_base(
            item_right_slot,
            item_right_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(item_right_slot_template, ctx2[21], dirty, get_item_right_slot_changes),
            get_item_right_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(item_right_slot, local);
      current = true;
    },
    o(local) {
      transition_out(item_right_slot, local);
      current = false;
    },
    d(detaching) {
      if (item_right_slot)
        item_right_slot.d(detaching);
    }
  };
}
function create_item_icon_slot$1(ctx) {
  let current;
  const item_icon_slot_template = ctx[13]["item-icon"];
  const item_icon_slot = create_slot(item_icon_slot_template, ctx, ctx[21], get_item_icon_slot_context);
  return {
    c() {
      if (item_icon_slot)
        item_icon_slot.c();
    },
    m(target, anchor) {
      if (item_icon_slot) {
        item_icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (item_icon_slot) {
        if (item_icon_slot.p && (!current || dirty & 10485760)) {
          update_slot_base(
            item_icon_slot,
            item_icon_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(item_icon_slot_template, ctx2[21], dirty, get_item_icon_slot_changes),
            get_item_icon_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(item_icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(item_icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (item_icon_slot)
        item_icon_slot.d(detaching);
    }
  };
}
function create_item_bottom_slot(ctx) {
  let current;
  const item_bottom_slot_template = ctx[13]["item-bottom"];
  const item_bottom_slot = create_slot(item_bottom_slot_template, ctx, ctx[21], get_item_bottom_slot_context);
  return {
    c() {
      if (item_bottom_slot)
        item_bottom_slot.c();
    },
    m(target, anchor) {
      if (item_bottom_slot) {
        item_bottom_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (item_bottom_slot) {
        if (item_bottom_slot.p && (!current || dirty & 10485760)) {
          update_slot_base(
            item_bottom_slot,
            item_bottom_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(item_bottom_slot_template, ctx2[21], dirty, get_item_bottom_slot_changes),
            get_item_bottom_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(item_bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(item_bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (item_bottom_slot)
        item_bottom_slot.d(detaching);
    }
  };
}
function create_bottom_slot$a(ctx) {
  let current;
  const bottom_slot_template = ctx[13].bottom;
  const bottom_slot = create_slot(bottom_slot_template, ctx, ctx[21], get_bottom_slot_context$1);
  return {
    c() {
      if (bottom_slot)
        bottom_slot.c();
    },
    m(target, anchor) {
      if (bottom_slot) {
        bottom_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (bottom_slot) {
        if (bottom_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            bottom_slot,
            bottom_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(bottom_slot_template, ctx2[21], dirty, get_bottom_slot_changes$1),
            get_bottom_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (bottom_slot)
        bottom_slot.d(detaching);
    }
  };
}
function create_fragment$58(ctx) {
  var _a;
  let menu;
  let updating_id;
  let current;
  const menu_spread_levels = [
    { toggle: false },
    {
      items: (_a = ctx[5]) != null ? _a : ctx[1]
    },
    { showError: ctx[3] },
    ctx[10],
    { strategy: ctx[4] }
  ];
  function menu_id_binding(value) {
    ctx[17](value);
  }
  let menu_props = {
    $$slots: {
      bottom: [create_bottom_slot$a],
      "item-bottom": [
        create_item_bottom_slot,
        ({ item }) => ({ 23: item }),
        ({ item }) => item ? 8388608 : 0
      ],
      "item-icon": [
        create_item_icon_slot$1,
        ({ item }) => ({ 23: item }),
        ({ item }) => item ? 8388608 : 0
      ],
      "item-right": [
        create_item_right_slot$4,
        ({ item }) => ({ 23: item }),
        ({ item }) => item ? 8388608 : 0
      ],
      top: [create_top_slot$3],
      "label-pre": [create_label_pre_slot$5],
      icon: [create_icon_slot$4]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < menu_spread_levels.length; i2 += 1) {
    menu_props = assign(menu_props, menu_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    menu_props.id = ctx[0];
  }
  menu = new Menu({ props: menu_props });
  binding_callbacks.push(() => bind$1(menu, "id", menu_id_binding));
  menu.$on("open", ctx[18]);
  menu.$on("open", ctx[8]);
  menu.$on("close", ctx[19]);
  menu.$on("close", ctx[9]);
  menu.$on("select", ctx[20]);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      const menu_changes = dirty & 1082 ? get_spread_update(menu_spread_levels, [
        menu_spread_levels[0],
        dirty & 34 && {
          items: (_a2 = ctx2[5]) != null ? _a2 : ctx2[1]
        },
        dirty & 8 && { showError: ctx2[3] },
        dirty & 1024 && get_spread_object(ctx2[10]),
        dirty & 16 && { strategy: ctx2[4] }
      ]) : {};
      if (dirty & 10485952) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        menu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$4Z($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "items", "field", "useLocalSearch", "showError", "strategy"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $field, $$unsubscribe_field = noop$1, $$subscribe_field = () => ($$unsubscribe_field(), $$unsubscribe_field = subscribe(field, ($$value) => $$invalidate(12, $field = $$value)), field);
  $$self.$$.on_destroy.push(() => $$unsubscribe_field());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id: id2 = null } = $$props;
  let { items = [] } = $$props;
  let { field = void 0 } = $$props;
  $$subscribe_field();
  let { useLocalSearch = false } = $$props;
  let { showError = false } = $$props;
  let { strategy } = $$props;
  let filteredItems = null;
  let onSearch = null;
  if (useLocalSearch) {
    onSearch = (val) => {
      let query = val.toLowerCase();
      $$invalidate(5, filteredItems = items.filter((item) => item.name.toLowerCase().includes(query)));
    };
  } else {
    onSearch = (val) => {
      dispatch("search", val);
    };
  }
  const dispatch = createEventDispatcher();
  let input;
  function focus() {
    setTimeout(() => input == null ? void 0 : input.focus(), 100);
  }
  function onClose() {
    onSearch("");
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(7, input);
    });
  }
  const input_handler = (e) => {
    const query = e.target.value.trim();
    onSearch(query);
  };
  function menu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2), $$invalidate(2, field), $$invalidate(12, $field);
  }
  function open_handler(event) {
    bubble.call(this, $$self, event);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  function select_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("items" in $$new_props)
      $$invalidate(1, items = $$new_props.items);
    if ("field" in $$new_props)
      $$subscribe_field($$invalidate(2, field = $$new_props.field));
    if ("useLocalSearch" in $$new_props)
      $$invalidate(11, useLocalSearch = $$new_props.useLocalSearch);
    if ("showError" in $$new_props)
      $$invalidate(3, showError = $$new_props.showError);
    if ("strategy" in $$new_props)
      $$invalidate(4, strategy = $$new_props.strategy);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4100) {
      field && $$invalidate(0, id2 = $field);
    }
  };
  return [
    id2,
    items,
    field,
    showError,
    strategy,
    filteredItems,
    onSearch,
    input,
    focus,
    onClose,
    $$restProps,
    useLocalSearch,
    $field,
    slots,
    click_handler,
    input_1_binding,
    input_handler,
    menu_id_binding,
    open_handler,
    close_handler,
    select_handler,
    $$scope
  ];
}
class SearchableMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4Z, create_fragment$58, safe_not_equal, {
      id: 0,
      items: 1,
      field: 2,
      useLocalSearch: 11,
      showError: 3,
      strategy: 4
    });
  }
}
function create_fragment$57(ctx) {
  let div;
  let input0;
  let t0;
  let input1;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 col-center-block" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>`;
      attr(input0, "type", "text");
      attr(input0, "class", "form-control flex-grow-1 flex-shrink-1 input-sm mr-2 w-auto");
      attr(input0, "placeholder", "Key");
      attr(input1, "type", "text");
      attr(input1, "class", "form-control flex-grow-1 flex-shrink-1 input-sm mr-2 w-auto");
      attr(input1, "placeholder", "Value");
      attr(button, "class", "btn btn-default btn-sm flex items-center");
      attr(button, "title", "Delete");
      attr(div, "class", "flex flex-row item-center mb-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input0);
      set_input_value(input0, ctx[0]);
      append(div, t0);
      append(div, input1);
      set_input_value(input1, ctx[1]);
      append(div, t1);
      append(div, button);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[9]),
          listen(input0, "input", ctx[10]),
          listen(input1, "input", ctx[11]),
          listen(input1, "input", ctx[12]),
          listen(button, "click", function() {
            if (is_function(ctx[2]))
              ctx[2].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & 1 && input0.value !== ctx[0]) {
        set_input_value(input0, ctx[0]);
      }
      if (dirty & 2 && input1.value !== ctx[1]) {
        set_input_value(input1, ctx[1]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4Y($$self, $$props, $$invalidate) {
  let $valueField;
  let $keyField;
  const dispatch = createEventDispatcher();
  let { model } = $$props;
  let { key } = $$props;
  let { value } = $$props;
  let { onRemove } = $$props;
  const keyField = model == null ? void 0 : model.fields.key;
  component_subscribe($$self, keyField, (value2) => $$invalidate(8, $keyField = value2));
  const valueField = model == null ? void 0 : model.fields.value;
  component_subscribe($$self, valueField, (value2) => $$invalidate(7, $valueField = value2));
  function input0_input_handler() {
    key = this.value;
    $$invalidate(0, key), $$invalidate(8, $keyField), $$invalidate(7, $valueField);
  }
  const input_handler = (e) => dispatch("keyUpdate", $$invalidate(0, key = e.target.value));
  function input1_input_handler() {
    value = this.value;
    $$invalidate(1, value), $$invalidate(8, $keyField), $$invalidate(7, $valueField);
  }
  const input_handler_1 = (e) => dispatch("valueUpdate", $$invalidate(1, value = e.target.value));
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(6, model = $$props2.model);
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("onRemove" in $$props2)
      $$invalidate(2, onRemove = $$props2.onRemove);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 384) {
      {
        if (keyField && valueField) {
          $$invalidate(0, key = $keyField);
          $$invalidate(1, value = $valueField);
        }
      }
    }
  };
  return [
    key,
    value,
    onRemove,
    dispatch,
    keyField,
    valueField,
    model,
    $valueField,
    $keyField,
    input0_input_handler,
    input_handler,
    input1_input_handler,
    input_handler_1
  ];
}
class KeyValueTable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4Y, create_fragment$57, safe_not_equal, { model: 6, key: 0, value: 1, onRemove: 2 });
  }
}
function create_fragment$56(ctx) {
  let li;
  let a;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let a_levels = [{ href: ctx[0] }, ctx[1]];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & 1) && { href: ctx2[0] },
        dirty & 2 && ctx2[1]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$4X($$self, $$props, $$invalidate) {
  const omit_props_names = ["href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { href: href2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("href" in $$new_props)
      $$invalidate(0, href2 = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  return [href2, $$restProps, $$scope, slots];
}
class MenuItemLink extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4X, create_fragment$56, safe_not_equal, { href: 0 });
  }
}
function create_icon_slot$3(ctx) {
  let t;
  return {
    c() {
      t = text("\u{1F464}");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_label_pre_slot$4(ctx) {
  let t;
  return {
    c() {
      t = text("Profile -");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$s(ctx) {
  let t;
  return {
    c() {
      t = text("Manage Profiles");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$1x(ctx) {
  let t;
  return {
    c() {
      t = text("Learn More");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_bottom_slot$9(ctx) {
  let li;
  let t0;
  let menuitemlink0;
  let t1;
  let menuitemlink1;
  let current;
  menuitemlink0 = new MenuItemLink({
    props: {
      class: "dropdown-item",
      href: "#/w/" + ctx[2].team + "/profiles/",
      target: "_blank",
      $$slots: { default: [create_default_slot_1$s] },
      $$scope: { ctx }
    }
  });
  menuitemlink1 = new MenuItemLink({
    props: {
      class: "dropdown-item",
      href: urlCfg.website + "/docs/web-monitor/profiles-for-cloud-monitors",
      target: "_blank",
      $$slots: { default: [create_default_slot$1x] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      li = element("li");
      t0 = space();
      create_component(menuitemlink0.$$.fragment);
      t1 = space();
      create_component(menuitemlink1.$$.fragment);
      attr(li, "class", "dropdown-divider");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      insert(target, t0, anchor);
      mount_component(menuitemlink0, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitemlink1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemlink0_changes = {};
      if (dirty & 4)
        menuitemlink0_changes.href = "#/w/" + ctx2[2].team + "/profiles/";
      if (dirty & 16384) {
        menuitemlink0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemlink0.$set(menuitemlink0_changes);
      const menuitemlink1_changes = {};
      if (dirty & 16384) {
        menuitemlink1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemlink1.$set(menuitemlink1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemlink0.$$.fragment, local);
      transition_in(menuitemlink1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemlink0.$$.fragment, local);
      transition_out(menuitemlink1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t0);
      destroy_component(menuitemlink0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitemlink1, detaching);
    }
  };
}
function create_fragment$55(ctx) {
  let searchablemenu;
  let updating_id;
  let current;
  const searchablemenu_spread_levels = [
    { title: "Select Session" },
    { items: ctx[1] },
    ctx[6]
  ];
  function searchablemenu_id_binding(value) {
    ctx[8](value);
  }
  let searchablemenu_props = {
    $$slots: {
      bottom: [create_bottom_slot$9],
      "label-pre": [create_label_pre_slot$4],
      icon: [create_icon_slot$3]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < searchablemenu_spread_levels.length; i2 += 1) {
    searchablemenu_props = assign(searchablemenu_props, searchablemenu_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    searchablemenu_props.id = ctx[0];
  }
  searchablemenu = new SearchableMenu({ props: searchablemenu_props });
  binding_callbacks.push(() => bind$1(searchablemenu, "id", searchablemenu_id_binding));
  searchablemenu.$on("close", ctx[5]);
  searchablemenu.$on("search", ctx[3]);
  searchablemenu.$on("select", ctx[4]);
  return {
    c() {
      create_component(searchablemenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchablemenu_changes = dirty & 66 ? get_spread_update(searchablemenu_spread_levels, [
        searchablemenu_spread_levels[0],
        dirty & 2 && { items: ctx2[1] },
        dirty & 64 && get_spread_object(ctx2[6])
      ]) : {};
      if (dirty & 16388) {
        searchablemenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        searchablemenu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      searchablemenu.$set(searchablemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemenu, detaching);
    }
  };
}
function instance$4W($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "session"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(2, $route = $$value));
  const dispatch = createEventDispatcher();
  let { id: id2 } = $$props;
  let { session } = $$props;
  let initSessions;
  let items = [];
  init2();
  async function init2() {
    initSessions = $$invalidate(1, items = await getSessions());
    await addSelected();
  }
  async function onSearch(e) {
    $$invalidate(1, items = await getSessions(e.detail));
  }
  async function getSessions(phrase = "") {
    const query = {
      _opt: { only: ["id", "name", "cookies"] }
    };
    if (phrase) {
      query["name.ilike"] = `%${phrase}%`;
    }
    const res = await Api.api("/sessions", query);
    return res.data;
  }
  async function addSelected() {
    if (!id2 || initSessions.find((s) => s.id === id2)) {
      return;
    }
    const item = await Api.api(`/sessions/${id2}`);
    $$invalidate(1, items = [item, ...initSessions]);
  }
  async function onSelect() {
    await addSelected();
    if (!id2) {
      return dispatch("select");
    }
    const selectedItem = items.find((session2) => session2.id === id2);
    dispatch("select", selectedItem);
  }
  async function resetSessions() {
    if (!id2 || initSessions.find((m) => m.id === id2)) {
      $$invalidate(1, items = initSessions);
    } else if (id2) {
      const s = items.find((m) => m.id === id2);
      $$invalidate(1, items = [s, ...initSessions]);
    }
  }
  function searchablemenu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("session" in $$new_props)
      $$invalidate(7, session = $$new_props.session);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $$invalidate(7, session = items.find((item) => item.id == id2));
    }
  };
  return [
    id2,
    items,
    $route,
    onSearch,
    onSelect,
    resetSessions,
    $$restProps,
    session,
    searchablemenu_id_binding
  ];
}
class SelectSession extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4W, create_fragment$55, safe_not_equal, { id: 0, session: 7 });
  }
}
const LS_PROXIES_USED = "PROXIES_USED";
async function getProxies() {
  let proxies = (await Api.api("/proxies/global")).data;
  proxies = proxies.map((p) => {
    p.disabled = !p.available;
    p.title = p.msgUpgrade;
    p.grade = -1;
    return p;
  });
  let customProxies = (await Api.api("/proxies")).data;
  customProxies = customProxies.map((p) => ({ ...p, available: true }));
  const allProxies = [...customProxies, ...proxies];
  const lastUsedProxies = getLastUsedProxies();
  if (!lastUsedProxies || lastUsedProxies.length === 0) {
    return allProxies;
  }
  return sortProxiesUsingLastUsed(allProxies);
}
function sortProxiesUsingLastUsed(proxies) {
  const lastUsedProxyIds = getLastUsedProxies() || [];
  const lastUsedIdSet = new Set(lastUsedProxyIds);
  const lastUsedProxies = lastUsedProxyIds.map((id2) => proxies.find((p) => p.id === id2)).filter(Boolean);
  const otherProxies = proxies.filter((p) => !lastUsedIdSet.has(p.id));
  const allProxies = [...lastUsedProxies, ...otherProxies];
  allProxies.forEach((p, i2) => {
    p.lastUsed = lastUsedIdSet.has(p.id);
  });
  return allProxies;
}
function getProxyIconClass(proxy) {
  return C$1.PROXY_REGION_ICONS_CLASS_NAMES[proxy.region] || C$1.PROXY_REGION_ICONS_CLASS_NAMES.WORLD;
}
async function getRegionProxyForURL(url) {
  return await Api.api("/proxies/region", "POST", { url });
}
function setLastUsedProxy(proxyId) {
  const Store2 = window.App.store;
  const proxiesUsed = Store2.get(LS_PROXIES_USED) || [];
  if (proxiesUsed.includes(proxyId)) {
    return;
  }
  if (proxiesUsed.length > 1) {
    proxiesUsed.pop();
  }
  proxiesUsed.unshift(proxyId);
  Store2.set(LS_PROXIES_USED, proxiesUsed);
}
function getLastUsedProxies() {
  const Store2 = window.App.store;
  return Store2.get(LS_PROXIES_USED);
}
function create_fragment$54(ctx) {
  let div;
  let span;
  let div_class_value;
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = "Loading...";
      attr(span, "class", "visually-hidden");
      attr(div, "class", div_class_value = "spinner-border " + ctx[0]);
      attr(div, "role", "status");
      attr(div, "style", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && div_class_value !== (div_class_value = "spinner-border " + ctx2[0])) {
        attr(div, "class", div_class_value);
      }
      if (dirty & 2) {
        attr(div, "style", ctx2[1]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function generateStyle(size2) {
  switch (size2) {
    case "sm":
      return "width: 1rem; height: 1rem; border-width: 0.15em;";
    case "lg":
      return "width: 2rem; height: 2rem; border-width: 0.25em;";
    case "md":
    default:
      return "width: 1.5rem; height: 1.5rem; border-width: 0.25em;";
  }
}
function instance$4V($$self, $$props, $$invalidate) {
  let { class: clazz = "text-primary" } = $$props;
  let { size: size2 = "sm" } = $$props;
  let style = generateStyle(size2);
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, clazz = $$props2.class);
    if ("size" in $$props2)
      $$invalidate(2, size2 = $$props2.size);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(1, style = generateStyle(size2));
    }
  };
  return [clazz, style, size2];
}
class Spinner extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4V, create_fragment$54, safe_not_equal, { class: 0, size: 2 });
  }
}
function create_catch_block$H(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$H(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block_1$1O;
    return create_else_block$1w;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$1w(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = "assets/icons/ic_ip.svg"))
        attr(img, "src", img_src_value);
      attr(img, "height", "20px");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block_1$1O(ctx) {
  let span;
  let span_class_value;
  return {
    c() {
      span = element("span");
      attr(span, "class", span_class_value = "fi " + getProxyIconClass(ctx[1]));
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && span_class_value !== (span_class_value = "fi " + getProxyIconClass(ctx2[1]))) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_pending_block$H(ctx) {
  let spinner;
  let current;
  spinner = new Spinner({ props: { class: "spinner-border-sm" } });
  return {
    c() {
      create_component(spinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spinner, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spinner, detaching);
    }
  };
}
function create_icon_slot$2(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$H,
    then: create_then_block$H,
    catch: create_catch_block$H,
    value: 11,
    blocks: [, , ,]
  };
  handle_promise(ctx[4], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_label_pre_slot$3(ctx) {
  let t;
  return {
    c() {
      t = text("Proxy -");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_item_icon_slot(ctx) {
  let span;
  let span_class_value;
  return {
    c() {
      span = element("span");
      attr(span, "class", span_class_value = "fi " + getProxyIconClass(ctx[10]) + " me-1");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && span_class_value !== (span_class_value = "fi " + getProxyIconClass(ctx2[10]) + " me-1")) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block$2V(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Used Recently";
      attr(span, "class", "ms-1");
      set_style(span, "font-size", "0.75rem");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_item_right_slot$3(ctx) {
  let if_block_anchor;
  let if_block = ctx[10].lastUsed && create_if_block$2V();
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[10].lastUsed) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$2V();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_bottom_slot$8(ctx) {
  let li0;
  let t0;
  let li1;
  let a0;
  let t1;
  let a0_href_value;
  let t2;
  let li2;
  let a1;
  let t3;
  return {
    c() {
      li0 = element("li");
      t0 = space();
      li1 = element("li");
      a0 = element("a");
      t1 = text("Manage Proxies");
      t2 = space();
      li2 = element("li");
      a1 = element("a");
      t3 = text("Learn More");
      attr(li0, "class", "dropdown-divider");
      attr(a0, "class", "dropdown-item");
      attr(a0, "href", a0_href_value = "#/w/" + ctx[3].team + "/proxies/");
      attr(a0, "target", "_blank");
      attr(a1, "class", "dropdown-item");
      attr(a1, "href", urlCfg.website + "/docs/web-monitor/monitor-webpage-using-proxy-servers/");
      attr(a1, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      insert(target, t0, anchor);
      insert(target, li1, anchor);
      append(li1, a0);
      append(a0, t1);
      insert(target, t2, anchor);
      insert(target, li2, anchor);
      append(li2, a1);
      append(a1, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && a0_href_value !== (a0_href_value = "#/w/" + ctx2[3].team + "/proxies/")) {
        attr(a0, "href", a0_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(li1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(li2);
    }
  };
}
function create_fragment$53(ctx) {
  let searchablemenu;
  let updating_id;
  let current;
  const searchablemenu_spread_levels = [
    { useLocalSearch: true },
    { items: ctx[2] },
    { defaultActionLabel: "Shared Pool" },
    { toggle: false },
    { "data-bs-placement": "left" },
    ctx[6]
  ];
  function searchablemenu_id_binding(value) {
    ctx[7](value);
  }
  let searchablemenu_props = {
    $$slots: {
      bottom: [create_bottom_slot$8],
      "item-right": [
        create_item_right_slot$3,
        ({ item }) => ({ 10: item }),
        ({ item }) => item ? 1024 : 0
      ],
      "item-icon": [
        create_item_icon_slot,
        ({ item }) => ({ 10: item }),
        ({ item }) => item ? 1024 : 0
      ],
      "label-pre": [create_label_pre_slot$3],
      icon: [create_icon_slot$2]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < searchablemenu_spread_levels.length; i2 += 1) {
    searchablemenu_props = assign(searchablemenu_props, searchablemenu_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    searchablemenu_props.id = ctx[0];
  }
  searchablemenu = new SearchableMenu({ props: searchablemenu_props });
  binding_callbacks.push(() => bind$1(searchablemenu, "id", searchablemenu_id_binding));
  searchablemenu.$on("select", ctx[8]);
  return {
    c() {
      create_component(searchablemenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchablemenu_changes = dirty & 68 ? get_spread_update(searchablemenu_spread_levels, [
        searchablemenu_spread_levels[0],
        dirty & 4 && { items: ctx2[2] },
        searchablemenu_spread_levels[2],
        searchablemenu_spread_levels[3],
        searchablemenu_spread_levels[4],
        dirty & 64 && get_spread_object(ctx2[6])
      ]) : {};
      if (dirty & 5130) {
        searchablemenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        searchablemenu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      searchablemenu.$set(searchablemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemenu, detaching);
    }
  };
}
function instance$4U($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "proxy"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(3, $route = $$value));
  let { id: id2 } = $$props;
  let { proxy } = $$props;
  let items = [];
  const dispatch = createEventDispatcher();
  const proxyFetchPromise = getProxies();
  proxyFetchPromise.then((_items) => {
    $$invalidate(2, items = _items);
  });
  function handleSelect(event) {
    const selectedProxyId = event.detail;
    setLastUsedProxy(selectedProxyId);
    $$invalidate(2, items = sortProxiesUsingLastUsed(items));
    dispatch("select", selectedProxyId);
  }
  function searchablemenu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  const select_handler = (e) => handleSelect(e);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("proxy" in $$new_props)
      $$invalidate(1, proxy = $$new_props.proxy);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 5) {
      $$invalidate(1, proxy = items.find((item) => item.id === id2));
    }
  };
  return [
    id2,
    proxy,
    items,
    $route,
    proxyFetchPromise,
    handleSelect,
    $$restProps,
    searchablemenu_id_binding,
    select_handler
  ];
}
class SelectProxy extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4U, create_fragment$53, safe_not_equal, { id: 0, proxy: 1 });
  }
}
const get_url_r_slot_changes = (dirty) => ({});
const get_url_r_slot_context = (ctx) => ({});
const get_addons_slot_changes = (dirty) => ({});
const get_addons_slot_context = (ctx) => ({});
function create_if_block_1$1N(ctx) {
  let selectsession;
  let updating_id;
  let current;
  function selectsession_id_binding(value) {
    ctx[15](value);
  }
  let selectsession_props = {
    class: "input-group-text",
    actionClass: "text-secondary-emphasis"
  };
  if (ctx[7].session_id !== void 0) {
    selectsession_props.id = ctx[7].session_id;
  }
  selectsession = new SelectSession({ props: selectsession_props });
  binding_callbacks.push(() => bind$1(selectsession, "id", selectsession_id_binding));
  return {
    c() {
      create_component(selectsession.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectsession, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectsession_changes = {};
      if (!updating_id && dirty & 128) {
        updating_id = true;
        selectsession_changes.id = ctx2[7].session_id;
        add_flush_callback(() => updating_id = false);
      }
      selectsession.$set(selectsession_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectsession.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectsession.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectsession, detaching);
    }
  };
}
function create_if_block$2U(ctx) {
  let selectproxy;
  let updating_id;
  let current;
  function selectproxy_id_binding(value) {
    ctx[17](value);
  }
  let selectproxy_props = {
    class: "input-group-text min-w-max p-0",
    actionClass: "text-secondary-emphasis"
  };
  if (ctx[7].proxy_id !== void 0) {
    selectproxy_props.id = ctx[7].proxy_id;
  }
  selectproxy = new SelectProxy({ props: selectproxy_props });
  binding_callbacks.push(() => bind$1(selectproxy, "id", selectproxy_id_binding));
  return {
    c() {
      create_component(selectproxy.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectproxy, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectproxy_changes = {};
      if (!updating_id && dirty & 128) {
        updating_id = true;
        selectproxy_changes.id = ctx2[7].proxy_id;
        add_flush_callback(() => updating_id = false);
      }
      selectproxy.$set(selectproxy_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectproxy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectproxy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectproxy, detaching);
    }
  };
}
function fallback_block$a(ctx) {
  let button;
  let t_value = TXT(ctx[3]) + "";
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", "btn btn-success");
      button.disabled = button_disabled_value = ctx[8] || ctx[0];
      toggle_class(button, "d-none", ctx[6]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[18]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = TXT(ctx2[3]) + ""))
        set_data(t, t_value);
      if (dirty & 257 && button_disabled_value !== (button_disabled_value = ctx2[8] || ctx2[0])) {
        button.disabled = button_disabled_value;
      }
      if (dirty & 64) {
        toggle_class(button, "d-none", ctx2[6]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$52(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let urledit;
  let t2;
  let t3;
  let current;
  let if_block0 = ctx[4] && create_if_block_1$1N(ctx);
  const addons_slot_template = ctx[14].addons;
  const addons_slot = create_slot(addons_slot_template, ctx, ctx[13], get_addons_slot_context);
  const urledit_spread_levels = [{ field: ctx[2] }, ctx[11]];
  let urledit_props = {};
  for (let i2 = 0; i2 < urledit_spread_levels.length; i2 += 1) {
    urledit_props = assign(urledit_props, urledit_spread_levels[i2]);
  }
  urledit = new UrlEdit({ props: urledit_props });
  urledit.$on("input", ctx[16]);
  let if_block1 = ctx[5] && !ctx[6] && create_if_block$2U(ctx);
  const url_r_slot_template = ctx[14]["url-r"];
  const url_r_slot = create_slot(url_r_slot_template, ctx, ctx[13], get_url_r_slot_context);
  const url_r_slot_or_fallback = url_r_slot || fallback_block$a(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (addons_slot)
        addons_slot.c();
      t1 = space();
      create_component(urledit.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (url_r_slot_or_fallback)
        url_r_slot_or_fallback.c();
      attr(div0, "class", "input-group");
      attr(div1, "class", "d-flex");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      if (addons_slot) {
        addons_slot.m(div0, null);
      }
      append(div0, t1);
      mount_component(urledit, div0, null);
      append(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      append(div0, t3);
      if (url_r_slot_or_fallback) {
        url_r_slot_or_fallback.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[4]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$1N(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (addons_slot) {
        if (addons_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            addons_slot,
            addons_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(addons_slot_template, ctx2[13], dirty, get_addons_slot_changes),
            get_addons_slot_context
          );
        }
      }
      const urledit_changes = dirty & 2052 ? get_spread_update(urledit_spread_levels, [
        dirty & 4 && { field: ctx2[2] },
        dirty & 2048 && get_spread_object(ctx2[11])
      ]) : {};
      urledit.$set(urledit_changes);
      if (ctx2[5] && !ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 96) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$2U(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (url_r_slot) {
        if (url_r_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            url_r_slot,
            url_r_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(url_r_slot_template, ctx2[13], dirty, get_url_r_slot_changes),
            get_url_r_slot_context
          );
        }
      } else {
        if (url_r_slot_or_fallback && url_r_slot_or_fallback.p && (!current || dirty & 329)) {
          url_r_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(addons_slot, local);
      transition_in(urledit.$$.fragment, local);
      transition_in(if_block1);
      transition_in(url_r_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(addons_slot, local);
      transition_out(urledit.$$.fragment, local);
      transition_out(if_block1);
      transition_out(url_r_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (addons_slot)
        addons_slot.d(detaching);
      destroy_component(urledit);
      if (if_block1)
        if_block1.d();
      if (url_r_slot_or_fallback)
        url_r_slot_or_fallback.d(detaching);
    }
  };
}
function instance$4T($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "model",
    "uri",
    "label",
    "disableGo",
    "showSessionSelector",
    "showProxySelector",
    "configView"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $uri, $$unsubscribe_uri = noop$1, $$subscribe_uri = () => ($$unsubscribe_uri(), $$unsubscribe_uri = subscribe(uri, ($$value) => $$invalidate(12, $uri = $$value)), uri);
  let $model, $$unsubscribe_model = noop$1, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe(model, ($$value) => $$invalidate(7, $model = $$value)), model);
  let $error;
  $$self.$$.on_destroy.push(() => $$unsubscribe_uri());
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { model } = $$props;
  $$subscribe_model();
  let { uri } = $$props;
  $$subscribe_uri();
  let { label = "a_go" } = $$props;
  let { disableGo } = $$props;
  let { showSessionSelector = !$model.content_type || $model.content_type === C$1.TYPE_HTML } = $$props;
  let { showProxySelector = !Supports.agents.local && (!$model.content_type || [C$1.TYPE_HTML, C$1.TYPE_JSON].includes($model.content_type)) } = $$props;
  let { configView = false } = $$props;
  const { error: error2 } = uri;
  component_subscribe($$self, error2, (value) => $$invalidate(8, $error = value));
  const dispatch = createEventDispatcher();
  let prevOrigin = null;
  async function getRegionProxy() {
    const uriObj = $uri;
    if (!uriObj || !uriObj.origin) {
      return;
    }
    if (uriObj.origin === prevOrigin) {
      return;
    }
    prevOrigin = uriObj.origin;
    try {
      $$invalidate(0, disableGo = true);
      const newProxy = await getRegionProxyForURL(uriObj.origin);
      model.set("proxy_id", (newProxy == null ? void 0 : newProxy.id) || null);
    } finally {
      $$invalidate(0, disableGo = false);
    }
  }
  function selectsession_id_binding(value) {
    if ($$self.$$.not_equal($model.session_id, value)) {
      $model.session_id = value;
      model.set($model);
    }
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function selectproxy_id_binding(value) {
    if ($$self.$$.not_equal($model.proxy_id, value)) {
      $model.proxy_id = value;
      model.set($model);
    }
  }
  const click_handler = () => dispatch("go");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("model" in $$new_props)
      $$subscribe_model($$invalidate(1, model = $$new_props.model));
    if ("uri" in $$new_props)
      $$subscribe_uri($$invalidate(2, uri = $$new_props.uri));
    if ("label" in $$new_props)
      $$invalidate(3, label = $$new_props.label);
    if ("disableGo" in $$new_props)
      $$invalidate(0, disableGo = $$new_props.disableGo);
    if ("showSessionSelector" in $$new_props)
      $$invalidate(4, showSessionSelector = $$new_props.showSessionSelector);
    if ("showProxySelector" in $$new_props)
      $$invalidate(5, showProxySelector = $$new_props.showProxySelector);
    if ("configView" in $$new_props)
      $$invalidate(6, configView = $$new_props.configView);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4096) {
      getRegionProxy();
    }
  };
  return [
    disableGo,
    model,
    uri,
    label,
    showSessionSelector,
    showProxySelector,
    configView,
    $model,
    $error,
    error2,
    dispatch,
    $$restProps,
    $uri,
    $$scope,
    slots,
    selectsession_id_binding,
    input_handler,
    selectproxy_id_binding,
    click_handler
  ];
}
class SelectorUrlEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4T, create_fragment$52, safe_not_equal, {
      model: 1,
      uri: 2,
      label: 3,
      disableGo: 0,
      showSessionSelector: 4,
      showProxySelector: 5,
      configView: 6
    });
  }
}
function get_each_context$1m(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[66] = list[i2];
  child_ctx[67] = list;
  child_ctx[68] = i2;
  return child_ctx;
}
function get_each_context_1$e(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[69] = list[i2];
  return child_ctx;
}
function get_each_context_2$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[66] = list[i2];
  child_ctx[72] = list;
  child_ctx[68] = i2;
  return child_ctx;
}
function get_each_context_3$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[66] = list[i2];
  child_ctx[68] = i2;
  return child_ctx;
}
function create_if_block_7$d(ctx) {
  let selectorurledit;
  let current;
  const selectorurledit_spread_levels = [
    { configView: ctx[5] },
    { model: ctx[15] },
    { uri: ctx[16] },
    { disableGo: ctx[4] },
    ctx[33]
  ];
  let selectorurledit_props = {
    $$slots: { addons: [create_addons_slot] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < selectorurledit_spread_levels.length; i2 += 1) {
    selectorurledit_props = assign(selectorurledit_props, selectorurledit_spread_levels[i2]);
  }
  selectorurledit = new SelectorUrlEdit({ props: selectorurledit_props });
  selectorurledit.$on("go", ctx[36]);
  selectorurledit.$on("input", ctx[37]);
  return {
    c() {
      create_component(selectorurledit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectorurledit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectorurledit_changes = dirty[0] & 98352 | dirty[1] & 4 ? get_spread_update(selectorurledit_spread_levels, [
        dirty[0] & 32 && { configView: ctx2[5] },
        dirty[0] & 32768 && { model: ctx2[15] },
        dirty[0] & 65536 && { uri: ctx2[16] },
        dirty[0] & 16 && { disableGo: ctx2[4] },
        dirty[1] & 4 && get_spread_object(ctx2[33])
      ]) : {};
      if (dirty[0] & 66 | dirty[2] & 4096) {
        selectorurledit_changes.$$scope = { dirty, ctx: ctx2 };
      }
      selectorurledit.$set(selectorurledit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectorurledit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectorurledit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectorurledit, detaching);
    }
  };
}
function create_if_block_8$8(ctx) {
  let menu;
  let updating_id;
  let current;
  function menu_id_binding(value) {
    ctx[35](value);
  }
  let menu_props = {
    title: "Request Method",
    items: ctx[18],
    allowNull: false,
    class: "input-group-addon min-w-max p-0 btn btn-default",
    actionClass: "btn btn-default border-0 "
  };
  if (ctx[6] !== void 0) {
    menu_props.id = ctx[6];
  }
  menu = new Menu({ props: menu_props });
  binding_callbacks.push(() => bind$1(menu, "id", menu_id_binding));
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menu_changes = {};
      if (!updating_id && dirty[0] & 64) {
        updating_id = true;
        menu_changes.id = ctx2[6];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function create_addons_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] && create_if_block_8$8(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_8$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$2T(ctx) {
  let ul;
  let li0;
  let a0;
  let t1;
  let li1;
  let a1;
  let t3;
  let t4;
  let t5;
  let div4;
  let div0;
  let t6;
  let button0;
  let t8;
  let div1;
  let t9;
  let button1;
  let t11;
  let div3;
  let div2;
  let label;
  let t13;
  let input;
  let t14;
  let t15;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[2] && create_if_block_6$l(ctx);
  let if_block1 = ctx[3] && create_if_block_5$r(ctx);
  let each_value_3 = ctx[9];
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value_2 = ctx[8];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block2 = ctx[2] && create_if_block_1$1M(ctx);
  return {
    c() {
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      a0.textContent = "Params";
      t1 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = "Header";
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      if (if_block1)
        if_block1.c();
      t5 = space();
      div4 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t6 = space();
      button0 = element("button");
      button0.textContent = "Add Query Param";
      t8 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t9 = space();
      button1 = element("button");
      button1.textContent = "Add Header";
      t11 = space();
      div3 = element("div");
      div2 = element("div");
      label = element("label");
      label.textContent = "Timeout";
      t13 = space();
      input = element("input");
      t14 = text(" secs");
      t15 = space();
      if (if_block2)
        if_block2.c();
      attr(a0, "class", "nav-link");
      attr(a0, "href", "#params_tab");
      attr(a0, "data-bs-toggle", "tab");
      toggle_class(a0, "active", ctx[10] === ctx[20].PARAMS);
      attr(li0, "class", "nav-item");
      attr(a1, "class", "nav-link");
      attr(a1, "href", "#header_tab");
      attr(a1, "data-bs-toggle", "tab");
      toggle_class(a1, "active", ctx[10] === ctx[20].HEADERS);
      attr(li1, "class", "nav-item");
      attr(ul, "class", "nav nav-tabs mt-2");
      attr(button0, "class", "btn btn-default btn-sm");
      attr(div0, "class", "tab-pane");
      attr(div0, "id", "params_tab");
      toggle_class(div0, "active", ctx[10] == ctx[20].PARAMS);
      attr(button1, "class", "btn btn-default btn-sm");
      attr(div1, "class", "tab-pane");
      attr(div1, "id", "header_tab");
      toggle_class(div1, "active", ctx[10] == ctx[20].HEADERS);
      attr(input, "type", "number");
      attr(input, "class", "w-20");
      attr(div2, "class", "mlb-3");
      attr(div3, "class", "tab-pane");
      attr(div3, "id", "options_tab");
      toggle_class(div3, "active", ctx[10] == ctx[20].OPTIONS);
      attr(div4, "class", "tab-content bg-white bb bl br border-bootstrap-border p-3");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      append(ul, li0);
      append(li0, a0);
      append(ul, t1);
      append(ul, li1);
      append(li1, a1);
      append(ul, t3);
      if (if_block0)
        if_block0.m(ul, null);
      append(ul, t4);
      if (if_block1)
        if_block1.m(ul, null);
      insert(target, t5, anchor);
      insert(target, div4, anchor);
      append(div4, div0);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(div0, null);
        }
      }
      append(div0, t6);
      append(div0, button0);
      append(div4, t8);
      append(div4, div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div1, t9);
      append(div1, button1);
      append(div4, t11);
      append(div4, div3);
      append(div3, div2);
      append(div2, label);
      append(div2, t13);
      append(div2, input);
      set_input_value(input, ctx[13].request.timeout);
      append(div2, t14);
      append(div4, t15);
      if (if_block2)
        if_block2.m(div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[38]),
          listen(a1, "click", ctx[39]),
          listen(button0, "click", ctx[27]),
          listen(button1, "click", ctx[25]),
          listen(input, "input", ctx[48]),
          listen(input, "input", ctx[32])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & 1049600) {
        toggle_class(a0, "active", ctx2[10] === ctx2[20].PARAMS);
      }
      if (!current || dirty[0] & 1049600) {
        toggle_class(a1, "active", ctx2[10] === ctx2[20].HEADERS);
      }
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$l(ctx2);
          if_block0.c();
          if_block0.m(ul, t4);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5$r(ctx2);
          if_block1.c();
          if_block1.m(ul, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & 1342177792 | dirty[1] & 1) {
        each_value_3 = ctx2[9];
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3$1(ctx2, each_value_3, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_3$1(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(div0, t6);
          }
        }
        group_outros();
        for (i2 = each_value_3.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty[0] & 1049600) {
        toggle_class(div0, "active", ctx2[10] == ctx2[20].PARAMS);
      }
      if (dirty[0] & 67109120) {
        each_value_2 = ctx2[8];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, t9);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
      if (!current || dirty[0] & 1049600) {
        toggle_class(div1, "active", ctx2[10] == ctx2[20].HEADERS);
      }
      if (dirty[0] & 8192 && to_number(input.value) !== ctx2[13].request.timeout) {
        set_input_value(input, ctx2[13].request.timeout);
      }
      if (!current || dirty[0] & 1049600) {
        toggle_class(div3, "active", ctx2[10] == ctx2[20].OPTIONS);
      }
      if (ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$1M(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div4, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div4);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_6$l(ctx) {
  let li;
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      a = element("a");
      a.textContent = "Body";
      attr(a, "class", "nav-link");
      attr(a, "href", "#body_tab");
      attr(a, "data-bs-toggle", "tab");
      toggle_class(a, "active", ctx[10] === ctx[20].BODY);
      attr(li, "class", "nav-item");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      if (!mounted) {
        dispose = listen(a, "click", ctx[40]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1049600) {
        toggle_class(a, "active", ctx2[10] === ctx2[20].BODY);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$r(ctx) {
  let li;
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      a = element("a");
      a.textContent = "Options";
      attr(a, "class", "nav-link");
      attr(a, "href", "#options_tab");
      attr(a, "data-bs-toggle", "tab");
      toggle_class(a, "active", ctx[10] === ctx[20].OPTIONS);
      attr(li, "class", "nav-item");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      if (!mounted) {
        dispose = listen(a, "click", ctx[41]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1049600) {
        toggle_class(a, "active", ctx2[10] === ctx2[20].OPTIONS);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_3$1(ctx) {
  let keyvaluetable;
  let current;
  function func2() {
    return ctx[42](ctx[68]);
  }
  function keyUpdate_handler(...args) {
    return ctx[43](ctx[68], ...args);
  }
  function valueUpdate_handler(...args) {
    return ctx[44](ctx[68], ...args);
  }
  keyvaluetable = new KeyValueTable({
    props: {
      key: ctx[66][0],
      value: ctx[66][1],
      onRemove: func2
    }
  });
  keyvaluetable.$on("keyUpdate", keyUpdate_handler);
  keyvaluetable.$on("valueUpdate", valueUpdate_handler);
  return {
    c() {
      create_component(keyvaluetable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvaluetable, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const keyvaluetable_changes = {};
      if (dirty[0] & 512)
        keyvaluetable_changes.key = ctx[66][0];
      if (dirty[0] & 512)
        keyvaluetable_changes.value = ctx[66][1];
      keyvaluetable.$set(keyvaluetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvaluetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvaluetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvaluetable, detaching);
    }
  };
}
function create_each_block_2$2(ctx) {
  let keyvaluetable;
  let updating_key;
  let updating_value;
  let current;
  function func_12() {
    return ctx[45](ctx[68]);
  }
  function keyvaluetable_key_binding(value) {
    ctx[46](value, ctx[66]);
  }
  function keyvaluetable_value_binding(value) {
    ctx[47](value, ctx[66]);
  }
  let keyvaluetable_props = { onRemove: func_12 };
  if (ctx[66][0] !== void 0) {
    keyvaluetable_props.key = ctx[66][0];
  }
  if (ctx[66][1] !== void 0) {
    keyvaluetable_props.value = ctx[66][1];
  }
  keyvaluetable = new KeyValueTable({ props: keyvaluetable_props });
  binding_callbacks.push(() => bind$1(keyvaluetable, "key", keyvaluetable_key_binding));
  binding_callbacks.push(() => bind$1(keyvaluetable, "value", keyvaluetable_value_binding));
  return {
    c() {
      create_component(keyvaluetable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvaluetable, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const keyvaluetable_changes = {};
      if (!updating_key && dirty[0] & 256) {
        updating_key = true;
        keyvaluetable_changes.key = ctx[66][0];
        add_flush_callback(() => updating_key = false);
      }
      if (!updating_value && dirty[0] & 256) {
        updating_value = true;
        keyvaluetable_changes.value = ctx[66][1];
        add_flush_callback(() => updating_value = false);
      }
      keyvaluetable.$set(keyvaluetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvaluetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvaluetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvaluetable, detaching);
    }
  };
}
function create_if_block_1$1M(ctx) {
  let div1;
  let div0;
  let label;
  let t1;
  let select2;
  let t2;
  let hr;
  let t3;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ctx[19];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$e(get_each_context_1$e(ctx, each_value_1, i2));
  }
  const if_block_creators = [create_if_block_2$17, create_if_block_3$R];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[7].type === "urlencoded")
      return 0;
    if (ctx2[7].type === "json")
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      label = element("label");
      label.innerHTML = `<b>Content Type</b>`;
      t1 = space();
      select2 = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      hr = element("hr");
      t3 = space();
      if (if_block)
        if_block.c();
      attr(select2, "class", "p-1");
      if (ctx[7].type === void 0)
        add_render_callback(() => ctx[49].call(select2));
      attr(div0, "class", "mlb-3");
      attr(hr, "class", "m-3");
      attr(div1, "class", "tab-pane");
      attr(div1, "id", "body_tab");
      toggle_class(div1, "active", ctx[10] === ctx[20].BODY);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, label);
      append(div0, t1);
      append(div0, select2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      select_option(select2, ctx[7].type, true);
      append(div1, t2);
      append(div1, hr);
      append(div1, t3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(select2, "change", ctx[49]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 524288) {
        each_value_1 = ctx2[19];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$e(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$e(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & 524416) {
        select_option(select2, ctx2[7].type);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div1, null);
        } else {
          if_block = null;
        }
      }
      if (!current || dirty[0] & 1049600) {
        toggle_class(div1, "active", ctx2[10] === ctx2[20].BODY);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1$e(ctx) {
  let option;
  let t_value = ctx[69] + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[69];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_3$R(ctx) {
  let div;
  let textarea;
  let t;
  let mounted;
  let dispose;
  let if_block = ctx[12] && create_if_block_4$z();
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      t = space();
      if (if_block)
        if_block.c();
      attr(textarea, "placeholder", "JSON");
      attr(textarea, "rows", "6");
      attr(textarea, "name", "bodyjson");
      attr(textarea, "class", "form-control");
      textarea.value = ctx[11];
      attr(div, "class", "flex flex-col");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          listen(textarea, "input", ctx[53]),
          listen(textarea, "blur", ctx[21])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048) {
        textarea.value = ctx2[11];
      }
      if (ctx2[12]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_4$z();
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$17(ctx) {
  let t0;
  let button;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[7].data;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1m(get_each_context$1m(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      button = element("button");
      button.textContent = "Add Field";
      attr(button, "class", "btn btn-default btn-sm");
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      insert(target, button, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[23]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16777344) {
        each_value = ctx2[7].data;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1m(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1m(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$z(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Invalid JSON";
      attr(div, "class", "alert alert-danger");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$1m(ctx) {
  let keyvaluetable;
  let updating_key;
  let updating_value;
  let current;
  function func_22() {
    return ctx[50](ctx[68]);
  }
  function keyvaluetable_key_binding_1(value) {
    ctx[51](value, ctx[66]);
  }
  function keyvaluetable_value_binding_1(value) {
    ctx[52](value, ctx[66]);
  }
  let keyvaluetable_props = { onRemove: func_22 };
  if (ctx[66][0] !== void 0) {
    keyvaluetable_props.key = ctx[66][0];
  }
  if (ctx[66][1] !== void 0) {
    keyvaluetable_props.value = ctx[66][1];
  }
  keyvaluetable = new KeyValueTable({ props: keyvaluetable_props });
  binding_callbacks.push(() => bind$1(keyvaluetable, "key", keyvaluetable_key_binding_1));
  binding_callbacks.push(() => bind$1(keyvaluetable, "value", keyvaluetable_value_binding_1));
  return {
    c() {
      create_component(keyvaluetable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvaluetable, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const keyvaluetable_changes = {};
      if (!updating_key && dirty[0] & 128) {
        updating_key = true;
        keyvaluetable_changes.key = ctx[66][0];
        add_flush_callback(() => updating_key = false);
      }
      if (!updating_value && dirty[0] & 128) {
        updating_value = true;
        keyvaluetable_changes.value = ctx[66][1];
        add_flush_callback(() => updating_value = false);
      }
      keyvaluetable.$set(keyvaluetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvaluetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvaluetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvaluetable, detaching);
    }
  };
}
function create_fragment$51(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[15] && create_if_block_7$d(ctx);
  let if_block1 = ctx[0] && create_if_block$2T(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[15])
        if_block0.p(ctx2, dirty);
      if (ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$2T(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function updateStores(store2, items) {
  if (store2) {
    const currentItems = {};
    items.forEach(([key, value]) => {
      currentItems[key] = value;
    });
    store2.set(currentItems);
  }
}
function instance$4S($$self, $$props, $$invalidate) {
  var _a;
  const omit_props_names = [
    "formModel",
    "showEditor",
    "showAddons",
    "configureBody",
    "configureOptions",
    "disableGo",
    "configView"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $config;
  let $uri;
  let { formModel } = $$props;
  let { showEditor = true } = $$props;
  let { showAddons = true } = $$props;
  let { configureBody = true } = $$props;
  let { configureOptions = false } = $$props;
  let { disableGo } = $$props;
  let { configView } = $$props;
  const { model } = formModel;
  const { uri, data: paramsStore, headers: headersStore } = formModel.fields;
  component_subscribe($$self, uri, (value) => $$invalidate(14, $uri = value));
  const config = (_a = formModel.fields.config) != null ? _a : writable({});
  component_subscribe($$self, config, (value) => $$invalidate(13, $config = value));
  const methods = ["GET", "POST", "PATCH", "PUT", "DELETE"];
  const methodMenuItems = methods.map((m) => ({ id: m, name: m }));
  const bodyTypes = ["none", "urlencoded", "json"];
  const TABS = {
    PARAMS: "params",
    HEADERS: "headers",
    BODY: "body"
  };
  let { method = "GET", body = { type: "none" }, headers = [], timeout } = ($config == null ? void 0 : $config.request) || {};
  let params2 = getParams();
  let currentTab = TABS.PARAMS;
  let resetParams = true;
  let jsonStr = null;
  let isBodyJSONInvalid = false;
  syncParamsHeaders();
  function onBodyTypeChange() {
    const data = body.data;
    switch (body.type) {
      case "json":
        if (data == null || !_.isObject(data) || _.isArray(data)) {
          $$invalidate(7, body.data = {}, body);
        }
        $$invalidate(11, jsonStr = JSON.stringify(body.data, null, 2));
        $$invalidate(12, isBodyJSONInvalid = false);
        break;
      case "urlencoded":
        if (!_.isArray(data)) {
          $$invalidate(7, body.data = [["", ""]], body);
        }
        break;
      default:
        $$invalidate(7, body.data = null, body);
    }
  }
  function formatJSON(e) {
    try {
      $$invalidate(11, jsonStr = JSON.stringify(JSON.parse(e.target.value), null, 2));
    } catch (e2) {
    }
  }
  function parseBodyJSON(str) {
    try {
      $$invalidate(7, body.data = JSON.parse(str), body);
      $$invalidate(12, isBodyJSONInvalid = false);
    } catch (e) {
      $$invalidate(12, isBodyJSONInvalid = true);
    }
  }
  function checkFormBody() {
    body.data || $$invalidate(7, body.data = [], body);
  }
  function addURLEncodedParam() {
    checkFormBody();
    body.data.push(["", ""]);
    $$invalidate(7, body);
  }
  function onRemoveUrlencoded(index2) {
    body.data.splice(index2, 1);
    $$invalidate(7, body);
  }
  function addHeader() {
    headers.push(["", ""]);
    $$invalidate(8, headers);
  }
  function onRemoveHeader(index2) {
    headers.splice(index2, 1);
    $$invalidate(8, headers);
  }
  function getParams() {
    const params3 = [];
    try {
      for (let [key, value] of $uri.searchParams.entries()) {
        params3.push([key, value]);
      }
    } catch (e) {
    }
    return params3;
  }
  function addNewParams() {
    $$invalidate(9, params2 = [...params2, ["", ""]]);
  }
  function onRemoveParam(index2) {
    params2.splice(index2, 1);
    $$invalidate(9, params2);
  }
  const onURLInputUpdateParams = _.debounce(
    (url) => {
      $$invalidate(9, params2 = []);
      resetParams = true;
      try {
        if (url.search) {
          for (let [key, value] of url.searchParams.entries()) {
            if (key || value)
              params2.push([key, value]);
          }
        }
      } catch (e) {
      }
    },
    200,
    false
  );
  const updateParamKey = _.debounce(
    (index2, key) => {
      $$invalidate(9, params2[index2][0] = key, params2);
    },
    200,
    false
  );
  const updateParamValue = _.debounce(
    (index2, value) => {
      $$invalidate(9, params2[index2][1] = value, params2);
    },
    200,
    false
  );
  function getParameterizedURL() {
    if (resetParams) {
      resetParams = false;
      return;
    }
    const search = new URLSearchParams(params2.filter(([key, _2]) => key)).toString();
    if (!$uri) {
      set_store_value(uri, $uri = new URL("https://example.com"), $uri);
    }
    set_store_value(uri, $uri.search = search.toString(), $uri);
    uri.set($uri);
  }
  function syncParamsHeaders() {
    if (paramsStore) {
      const currentParams = paramsStore.get();
      $$invalidate(9, params2 = Object.entries(currentParams));
    }
    if (headersStore) {
      const currentHeaders = headersStore.get();
      $$invalidate(8, headers = Object.entries(currentHeaders));
    }
  }
  function addTimeout(e) {
    const value = parseInt(e.target.value) || 30;
    set_store_value(config, $config.request.timeout = value, $config);
  }
  function menu_id_binding(value) {
    method = value;
    $$invalidate(6, method);
  }
  function go_handler(event) {
    bubble.call(this, $$self, event);
  }
  const input_handler = () => onURLInputUpdateParams($uri);
  const click_handler = (e) => $$invalidate(10, currentTab = TABS.PARAMS);
  const click_handler_1 = (e) => $$invalidate(10, currentTab = TABS.HEADERS);
  const click_handler_2 = (e) => $$invalidate(10, currentTab = TABS.BODY);
  const click_handler_3 = (e) => $$invalidate(10, currentTab = TABS.OPTIONS);
  const func2 = (i2) => onRemoveParam(i2);
  const keyUpdate_handler = (i2, e) => updateParamKey(i2, e.detail);
  const valueUpdate_handler = (i2, e) => updateParamValue(i2, e.detail);
  const func_12 = (i2) => onRemoveHeader(i2);
  function keyvaluetable_key_binding(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[0], value)) {
      keyValue[0] = value;
      $$invalidate(8, headers);
    }
  }
  function keyvaluetable_value_binding(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[1], value)) {
      keyValue[1] = value;
      $$invalidate(8, headers);
    }
  }
  function input_input_handler() {
    $config.request.timeout = to_number(this.value);
    config.set($config);
  }
  function select_change_handler() {
    body.type = select_value(this);
    $$invalidate(7, body);
    $$invalidate(19, bodyTypes);
  }
  const func_22 = (i2) => onRemoveUrlencoded(i2);
  function keyvaluetable_key_binding_1(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[0], value)) {
      keyValue[0] = value;
      $$invalidate(7, body);
    }
  }
  function keyvaluetable_value_binding_1(value, keyValue) {
    if ($$self.$$.not_equal(keyValue[1], value)) {
      keyValue[1] = value;
      $$invalidate(7, body);
    }
  }
  const input_handler_1 = (e) => parseBodyJSON(e.target.value);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("formModel" in $$new_props)
      $$invalidate(34, formModel = $$new_props.formModel);
    if ("showEditor" in $$new_props)
      $$invalidate(0, showEditor = $$new_props.showEditor);
    if ("showAddons" in $$new_props)
      $$invalidate(1, showAddons = $$new_props.showAddons);
    if ("configureBody" in $$new_props)
      $$invalidate(2, configureBody = $$new_props.configureBody);
    if ("configureOptions" in $$new_props)
      $$invalidate(3, configureOptions = $$new_props.configureOptions);
    if ("disableGo" in $$new_props)
      $$invalidate(4, disableGo = $$new_props.disableGo);
    if ("configView" in $$new_props)
      $$invalidate(5, configView = $$new_props.configView);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 448) {
      set_store_value(config, $config.request = { method, body, headers, timeout }, $config);
    }
    if ($$self.$$.dirty[0] & 128) {
      body.type && onBodyTypeChange();
    }
    if ($$self.$$.dirty[0] & 512) {
      params2 && uri && getParameterizedURL();
    }
    if ($$self.$$.dirty[0] & 512) {
      updateStores(paramsStore, params2);
    }
    if ($$self.$$.dirty[0] & 256) {
      updateStores(headersStore, headers);
    }
  };
  return [
    showEditor,
    showAddons,
    configureBody,
    configureOptions,
    disableGo,
    configView,
    method,
    body,
    headers,
    params2,
    currentTab,
    jsonStr,
    isBodyJSONInvalid,
    $config,
    $uri,
    model,
    uri,
    config,
    methodMenuItems,
    bodyTypes,
    TABS,
    formatJSON,
    parseBodyJSON,
    addURLEncodedParam,
    onRemoveUrlencoded,
    addHeader,
    onRemoveHeader,
    addNewParams,
    onRemoveParam,
    onURLInputUpdateParams,
    updateParamKey,
    updateParamValue,
    addTimeout,
    $$restProps,
    formModel,
    menu_id_binding,
    go_handler,
    input_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    func2,
    keyUpdate_handler,
    valueUpdate_handler,
    func_12,
    keyvaluetable_key_binding,
    keyvaluetable_value_binding,
    input_input_handler,
    select_change_handler,
    func_22,
    keyvaluetable_key_binding_1,
    keyvaluetable_value_binding_1,
    input_handler_1
  ];
}
class RequestEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$4S,
      create_fragment$51,
      safe_not_equal,
      {
        formModel: 34,
        showEditor: 0,
        showAddons: 1,
        configureBody: 2,
        configureOptions: 3,
        disableGo: 4,
        configView: 5
      },
      null,
      [-1, -1, -1]
    );
  }
}
function create_fragment$50(ctx) {
  let form;
  let div;
  let label;
  let t1;
  let inputedit;
  let t2;
  let p;
  let t3;
  let b;
  let t5;
  let current;
  inputedit = new InputEdit({ props: { field: ctx[0] } });
  return {
    c() {
      form = element("form");
      div = element("div");
      label = element("label");
      label.textContent = "Subject";
      t1 = space();
      create_component(inputedit.$$.fragment);
      t2 = space();
      p = element("p");
      t3 = text("Use the placeholders ");
      b = element("b");
      b.textContent = `${templateText}`;
      t5 = text(" for email subject generation.");
      attr(label, "for", "subject");
      attr(label, "class", "form-label mt-2 px-2");
      attr(div, "class", "input-group");
      attr(p, "class", "help px-20");
      attr(form, "class", "bg-white p-1");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, div);
      append(div, label);
      append(div, t1);
      mount_component(inputedit, div, null);
      append(form, t2);
      append(form, p);
      append(p, t3);
      append(p, b);
      append(p, t5);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(form);
      destroy_component(inputedit);
    }
  };
}
const templateText = "{{sieve.tags}} and {{sieve.name}}";
function instance$4R($$self, $$props, $$invalidate) {
  let { fields } = $$props;
  const subject = fields.subject;
  $$self.$$set = ($$props2) => {
    if ("fields" in $$props2)
      $$invalidate(1, fields = $$props2.fields);
  };
  return [subject, fields];
}
class EmailActionEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4R, create_fragment$50, safe_not_equal, { fields: 1 });
  }
}
function create_fragment$4$(ctx) {
  let i2;
  let mounted;
  let dispose;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-gear");
      attr(i2, "title", "Show Input Fields");
      set_style(i2, "color", ctx[1] ? "inherit" : "#ccc");
      set_style(i2, "opacity", ctx[1] ? 1 : 0.5);
      set_style(i2, "cursor", ctx[1] ? "pointer" : "not-allowed");
      toggle_class(i2, "disabled", ctx[1]);
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      if (!mounted) {
        dispose = listen(i2, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        set_style(i2, "color", ctx2[1] ? "inherit" : "#ccc");
      }
      if (dirty & 2) {
        set_style(i2, "opacity", ctx2[1] ? 1 : 0.5);
      }
      if (dirty & 2) {
        set_style(i2, "cursor", ctx2[1] ? "pointer" : "not-allowed");
      }
      if (dirty & 2) {
        toggle_class(i2, "disabled", ctx2[1]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(i2);
      mounted = false;
      dispose();
    }
  };
}
function instance$4Q($$self, $$props, $$invalidate) {
  let { isSelected } = $$props;
  let { showParamsModal } = $$props;
  const click_handler = () => isSelected ? $$invalidate(0, showParamsModal = true) : null;
  $$self.$$set = ($$props2) => {
    if ("isSelected" in $$props2)
      $$invalidate(1, isSelected = $$props2.isSelected);
    if ("showParamsModal" in $$props2)
      $$invalidate(0, showParamsModal = $$props2.showParamsModal);
  };
  return [showParamsModal, isSelected, click_handler];
}
class MacroSettings extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4Q, create_fragment$4$, safe_not_equal, { isSelected: 1, showParamsModal: 0 });
  }
}
const get_label_pre_slot_changes = (dirty) => ({});
const get_label_pre_slot_context = (ctx) => ({ slot: "label-pre" });
const get_bottom_slot_changes = (dirty) => ({});
const get_bottom_slot_context = (ctx) => ({ slot: "bottom" });
function create_label_pre_slot$2(ctx) {
  let current;
  const label_pre_slot_template = ctx[7]["label-pre"];
  const label_pre_slot = create_slot(label_pre_slot_template, ctx, ctx[14], get_label_pre_slot_context);
  return {
    c() {
      if (label_pre_slot)
        label_pre_slot.c();
    },
    m(target, anchor) {
      if (label_pre_slot) {
        label_pre_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_pre_slot) {
        if (label_pre_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            label_pre_slot,
            label_pre_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(label_pre_slot_template, ctx2[14], dirty, get_label_pre_slot_changes),
            get_label_pre_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_pre_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_pre_slot, local);
      current = false;
    },
    d(detaching) {
      if (label_pre_slot)
        label_pre_slot.d(detaching);
    }
  };
}
function create_if_block$2S(ctx) {
  let macrosettings;
  let updating_showParamsModal;
  let current;
  function macrosettings_showParamsModal_binding(value) {
    ctx[8](value);
  }
  let macrosettings_props = {
    isSelected: ctx[15].id == ctx[0]
  };
  if (ctx[1] !== void 0) {
    macrosettings_props.showParamsModal = ctx[1];
  }
  macrosettings = new MacroSettings({ props: macrosettings_props });
  binding_callbacks.push(() => bind$1(macrosettings, "showParamsModal", macrosettings_showParamsModal_binding));
  return {
    c() {
      create_component(macrosettings.$$.fragment);
    },
    m(target, anchor) {
      mount_component(macrosettings, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const macrosettings_changes = {};
      if (dirty & 32769)
        macrosettings_changes.isSelected = ctx2[15].id == ctx2[0];
      if (!updating_showParamsModal && dirty & 2) {
        updating_showParamsModal = true;
        macrosettings_changes.showParamsModal = ctx2[1];
        add_flush_callback(() => updating_showParamsModal = false);
      }
      macrosettings.$set(macrosettings_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(macrosettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(macrosettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(macrosettings, detaching);
    }
  };
}
function create_item_right_slot$2(ctx) {
  var _a, _b;
  let if_block_anchor;
  let current;
  let if_block = ((_b = (_a = ctx[15].spec) == null ? void 0 : _a.params) == null ? void 0 : _b.length) > 0 && create_if_block$2S(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      if (((_b2 = (_a2 = ctx2[15].spec) == null ? void 0 : _a2.params) == null ? void 0 : _b2.length) > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32768) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2S(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_bottom_slot$7(ctx) {
  let current;
  const bottom_slot_template = ctx[7].bottom;
  const bottom_slot = create_slot(bottom_slot_template, ctx, ctx[14], get_bottom_slot_context);
  return {
    c() {
      if (bottom_slot)
        bottom_slot.c();
    },
    m(target, anchor) {
      if (bottom_slot) {
        bottom_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (bottom_slot) {
        if (bottom_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            bottom_slot,
            bottom_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(bottom_slot_template, ctx2[14], dirty, get_bottom_slot_changes),
            get_bottom_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(bottom_slot, local);
      current = true;
    },
    o(local) {
      transition_out(bottom_slot, local);
      current = false;
    },
    d(detaching) {
      if (bottom_slot)
        bottom_slot.d(detaching);
    }
  };
}
function create_fragment$4_(ctx) {
  let searchablemenu;
  let updating_id;
  let current;
  function searchablemenu_id_binding(value) {
    ctx[9](value);
  }
  let searchablemenu_props = {
    title: ctx[4],
    items: ctx[2],
    field: ctx[6],
    showError: ctx[5],
    actionClass: ctx[3],
    $$slots: {
      bottom: [create_bottom_slot$7],
      "item-right": [
        create_item_right_slot$2,
        ({ item }) => ({ 15: item }),
        ({ item }) => item ? 32768 : 0
      ],
      "label-pre": [create_label_pre_slot$2]
    },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    searchablemenu_props.id = ctx[0];
  }
  searchablemenu = new SearchableMenu({ props: searchablemenu_props });
  binding_callbacks.push(() => bind$1(searchablemenu, "id", searchablemenu_id_binding));
  searchablemenu.$on("open", ctx[10]);
  searchablemenu.$on("close", ctx[11]);
  searchablemenu.$on("select", ctx[12]);
  searchablemenu.$on("search", ctx[13]);
  return {
    c() {
      create_component(searchablemenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchablemenu_changes = {};
      if (dirty & 16)
        searchablemenu_changes.title = ctx2[4];
      if (dirty & 4)
        searchablemenu_changes.items = ctx2[2];
      if (dirty & 64)
        searchablemenu_changes.field = ctx2[6];
      if (dirty & 32)
        searchablemenu_changes.showError = ctx2[5];
      if (dirty & 8)
        searchablemenu_changes.actionClass = ctx2[3];
      if (dirty & 49155) {
        searchablemenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        searchablemenu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      searchablemenu.$set(searchablemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemenu, detaching);
    }
  };
}
function instance$4P($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { id: id2 = null } = $$props;
  let { showParamsModal = false } = $$props;
  let { items = [] } = $$props;
  let { actionClass = "" } = $$props;
  let { title = "" } = $$props;
  let { showError = false } = $$props;
  let { field = void 0 } = $$props;
  function macrosettings_showParamsModal_binding(value) {
    showParamsModal = value;
    $$invalidate(1, showParamsModal);
  }
  function searchablemenu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  function open_handler(event) {
    bubble.call(this, $$self, event);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  function select_handler(event) {
    bubble.call(this, $$self, event);
  }
  function search_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("showParamsModal" in $$props2)
      $$invalidate(1, showParamsModal = $$props2.showParamsModal);
    if ("items" in $$props2)
      $$invalidate(2, items = $$props2.items);
    if ("actionClass" in $$props2)
      $$invalidate(3, actionClass = $$props2.actionClass);
    if ("title" in $$props2)
      $$invalidate(4, title = $$props2.title);
    if ("showError" in $$props2)
      $$invalidate(5, showError = $$props2.showError);
    if ("field" in $$props2)
      $$invalidate(6, field = $$props2.field);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  return [
    id2,
    showParamsModal,
    items,
    actionClass,
    title,
    showError,
    field,
    slots,
    macrosettings_showParamsModal_binding,
    searchablemenu_id_binding,
    open_handler,
    close_handler,
    select_handler,
    search_handler,
    $$scope
  ];
}
class SearchableMacroMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4P, create_fragment$4_, safe_not_equal, {
      id: 0,
      showParamsModal: 1,
      items: 2,
      actionClass: 3,
      title: 4,
      showError: 5,
      field: 6
    });
  }
}
function get_each_context$1l(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[40] = list[i2][0];
  child_ctx[41] = list[i2][1];
  return child_ctx;
}
function create_catch_block$G(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$G(ctx) {
  let div2;
  let div1;
  let button;
  let i2;
  let t0;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let t2;
  let t3;
  let t4;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_6$k, create_else_block$1v];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[16].has("login") && !ctx2[13].isLoggedIn())
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[14] == C$1.ACTION_WEBHOOK && create_if_block_5$q(ctx);
  let if_block2 = ctx[14] == C$1.ACTION_WEBHOOK && ctx[5] && create_if_block_4$y(ctx);
  let if_block3 = ctx[14] == C$1.ACTION_EMAIL && ctx[6] && create_if_block_3$Q(ctx);
  let if_block4 = ctx[14] == C$1.ACTION_MACRO && create_if_block$2R(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      button = element("button");
      i2 = element("i");
      t0 = space();
      div0 = element("div");
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      attr(i2, "class", "fa fa-trash-o");
      attr(button, "class", "btn xbtn-light py-2");
      attr(button, "title", TXT("h_del_action"));
      attr(div0, "class", "d-inline-flex flex-grow-1 flex-column gap-2");
      attr(div1, "class", "d-flex align-items-center gap-2");
      attr(div2, "class", "d-flex flex-column");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, button);
      append(button, i2);
      append(div1, t0);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      append(div2, t3);
      if (if_block3)
        if_block3.m(div2, null);
      append(div2, t4);
      if (if_block4)
        if_block4.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[19]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if_block0.p(ctx2, dirty);
      if (ctx2[14] == C$1.ACTION_WEBHOOK)
        if_block1.p(ctx2, dirty);
      if (ctx2[14] == C$1.ACTION_WEBHOOK && ctx2[5]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4$y(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[14] == C$1.ACTION_EMAIL && ctx2[6]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 64) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_3$Q(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[14] == C$1.ACTION_MACRO)
        if_block4.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$1v(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = Object.entries(ctx[3]);
  const get_key = (ctx2) => ctx2[40];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$1l(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$1l(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1302493) {
        each_value = Object.entries(ctx2[3]);
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$1l, each_1_anchor, get_each_context$1l);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_6$k(ctx) {
  let a;
  let b;
  return {
    c() {
      a = element("a");
      b = element("b");
      b.textContent = `${TXT("a_signin")}`;
      attr(a, "href", urlCfg.login);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, b);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block_16(ctx) {
  let inputedit;
  let current;
  inputedit = new InputEdit({
    props: {
      inputClasses: "w-auto form-control-sm",
      field: ctx[2].fields[ctx[40]]
    }
  });
  return {
    c() {
      create_component(inputedit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputedit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inputedit_changes = {};
      if (dirty[0] & 12)
        inputedit_changes.field = ctx2[2].fields[ctx2[40]];
      inputedit.$set(inputedit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputedit, detaching);
    }
  };
}
function create_if_block_15(ctx) {
  let urledit;
  let current;
  urledit = new UrlEdit({
    props: {
      inputClasses: "w-auto form-control-sm",
      field: ctx[2].fields[ctx[40]]
    }
  });
  return {
    c() {
      create_component(urledit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(urledit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const urledit_changes = {};
      if (dirty[0] & 12)
        urledit_changes.field = ctx2[2].fields[ctx2[40]];
      urledit.$set(urledit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(urledit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urledit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(urledit, detaching);
    }
  };
}
function create_if_block_7$c(ctx) {
  let div;
  let switch_instance;
  let updating_showParamsModal;
  let t0;
  let t1;
  let t2;
  let show_if = ctx[14] == C$1.ACTION_LOCAL_AUDIO && ctx[16].has("audio");
  let t3;
  let current;
  function switch_instance_showParamsModal_binding(value) {
    ctx[26](value);
  }
  function select_handler(...args) {
    return ctx[28](ctx[41], ...args);
  }
  var switch_value = ctx[17];
  function switch_props(ctx2) {
    let switch_instance_props = {
      field: ctx2[41],
      showError: !!ctx2[11][ctx2[40]],
      actionClass: "btn btn-default btn-sm",
      style: "--bs-btn-padding-y: .1rem",
      items: ctx2[4],
      allowNull: false,
      "data-bs-auto-close": "false",
      $$slots: { bottom: [create_bottom_slot$6] },
      $$scope: { ctx: ctx2 }
    };
    if (ctx2[7] !== void 0) {
      switch_instance_props.showParamsModal = ctx2[7];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind$1(switch_instance, "showParamsModal", switch_instance_showParamsModal_binding));
    switch_instance.$on("search", function() {
      if (is_function(ctx[8]))
        ctx[8].apply(this, arguments);
    });
    switch_instance.$on("open", ctx[27]);
    switch_instance.$on("select", select_handler);
  }
  let if_block0 = ctx[14] == C$1.ACTION_EMAIL && ctx[0] && create_if_block_11$4(ctx);
  let if_block1 = ctx[14] == C$1.ACTION_MACRO && ctx[9] && create_if_block_9$6(ctx);
  let if_block2 = show_if && create_if_block_8$7(ctx);
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      attr(div, "class", "d-flex align-self-start align-items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t2);
      if (if_block2)
        if_block2.m(div, null);
      append(div, t3);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[0] & 8)
        switch_instance_changes.field = ctx[41];
      if (dirty[0] & 2056)
        switch_instance_changes.showError = !!ctx[11][ctx[40]];
      if (dirty[0] & 16)
        switch_instance_changes.items = ctx[4];
      if (dirty[0] & 4096 | dirty[1] & 8192) {
        switch_instance_changes.$$scope = { dirty, ctx };
      }
      if (!updating_showParamsModal && dirty[0] & 128) {
        updating_showParamsModal = true;
        switch_instance_changes.showParamsModal = ctx[7];
        add_flush_callback(() => updating_showParamsModal = false);
      }
      if (switch_value !== (switch_value = ctx[17])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          binding_callbacks.push(() => bind$1(switch_instance, "showParamsModal", switch_instance_showParamsModal_binding));
          switch_instance.$on("search", function() {
            if (is_function(ctx[8]))
              ctx[8].apply(this, arguments);
          });
          switch_instance.$on("open", ctx[27]);
          switch_instance.$on("select", select_handler);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t0);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if (ctx[14] == C$1.ACTION_EMAIL && ctx[0]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_11$4(ctx);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx[14] == C$1.ACTION_MACRO && ctx[9]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_9$6(ctx);
          if_block1.c();
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (show_if)
        if_block2.p(ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_14(ctx) {
  let li0;
  let a0;
  let t0;
  let a0_href_value;
  let t1;
  let li1;
  let a1;
  let t2;
  return {
    c() {
      li0 = element("li");
      a0 = element("a");
      t0 = text("Manage Macros");
      t1 = space();
      li1 = element("li");
      a1 = element("a");
      t2 = text("Learn More");
      attr(a0, "class", "dropdown-item");
      attr(a0, "href", a0_href_value = "#/w/" + ctx[12].team + "/macros/");
      attr(a0, "target", "_blank");
      attr(a1, "class", "dropdown-item");
      attr(a1, "href", urlCfg.website + "/docs/web-monitor/macro-to-record-replay-actions/");
      attr(a1, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      append(li0, a0);
      append(a0, t0);
      insert(target, t1, anchor);
      insert(target, li1, anchor);
      append(li1, a1);
      append(a1, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4096 && a0_href_value !== (a0_href_value = "#/w/" + ctx2[12].team + "/macros/")) {
        attr(a0, "href", a0_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(li1);
    }
  };
}
function create_if_block_13(ctx) {
  let li;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      li.innerHTML = `<a href="#" class="dropdown-item">Manage Phones</a>`;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (!mounted) {
        dispose = listen(li, "click", ctx[25]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_12$1(ctx) {
  let li;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      li.innerHTML = `<a href="#" class="dropdown-item">Manage Emails</a>`;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (!mounted) {
        dispose = listen(li, "click", ctx[24]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_bottom_slot$6(ctx) {
  let li;
  let t;
  let if_block_anchor;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[14] == C$1.ACTION_EMAIL)
      return create_if_block_12$1;
    if (ctx2[14] == C$1.ACTION_SMS)
      return create_if_block_13;
    if (ctx2[14] == C$1.ACTION_MACRO)
      return create_if_block_14;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      li = element("li");
      li.innerHTML = `<hr class="dropdown-divider"/>`;
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t);
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_11$4(ctx) {
  let a;
  let t0_value = ctx[6] ? "Hide" : "";
  let t0;
  let t1;
  let t2_value = TXT("l_options") + "";
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      attr(a, "href", "javascript:void 0");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", ctx[29]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64 && t0_value !== (t0_value = ctx2[6] ? "Hide" : ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_9$6(ctx) {
  var _a, _b, _c;
  let show_if = (_c = (_b = (_a = ctx[4].find(ctx[23])) == null ? void 0 : _a.spec) == null ? void 0 : _b.params) == null ? void 0 : _c.length;
  let if_block_anchor;
  let if_block = show_if && create_if_block_10$5(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2;
      if (dirty[0] & 528)
        show_if = (_c2 = (_b2 = (_a2 = ctx2[4].find(ctx2[23])) == null ? void 0 : _a2.spec) == null ? void 0 : _b2.params) == null ? void 0 : _c2.length;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_10$5(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_10$5(ctx) {
  let a;
  let t0_value = ctx[10] ? "Hide" : "";
  let t0;
  let t1;
  let t2_value = TXT("Input Fields") + "";
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      attr(a, "href", "javascript:void 0");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", ctx[30]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t0_value !== (t0_value = ctx2[10] ? "Hide" : ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_8$7(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = `${TXT("a_play")}`;
      attr(a, "href", "javascript:void 0");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[31]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$1l(key_1, ctx) {
  let first2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_7$c, create_if_block_15, create_if_block_16];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[41].def.type == "enum")
      return 0;
    if (ctx2[41].def.type == "url")
      return 1;
    if (ctx2[41].def.type == "string" && ctx2[14] !== C$1.ACTION_EMAIL)
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_5$q(ctx) {
  let a;
  let t0_value = ctx[5] ? "Hide" : "";
  let t0;
  let t1;
  let t2_value = TXT("l_options") + "";
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      attr(a, "href", "javascript:void 0");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", ctx[32]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32 && t0_value !== (t0_value = ctx2[5] ? "Hide" : ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$y(ctx) {
  let requesteditor;
  let current;
  requesteditor = new RequestEditor({
    props: {
      formModel: ctx[2],
      configureBody: false
    }
  });
  return {
    c() {
      create_component(requesteditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const requesteditor_changes = {};
      if (dirty[0] & 4)
        requesteditor_changes.formModel = ctx2[2];
      requesteditor.$set(requesteditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
    }
  };
}
function create_if_block_3$Q(ctx) {
  let emailactioneditor;
  let current;
  emailactioneditor = new EmailActionEditor({
    props: {
      fields: ctx[2].fields
    }
  });
  return {
    c() {
      create_component(emailactioneditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(emailactioneditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const emailactioneditor_changes = {};
      if (dirty[0] & 4)
        emailactioneditor_changes.fields = ctx2[2].fields;
      emailactioneditor.$set(emailactioneditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(emailactioneditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(emailactioneditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(emailactioneditor, detaching);
    }
  };
}
function create_if_block$2R(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[7] && create_if_block_2$16(ctx);
  let if_block1 = ctx[10] && create_if_block_1$1L(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[7]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$16(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[10]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$1L(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_if_block_2$16(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      onSave: ctx[21],
      $$slots: {
        header: [create_header_slot$q],
        default: [create_default_slot$1w]
      },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[35]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty[0] & 534 | dirty[1] & 8192) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$1w(ctx) {
  let paramseditor;
  let updating_updatedFields;
  let current;
  function paramseditor_updatedFields_binding(value) {
    ctx[34](value);
  }
  let paramseditor_props = {
    paramLabelClass: "xoption-label " + ctx[1],
    fields: ctx[2].fields.params.get(),
    spec: ctx[4].find(ctx[33]).spec,
    onUpdate: updateParams
  };
  if (ctx[2].fields.params !== void 0) {
    paramseditor_props.updatedFields = ctx[2].fields.params;
  }
  paramseditor = new ParamsEditor({ props: paramseditor_props });
  binding_callbacks.push(() => bind$1(paramseditor, "updatedFields", paramseditor_updatedFields_binding));
  return {
    c() {
      create_component(paramseditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(paramseditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const paramseditor_changes = {};
      if (dirty[0] & 2)
        paramseditor_changes.paramLabelClass = "xoption-label " + ctx2[1];
      if (dirty[0] & 4)
        paramseditor_changes.fields = ctx2[2].fields.params.get();
      if (dirty[0] & 528)
        paramseditor_changes.spec = ctx2[4].find(ctx2[33]).spec;
      if (!updating_updatedFields && dirty[0] & 4) {
        updating_updatedFields = true;
        paramseditor_changes.updatedFields = ctx2[2].fields.params;
        add_flush_callback(() => updating_updatedFields = false);
      }
      paramseditor.$set(paramseditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(paramseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(paramseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(paramseditor, detaching);
    }
  };
}
function create_header_slot$q(ctx) {
  let t;
  return {
    c() {
      t = text("Configure Input Fields");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$1L(ctx) {
  let paramseditor;
  let updating_updatedFields;
  let current;
  function paramseditor_updatedFields_binding_1(value) {
    ctx[37](value);
  }
  let paramseditor_props = {
    paramLabelClass: "xoption-label " + ctx[1],
    fields: ctx[2].fields.params.get(),
    spec: ctx[4].find(ctx[36]).spec,
    onUpdate: updateParams
  };
  if (ctx[2].fields.params !== void 0) {
    paramseditor_props.updatedFields = ctx[2].fields.params;
  }
  paramseditor = new ParamsEditor({ props: paramseditor_props });
  binding_callbacks.push(() => bind$1(paramseditor, "updatedFields", paramseditor_updatedFields_binding_1));
  return {
    c() {
      create_component(paramseditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(paramseditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const paramseditor_changes = {};
      if (dirty[0] & 2)
        paramseditor_changes.paramLabelClass = "xoption-label " + ctx2[1];
      if (dirty[0] & 4)
        paramseditor_changes.fields = ctx2[2].fields.params.get();
      if (dirty[0] & 528)
        paramseditor_changes.spec = ctx2[4].find(ctx2[36]).spec;
      if (!updating_updatedFields && dirty[0] & 4) {
        updating_updatedFields = true;
        paramseditor_changes.updatedFields = ctx2[2].fields.params;
        add_flush_callback(() => updating_updatedFields = false);
      }
      paramseditor.$set(paramseditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(paramseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(paramseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(paramseditor, detaching);
    }
  };
}
function create_pending_block$G(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_fragment$4Z(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$G,
    then: create_then_block$G,
    catch: create_catch_block$G,
    value: 39,
    blocks: [, , ,]
  };
  handle_promise(ctx[20](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function updateParams(newParamsValues, updatedFields) {
  updatedFields.set(newParamsValues);
}
function instance$4O($$self, $$props, $$invalidate) {
  let $allFieldErrorsStore;
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(12, $route = $$value));
  let { action } = $$props;
  let { customizableEmailSubject = true } = $$props;
  let { paramLabelClass = "" } = $$props;
  const user = getContext("user");
  const type = action.get("type");
  const dispatch = createEventDispatcher();
  const sieveActionModel = action.get("config");
  const fields = sieveActionModel.fields;
  const plugins = new Set(action.desc.plugins);
  let data = [];
  let initData = [];
  let showRequestEditor = false;
  let showEmailActionEditor = false;
  let showParamsModal = false;
  let onSearch = void 0;
  let selectedField;
  let showParams = false;
  const Component = type === C$1.ACTION_MACRO ? SearchableMacroMenu : SearchableMenu;
  const allFieldErrorsStore = writable({});
  component_subscribe($$self, allFieldErrorsStore, (value) => $$invalidate(11, $allFieldErrorsStore = value));
  Object.entries(fields).forEach(([fieldName, field]) => {
    field.showError.subscribe((val) => {
      allFieldErrorsStore.update((oldValue) => ({ ...oldValue, [fieldName]: val }));
    });
  });
  function removeAction() {
    dispatch("remove", action.cid);
  }
  async function fetchData() {
    $$invalidate(4, data = await action.desc.fetchData(fields, user));
    initData = data;
    if (type === C$1.ACTION_MACRO) {
      $$invalidate(9, selectedField = fields.macro_id.get());
      $$invalidate(8, onSearch = async (customEvent) => {
        const query = customEvent.detail;
        if (!query) {
          $$invalidate(4, data = JSON.parse(JSON.stringify(initData)));
          $$invalidate(3, fields.macro_id.def.options = data, fields);
          return;
        }
        $$invalidate(4, data = await action.desc.fetchData(fields, user, { query }));
      });
    } else {
      $$invalidate(8, onSearch = async (customEvent) => {
        const query = customEvent.detail;
        if (!query) {
          $$invalidate(4, data = JSON.parse(JSON.stringify(initData)));
          return;
        }
        $$invalidate(4, data = initData.filter((item) => item.name.toLowerCase().includes(query.toLowerCase())));
      });
    }
  }
  function onSave() {
    $$invalidate(7, showParamsModal = false);
  }
  const func2 = (item) => item.id === selectedField;
  const click_handler = () => dispatch("manage", "email");
  const click_handler_1 = () => dispatch("manage", "phone");
  function switch_instance_showParamsModal_binding(value) {
    showParamsModal = value;
    $$invalidate(7, showParamsModal);
  }
  const open_handler = () => fetchData();
  const select_handler = (field, e) => {
    field.set(e.detail);
    $$invalidate(9, selectedField = e.detail);
    if (type == C$1.ACTION_MACRO) {
      $$invalidate(10, showParams = false);
      sieveActionModel.fields.params.set({});
    }
  };
  const click_handler_2 = () => {
    $$invalidate(6, showEmailActionEditor = !showEmailActionEditor);
  };
  const click_handler_3 = () => {
    $$invalidate(10, showParams = !showParams);
  };
  const click_handler_4 = async () => {
    const audio = new Audio();
    let tone = fields.tone.get();
    if (tone) {
      if (tone.indexOf("tone:") == 0) {
        let doc = await serviceProxy.store.KVStore.findOne(tone);
        tone = doc.value;
      }
      audio.src = tone;
      audio.load();
      audio.play();
    }
  };
  const click_handler_5 = () => {
    $$invalidate(5, showRequestEditor = !showRequestEditor);
  };
  const func_12 = (item) => item.id === selectedField;
  function paramseditor_updatedFields_binding(value) {
    if ($$self.$$.not_equal(sieveActionModel.fields.params, value)) {
      sieveActionModel.fields.params = value;
      $$invalidate(2, sieveActionModel);
    }
  }
  const close_handler = () => $$invalidate(7, showParamsModal = false);
  const func_22 = (item) => item.id === selectedField;
  function paramseditor_updatedFields_binding_1(value) {
    if ($$self.$$.not_equal(sieveActionModel.fields.params, value)) {
      sieveActionModel.fields.params = value;
      $$invalidate(2, sieveActionModel);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("action" in $$props2)
      $$invalidate(22, action = $$props2.action);
    if ("customizableEmailSubject" in $$props2)
      $$invalidate(0, customizableEmailSubject = $$props2.customizableEmailSubject);
    if ("paramLabelClass" in $$props2)
      $$invalidate(1, paramLabelClass = $$props2.paramLabelClass);
  };
  return [
    customizableEmailSubject,
    paramLabelClass,
    sieveActionModel,
    fields,
    data,
    showRequestEditor,
    showEmailActionEditor,
    showParamsModal,
    onSearch,
    selectedField,
    showParams,
    $allFieldErrorsStore,
    $route,
    user,
    type,
    dispatch,
    plugins,
    Component,
    allFieldErrorsStore,
    removeAction,
    fetchData,
    onSave,
    action,
    func2,
    click_handler,
    click_handler_1,
    switch_instance_showParamsModal_binding,
    open_handler,
    select_handler,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    func_12,
    paramseditor_updatedFields_binding,
    close_handler,
    func_22,
    paramseditor_updatedFields_binding_1
  ];
}
class SieveActionEditor$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$4O,
      create_fragment$4Z,
      safe_not_equal,
      {
        action: 22,
        customizableEmailSubject: 0,
        paramLabelClass: 1
      },
      null,
      [-1, -1]
    );
  }
}
function get_each_context$1k(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  return child_ctx;
}
function create_if_block_4$x(ctx) {
  let button;
  let i2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fa fa-trash-o");
      attr(button, "class", "btn xbtn-light");
      attr(button, "title", TXT("h_del_action"));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(ctx[8])));
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$P(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "class", "btn fa fa-plus xbtn-light pull-right");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(ctx[7])));
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$1K(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[4].models;
  const get_key = (ctx2) => ctx2[15].cid;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$1k(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$1k(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 529) {
        each_value = ctx2[4].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$1k, each_1_anchor, get_each_context$1k);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block$2Q(ctx) {
  let p;
  let t0_value = ctx[5].error + "";
  let t0;
  let t1;
  let a;
  let t2_value = TXT("l_learn_more") + "";
  let t2;
  return {
    c() {
      p = element("p");
      t0 = text(t0_value);
      t1 = space();
      a = element("a");
      t2 = text(t2_value);
      attr(a, "href", urlCfg.usageAvailabilityForTeam());
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener");
      attr(p, "class", "error mt-[-5px] p-[5px] pl-[36px] text-base");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
      append(p, a);
      append(a, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t0_value !== (t0_value = ctx2[5].error + ""))
        set_data(t0, t0_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_2$15(ctx) {
  let sieveactioneditor;
  let current;
  const sieveactioneditor_spread_levels = [{ action: ctx[15] }, ctx[9]];
  let sieveactioneditor_props = {};
  for (let i2 = 0; i2 < sieveactioneditor_spread_levels.length; i2 += 1) {
    sieveactioneditor_props = assign(sieveactioneditor_props, sieveactioneditor_spread_levels[i2]);
  }
  sieveactioneditor = new SieveActionEditor$1({ props: sieveactioneditor_props });
  sieveactioneditor.$on("remove", ctx[10]);
  sieveactioneditor.$on("manage", ctx[11]);
  return {
    c() {
      create_component(sieveactioneditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveactioneditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveactioneditor_changes = dirty & 528 ? get_spread_update(sieveactioneditor_spread_levels, [
        dirty & 16 && { action: ctx2[15] },
        dirty & 512 && get_spread_object(ctx2[9])
      ]) : {};
      sieveactioneditor.$set(sieveactioneditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveactioneditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveactioneditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveactioneditor, detaching);
    }
  };
}
function create_each_block$1k(key_1, ctx) {
  let first2;
  let show_if = ctx[15].get("type") == ctx[0];
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_2$15(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 17)
        show_if = ctx[15].get("type") == ctx[0];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$15(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$4Y(ctx) {
  let div;
  let t0;
  let show_if = !ctx[3].has("single");
  let t1;
  let span0;
  let t2_value = TXT(ctx[2].label) + "";
  let t2;
  let t3;
  let span1;
  let current_block_type_index;
  let if_block2;
  let current;
  let if_block0 = (ctx[5].error || !ctx[6]) && create_if_block_4$x(ctx);
  let if_block1 = show_if && create_if_block_3$P(ctx);
  const if_block_creators = [create_if_block$2Q, create_if_block_1$1K];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5].error)
      return 0;
    if (ctx2[6])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      span0 = element("span");
      t2 = text(t2_value);
      t3 = space();
      span1 = element("span");
      if (if_block2)
        if_block2.c();
      attr(span0, "class", "mr-10");
      attr(div, "class", "xtype-group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      append(div, span0);
      append(span0, t2);
      append(div, t3);
      append(div, span1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[5].error || !ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4$x(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 8)
        show_if = !ctx2[3].has("single");
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_3$P(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if ((!current || dirty & 4) && t2_value !== (t2_value = TXT(ctx2[2].label) + ""))
        set_data(t2, t2_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block2) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block2 = if_blocks[current_block_type_index];
          if (!if_block2) {
            if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block2.c();
          } else {
            if_block2.p(ctx2, dirty);
          }
          transition_in(if_block2, 1);
          if_block2.m(span1, null);
        } else {
          if_block2 = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function instance$4N($$self, $$props, $$invalidate) {
  const omit_props_names = ["type", "actions"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $actions, $$unsubscribe_actions = noop$1, $$subscribe_actions = () => ($$unsubscribe_actions(), $$unsubscribe_actions = subscribe(actions, ($$value) => $$invalidate(4, $actions = $$value)), actions);
  $$self.$$.on_destroy.push(() => $$unsubscribe_actions());
  let { type } = $$props;
  let { actions } = $$props;
  $$subscribe_actions();
  const user = getContext("user");
  const actionDescOverride = getContext("actionDescOverride") || {};
  const dispatch = createEventDispatcher();
  let desc = null;
  let plugins = null;
  let quotaAvailability = {};
  let renderSieveActionEditor = false;
  const onActionAdd = () => {
    const Type2 = Model$2.SieveAction[type];
    let attrs = null;
    if (actionDescOverride[type]) {
      attrs = structuredClone(actionDescOverride[type]);
    }
    actions.add(new Type2(attrs, { parse: true }));
  };
  function onActionRemove() {
    const action = actions.where({ type }).at(0);
    dispatch("remove", action.cid);
  }
  function remove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function manage_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("type" in $$new_props)
      $$invalidate(0, type = $$new_props.type);
    if ("actions" in $$new_props)
      $$subscribe_actions($$invalidate(1, actions = $$new_props.actions));
  };
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & 29) {
      {
        if ($actions) {
          $$invalidate(2, desc = SieveActionDescList.find((desc2) => desc2.type === type));
          $$invalidate(3, plugins = new Set(desc.plugins));
          if (plugins.has("quota")) {
            $$invalidate(5, quotaAvailability = (_a = isQuotaAvailable(user, desc)) != null ? _a : {});
          }
          $$invalidate(6, renderSieveActionEditor = !!desc.fields);
        }
      }
    }
  };
  return [
    type,
    actions,
    desc,
    plugins,
    $actions,
    quotaAvailability,
    renderSieveActionEditor,
    onActionAdd,
    onActionRemove,
    $$restProps,
    remove_handler,
    manage_handler
  ];
}
class SieveActionGroup$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4N, create_fragment$4Y, safe_not_equal, { type: 0, actions: 1 });
  }
}
function get_each_context$1j(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  return child_ctx;
}
function get_each_context_1$d(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i2];
  return child_ctx;
}
function create_if_block_2$14(ctx) {
  let li;
  let a;
  let i2;
  let t0;
  let span;
  let t1_value = TXT(ctx[29].label) + "";
  let t1;
  let t2_value = ctx[29].paid ? " *" : "";
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[16](ctx[29]);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      i2 = element("i");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = text(t2_value);
      attr(i2, "class", "fa " + ctx[29].icon);
      set_style(span, "margin-left", "10px");
      attr(a, "class", "dropdown-item");
      attr(a, "href", "#");
      attr(a, "tabindex", "-1");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, i2);
      append(a, t0);
      append(a, span);
      append(span, t1);
      append(span, t2);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1$d(ctx) {
  let show_if = ctx[2].includes(ctx[29].type);
  let if_block_anchor;
  let if_block = show_if && create_if_block_2$14(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4)
        show_if = ctx2[2].includes(ctx2[29].type);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$14(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$1J(ctx) {
  let a;
  let t0;
  let span;
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      t0 = text("Global Actions: ");
      span = element("span");
      t1 = text(ctx[7]);
      attr(a, "href", "javascript:void 0");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, span);
      append(span, t1);
      if (!mounted) {
        dispose = listen(a, "click", ctx[17]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128)
        set_data(t1, ctx2[7]);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$2P(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "No action added - add one to get alerted on changes";
      attr(div, "class", "alert alert-warning hide");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$1j(ctx) {
  let sieveactiongroup;
  let current;
  sieveactiongroup = new SieveActionGroup$1({
    props: {
      customizableEmailSubject: ctx[3],
      paramLabelClass: ctx[4],
      type: ctx[26],
      actions: ctx[0]
    }
  });
  sieveactiongroup.$on("remove", ctx[13]);
  sieveactiongroup.$on("manage", ctx[18]);
  return {
    c() {
      create_component(sieveactiongroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveactiongroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveactiongroup_changes = {};
      if (dirty[0] & 8)
        sieveactiongroup_changes.customizableEmailSubject = ctx2[3];
      if (dirty[0] & 16)
        sieveactiongroup_changes.paramLabelClass = ctx2[4];
      if (dirty[0] & 64)
        sieveactiongroup_changes.type = ctx2[26];
      if (dirty[0] & 1)
        sieveactiongroup_changes.actions = ctx2[0];
      sieveactiongroup.$set(sieveactiongroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveactiongroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveactiongroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveactiongroup, detaching);
    }
  };
}
function create_fragment$4X(ctx) {
  let div1;
  let div0;
  let a0;
  let t1;
  let ul;
  let t2;
  let li;
  let a1;
  let t5;
  let t6;
  let t7;
  let current;
  let each_value_1 = Model$2.SieveActionDescList;
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$d(get_each_context_1$d(ctx, each_value_1, i2));
  }
  let if_block0 = !ctx[9] && ctx[1] && create_if_block_1$1J(ctx);
  let if_block1 = !ctx[5].length && create_if_block$2P();
  let each_value = ctx[6];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1j(get_each_context$1j(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      a0 = element("a");
      a0.textContent = `${TXT("a_add_action")}`;
      t1 = space();
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t2 = space();
      li = element("li");
      a1 = element("a");
      a1.textContent = `*\xA0${TXT("m_premium_only")}`;
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(a0, "href", "#");
      attr(a0, "class", "dropdown-toggle");
      attr(a0, "data-bs-toggle", "dropdown");
      attr(a1, "href", "javascript:void 0");
      attr(a1, "class", "dropdown-item disabled");
      attr(li, "class", "text-end");
      attr(ul, "class", "dropdown-menu");
      attr(ul, "role", "menu");
      attr(div0, "class", "d-flex gap-3");
      set_style(div1, "position", "relative");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, a0);
      append(div0, t1);
      append(div0, ul);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(ul, null);
        }
      }
      append(ul, t2);
      append(ul, li);
      append(li, a1);
      append(div0, t5);
      if (if_block0)
        if_block0.m(div0, null);
      append(div1, t6);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t7);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4100) {
        each_value_1 = Model$2.SieveActionDescList;
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$d(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
          } else {
            each_blocks_1[i2] = create_each_block_1$d(child_ctx);
            each_blocks_1[i2].c();
            each_blocks_1[i2].m(ul, t2);
          }
        }
        for (; i2 < each_blocks_1.length; i2 += 1) {
          each_blocks_1[i2].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (!ctx2[9] && ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$1J(ctx2);
          if_block0.c();
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!ctx2[5].length) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block$2P();
          if_block1.c();
          if_block1.m(div1, t7);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & 8281) {
        each_value = ctx2[6];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1j(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1j(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks_1, detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$4M($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "actions",
    "showGlobalActions",
    "allowedActionTypes",
    "customizableEmailSubject",
    "paramLabelClass",
    "getChanges"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $actions, $$unsubscribe_actions = noop$1, $$subscribe_actions = () => ($$unsubscribe_actions(), $$unsubscribe_actions = subscribe(actions, ($$value) => $$invalidate(5, $actions = $$value)), actions);
  let $user;
  let $sieve;
  $$self.$$.on_destroy.push(() => $$unsubscribe_actions());
  let { actions } = $$props;
  $$subscribe_actions();
  let { showGlobalActions = true } = $$props;
  let { allowedActionTypes = Model$2.SieveActionDescList.map((sag) => sag.type) } = $$props;
  let { customizableEmailSubject = true } = $$props;
  let { paramLabelClass } = $$props;
  const { sieve, global: global2 } = $$restProps;
  component_subscribe($$self, sieve, (value) => $$invalidate(19, $sieve = value));
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(15, $user = value));
  const actionDescOverride = getContext("actionDescOverride") || {};
  const dispatch = createEventDispatcher();
  let dels = [];
  let groups = [];
  const groupsSet = /* @__PURE__ */ new Set();
  let globalActionsCount = 0;
  if (!actions) {
    $$subscribe_actions(actions = new Model$2.SieveActions(null, { parent: sieve }));
    if (sieve && $sieve.id) {
      actions.fetch({ data: { state: 0 } });
    }
  }
  async function fetchGlobalActions() {
    try {
      const data = await Api.api("/prefs/actions");
      Msg.reset();
      return data;
    } catch (e) {
      console.error(e);
      Msg.error("Please try again later. Failed to fetch global actions.");
      if (global2) {
        dispatch("close");
      }
    }
  }
  async function setGlobalActionCount() {
    const globalActions = await fetchGlobalActions();
    $$invalidate(7, globalActionsCount = (globalActions == null ? void 0 : globalActions.length) || 0);
  }
  onMount(async () => {
    if (global2) {
      let data = await fetchGlobalActions();
      actions.set({ data }, { parse: true });
    }
  });
  function addAction(type) {
    const Type2 = Model$2.SieveAction[type];
    const existingActions = actions.models.filter((action) => action.get("type") === Type2.desc.type);
    if (Type2.desc.single && existingActions.length) {
      Msg.info("m_action_can_add_only_one");
      return;
    }
    let attrs = null;
    if (actionDescOverride[type]) {
      attrs = structuredClone(actionDescOverride[type]);
    }
    actions.add(new Type2(attrs, { parent: sieve, parse: true }));
  }
  function getChanges2() {
    return {
      dels,
      posts: actions.getPosts(),
      puts: actions.getPuts()
    };
  }
  function onActionRemove(e) {
    const cid = e.detail;
    const action = actions.find((action2) => action2.cid == cid);
    if (action) {
      if (!action.isNew()) {
        dels.push(action);
      }
      actions.remove(action);
    }
  }
  const click_handler = (desc) => addAction(desc.type);
  const click_handler_1 = () => {
    dispatch("globalaction");
  };
  function manage_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("actions" in $$new_props)
      $$subscribe_actions($$invalidate(0, actions = $$new_props.actions));
    if ("showGlobalActions" in $$new_props)
      $$invalidate(1, showGlobalActions = $$new_props.showGlobalActions);
    if ("allowedActionTypes" in $$new_props)
      $$invalidate(2, allowedActionTypes = $$new_props.allowedActionTypes);
    if ("customizableEmailSubject" in $$new_props)
      $$invalidate(3, customizableEmailSubject = $$new_props.customizableEmailSubject);
    if ("paramLabelClass" in $$new_props)
      $$invalidate(4, paramLabelClass = $$new_props.paramLabelClass);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 32768) {
      {
        if (user.isLoggedIn() && !global2 && $user) {
          setGlobalActionCount();
        }
      }
    }
    if ($$self.$$.dirty[0] & 32) {
      {
        const currentGroups = new Set($actions.models.map((a) => a.get("type")));
        currentGroups.forEach((group2) => groupsSet.add(group2));
        groupsSet.forEach((group2) => {
          if (!currentGroups.has(group2)) {
            groupsSet.delete(group2);
          }
        });
        $$invalidate(6, groups = [...groupsSet]);
      }
    }
  };
  return [
    actions,
    showGlobalActions,
    allowedActionTypes,
    customizableEmailSubject,
    paramLabelClass,
    $actions,
    groups,
    globalActionsCount,
    sieve,
    global2,
    user,
    dispatch,
    addAction,
    onActionRemove,
    getChanges2,
    $user,
    click_handler,
    click_handler_1,
    manage_handler
  ];
}
class ActionsEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$4M,
      create_fragment$4X,
      safe_not_equal,
      {
        actions: 0,
        showGlobalActions: 1,
        allowedActionTypes: 2,
        customizableEmailSubject: 3,
        paramLabelClass: 4,
        getChanges: 14
      },
      null,
      [-1, -1]
    );
  }
  get getChanges() {
    return this.$$.ctx[14];
  }
}
function create_default_slot$1v(ctx) {
  let t;
  return {
    c() {
      t = text("Trigger notifications");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$2O(ctx) {
  let actionseditor;
  let updating_actions;
  let current;
  function actionseditor_actions_binding(value) {
    ctx[7](value);
  }
  let actionseditor_props = {
    allowedActionTypes: ctx[6],
    customizableEmailSubject: false,
    showGlobalActions: false
  };
  if (ctx[1] !== void 0) {
    actionseditor_props.actions = ctx[1];
  }
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  binding_callbacks.push(() => bind$1(actionseditor, "actions", actionseditor_actions_binding));
  actionseditor.$on("close", ctx[8]);
  actionseditor.$on("manage", ctx[9]);
  return {
    c() {
      create_component(actionseditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actionseditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actionseditor_changes = {};
      if (!updating_actions && dirty & 2) {
        updating_actions = true;
        actionseditor_changes.actions = ctx2[1];
        add_flush_callback(() => updating_actions = false);
      }
      actionseditor.$set(actionseditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actionseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(actionseditor, detaching);
    }
  };
}
function create_fragment$4W(ctx) {
  let div6;
  let div0;
  let checkbox;
  let t0;
  let div5;
  let div2;
  let div1;
  let inputedit0;
  let t1;
  let label0;
  let t2;
  let t3;
  let div4;
  let div3;
  let inputedit1;
  let t4;
  let label1;
  let t5;
  let t6;
  let current;
  checkbox = new Checkbox({
    props: {
      field: ctx[0].fields.trigger,
      $$slots: { default: [create_default_slot$1v] },
      $$scope: { ctx }
    }
  });
  inputedit0 = new InputEdit({
    props: {
      id: ctx[4],
      field: ctx[0].fields.minimum_time_interval,
      classes: "me-2",
      disabled: !ctx[2]
    }
  });
  inputedit1 = new InputEdit({
    props: {
      id: ctx[5],
      field: ctx[0].fields.number_of_consecutive_errors,
      classes: "me-2",
      disabled: !ctx[2]
    }
  });
  let if_block = ctx[2] && create_if_block$2O(ctx);
  return {
    c() {
      div6 = element("div");
      div0 = element("div");
      create_component(checkbox.$$.fragment);
      t0 = space();
      div5 = element("div");
      div2 = element("div");
      div1 = element("div");
      create_component(inputedit0.$$.fragment);
      t1 = space();
      label0 = element("label");
      t2 = text("Minimum time interval between notifications (in minutes)");
      t3 = space();
      div4 = element("div");
      div3 = element("div");
      create_component(inputedit1.$$.fragment);
      t4 = space();
      label1 = element("label");
      t5 = text("No. of consecutive errors to trigger notifications");
      t6 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "d-flex align-items-center gap-2 mb-2");
      attr(div1, "class", "w-[10%]");
      attr(label0, "class", "font-normal form-label");
      attr(label0, "for", ctx[4]);
      attr(div2, "class", "d-flex items-center gap-1");
      attr(div3, "class", "w-[10%]");
      attr(label1, "class", "font-normal form-label");
      attr(label1, "for", ctx[5]);
      attr(div4, "class", "d-flex align-items-center gap-1");
      attr(div5, "class", "d-flex flex-column gap-1");
      attr(div6, "class", "d-flex flex-column gap-3");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div0);
      mount_component(checkbox, div0, null);
      append(div6, t0);
      append(div6, div5);
      append(div5, div2);
      append(div2, div1);
      mount_component(inputedit0, div1, null);
      append(div2, t1);
      append(div2, label0);
      append(label0, t2);
      append(div5, t3);
      append(div5, div4);
      append(div4, div3);
      mount_component(inputedit1, div3, null);
      append(div4, t4);
      append(div4, label1);
      append(label1, t5);
      append(div6, t6);
      if (if_block)
        if_block.m(div6, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const checkbox_changes = {};
      if (dirty & 1)
        checkbox_changes.field = ctx2[0].fields.trigger;
      if (dirty & 4096) {
        checkbox_changes.$$scope = { dirty, ctx: ctx2 };
      }
      checkbox.$set(checkbox_changes);
      const inputedit0_changes = {};
      if (dirty & 1)
        inputedit0_changes.field = ctx2[0].fields.minimum_time_interval;
      if (dirty & 4)
        inputedit0_changes.disabled = !ctx2[2];
      inputedit0.$set(inputedit0_changes);
      const inputedit1_changes = {};
      if (dirty & 1)
        inputedit1_changes.field = ctx2[0].fields.number_of_consecutive_errors;
      if (dirty & 4)
        inputedit1_changes.disabled = !ctx2[2];
      inputedit1.$set(inputedit1_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2O(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div6, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      transition_in(inputedit0.$$.fragment, local);
      transition_in(inputedit1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(checkbox.$$.fragment, local);
      transition_out(inputedit0.$$.fragment, local);
      transition_out(inputedit1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_component(checkbox);
      destroy_component(inputedit0);
      destroy_component(inputedit1);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$4L($$self, $$props, $$invalidate) {
  let $triggerField;
  let { errorActionFormModel } = $$props;
  let actions = errorActionFormModel.getActions();
  const triggerField = errorActionFormModel.fields.trigger;
  component_subscribe($$self, triggerField, (value) => $$invalidate(2, $triggerField = value));
  const minTimeIntervalFieldID = ID() + "";
  const noOfConsecutiveErrorsID = ID() + "";
  const allowedActionTypes = [
    C$1.ACTION_EMAIL,
    C$1.ACTION_LOCAL_POPUP,
    C$1.ACTION_LOCAL_AUDIO,
    C$1.ACTION_SMS,
    C$1.ACTION_WEBHOOK
  ];
  _.filter(allowedActionTypes, (t) => t !== C$1.ACTION_WEBHOOK);
  const actionDescOverride = {
    [C$1.ACTION_WEBHOOK]: {
      config: JSON.stringify({
        data: {
          sieve_id: "{{sieve.id}}",
          sieve_name: "{{sieve.name}}",
          sieve_uri: "{{sieve.uri}}",
          work_id: "{{work.id}}",
          error_code: "{{error_code}}"
        }
      })
    }
  };
  setContext("actionDescOverride", actionDescOverride);
  function actionseditor_actions_binding(value) {
    actions = value;
    $$invalidate(1, actions);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  function manage_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("errorActionFormModel" in $$props2)
      $$invalidate(0, errorActionFormModel = $$props2.errorActionFormModel);
  };
  return [
    errorActionFormModel,
    actions,
    $triggerField,
    triggerField,
    minTimeIntervalFieldID,
    noOfConsecutiveErrorsID,
    allowedActionTypes,
    actionseditor_actions_binding,
    close_handler,
    manage_handler
  ];
}
class ErrorAction extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4L, create_fragment$4W, safe_not_equal, { errorActionFormModel: 0 });
  }
}
function get_each_context$1i(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  child_ctx[8] = i2;
  return child_ctx;
}
function create_each_block$1i(ctx) {
  let erroraction;
  let current;
  erroraction = new ErrorAction({
    props: {
      errorActionFormModel: ctx[6]
    }
  });
  erroraction.$on("manage", ctx[3]);
  return {
    c() {
      create_component(erroraction.$$.fragment);
    },
    m(target, anchor) {
      mount_component(erroraction, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const erroraction_changes = {};
      if (dirty & 1)
        erroraction_changes.errorActionFormModel = ctx2[6];
      erroraction.$set(erroraction_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(erroraction.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(erroraction.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(erroraction, detaching);
    }
  };
}
function create_if_block_1$1I(ctx) {
  let manageemailsmodal;
  let current;
  manageemailsmodal = new ManageEmailModal({});
  manageemailsmodal.$on("close", ctx[4]);
  return {
    c() {
      create_component(manageemailsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(manageemailsmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(manageemailsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(manageemailsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(manageemailsmodal, detaching);
    }
  };
}
function create_if_block$2N(ctx) {
  let managephonesmodal;
  let current;
  managephonesmodal = new ManagePhonesModal({});
  managephonesmodal.$on("close", ctx[5]);
  return {
    c() {
      create_component(managephonesmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managephonesmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(managephonesmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managephonesmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managephonesmodal, detaching);
    }
  };
}
function create_fragment$4V(ctx) {
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let each_value = ctx[0].fields;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1i(get_each_context$1i(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block0 = ctx[1] && create_if_block_1$1I(ctx);
  let if_block1 = ctx[2] && create_if_block$2N(ctx);
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 9) {
        each_value = ctx2[0].fields;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1i(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1i(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$1I(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$2N(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$4K($$self, $$props, $$invalidate) {
  let { errorActionsFormModelList } = $$props;
  if (errorActionsFormModelList.length === 0) {
    errorActionsFormModelList.add();
  }
  let showManageEmailsModal = false;
  let showManagePhonesModal = false;
  function showModal(e) {
    const type = e.detail;
    if (type === "email") {
      $$invalidate(1, showManageEmailsModal = true);
    } else if (type === "phone") {
      $$invalidate(2, showManagePhonesModal = true);
    }
  }
  const close_handler = () => $$invalidate(1, showManageEmailsModal = false);
  const close_handler_1 = () => $$invalidate(2, showManagePhonesModal = false);
  $$self.$$set = ($$props2) => {
    if ("errorActionsFormModelList" in $$props2)
      $$invalidate(0, errorActionsFormModelList = $$props2.errorActionsFormModelList);
  };
  return [
    errorActionsFormModelList,
    showManageEmailsModal,
    showManagePhonesModal,
    showModal,
    close_handler,
    close_handler_1
  ];
}
class ErrorActions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4K, create_fragment$4V, safe_not_equal, { errorActionsFormModelList: 0 });
  }
}
class ErrorActionFieldType extends TYPES.base {
  static toJSON(obj) {
    return obj.toJSON();
  }
  static parse(json) {
    return new ErrorActionFormModel(json);
  }
}
register("errorAction", ErrorActionFieldType);
class ErrorActionsFormModelList extends FieldList {
  constructor(values2) {
    super({ type: "errorAction" }, values2);
  }
  getDef() {
    return {
      type: "errorAction"
    };
  }
  getDefaultValue() {
    return ErrorActionFormModel.getDefaultValue();
  }
}
const _ErrorActionFormModel = class extends FormModel {
  constructor(json) {
    super(_ErrorActionFormModel.fields, json);
    __publicField(this, "actions");
    this.actions = new Model$2.SieveActions(null, { parse: true });
    (json["actions"] || []).forEach((actionPojo) => {
      const SieveActionType = Model$2.SieveAction[actionPojo["type"]];
      this.actions.add(new SieveActionType(actionPojo, { parse: true }));
    });
  }
  static getDefaultValue() {
    return {
      trigger: false,
      minimum_time_interval: 15,
      number_of_consecutive_errors: 5,
      sieve_filter: ""
    };
  }
  getActions() {
    return this.actions;
  }
  toJSON(dirty = false) {
    const valueWithoutActions = super.toJSON(dirty);
    return {
      ...valueWithoutActions,
      actions: this.actions.toJSON()
    };
  }
};
let ErrorActionFormModel = _ErrorActionFormModel;
__publicField(ErrorActionFormModel, "fields", Object.freeze({
  trigger: {
    required: false,
    type: "boolean",
    default: false
  },
  minimum_time_interval: {
    required: false,
    type: "uint",
    default: 15,
    validators: [cannotBeLessThan(2)]
  },
  number_of_consecutive_errors: {
    required: false,
    type: "int",
    default: 5,
    validators: [cannotBeLessThan(1)]
  },
  sieve_filter: {
    required: false,
    type: "string",
    default: ""
  }
}));
function create_catch_block$F(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$F(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$2M, create_else_block$1u];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$1u(ctx) {
  let div1;
  let h3;
  let t0;
  let t1_value = ctx[1] ? "(local)" : "";
  let t1;
  let t2;
  let div0;
  let erroractions;
  let t3;
  let button;
  let t4;
  let current;
  let mounted;
  let dispose;
  erroractions = new ErrorActions({
    props: {
      errorActionsFormModelList: ctx[3]
    }
  });
  return {
    c() {
      div1 = element("div");
      h3 = element("h3");
      t0 = text("Error Actions ");
      t1 = text(t1_value);
      t2 = space();
      div0 = element("div");
      create_component(erroractions.$$.fragment);
      t3 = space();
      button = element("button");
      t4 = text("Save");
      attr(h3, "class", "card-header");
      attr(button, "type", "button");
      attr(button, "class", "btn btn-primary mt-2");
      set_style(button, "width", "100px");
      button.disabled = ctx[2];
      attr(div0, "class", "card-body");
      attr(div1, "class", "card");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, h3);
      append(h3, t0);
      append(h3, t1);
      append(div1, t2);
      append(div1, div0);
      mount_component(erroractions, div0, null);
      append(div0, t3);
      append(div0, button);
      append(button, t4);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 2) && t1_value !== (t1_value = ctx2[1] ? "(local)" : ""))
        set_data(t1, t1_value);
      const erroractions_changes = {};
      if (dirty & 8)
        erroractions_changes.errorActionsFormModelList = ctx2[3];
      erroractions.$set(erroractions_changes);
      if (!current || dirty & 4) {
        button.disabled = ctx2[2];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(erroractions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(erroractions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(erroractions);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$2M(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Error Actions",
      disableSave: ctx[2],
      onSave: ctx[6],
      $$slots: {
        default: [create_default_slot$1u],
        header: [create_header_slot$p]
      },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[7]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 4)
        savemodal_changes.disableSave = ctx2[2];
      if (dirty & 32778) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_header_slot$p(ctx) {
  let t0;
  let t1_value = ctx[1] ? "(local)" : "";
  let t1;
  return {
    c() {
      t0 = text("Error Actions ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t1_value !== (t1_value = ctx2[1] ? "(local)" : ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot$1u(ctx) {
  let erroractions;
  let current;
  erroractions = new ErrorActions({
    props: {
      errorActionsFormModelList: ctx[3]
    }
  });
  return {
    c() {
      create_component(erroractions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(erroractions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const erroractions_changes = {};
      if (dirty & 8)
        erroractions_changes.errorActionsFormModelList = ctx2[3];
      erroractions.$set(erroractions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(erroractions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(erroractions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(erroractions, detaching);
    }
  };
}
function create_pending_block$F(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$4U(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$F,
    then: create_then_block$F,
    catch: create_catch_block$F,
    value: 14,
    blocks: [, , ,]
  };
  handle_promise(ctx[5](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$4J($$self, $$props, $$invalidate) {
  let $user;
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(10, $route = $$value));
  let { modalView = true } = $$props;
  let localClient = false;
  const team = $route.team;
  const dispatch = createEventDispatcher();
  let disableSave = false;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(9, $user = value));
  let errorActions = [];
  let errorActionsFormModelList;
  async function fetchErrorActions() {
    try {
      if (Supports.agents.local) {
        errorActions = await serviceProxy.store.Prefs.get("errorActions");
        $$invalidate(1, localClient = true);
      } else {
        errorActions = user.getErrorActionsPref({ groupId: team }) || [];
      }
      if (!errorActions) {
        errorActions = [];
      }
      $$invalidate(3, errorActionsFormModelList = new ErrorActionsFormModelList(structuredClone(errorActions)));
      const outerFormError = errorActionsFormModelList.error;
      outerFormError.subscribe((err) => {
        $$invalidate(2, disableSave = !!err);
      });
    } catch (e) {
      console.error("error while fetching the errorActions", e);
      Msg.error("Failed to fetch the error actions");
    }
  }
  onMount(() => {
    if (!$user.id) {
      close();
      alert("Please sign in to save global actions");
    }
  });
  function close() {
    dispatch("close");
  }
  async function save() {
    let allActionsValid = true;
    errorActionsFormModelList.fields.forEach((field) => {
      const actions = field.getActions();
      const isValid2 = actions.validateActions();
      if (!isValid2) {
        allActionsValid = false;
      }
    });
    if (allActionsValid) {
      try {
        const data = errorActionsFormModelList.toJSON();
        Msg.info("Saving");
        if (localClient) {
          await serviceProxy.store.Prefs.set("errorActions", data);
        } else {
          await user.updateErrorActionsPref(data, { groupId: team || "0" });
        }
        close();
        Msg.reset();
      } catch (e) {
        console.error("error while saving the errorActions", e);
        Msg.error("Failed to update the error actions");
      }
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("modalView" in $$props2)
      $$invalidate(0, modalView = $$props2.modalView);
  };
  return [
    modalView,
    localClient,
    disableSave,
    errorActionsFormModelList,
    user,
    fetchErrorActions,
    save,
    close_handler
  ];
}
class ErrorActionsModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4J, create_fragment$4U, safe_not_equal, { modalView: 0 });
  }
}
function create_default_slot_1$r(ctx) {
  let a0;
  let t1;
  let a1;
  let t3;
  let a2;
  let t5;
  let a3;
  let t7;
  let a4;
  return {
    c() {
      a0 = element("a");
      a0.innerHTML = `General<i class="fa fa-chevron-right right"></i>`;
      t1 = space();
      a1 = element("a");
      a1.innerHTML = `Actions<i class="fa fa-chevron-right right"></i>`;
      t3 = space();
      a2 = element("a");
      a2.innerHTML = `Error Actions<i class="fa fa-chevron-right"></i>`;
      t5 = space();
      a3 = element("a");
      a3.innerHTML = `Devices<i class="fa fa-chevron-right right"></i>`;
      t7 = space();
      a4 = element("a");
      a4.innerHTML = `Advanced<i class="fa fa-chevron-right right"></i>`;
      attr(a0, "href", "#/settings/general/");
      attr(a0, "class", "list-group-item d-flex align-items-center justify-content-between");
      toggle_class(a0, "active", ctx[0].module == "general");
      attr(a1, "href", "#/settings/actions/");
      attr(a1, "class", "list-group-item d-flex align-items-center justify-content-between");
      toggle_class(a1, "active", ctx[0].module == "actions");
      attr(a2, "href", "#/settings/error_actions/");
      attr(a2, "class", "list-group-item d-flex align-items-center justify-content-between");
      toggle_class(a2, "active", ctx[0].module === "error_actions");
      attr(a3, "href", "#/settings/devices/");
      attr(a3, "class", "list-group-item d-flex align-items-center justify-content-between");
      toggle_class(a3, "active", ctx[0].module == "devices");
      attr(a4, "href", "#/settings/advanced/");
      attr(a4, "class", "list-group-item d-flex align-items-center justify-content-between");
      toggle_class(a4, "active", ctx[0].module == "advanced");
    },
    m(target, anchor) {
      insert(target, a0, anchor);
      insert(target, t1, anchor);
      insert(target, a1, anchor);
      insert(target, t3, anchor);
      insert(target, a2, anchor);
      insert(target, t5, anchor);
      insert(target, a3, anchor);
      insert(target, t7, anchor);
      insert(target, a4, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        toggle_class(a0, "active", ctx2[0].module == "general");
      }
      if (dirty & 1) {
        toggle_class(a1, "active", ctx2[0].module == "actions");
      }
      if (dirty & 1) {
        toggle_class(a2, "active", ctx2[0].module === "error_actions");
      }
      if (dirty & 1) {
        toggle_class(a3, "active", ctx2[0].module == "devices");
      }
      if (dirty & 1) {
        toggle_class(a4, "active", ctx2[0].module == "advanced");
      }
    },
    d(detaching) {
      if (detaching)
        detach(a0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(a1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(a2);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(a3);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(a4);
    }
  };
}
function create_default_slot$1t(ctx) {
  let div6;
  let div5;
  let div3;
  let collapse;
  let t0;
  let div0;
  let a0;
  let t1;
  let i0;
  let t2;
  let a1;
  let t3;
  let i1;
  let t4;
  let a2;
  let t5;
  let i2;
  let t6;
  let a3;
  let t7;
  let i3;
  let t8;
  let a4;
  let t9;
  let i4;
  let t10;
  let div1;
  let span0;
  let t13;
  let div2;
  let span1;
  let t16;
  let div4;
  let switch_instance;
  let current;
  collapse = new Collapse({
    props: {
      actionClass: "visible-xs",
      collapseClass: "dont-collapse-sm list-group mt-2",
      $$slots: { default: [create_default_slot_1$r] },
      $$scope: { ctx }
    }
  });
  const switch_instance_spread_levels = [ctx[1][ctx[0].module].props];
  var switch_value = ctx[1][ctx[0].module].component;
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i5 = 0; i5 < switch_instance_spread_levels.length; i5 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i5]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
  }
  return {
    c() {
      div6 = element("div");
      div5 = element("div");
      div3 = element("div");
      create_component(collapse.$$.fragment);
      t0 = space();
      div0 = element("div");
      a0 = element("a");
      t1 = text("Account");
      i0 = element("i");
      t2 = space();
      a1 = element("a");
      t3 = text("Alert Format");
      i1 = element("i");
      t4 = space();
      a2 = element("a");
      t5 = text("Billing");
      i2 = element("i");
      t6 = space();
      a3 = element("a");
      t7 = text("Emails and Phones");
      i3 = element("i");
      t8 = space();
      a4 = element("a");
      t9 = text("Profile");
      i4 = element("i");
      t10 = space();
      div1 = element("div");
      span0 = element("span");
      span0.textContent = `Version: ${serviceProxy.CFG.VERSION}`;
      t13 = space();
      div2 = element("div");
      span1 = element("span");
      span1.textContent = `Device: ${serviceProxy.CFG.CLIENT.INFO}`;
      t16 = space();
      div4 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(i0, "class", "fa fa-external-link right");
      attr(a0, "href", URL_ROOT + "#/settings/account/");
      attr(a0, "class", "list-group-item d-flex align-items-center justify-content-between");
      attr(a0, "target", "_blank");
      attr(i1, "class", "fa fa-external-link right");
      attr(a1, "href", URL_ROOT + "#/settings/actions/");
      attr(a1, "class", "list-group-item d-flex align-items-center justify-content-between");
      attr(a1, "target", "_blank");
      attr(i2, "class", "fa fa-external-link right");
      attr(a2, "href", URL_ROOT + "#/settings/billing/");
      attr(a2, "class", "list-group-item d-flex align-items-center justify-content-between");
      attr(a2, "target", "_blank");
      attr(i3, "class", "fa fa-external-link right");
      attr(a3, "href", URL_ROOT + "#/settings/emails_phones/");
      attr(a3, "class", "list-group-item d-flex align-items-center justify-content-between");
      attr(a3, "target", "_blank");
      attr(i4, "class", "fa fa-external-link right");
      attr(a4, "href", URL_ROOT + "#/settings/profile/");
      attr(a4, "class", "list-group-item d-flex align-items-center justify-content-between");
      attr(a4, "target", "_blank");
      attr(div0, "class", "list-group collapse dont-collapse-sm mt-4");
      attr(span0, "class", "pl-4 ml-2 font-sans font-extralight text-base");
      attr(div1, "class", "mt-2");
      attr(span1, "class", "pl-4 ml-2 font-sans font-extralight text-base");
      attr(div3, "class", "col-sm-3");
      attr(div4, "class", "col-sm-9");
      attr(div5, "class", "row");
      attr(div6, "class", "container pt4");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div5);
      append(div5, div3);
      mount_component(collapse, div3, null);
      append(div3, t0);
      append(div3, div0);
      append(div0, a0);
      append(a0, t1);
      append(a0, i0);
      append(div0, t2);
      append(div0, a1);
      append(a1, t3);
      append(a1, i1);
      append(div0, t4);
      append(div0, a2);
      append(a2, t5);
      append(a2, i2);
      append(div0, t6);
      append(div0, a3);
      append(a3, t7);
      append(a3, i3);
      append(div0, t8);
      append(div0, a4);
      append(a4, t9);
      append(a4, i4);
      append(div3, t10);
      append(div3, div1);
      append(div1, span0);
      append(div3, t13);
      append(div3, div2);
      append(div2, span1);
      append(div5, t16);
      append(div5, div4);
      if (switch_instance)
        mount_component(switch_instance, div4, null);
      current = true;
    },
    p(ctx2, dirty) {
      const collapse_changes = {};
      if (dirty & 5) {
        collapse_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapse.$set(collapse_changes);
      const switch_instance_changes = dirty & 3 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[1][ctx2[0].module].props)]) : {};
      if (dirty & 1 && switch_value !== (switch_value = ctx2[1][ctx2[0].module].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div4, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(collapse.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(collapse.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_component(collapse);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_topbar_slot$c(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Settings" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$4T(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$c],
        default: [create_default_slot$1t]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 5) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$4I($$self, $$props, $$invalidate) {
  let { params: params2 } = $$props;
  const components = {
    actions: { component: ActionsExt },
    advanced: { component: AdvancedExt },
    devices: { component: Devices },
    general: { component: GeneralExt },
    error_actions: {
      component: ErrorActionsModal,
      props: { modalView: false, params: params2 }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(0, params2 = $$props2.params);
  };
  return [params2, components];
}
class Index_ext extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4I, create_fragment$4T, safe_not_equal, { params: 0 });
  }
}
function create_fragment$4S(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "This account is not subscribed to an Enterprise plan. If your company has an Enterprise account with us or need to get one, please contact support.";
      attr(div, "class", "alert alert-info ma4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class EnterpriseOnly extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4S, safe_not_equal, {});
  }
}
function create_else_block$1t(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `404 - Path Not Found - ${location.hash.slice(1)}`;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$2L(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: { default: [create_default_slot$1s] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const layout_changes = {};
      if (dirty & 4) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function create_default_slot$1s(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `404 - Path Not Found - ${location.hash.slice(1)}`;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$4R(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$2L, create_else_block$1t];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$4H($$self, $$props, $$invalidate) {
  let { params: params2 = null } = $$props;
  let { useLayout = true } = $$props;
  console.error("404", params2);
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(1, params2 = $$props2.params);
    if ("useLayout" in $$props2)
      $$invalidate(0, useLayout = $$props2.useLayout);
  };
  return [useLayout, params2];
}
class Error404 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4H, create_fragment$4R, safe_not_equal, { params: 1, useLayout: 0 });
  }
}
var Account_svelte_svelte_type_style_lang = "";
function create_fragment$4Q(ctx) {
  let div1;
  let t1;
  let form;
  let div2;
  let label0;
  let t3;
  let input0;
  let t4;
  let div3;
  let label1;
  let t6;
  let input1;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="col-md-3"><h4>Account</h4></div>`;
      t1 = space();
      form = element("form");
      div2 = element("div");
      label0 = element("label");
      label0.textContent = "Name";
      t3 = space();
      input0 = element("input");
      t4 = space();
      div3 = element("div");
      label1 = element("label");
      label1.textContent = "Company Icon URL";
      t6 = space();
      input1 = element("input");
      attr(div1, "class", "row");
      set_style(div1, "margin-bottom", "15px");
      set_style(div1, "border-bottom", "1px solid #ccc");
      set_style(div1, "padding-bottom", "10px");
      attr(label0, "class", "svelte-gjmi4x");
      attr(input0, "id", "name");
      attr(input0, "type", "text");
      attr(input0, "name", "name");
      attr(input0, "placeholder", "Name");
      attr(input0, "class", "form-control");
      attr(div2, "class", "form-group");
      attr(label1, "class", "svelte-gjmi4x");
      attr(input1, "id", "name");
      attr(input1, "type", "text");
      attr(input1, "class", "form-control");
      attr(input1, "placeholder", "Enter 48x48 or bigger icon url. e.g. https://www.example.com/company-icon.png");
      attr(div3, "class", "form-group");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      insert(target, t1, anchor);
      insert(target, form, anchor);
      append(form, div2);
      append(div2, label0);
      append(div2, t3);
      append(div2, input0);
      set_input_value(input0, ctx[0].name);
      append(form, t4);
      append(form, div3);
      append(div3, label1);
      append(div3, t6);
      append(div3, input1);
      set_input_value(input1, ctx[1].icon);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[4]),
          listen(input0, "input", ctx[2]),
          listen(input1, "input", ctx[5]),
          listen(input1, "input", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input0.value !== ctx2[0].name) {
        set_input_value(input0, ctx2[0].name);
      }
      if (dirty & 2 && input1.value !== ctx2[1].icon) {
        set_input_value(input1, ctx2[1].icon);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(form);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4G($$self, $$props, $$invalidate) {
  let account = {};
  let prefs = {};
  onMount(async () => {
    $$invalidate(0, account = await Api.api("/admin/account"));
    $$invalidate(1, prefs = account.prefs || {});
  });
  async function saveName() {
    await Api.api("/admin/account", "PATCH", { name: account.name });
  }
  async function saveIcon() {
    await Api.api("/admin/account", "PATCH", { prefs });
  }
  function input0_input_handler() {
    account.name = this.value;
    $$invalidate(0, account);
  }
  function input1_input_handler() {
    prefs.icon = this.value;
    $$invalidate(1, prefs);
  }
  return [account, prefs, saveName, saveIcon, input0_input_handler, input1_input_handler];
}
class Account extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4G, create_fragment$4Q, safe_not_equal, {});
  }
}
const downloadBlob = (text2, filename) => {
  const blob = new Blob([text2], { type: "text/plain" });
  const objectUrl = URL.createObjectURL(blob);
  downloadUrl(objectUrl, filename);
  URL.revokeObjectURL(objectUrl);
};
const downloadUrl = (href2, filename) => {
  const element2 = document.createElement("a");
  element2.setAttribute("href", href2);
  element2.setAttribute("download", filename);
  document.body.appendChild(element2);
  element2.click();
  document.body.removeChild(element2);
};
function get_each_context$1h(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  return child_ctx;
}
function create_default_slot_1$q(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$2K(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      $$slots: {
        header: [create_header_slot$o],
        default: [create_default_slot$1r]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[6]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 4097) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_each_block$1h(ctx) {
  let div;
  let t_value = ctx[9].full_name + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "pa2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[9].full_name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$1r(ctx) {
  let each_1_anchor;
  let each_value = ctx[0].users;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1h(get_each_context$1h(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value = ctx2[0].users;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1h(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$1h(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_header_slot$o(ctx) {
  let div;
  let t0;
  let a;
  let t1;
  let a_href_value;
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text("Members\n      (");
      a = element("a");
      t1 = text("Manage");
      t2 = text(")");
      attr(a, "class", "f5");
      attr(a, "href", a_href_value = "#/teams/" + ctx[0].id);
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, a);
      append(a, t1);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && a_href_value !== (a_href_value = "#/teams/" + ctx2[0].id)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$4P(ctx) {
  let div5;
  let div0;
  let t0_value = ctx[0].name + "";
  let t0;
  let t1;
  let div1;
  let a;
  let t2_value = ctx[0].users.length + "";
  let t2;
  let t3;
  let t4_value = ctx[0].users.length > 1 ? "s" : "";
  let t4;
  let a_data_content_value;
  let t5;
  let div3;
  let div2;
  let button;
  let t6;
  let t7;
  let div4;
  let confirmbtn;
  let t8;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot_1$q] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[4]);
  let if_block = ctx[2] && create_if_block$2K(ctx);
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      a = element("a");
      t2 = text(t2_value);
      t3 = text(" Member");
      t4 = text(t4_value);
      t5 = space();
      div3 = element("div");
      div2 = element("div");
      button = element("button");
      t6 = text("Export");
      t7 = space();
      div4 = element("div");
      create_component(confirmbtn.$$.fragment);
      t8 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div0, "class", "col-md-3");
      attr(a, "href", "#");
      attr(a, "tabindex", "0");
      attr(a, "role", "button");
      set_style(a, "border", "none");
      set_style(a, "cursor", "pointer");
      attr(a, "title", "Group Members");
      attr(a, "data-content", a_data_content_value = ctx[0].users.map(func$3).join("<br/>"));
      attr(div1, "class", "text-center col-md-3");
      attr(button, "class", "btn btn-default");
      button.disabled = ctx[1];
      attr(div2, "class", "text-center");
      attr(div3, "class", "col-md-3");
      attr(div4, "class", "text-center col-md-3");
      attr(div5, "class", "row flex items-center pt2 pb2 bb b--black-20");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      append(div0, t0);
      append(div5, t1);
      append(div5, div1);
      append(div1, a);
      append(a, t2);
      append(a, t3);
      append(a, t4);
      append(div5, t5);
      append(div5, div3);
      append(div3, div2);
      append(div2, button);
      append(button, t6);
      append(div5, t7);
      append(div5, div4);
      mount_component(confirmbtn, div4, null);
      insert(target, t8, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a, "click", prevent_default(ctx[5])),
          listen(button, "click", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0].users.length + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & 1) && t4_value !== (t4_value = ctx2[0].users.length > 1 ? "s" : ""))
        set_data(t4, t4_value);
      if (!current || dirty & 1 && a_data_content_value !== (a_data_content_value = ctx2[0].users.map(func$3).join("<br/>"))) {
        attr(a, "data-content", a_data_content_value);
      }
      if (!current || dirty & 2) {
        button.disabled = ctx2[1];
      }
      const confirmbtn_changes = {};
      if (dirty & 4096) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2K(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(confirmbtn);
      if (detaching)
        detach(t8);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
const func$3 = (u) => u.full_name;
function instance$4F($$self, $$props, $$invalidate) {
  let { group: group2 } = $$props;
  let loading2 = false;
  let showUsers = false;
  async function exportMonitors() {
    try {
      $$invalidate(1, loading2 = true);
      await load([], 0, group2.id);
    } catch (e) {
      console.error(e);
    } finally {
      $$invalidate(1, loading2 = false);
    }
  }
  async function load(list, offset, id2) {
    const res = await Api.api(`/admin/users/${id2}/sieves`, "GET", _.extend(
      {
        _opt: {
          offset,
          only: [
            "name",
            "uri",
            "config",
            "tags",
            "content_type",
            "state",
            "schedule",
            "ts"
          ]
        }
      },
      { "state.in": [40, 45] }
    ));
    list = list.concat(res.data);
    offset += res.count;
    if (offset < res.total_count) {
      await load(list, offset, id2);
    } else {
      onLoadListDone(id2, list);
    }
  }
  async function onLoadListDone(id2, list) {
    const res = await Api.api(`/admin/users/${id2}/tags`, "GET");
    const tags = res.data.reduce(
      (memo, item) => {
        memo[item.id] = item;
        return memo;
      },
      {}
    );
    list.forEach((x) => {
      x.tags = _.compact((x.tags || "").split(",").map(function(id3) {
        const tag = tags[id3];
        return tag ? tag.name : void 0;
      }));
      delete x.id;
      delete x.rule_id;
      delete x.ts;
      delete x.ts_mod;
      delete x._state;
    });
    const json = JSON.stringify({ client: Supports.agents, data: list });
    downloadBlob(json, `${group2.name}-sieves.json`);
  }
  async function removeGroup() {
    try {
      const response = await Api.api(`/admin/groups/${group2.id}`, "DELETE");
    } catch (e) {
      alert("Something went wrong");
      console.error(e);
    }
  }
  function onShowUsers(e) {
    e.preventDefault();
    $$invalidate(2, showUsers = true);
  }
  const close_handler = (e) => $$invalidate(2, showUsers = false);
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(0, group2 = $$props2.group);
  };
  return [
    group2,
    loading2,
    showUsers,
    exportMonitors,
    removeGroup,
    onShowUsers,
    close_handler
  ];
}
class Group extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4F, create_fragment$4P, safe_not_equal, { group: 0 });
  }
}
function get_each_context$1g(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_each_block$1g(ctx) {
  let group2;
  let current;
  group2 = new Group({
    props: {
      group: ctx[0][ctx[4]],
      users: ctx[1]
    }
  });
  return {
    c() {
      create_component(group2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(group2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const group_changes = {};
      if (dirty & 1)
        group_changes.group = ctx2[0][ctx2[4]];
      if (dirty & 2)
        group_changes.users = ctx2[1];
      group2.$set(group_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(group2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(group2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(group2, detaching);
    }
  };
}
function create_fragment$4O(ctx) {
  let div4;
  let t4;
  let div9;
  let t12;
  let each_1_anchor;
  let current;
  let each_value = Object.keys(ctx[0]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1g(get_each_context$1g(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div4 = element("div");
      div4.innerHTML = `<div class="col-md-12"><a href="#/teams/" class="btn btn-primary right">+ Add New Team</a></div> 
  <div style="text-align: left;" class="col-md-2"></div> 
  <div class="col-md-3"></div> 
  <div class="col-md-3"></div>`;
      t4 = space();
      div9 = element("div");
      div9.innerHTML = `<div class="col-md-3"><h5>Name</h5></div> 
  <div class="text-center col-md-3"><h5>Members</h5></div> 
  <div class="text-center col-md-3"><h5>Export Watchlist</h5></div> 
  <div class="text-center col-md-3"><h5>Delete</h5></div>`;
      t12 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(div4, "class", "row mb3");
      attr(div9, "class", "row pb2 bb");
      set_style(div9, "border-color", "#ccc");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      insert(target, t4, anchor);
      insert(target, div9, anchor);
      insert(target, t12, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = Object.keys(ctx2[0]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1g(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1g(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(div9);
      if (detaching)
        detach(t12);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
const LIMIT$1 = 50;
function instance$4E($$self, $$props, $$invalidate) {
  let groups = {};
  let users = [];
  onMount(() => {
    refreshGroups();
  });
  async function refreshGroups() {
    let allGroups = await fetchGroups();
    $$invalidate(1, users = (await Api.api("/accounts/users")).data);
    for (let guser of allGroups) {
      let { id: id2, name } = guser;
      let group2 = { id: id2, name, users: [guser] };
      if (groups[id2]) {
        groups[id2].users.push(guser);
      } else {
        $$invalidate(0, groups[id2] = group2, groups);
      }
    }
  }
  async function fetchGroups(offset = 0, groups2 = []) {
    const response = await Api.api("/admin/groups/users", "GET", { _opt: { limit: LIMIT$1, offset } });
    groups2 = groups2.concat(response.data);
    if (response.count === LIMIT$1) {
      return await fetchGroups(offset + LIMIT$1, groups2);
    }
    return groups2;
  }
  return [groups, users];
}
class Groups extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4E, create_fragment$4O, safe_not_equal, {});
  }
}
function create_default_slot$1q(ctx) {
  let t;
  return {
    c() {
      t = text("Remove");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$4N(ctx) {
  let div5;
  let div0;
  let t0_value = ctx[0].full_name + "";
  let t0;
  let t1;
  let div1;
  let t2_value = ctx[0].email + "";
  let t2;
  let t3;
  let div2;
  let input;
  let input_checked_value;
  let input_disabled_value;
  let t4;
  let div3;
  let button;
  let t5;
  let t6;
  let div4;
  let confirmbtn;
  let current;
  let mounted;
  let dispose;
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot$1q] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[4]);
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      input = element("input");
      t4 = space();
      div3 = element("div");
      button = element("button");
      t5 = text("Export");
      t6 = space();
      div4 = element("div");
      create_component(confirmbtn.$$.fragment);
      attr(div0, "class", "col-md-3");
      attr(div1, "class", "col-md-3");
      attr(input, "type", "checkbox");
      input.checked = input_checked_value = ctx[0].role == "admin";
      input.disabled = input_disabled_value = ctx[0].id == USER.id;
      attr(div2, "class", "text-center col-md-2");
      attr(button, "class", "btn btn-default btn-slim");
      button.disabled = ctx[1];
      attr(div3, "class", "text-center col-md-2");
      attr(div4, "class", "text-center col-md-2");
      toggle_class(div4, "hide", ctx[2].id == ctx[0].id);
      attr(div5, "class", "row flex items-center pt2 pb2 bb b--black-20");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      append(div0, t0);
      append(div5, t1);
      append(div5, div1);
      append(div1, t2);
      append(div5, t3);
      append(div5, div2);
      append(div2, input);
      append(div5, t4);
      append(div5, div3);
      append(div3, button);
      append(button, t5);
      append(div5, t6);
      append(div5, div4);
      mount_component(confirmbtn, div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "click", ctx[5]),
          listen(button, "click", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].full_name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0].email + ""))
        set_data(t2, t2_value);
      if (!current || dirty & 1 && input_checked_value !== (input_checked_value = ctx2[0].role == "admin")) {
        input.checked = input_checked_value;
      }
      if (!current || dirty & 1 && input_disabled_value !== (input_disabled_value = ctx2[0].id == USER.id)) {
        input.disabled = input_disabled_value;
      }
      if (!current || dirty & 2) {
        button.disabled = ctx2[1];
      }
      const confirmbtn_changes = {};
      if (dirty & 512) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
      if (!current || dirty & 5) {
        toggle_class(div4, "hide", ctx2[2].id == ctx2[0].id);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_component(confirmbtn);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4D($$self, $$props, $$invalidate) {
  let { user } = $$props;
  let dispatch = createEventDispatcher();
  let thisUser = getContext("user");
  let loading2 = false;
  async function exportMonitors() {
    try {
      $$invalidate(1, loading2 = true);
      await load([], 0, user.id);
    } catch (e) {
      console.error(e);
    } finally {
      $$invalidate(1, loading2 = false);
    }
  }
  async function load(list, offset, id2) {
    const res = await Api.api(`/admin/users/${id2}/sieves`, "GET", _.extend(
      {
        _opt: {
          offset,
          only: [
            "name",
            "uri",
            "config",
            "tags",
            "content_type",
            "state",
            "schedule",
            "ts"
          ]
        }
      },
      { "state.in": [40, 45] }
    ));
    list = list.concat(res.data);
    offset += res.count;
    if (offset < res.total_count) {
      await load(list, offset, id2);
    } else {
      onLoadListDone(id2, list);
    }
  }
  async function onLoadListDone(id2, list) {
    const res = await Api.api(`/admin/users/${id2}/tags`, "GET");
    const tags = res.data.reduce(
      (memo, item) => {
        memo[item.id] = item;
        return memo;
      },
      {}
    );
    list.forEach((x) => {
      x.tags = _.compact((x.tags || "").split(",").map(function(id3) {
        const tag = tags[id3];
        return tag ? tag.name : void 0;
      }));
      delete x.id;
      delete x.rule_id;
      delete x.ts;
      delete x.ts_mod;
      delete x._state;
    });
    const json = JSON.stringify({ client: Supports.agents, data: list });
    downloadBlob(json, `${user.name}-sieves.json`);
  }
  async function removeUser() {
    try {
      const response = await Api.api(`/admin/users/${user.id}`, "DELETE");
      if (response.msg == "ok") {
        dispatch("change");
      } else {
        alert("Please try again later, something went wrong");
        console.error(response);
      }
    } catch (e) {
      alert("Please try again later, something went wrong");
      console.error(e);
    }
  }
  async function modifyAdminStatus(e) {
    const params2 = {};
    if (e.target.checked) {
      params2.role = "admin";
    } else {
      params2.role = "user";
    }
    try {
      const response = await Api.api(`/admin/users/${user.id}`, "PUT", params2);
      if (response && response.msg == "ok") {
        dispatch("change");
      } else {
        alert("Something went wrong");
        console.error(response);
      }
    } catch (e2) {
      alert("Something went wrong");
      console.error(e2);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("user" in $$props2)
      $$invalidate(0, user = $$props2.user);
  };
  return [user, loading2, thisUser, exportMonitors, removeUser, modifyAdminStatus];
}
class User extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4D, create_fragment$4N, safe_not_equal, { user: 0 });
  }
}
function create_default_slot$1p(ctx) {
  let input;
  let input_class_value;
  let input_placeholder_value;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "email" },
    {
      class: input_class_value = "form-control " + ctx[1]
    },
    {
      placeholder: input_placeholder_value = TXT("l_email")
    },
    ctx[3]
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign(input_data, input_levels[i2]);
  }
  return {
    c() {
      input = element("input");
      set_attributes(input, input_data);
      toggle_class(input, "is-invalid", ctx[6]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (input.autofocus)
        input.focus();
      if (!mounted) {
        dispose = [
          action_destroyer(ctx[5].call(null, input)),
          listen(input, "input", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "email" },
        dirty & 2 && input_class_value !== (input_class_value = "form-control " + ctx2[1]) && { class: input_class_value },
        { placeholder: input_placeholder_value },
        dirty & 8 && ctx2[3]
      ]));
      toggle_class(input, "is-invalid", ctx2[6]);
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$2J(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element("p");
      t = text(ctx[2]);
      attr(p, "class", "help");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_fragment$4M(ctx) {
  let fieldwrapper;
  let t;
  let if_block_anchor;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[0],
      $$slots: {
        default: [
          create_default_slot$1p,
          ({ action, showError }) => ({ 5: action, 6: showError }),
          ({ action, showError }) => (action ? 32 : 0) | (showError ? 64 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = !!ctx[2] && create_if_block$2J(ctx);
  return {
    c() {
      create_component(fieldwrapper.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(fieldwrapper, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 1)
        fieldwrapper_changes.field = ctx2[0];
      if (dirty & 202) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
      if (!!ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$2J(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldwrapper, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$4C($$self, $$props, $$invalidate) {
  const omit_props_names = ["field", "inputClasses", "help"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { field } = $$props;
  let { inputClasses = "" } = $$props;
  let { help = "" } = $$props;
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("field" in $$new_props)
      $$invalidate(0, field = $$new_props.field);
    if ("inputClasses" in $$new_props)
      $$invalidate(1, inputClasses = $$new_props.inputClasses);
    if ("help" in $$new_props)
      $$invalidate(2, help = $$new_props.help);
  };
  return [field, inputClasses, help, $$restProps, input_handler];
}
class EmailEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4C, create_fragment$4M, safe_not_equal, { field: 0, inputClasses: 1, help: 2 });
  }
}
function get_each_context$1f(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  return child_ctx;
}
function create_if_block_1$1H(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Please enter different email, entered email already exists";
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block$2I(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `Email should belong to the following domains: ${ctx[3].domains.join(", ")}`;
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_each_block$1f(key_1, ctx) {
  let div;
  let label;
  let input;
  let t0;
  let t1_value = ctx[19].name + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return ctx[9](ctx[19], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "checkbox");
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, input);
      append(label, t0);
      append(label, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(input, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t1_value !== (t1_value = ctx[19].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4L(ctx) {
  let div4;
  let form;
  let div0;
  let label0;
  let t1;
  let inputedit;
  let t2;
  let div1;
  let label1;
  let t4;
  let emailedit;
  let t5;
  let t6;
  let t7;
  let div2;
  let label2;
  let t9;
  let select2;
  let option0;
  let option1;
  let t12;
  let label3;
  let t14;
  let div3;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let mounted;
  let dispose;
  inputedit = new InputEdit({
    props: {
      field: ctx[5],
      placeholder: "Full Name"
    }
  });
  emailedit = new EmailEdit({
    props: {
      field: ctx[4],
      placeholder: "Email ID"
    }
  });
  let if_block0 = ctx[2].duplicate_email && create_if_block_1$1H();
  let if_block1 = ctx[2].email_domain && create_if_block$2I(ctx);
  let each_value = ctx[1];
  const get_key = (ctx2) => ctx2[19].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$1f(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$1f(key, child_ctx));
  }
  return {
    c() {
      div4 = element("div");
      form = element("form");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Full Name";
      t1 = space();
      create_component(inputedit.$$.fragment);
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Email ID";
      t4 = space();
      create_component(emailedit.$$.fragment);
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      div2 = element("div");
      label2 = element("label");
      label2.textContent = "Role";
      t9 = space();
      select2 = element("select");
      option0 = element("option");
      option0.textContent = "User";
      option1 = element("option");
      option1.textContent = "Admin";
      t12 = space();
      label3 = element("label");
      label3.textContent = "Add to Team";
      t14 = space();
      div3 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(label0, "for", "groupName");
      attr(div0, "class", "form-group");
      attr(label1, "for", "groupName");
      attr(div1, "class", "form-group mt-1");
      attr(label2, "for", "employeeRole");
      option0.__value = "user";
      option0.value = option0.__value;
      option1.__value = "admin";
      option1.value = option1.__value;
      attr(select2, "class", "form-control");
      attr(select2, "id", "employeeRole");
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[8].call(select2));
      attr(div2, "class", "form-group mt-1");
      attr(label3, "class", "mt-1");
      attr(div3, "class", "p-4 max-h-[32rem] border border-solid border-gray-300");
      set_style(div3, "overflow", "scroll");
      attr(div4, "class", "row p-8");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, form);
      append(form, div0);
      append(div0, label0);
      append(div0, t1);
      mount_component(inputedit, div0, null);
      append(form, t2);
      append(form, div1);
      append(div1, label1);
      append(div1, t4);
      mount_component(emailedit, div1, null);
      append(form, t5);
      if (if_block0)
        if_block0.m(form, null);
      append(form, t6);
      if (if_block1)
        if_block1.m(form, null);
      append(form, t7);
      append(form, div2);
      append(div2, label2);
      append(div2, t9);
      append(div2, select2);
      append(select2, option0);
      append(select2, option1);
      select_option(select2, ctx[0], true);
      append(form, t12);
      append(form, label3);
      append(form, t14);
      append(form, div3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div3, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen(select2, "change", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[2].duplicate_email) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_1$1H();
          if_block0.c();
          if_block0.m(form, t6);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[2].email_domain) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$2I(ctx2);
          if_block1.c();
          if_block1.m(form, t7);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 1) {
        select_option(select2, ctx2[0]);
      }
      if (dirty & 66) {
        each_value = ctx2[1];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div3, destroy_block, create_each_block$1f, null, get_each_context$1f);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      transition_in(emailedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      transition_out(emailedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(inputedit);
      destroy_component(emailedit);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$4B($$self, $$props, $$invalidate) {
  let $email;
  let $full_name;
  let user = getContext("user");
  let account = user.get("account");
  const userFieldsDef = {
    email: { required: true, type: "email" },
    full_name: { required: true, type: "string" }
  };
  const userFormModel = new FormModel(userFieldsDef);
  let email = userFormModel.fields.email;
  component_subscribe($$self, email, (value) => $$invalidate(11, $email = value));
  let full_name = userFormModel.fields.full_name;
  component_subscribe($$self, full_name, (value) => $$invalidate(12, $full_name = value));
  let role = "user";
  let groups = [];
  let selectedGroups = [];
  let errors = {
    email_domain: false,
    duplicate_email: false
  };
  onMount(async () => {
    fetchGroups();
  });
  function addGroup(id2, e) {
    if (e.target.checked) {
      selectedGroups.push({ id: id2, admin: false, edit: true });
    } else {
      selectedGroups = _.filter(selectedGroups, (group2) => group2.id != id2);
    }
  }
  async function isDuplicate(email2) {
    const emailList = (await Api.api(`/admin/users`)).data.map((item) => {
      return item["email"];
    });
    return emailList.includes(email2);
  }
  async function validate() {
    let valid = true;
    if (!$full_name) {
      valid = false;
      full_name.setTouched(true);
    }
    if (await isDuplicate($email)) {
      valid = false;
      $$invalidate(2, errors = { ...errors, duplicate_email: true });
    }
    if (!$email || $email == "") {
      valid = false;
      email.setTouched(true);
    } else {
      set_store_value(email, $email = $email.trim(), $email);
      const emailParts = $email.split("@");
      let domain = emailParts[emailParts.length - 1];
      const domains = account.domains.map((domain2) => domain2.toLowerCase());
      domain = domain.toLowerCase();
      if (domains.indexOf(domain) == -1) {
        valid = false;
        $$invalidate(2, errors = { ...errors, email_domain: true });
      }
    }
    return valid;
  }
  async function fetchGroups() {
    const response = await Api.api("/admin/groups");
    $$invalidate(1, groups = response.data);
  }
  async function save() {
    if (!await validate()) {
      return false;
    }
    return await Api.api(`/admin/users`, "POST", {
      user: {
        role,
        full_name: $full_name.trim(),
        email: $email
      },
      groups: selectedGroups
    });
  }
  function select_change_handler() {
    role = select_value(this);
    $$invalidate(0, role);
  }
  const click_handler = (group2, e) => addGroup(group2.id, e);
  return [
    role,
    groups,
    errors,
    account,
    email,
    full_name,
    addGroup,
    save,
    select_change_handler,
    click_handler
  ];
}
class UserNew extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4B, create_fragment$4L, safe_not_equal, { save: 7 });
  }
  get save() {
    return this.$$.ctx[7];
  }
}
function get_each_context$1e(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_each_block$1e(key_1, ctx) {
  let first2;
  let user;
  let current;
  user = new User({ props: { user: ctx[8] } });
  user.$on("change", ctx[3]);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(user.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(user, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const user_changes = {};
      if (dirty & 1)
        user_changes.user = ctx[8];
      user.$set(user_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(user.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(user.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(user, detaching);
    }
  };
}
function create_if_block$2H(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      $$slots: {
        buttons: [create_buttons_slot$7],
        header: [create_header_slot$n],
        default: [create_default_slot$1o]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[7]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 2052) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_default_slot$1o(ctx) {
  let usernew;
  let current;
  let usernew_props = {};
  usernew = new UserNew({ props: usernew_props });
  ctx[6](usernew);
  return {
    c() {
      create_component(usernew.$$.fragment);
    },
    m(target, anchor) {
      mount_component(usernew, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const usernew_changes = {};
      usernew.$set(usernew_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(usernew.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(usernew.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[6](null);
      destroy_component(usernew, detaching);
    }
  };
}
function create_header_slot$n(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Add User";
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_buttons_slot$7(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = "Add User";
      attr(button, "class", "btn btn-primary");
      attr(div, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4K(ctx) {
  let div1;
  let div0;
  let button;
  let t1;
  let div7;
  let t11;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t12;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[8].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$1e(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$1e(key, child_ctx));
  }
  let if_block = ctx[1] && create_if_block$2H(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button = element("button");
      button.textContent = "+ Add New User";
      t1 = space();
      div7 = element("div");
      div7.innerHTML = `<div class="col-md-3"><h5>Name</h5></div> 
  <div class="col-md-3"><h5>Email</h5></div> 
  <div class="text-center col-md-2"><h5>Admin</h5></div> 
  <div class="text-center col-md-2"><h5>Export Watchlist</h5></div> 
  <div class="text-center col-md-2"><h5>Remove</h5></div>`;
      t11 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t12 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(button, "class", "btn btn-primary right");
      attr(div0, "class", "col-md-12");
      attr(div1, "class", "row mb3");
      attr(div7, "class", "row flex items-center pb2 bb");
      set_style(div7, "border-color", "#ccc");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button);
      insert(target, t1, anchor);
      insert(target, div7, anchor);
      insert(target, t11, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t12, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 9) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t12.parentNode, outro_and_destroy_block, create_each_block$1e, t12, get_each_context$1e);
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2H(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div7);
      if (detaching)
        detach(t11);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(t12);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$4A($$self, $$props, $$invalidate) {
  let users = [];
  let add = false;
  let addUser;
  async function refreshUsers() {
    const response = await Api.api("/admin/users", { _opt: { limit: 200 } });
    $$invalidate(0, users = response.data);
  }
  onMount(() => {
    refreshUsers();
  });
  async function onSaveNew() {
    try {
      if (await addUser.save()) {
        $$invalidate(1, add = false);
        await refreshUsers();
      }
    } catch (e) {
      alert("Something went wrong: " + e.message);
      console.error(e);
    }
  }
  const click_handler = (e) => $$invalidate(1, add = true);
  function usernew_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      addUser = $$value;
      $$invalidate(2, addUser);
    });
  }
  const close_handler = () => $$invalidate(1, add = false);
  return [
    users,
    add,
    addUser,
    refreshUsers,
    onSaveNew,
    click_handler,
    usernew_binding,
    close_handler
  ];
}
class Users extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4A, create_fragment$4K, safe_not_equal, {});
  }
}
function create_else_block$1s(ctx) {
  let entonly;
  let current;
  entonly = new EnterpriseOnly({});
  return {
    c() {
      create_component(entonly.$$.fragment);
    },
    m(target, anchor) {
      mount_component(entonly, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(entonly.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(entonly.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(entonly, detaching);
    }
  };
}
function create_if_block$2G(ctx) {
  let div4;
  let div1;
  let div0;
  let a0;
  let t1;
  let a1;
  let t3;
  let a2;
  let t5;
  let div3;
  let div2;
  let router;
  let current;
  router = new Router({
    props: {
      routes: ctx[3],
      prefix: "/admin"
    }
  });
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      a0 = element("a");
      a0.textContent = "Account";
      t1 = space();
      a1 = element("a");
      a1.textContent = "Users";
      t3 = space();
      a2 = element("a");
      a2.textContent = "Teams";
      t5 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(router.$$.fragment);
      attr(a0, "class", "list-group-item");
      attr(a0, "href", "#/admin/account/");
      toggle_class(a0, "active", ctx[0].module == "account");
      attr(a1, "class", "list-group-item");
      attr(a1, "href", "#/admin/users/");
      toggle_class(a1, "active", ctx[0].module == "users");
      attr(a2, "class", "list-group-item");
      attr(a2, "href", "#/admin/teams/");
      toggle_class(a2, "active", ctx[0].module == "teams");
      attr(div0, "class", "list-group collapse dont-collapse-sm");
      set_style(div0, "width", "18rem");
      attr(div1, "class", "col-md-3");
      attr(div2, "class", "container-fluid");
      attr(div3, "class", "col-md-8 ml4");
      attr(div4, "class", "row");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, div0);
      append(div0, a0);
      append(div0, t1);
      append(div0, a1);
      append(div0, t3);
      append(div0, a2);
      append(div4, t5);
      append(div4, div3);
      append(div3, div2);
      mount_component(router, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 1) {
        toggle_class(a0, "active", ctx2[0].module == "account");
      }
      if (!current || dirty & 1) {
        toggle_class(a1, "active", ctx2[0].module == "users");
      }
      if (!current || dirty & 1) {
        toggle_class(a2, "active", ctx2[0].module == "teams");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(router.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(router.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(router);
    }
  };
}
function create_default_slot$1n(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$2G, create_else_block$1s];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].account)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      attr(div0, "class", "row");
      attr(div1, "class", "container");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_topbar_slot$b(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Teams" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$4J(ctx) {
  let t;
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$b],
        default: [create_default_slot$1n]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(layout.$$.fragment);
      document.title = "Admin Console - Distill Web Monitor";
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 19) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(layout, detaching);
    }
  };
}
function instance$4z($$self, $$props, $$invalidate) {
  let $user;
  let { params: params2 } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(1, $user = value));
  const routes = {
    "/account/": Account,
    "/teams/": Groups,
    "/users/": Users,
    "*": Error404
  };
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(0, params2 = $$props2.params);
  };
  return [params2, $user, user, routes];
}
class Admin extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4z, create_fragment$4J, safe_not_equal, { params: 0 });
  }
}
var index_svelte_svelte_type_style_lang$1 = "";
function get_each_context$1d(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function create_else_block$1r(ctx) {
  let div12;
  let div11;
  let div10;
  let div0;
  let t0;
  let div8;
  let div5;
  let t8;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t9;
  let form;
  let div6;
  let input;
  let t10;
  let t11;
  let div7;
  let button;
  let t13;
  let div9;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[18].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$1d(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$1d(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$k();
  }
  let if_block = ctx[1] && create_if_block_1$1G();
  return {
    c() {
      div12 = element("div");
      div11 = element("div");
      div10 = element("div");
      div0 = element("div");
      t0 = space();
      div8 = element("div");
      div5 = element("div");
      div5.innerHTML = `<div class="col-md-4"><h4>Team Name</h4></div> 
              <div class="col-md-2 text-center"><h4>Role</h4></div> 
              <div class="col-md-3 text-center"><h4>Leave Team</h4></div> 
              <div class="col-md-3 text-center"><h4>Delete Team</h4></div>`;
      t8 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t9 = space();
      form = element("form");
      div6 = element("div");
      input = element("input");
      t10 = space();
      if (if_block)
        if_block.c();
      t11 = space();
      div7 = element("div");
      button = element("button");
      button.textContent = "Create New Team";
      t13 = space();
      div9 = element("div");
      attr(div0, "class", "col-md-2");
      attr(div5, "class", "row team svelte-grlz0z");
      attr(div5, "data-id", "");
      attr(input, "type", "text");
      attr(input, "class", "form-control");
      attr(input, "placeholder", "New Team Name");
      attr(div6, "class", "col-md-6");
      attr(button, "class", "btn btn-primary");
      attr(button, "type", "button");
      attr(div7, "class", "col-md-3 text-center");
      attr(form, "class", "row team svelte-grlz0z");
      attr(div8, "class", "col-md-8");
      attr(div9, "class", "col-md-2");
      attr(div10, "class", "row");
      attr(div11, "class", "group-table container-fluid");
      attr(div12, "class", "add-group");
      toggle_class(div12, "hide", !ctx[3]);
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append(div12, div11);
      append(div11, div10);
      append(div10, div0);
      append(div10, t0);
      append(div10, div8);
      append(div8, div5);
      append(div8, t8);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div8, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(div8, null);
      }
      append(div8, t9);
      append(div8, form);
      append(form, div6);
      append(div6, input);
      set_input_value(input, ctx[2].name);
      append(div6, t10);
      if (if_block)
        if_block.m(div6, null);
      append(form, t11);
      append(form, div7);
      append(div7, button);
      append(div10, t13);
      append(div10, div9);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[12]),
          listen(button, "click", ctx[13]),
          listen(form, "submit", ctx[14])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 97) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div8, outro_and_destroy_block, create_each_block$1d, t9, get_each_context$1d);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block_1$k();
          each_1_else.c();
          each_1_else.m(div8, t9);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
      if (dirty & 4 && input.value !== ctx2[2].name) {
        set_input_value(input, ctx2[2].name);
      }
      if (ctx2[1]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$1G();
          if_block.c();
          if_block.m(div6, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 8) {
        toggle_class(div12, "hide", !ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div12);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$2F(ctx) {
  let entonly;
  let current;
  entonly = new EnterpriseOnly({});
  return {
    c() {
      create_component(entonly.$$.fragment);
    },
    m(target, anchor) {
      mount_component(entonly, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(entonly.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(entonly.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(entonly, detaching);
    }
  };
}
function create_else_block_1$k(ctx) {
  let div1;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="col-md-9 alert alert-info ml3 mt2 mb2">Not part of any team. To be part of an existing team, please ask team admin to add you to the group.</div> 
              `;
      attr(div1, "class", "row team svelte-grlz0z");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_default_slot_2$f(ctx) {
  let t;
  return {
    c() {
      t = text("Leave");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$13(ctx) {
  let confirmbtn;
  let current;
  function click_handler_1(...args) {
    return ctx[11](ctx[18], ...args);
  }
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot_1$p] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", click_handler_1);
  return {
    c() {
      create_component(confirmbtn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmbtn, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const confirmbtn_changes = {};
      if (dirty & 2097152) {
        confirmbtn_changes.$$scope = { dirty, ctx };
      }
      confirmbtn.$set(confirmbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmbtn, detaching);
    }
  };
}
function create_default_slot_1$p(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$1d(key_1, ctx) {
  let div4;
  let div0;
  let a;
  let t0_value = ctx[18].name + "";
  let t0;
  let a_href_value;
  let t1;
  let div1;
  let t2_value = checkRole(ctx[18]) + "";
  let t2;
  let t3;
  let div2;
  let confirmbtn;
  let t4;
  let div3;
  let t5;
  let current;
  function click_handler(...args) {
    return ctx[10](ctx[18], ...args);
  }
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot_2$f] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", click_handler);
  let if_block = ctx[18].permissions.admin && create_if_block_2$13(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      div4 = element("div");
      div0 = element("div");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      create_component(confirmbtn.$$.fragment);
      t4 = space();
      div3 = element("div");
      if (if_block)
        if_block.c();
      t5 = space();
      attr(a, "href", a_href_value = "#/teams/" + ctx[18].id);
      attr(div0, "class", "col-md-4");
      attr(div1, "class", "col-md-2 text-center ");
      attr(div2, "class", "col-md-3 text-center remove-user");
      attr(div3, "class", "col-md-3 text-center remove-user");
      attr(div4, "class", "row team svelte-grlz0z");
      this.first = div4;
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div0, a);
      append(a, t0);
      append(div4, t1);
      append(div4, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div2);
      mount_component(confirmbtn, div2, null);
      append(div4, t4);
      append(div4, div3);
      if (if_block)
        if_block.m(div3, null);
      append(div4, t5);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[18].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 1 && a_href_value !== (a_href_value = "#/teams/" + ctx[18].id)) {
        attr(a, "href", a_href_value);
      }
      if ((!current || dirty & 1) && t2_value !== (t2_value = checkRole(ctx[18]) + ""))
        set_data(t2, t2_value);
      const confirmbtn_changes = {};
      if (dirty & 2097152) {
        confirmbtn_changes.$$scope = { dirty, ctx };
      }
      confirmbtn.$set(confirmbtn_changes);
      if (ctx[18].permissions.admin) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$13(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(confirmbtn);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$1G(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Please enter a team name.";
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_default_slot$1m(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$2F, create_else_block$1r];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_topbar_slot$a(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Teams" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$4I(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$a],
        default: [create_default_slot$1m]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 2097167) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function checkRole({ permissions }) {
  if (permissions.admin) {
    return "Admin";
  } else if (permissions.edit) {
    return "Editor";
  } else {
    return "Viewer";
  }
}
function instance$4y($$self, $$props, $$invalidate) {
  let $user;
  let { params: params2 = null } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(9, $user = value));
  let groups = [];
  let errEmptyTeam = false;
  let state = { name: "" };
  let isEnterprise = $user.account_id;
  fetchGroups();
  function validate() {
    $$invalidate(1, errEmptyTeam = false);
    let name = state.name;
    name = name.trim();
    if (!name || name == "") {
      $$invalidate(1, errEmptyTeam = true);
      return false;
    }
    return true;
  }
  async function fetchGroups() {
    let res = await Api.api("/groups", "GET", {
      user: { id: $user.id },
      _opt: { order: ["ts"] }
    });
    $$invalidate(0, groups = res.data);
  }
  async function leaveGroup(id2) {
    await Api.api(`/groups/${id2}/unsubscribe`, "POST");
    fetchGroups();
  }
  async function deleteGroup(id2) {
    await Api.api(`/groups/${id2}`, "DELETE");
    fetchGroups();
  }
  function resetFieldData() {
    document.getElementById("new-team-field").value = "";
    $$invalidate(2, state.name = "", state);
  }
  async function addGroup() {
    const name = state.name;
    if (validate()) {
      await Api.api(`/groups`, "POST", { name });
      fetchGroups();
      resetFieldData();
    }
  }
  const click_handler = (group2, e) => leaveGroup(group2.id);
  const click_handler_1 = (group2, e) => deleteGroup(group2.id);
  function input_input_handler() {
    state.name = this.value;
    $$invalidate(2, state);
  }
  const click_handler_2 = () => addGroup();
  const submit_handler = (e) => addGroup();
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(8, params2 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      $$invalidate(3, isEnterprise = !!$user.account_id);
    }
  };
  return [
    groups,
    errEmptyTeam,
    state,
    isEnterprise,
    user,
    leaveGroup,
    deleteGroup,
    addGroup,
    params2,
    $user,
    click_handler,
    click_handler_1,
    input_input_handler,
    click_handler_2,
    submit_handler
  ];
}
class Teams extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4y, create_fragment$4I, safe_not_equal, { params: 8 });
  }
}
function create_if_block_2$12(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = ctx[0].permissions.edit;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[7]),
          listen(input, "change", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        input.checked = ctx2[0].permissions.edit;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$1F(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "checkbox");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = ctx[0].permissions.admin;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[9]),
          listen(input, "change", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        input.checked = ctx2[0].permissions.admin;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$2E(ctx) {
  let confirmbtn;
  let current;
  confirmbtn = new ConfirmBtn({
    props: {
      $$slots: { default: [create_default_slot$1l] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[4]);
  return {
    c() {
      create_component(confirmbtn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmbtn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const confirmbtn_changes = {};
      if (dirty & 4096) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmbtn, detaching);
    }
  };
}
function create_default_slot$1l(ctx) {
  let t;
  return {
    c() {
      t = text("Remove User");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$4H(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[0].full_name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[0].email + "";
  let t2;
  let t3;
  let td2;
  let t4;
  let td3;
  let t5;
  let td4;
  let current;
  let if_block0 = !ctx[3] && ctx[1].permissions.admin && create_if_block_2$12(ctx);
  let if_block1 = !ctx[3] && ctx[1].permissions.admin && create_if_block_1$1F(ctx);
  let if_block2 = ctx[0].id != ctx[2].id && ctx[1].permissions.admin && create_if_block$2E(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      if (if_block0)
        if_block0.c();
      t4 = space();
      td3 = element("td");
      if (if_block1)
        if_block1.c();
      t5 = space();
      td4 = element("td");
      if (if_block2)
        if_block2.c();
      attr(td0, "class", "pa3");
      set_style(td0, "border-bottom", "solid 1px #ccc");
      attr(td1, "class", "pa3");
      set_style(td1, "border-bottom", "solid 1px #ccc");
      attr(td2, "class", "pa3");
      set_style(td2, "border-bottom", "solid 1px #ccc");
      set_style(td3, "padding", "5px");
      set_style(td3, "border-bottom", "solid 1px #ccc");
      set_style(td4, "padding", "5px");
      set_style(td4, "border-bottom", "solid 1px #ccc");
      set_style(tr, "height", "50px");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      if (if_block0)
        if_block0.m(td2, null);
      append(tr, t4);
      append(tr, td3);
      if (if_block1)
        if_block1.m(td3, null);
      append(tr, t5);
      append(tr, td4);
      if (if_block2)
        if_block2.m(td4, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].full_name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0].email + ""))
        set_data(t2, t2_value);
      if (!ctx2[3] && ctx2[1].permissions.admin) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$12(ctx2);
          if_block0.c();
          if_block0.m(td2, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!ctx2[3] && ctx2[1].permissions.admin) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$1F(ctx2);
          if_block1.c();
          if_block1.m(td3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[0].id != ctx2[2].id && ctx2[1].permissions.admin) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 3) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$2E(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(td4, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$4x($$self, $$props, $$invalidate) {
  let { group: group2 } = $$props;
  let { user } = $$props;
  let { reload } = $$props;
  const USER2 = getContext("user");
  const isSelf = user.id == USER2.id;
  async function onRemoveClick() {
    await Api.api(`/groups/${group2.id}/unsubscribe/${user.id}`, "DELETE");
    reload();
  }
  async function onChangeRole(e, context) {
    if (context == "admin") {
      if (e.target.checked) {
        await saveRole(user.id, { admin: true, edit: true });
      } else {
        await saveRole(user.id, { admin: false, edit: true });
      }
    } else if (context == "edit") {
      if (e.target.checked) {
        await saveRole(user.id, { admin: false, edit: true });
      } else {
        await saveRole(user.id, { admin: false, edit: false });
      }
    }
    reload();
  }
  async function saveRole(id2, permissions) {
    try {
      await Api.api(`/groups/${group2.id}/role/${id2}`, "PUT", permissions);
      reload();
    } catch (e) {
      console.error(e);
    }
  }
  const change_handler = (e) => onChangeRole(e, "edit");
  function input_change_handler() {
    user.permissions.edit = this.checked;
    $$invalidate(0, user);
  }
  const change_handler_1 = (e) => onChangeRole(e, "admin");
  function input_change_handler_1() {
    user.permissions.admin = this.checked;
    $$invalidate(0, user);
  }
  $$self.$$set = ($$props2) => {
    if ("group" in $$props2)
      $$invalidate(1, group2 = $$props2.group);
    if ("user" in $$props2)
      $$invalidate(0, user = $$props2.user);
    if ("reload" in $$props2)
      $$invalidate(6, reload = $$props2.reload);
  };
  return [
    user,
    group2,
    USER2,
    isSelf,
    onRemoveClick,
    onChangeRole,
    reload,
    change_handler,
    input_change_handler,
    change_handler_1,
    input_change_handler_1
  ];
}
class TeamUser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4x, create_fragment$4H, safe_not_equal, { group: 1, user: 0, reload: 6 });
  }
}
var Team_svelte_svelte_type_style_lang = "";
function get_each_context$1c(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_catch_block$E(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$E(ctx) {
  let div9;
  let div3;
  let div0;
  let t0;
  let div1;
  let button;
  let t2;
  let div2;
  let t3;
  let div8;
  let div4;
  let t4;
  let div6;
  let div5;
  let h4;
  let t5;
  let t6_value = ctx[1].name + "";
  let t6;
  let t7;
  let t8;
  let table;
  let thead;
  let t18;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t19;
  let t20;
  let div7;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[1].permissions.admin && create_if_block_2$11(ctx);
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[8].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$1c(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$1c(key, child_ctx));
  }
  let if_block1 = ctx[1].permissions.admin && create_if_block_1$1E(ctx);
  return {
    c() {
      div9 = element("div");
      div3 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      button = element("button");
      button.innerHTML = `<i class="fa fa-caret-left mr2" aria-hidden="true"></i> Back`;
      t2 = space();
      div2 = element("div");
      t3 = space();
      div8 = element("div");
      div4 = element("div");
      t4 = space();
      div6 = element("div");
      div5 = element("div");
      h4 = element("h4");
      t5 = text("Team: ");
      t6 = text(t6_value);
      t7 = space();
      if (if_block0)
        if_block0.c();
      t8 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="pa3 svelte-15nnkot">Name</th> 
                <th class="pa3 svelte-15nnkot">Email</th> 
                <th class="pa3 svelte-15nnkot">Edit</th> 
                <th class="pa3 svelte-15nnkot">Admin</th> 
                <th class="pa3 svelte-15nnkot" style="width: 300px;">Remove</th></tr>`;
      t18 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t19 = space();
      if (if_block1)
        if_block1.c();
      t20 = space();
      div7 = element("div");
      attr(div0, "class", "col-md-2");
      attr(button, "class", "btn btn-default");
      attr(button, "type", "button");
      attr(div1, "class", "col-md-2");
      attr(div2, "class", "col-md-8");
      attr(div3, "class", "row");
      attr(div4, "class", "col-md-2");
      attr(div5, "class", "page-header");
      set_style(table, "width", "100%");
      set_style(table, "margin-bottom", "40px");
      attr(div6, "class", "col-md-8");
      attr(div7, "class", "col-md-2");
      attr(div8, "class", "row");
      attr(div9, "class", "container-fluid");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, div3);
      append(div3, div0);
      append(div3, t0);
      append(div3, div1);
      append(div1, button);
      append(div3, t2);
      append(div3, div2);
      append(div9, t3);
      append(div9, div8);
      append(div8, div4);
      append(div8, t4);
      append(div8, div6);
      append(div6, div5);
      append(div5, h4);
      append(h4, t5);
      append(h4, t6);
      append(h4, t7);
      if (if_block0)
        if_block0.m(h4, null);
      append(div6, t8);
      append(div6, table);
      append(table, thead);
      append(table, t18);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      append(div6, t19);
      if (if_block1)
        if_block1.m(div6, null);
      append(div8, t20);
      append(div8, div7);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 2) && t6_value !== (t6_value = ctx2[1].name + ""))
        set_data(t6, t6_value);
      if (ctx2[1].permissions.admin) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$11(ctx2);
          if_block0.c();
          if_block0.m(h4, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 131) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$1c, null, get_each_context$1c);
        check_outros();
      }
      if (ctx2[1].permissions.admin) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$1E(ctx2);
          if_block1.c();
          if_block1.m(div6, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div9);
      if (if_block0)
        if_block0.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$11(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = "Edit";
      attr(a, "class", "f6");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[5]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$1c(key_1, ctx) {
  let first2;
  let teamuser;
  let current;
  teamuser = new TeamUser({
    props: {
      user: ctx[8],
      group: ctx[1],
      reload: ctx[7]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(teamuser.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(teamuser, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const teamuser_changes = {};
      if (dirty & 1)
        teamuser_changes.user = ctx[8];
      if (dirty & 2)
        teamuser_changes.group = ctx[1];
      teamuser.$set(teamuser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(teamuser.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(teamuser.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(teamuser, detaching);
    }
  };
}
function create_if_block_1$1E(ctx) {
  let input;
  return {
    c() {
      input = element("input");
      attr(input, "placeholder", "Add User");
      attr(input, "type", "text");
      attr(input, "autocomplete", "off");
      attr(input, "class", "form-control");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      ctx[12](input);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(input);
      ctx[12](null);
    }
  };
}
function create_pending_block$E(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$o(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$E,
    then: create_then_block$E,
    catch: create_catch_block$E,
    blocks: [, , ,]
  };
  handle_promise(ctx[4], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_topbar_slot$9(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Manage Team" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_if_block$2D(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Edit Team Name",
      onSave: ctx[6],
      $$slots: { default: [create_default_slot$1k] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[14]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 1048578) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$1k(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      input.autofocus = true;
      attr(input, "class", "form-control");
      attr(input, "type", "text");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1].name);
      input.focus();
      if (!mounted) {
        dispose = listen(input, "input", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1].name) {
        set_input_value(input, ctx2[1].name);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4G(ctx) {
  let layout;
  let t;
  let if_block_anchor;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$9],
        default: [create_default_slot_1$o]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[2] && create_if_block$2D(ctx);
  return {
    c() {
      create_component(layout.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 1048587) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2D(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$4w($$self, $$props, $$invalidate) {
  let $user;
  let { params: params2 = null } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(10, $user = value));
  let users = [];
  let nonMembers = [];
  let group2;
  let promiseLoad = reload();
  let editingName = false;
  let elUserInput;
  afterUpdate(async () => {
    await promiseLoad;
    window.$(elUserInput).atwho({
      at: "",
      data: nonMembers,
      displayTpl: "<li data-id=${id} data-full_name=${full_name}>${full_name} - ${email}</li>",
      searchKey: "full_name",
      callbacks: {
        beforeInsert: (value, $li) => {
          subscribe2($li.data("id"));
          return "";
        }
      }
    });
  });
  function changeName(e) {
    e.preventDefault();
    $$invalidate(2, editingName = true);
  }
  async function onSaveName() {
    $$invalidate(2, editingName = false);
    await Api.api(`/groups/${group2.id}`, "PATCH", { name: group2.name });
  }
  async function reload() {
    $$invalidate(1, group2 = await Api.api(`/groups/${params2.id}`));
    const resUsersGroup = await Api.api(`/groups/${group2.id}/users`);
    $$invalidate(0, users = resUsersGroup.data);
    const resUsersAll = await Api.api(`/accounts/users`);
    let usersAll = resUsersAll.data;
    let ids = users.map((u) => u.id);
    nonMembers = usersAll.filter((u) => !ids.includes(u.id));
  }
  async function subscribe2(user_id) {
    try {
      const response = await Api.api(`/groups/${group2.id}/subscribe`, "POST", { user_id, admin: false, edit: true });
      await reload();
    } catch (e) {
      console.error(e);
    }
  }
  const click_handler = (e) => history.back();
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elUserInput = $$value;
      $$invalidate(3, elUserInput);
    });
  }
  function input_input_handler() {
    group2.name = this.value;
    $$invalidate(1, group2);
  }
  const close_handler = (e) => $$invalidate(2, editingName = false);
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(9, params2 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      !!$user.account_id;
    }
  };
  return [
    users,
    group2,
    editingName,
    elUserInput,
    promiseLoad,
    changeName,
    onSaveName,
    reload,
    user,
    params2,
    $user,
    click_handler,
    input_binding,
    input_input_handler,
    close_handler
  ];
}
class Team extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4w, create_fragment$4G, safe_not_equal, { params: 9 });
  }
}
function create_fragment$4F(ctx) {
  let form_1;
  return {
    c() {
      form_1 = element("form");
      form_1.innerHTML = `<i class="fa fa-search p-3"></i> 
  <input name="q" class="flex-grow p-3 border-0 border-l border-solid border-gray-300" type="text" autocomplete="off" placeholder="Search..."/>`;
      attr(form_1, "class", "xsearchbar flex mt1 border border-solid border-bottom-0 border-gray-300");
    },
    m(target, anchor) {
      insert(target, form_1, anchor);
      ctx[3](form_1);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(form_1);
      ctx[3](null);
    }
  };
}
function instance$4v($$self, $$props, $$invalidate) {
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(2, $params = $$value));
  let form;
  let labels = getContext("labels");
  let parent2 = getContext("view:root");
  let view;
  onMount(() => {
    $$invalidate(1, view = new SearchForm({ el: form, parent: parent2, labels }));
    return () => view.remove();
  });
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      form = $$value;
      $$invalidate(0, form);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      view && view.setRouteParams($params);
    }
  };
  return [form, view, $params, form_1_binding];
}
class Search extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4v, create_fragment$4F, safe_not_equal, {});
  }
}
const get_title_slot_changes$1 = (dirty) => ({});
const get_title_slot_context$1 = (ctx) => ({});
const get_header_slot_changes$2 = (dirty) => ({});
const get_header_slot_context$2 = (ctx) => ({});
const get_action_slot_changes = (dirty) => ({});
const get_action_slot_context = (ctx) => ({});
function fallback_block_1$1(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[1]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$1q(ctx) {
  let div;
  let t;
  let button;
  let current;
  const title_slot_template = ctx[7].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[6], get_title_slot_context$1);
  const title_slot_or_fallback = title_slot || fallback_block$9(ctx);
  return {
    c() {
      div = element("div");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      t = space();
      button = element("button");
      attr(button, "type", "button");
      attr(button, "class", "btn-close text-reset");
      attr(button, "data-bs-dismiss", "offcanvas");
      attr(div, "class", "offcanvas-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(div, null);
      }
      append(div, t);
      append(div, button);
      current = true;
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(title_slot_template, ctx2[6], dirty, get_title_slot_changes$1),
            get_title_slot_context$1
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & 9)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block$2C(ctx) {
  let current;
  const header_slot_template = ctx[7].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[6], get_header_slot_context$2);
  return {
    c() {
      if (header_slot)
        header_slot.c();
    },
    m(target, anchor) {
      if (header_slot) {
        header_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(header_slot_template, ctx2[6], dirty, get_header_slot_changes$2),
            get_header_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d(detaching) {
      if (header_slot)
        header_slot.d(detaching);
    }
  };
}
function fallback_block$9(ctx) {
  let h3;
  let t;
  let h3_class_value;
  return {
    c() {
      h3 = element("h3");
      t = text(ctx[0]);
      attr(h3, "class", h3_class_value = "offcanvas-title " + ctx[3]);
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
      if (dirty & 8 && h3_class_value !== (h3_class_value = "offcanvas-title " + ctx2[3])) {
        attr(h3, "class", h3_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(h3);
    }
  };
}
function create_fragment$4E(ctx) {
  let a;
  let a_class_value;
  let t0;
  let div1;
  let current_block_type_index;
  let if_block;
  let t1;
  let div0;
  let div1_class_value;
  let current;
  const action_slot_template = ctx[7].action;
  const action_slot = create_slot(action_slot_template, ctx, ctx[6], get_action_slot_context);
  const action_slot_or_fallback = action_slot || fallback_block_1$1(ctx);
  const if_block_creators = [create_if_block$2C, create_else_block$1q];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5].header)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  return {
    c() {
      a = element("a");
      if (action_slot_or_fallback)
        action_slot_or_fallback.c();
      t0 = space();
      div1 = element("div");
      if_block.c();
      t1 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(a, "class", a_class_value = "xbtn-primary " + ctx[4]);
      attr(a, "data-bs-toggle", "offcanvas");
      attr(a, "href", "#offcanvasExample");
      attr(div0, "class", "offcanvas-body");
      attr(div1, "class", div1_class_value = "offcanvas " + ctx[2]);
      attr(div1, "tabindex", "-1");
      attr(div1, "id", "offcanvasExample");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (action_slot_or_fallback) {
        action_slot_or_fallback.m(a, null);
      }
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      if_blocks[current_block_type_index].m(div1, null);
      append(div1, t1);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (action_slot) {
        if (action_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(action_slot_template, ctx2[6], dirty, get_action_slot_changes),
            get_action_slot_context
          );
        }
      } else {
        if (action_slot_or_fallback && action_slot_or_fallback.p && (!current || dirty & 2)) {
          action_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 16 && a_class_value !== (a_class_value = "xbtn-primary " + ctx2[4])) {
        attr(a, "class", a_class_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, t1);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4 && div1_class_value !== (div1_class_value = "offcanvas " + ctx2[2])) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(action_slot_or_fallback, local);
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(action_slot_or_fallback, local);
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (action_slot_or_fallback)
        action_slot_or_fallback.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$4u($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { title } = $$props;
  let { label } = $$props;
  let { drawerClasses = "offcanvas-start" } = $$props;
  let { titleClasses = "" } = $$props;
  let { class: classes = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("drawerClasses" in $$props2)
      $$invalidate(2, drawerClasses = $$props2.drawerClasses);
    if ("titleClasses" in $$props2)
      $$invalidate(3, titleClasses = $$props2.titleClasses);
    if ("class" in $$props2)
      $$invalidate(4, classes = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [title, label, drawerClasses, titleClasses, classes, $$slots, $$scope, slots];
}
class Drawer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4u, create_fragment$4E, safe_not_equal, {
      title: 0,
      label: 1,
      drawerClasses: 2,
      titleClasses: 3,
      class: 4
    });
  }
}
class ClientMsgs extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "url", "/public/clients/messages");
  }
  isEmpty() {
    return this.models.length == 0;
  }
}
class UserMsgs extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "url", "/users/messages");
  }
}
let clientMsgs = new ClientMsgs();
let userMsgs = new UserMsgs([], {
  orderBy: "-ts",
  limit: 25
});
let count = derived(
  [clientMsgs, userMsgs],
  ([$1, $2]) => $1.length + $2.length
);
let flash = derived(
  [clientMsgs, userMsgs],
  ([$1, $2]) => $1.find((m) => m.get("flash")) || $2.find((m) => m.get("flash"))
);
function get_each_context$1b(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2];
  return child_ctx;
}
function create_default_slot$1j(ctx) {
  let t_value = ctx[1].body + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].body + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_header_slot$m(ctx) {
  let div;
  let t0_value = ctx[1].title + "";
  let t0;
  let t1;
  let small;
  let t2_value = formatTime(ctx[1].ts, true) + "";
  let t2;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      small = element("small");
      t2 = text(t2_value);
      attr(small, "class", "pl-4 text-gray-400");
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, small);
      append(small, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1].title + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = formatTime(ctx2[1].ts, true) + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$1b(ctx) {
  let a;
  let t0_value = ctx[3].label + "";
  let t0;
  let t1;
  let a_href_value;
  return {
    c() {
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "href", a_href_value = ctx[3].link);
      attr(a, "target", "_blank");
      attr(a, "class", "text-center btn btn-default btn-sm capitalize");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t0);
      append(a, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[3].label + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && a_href_value !== (a_href_value = ctx2[3].link)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_footer_slot(ctx) {
  let div;
  let each_value = ctx[1].actions;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1b(get_each_context$1b(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "slot", "footer");
      attr(div, "class", "flex space-x-2");
      toggle_class(div, "hide", ctx[1].actions.length == 0);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        each_value = ctx2[1].actions;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1b(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$1b(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2) {
        toggle_class(div, "hide", ctx2[1].actions.length == 0);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$4D(ctx) {
  let card;
  let current;
  card = new Card({
    props: {
      $$slots: {
        footer: [create_footer_slot],
        header: [create_header_slot$m],
        default: [create_default_slot$1j]
      },
      $$scope: { ctx }
    }
  });
  card.$on("close", ctx[2]);
  return {
    c() {
      create_component(card.$$.fragment);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const card_changes = {};
      if (dirty & 66) {
        card_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function instance$4t($$self, $$props, $$invalidate) {
  let $message, $$unsubscribe_message = noop$1, $$subscribe_message = () => ($$unsubscribe_message(), $$unsubscribe_message = subscribe(message, ($$value) => $$invalidate(1, $message = $$value)), message);
  $$self.$$.on_destroy.push(() => $$unsubscribe_message());
  let { message } = $$props;
  $$subscribe_message();
  const close_handler = (e) => message.destroy();
  $$self.$$set = ($$props2) => {
    if ("message" in $$props2)
      $$subscribe_message($$invalidate(0, message = $$props2.message));
  };
  return [message, $message, close_handler];
}
class MessageCard extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4t, create_fragment$4D, safe_not_equal, { message: 0 });
  }
}
function get_each_context$1a(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2];
  return child_ctx;
}
function create_if_block$2B(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$1p(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "No more message to show.";
      attr(p, "class", "text-2xl text-center");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_each_block$1a(key_1, ctx) {
  let first2;
  let card;
  let current;
  card = new MessageCard({ props: { message: ctx[3] } });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(card.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 4)
        card_changes.message = ctx[3];
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(card, detaching);
    }
  };
}
function create_fragment$4C(ctx) {
  let div;
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let if_block = ctx[1] === true && create_if_block$2B();
  let each_value = ctx[2].models;
  const get_key = (ctx2) => ctx2[3].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$1a(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$1a(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$1p();
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      attr(div, "class", "d-flex flex-column gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1] === true) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$2B();
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 4) {
        each_value = ctx2[2].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$1a, null, get_each_context$1a);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$1p();
          each_1_else.c();
          each_1_else.m(div, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$4s($$self, $$props, $$invalidate) {
  let $isSyncing, $$unsubscribe_isSyncing = noop$1, $$subscribe_isSyncing = () => ($$unsubscribe_isSyncing(), $$unsubscribe_isSyncing = subscribe(isSyncing, ($$value) => $$invalidate(1, $isSyncing = $$value)), isSyncing);
  let $userMsgs;
  component_subscribe($$self, userMsgs, ($$value) => $$invalidate(2, $userMsgs = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_isSyncing());
  let { isSyncing = userMsgs.syncing } = $$props;
  $$subscribe_isSyncing();
  $$self.$$set = ($$props2) => {
    if ("isSyncing" in $$props2)
      $$subscribe_isSyncing($$invalidate(0, isSyncing = $$props2.isSyncing));
  };
  return [isSyncing, $isSyncing, $userMsgs];
}
class UserMessages extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4s, create_fragment$4C, safe_not_equal, { isSyncing: 0 });
  }
}
function get_each_context$19(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i2];
  return child_ctx;
}
function create_each_block$19(key_1, ctx) {
  let first2;
  let card;
  let current;
  card = new MessageCard({ props: { message: ctx[1] } });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(card.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(card, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const card_changes = {};
      if (dirty & 1)
        card_changes.message = ctx[1];
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(card, detaching);
    }
  };
}
function create_fragment$4B(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[0].models;
  const get_key = (ctx2) => ctx2[1].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$19(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$19(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$19, each_1_anchor, get_each_context$19);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function instance$4r($$self, $$props, $$invalidate) {
  let $clientMsgs;
  component_subscribe($$self, clientMsgs, ($$value) => $$invalidate(0, $clientMsgs = $$value));
  return [$clientMsgs];
}
class ClientMessages extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4r, create_fragment$4B, safe_not_equal, {});
  }
}
function create_action_slot$e(ctx) {
  let i2;
  let t0;
  let span;
  let t1;
  let t2;
  let t3;
  return {
    c() {
      i2 = element("i");
      t0 = space();
      span = element("span");
      t1 = text("(");
      t2 = text(ctx[0]);
      t3 = text(")");
      attr(i2, "class", "fa fa-envelope");
      attr(span, "class", "px-1 text-md font-bold");
      toggle_class(span, "d-none", !ctx[0]);
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
      append(span, t2);
      append(span, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t2, ctx2[0]);
      if (dirty & 1) {
        toggle_class(span, "d-none", !ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(i2);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(span);
    }
  };
}
function create_header_slot$l(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<h3>Messages</h3> 
      <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas"></button>`;
      attr(div, "class", "offcanvas-header bg-primary text-white");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$1D(ctx) {
  let clientmessages;
  let current;
  clientmessages = new ClientMessages({});
  return {
    c() {
      create_component(clientmessages.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clientmessages, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(clientmessages.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientmessages.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clientmessages, detaching);
    }
  };
}
function create_if_block$2A(ctx) {
  let usermessages;
  let current;
  usermessages = new UserMessages({});
  return {
    c() {
      create_component(usermessages.$$.fragment);
    },
    m(target, anchor) {
      mount_component(usermessages, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(usermessages.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(usermessages.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(usermessages, detaching);
    }
  };
}
function create_default_slot$1i(ctx) {
  let t;
  let show_if = ctx[1].isLoggedIn();
  let if_block1_anchor;
  let current;
  let if_block0 = Supports.agents.local && create_if_block_1$1D();
  let if_block1 = show_if && create_if_block$2A();
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_fragment$4A(ctx) {
  let drawer;
  let current;
  drawer = new Drawer({
    props: {
      class: "text-primary text-nowrap",
      drawerClasses: "offcanvas-end",
      $$slots: {
        default: [create_default_slot$1i],
        header: [create_header_slot$l],
        action: [create_action_slot$e]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(drawer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(drawer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const drawer_changes = {};
      if (dirty & 5) {
        drawer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      drawer.$set(drawer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(drawer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(drawer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(drawer, detaching);
    }
  };
}
function instance$4q($$self, $$props, $$invalidate) {
  let $count;
  component_subscribe($$self, count, ($$value) => $$invalidate(0, $count = $$value));
  const user = getContext("user");
  return [$count, user];
}
class Messages extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4q, create_fragment$4A, safe_not_equal, {});
  }
}
function get_each_context$18(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function create_if_block$2z(ctx) {
  let div4;
  let div2;
  let div0;
  let t0_value = formatTime(ctx[0].ts, true) + "";
  let t0;
  let t1;
  let div1;
  let t2_value = ctx[0].body + "";
  let t2;
  let t3;
  let div3;
  let t4;
  let button;
  let div4_class_value;
  let mounted;
  let dispose;
  let each_value = ctx[0].actions;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$18(get_each_context$18(ctx, each_value, i2));
  }
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div3 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t4 = space();
      button = element("button");
      button.innerHTML = `<span aria-hidden="true">Dismiss</span>`;
      attr(div0, "class", "text-base");
      attr(div1, "class", "overflow-hidden");
      attr(div2, "class", "flex flex-column");
      attr(button, "class", "btn btn-default btn-sm");
      attr(button, "aria-label", "Close");
      attr(div3, "class", "flex self-center gap-4");
      attr(div4, "class", div4_class_value = "alert alert-dismissible mb-0 alert-" + ctx[2] + " flex justify-between p-2 max-h-[70px]");
      attr(div4, "role", "alert");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div3, null);
        }
      }
      append(div3, t4);
      append(div3, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = formatTime(ctx2[0].ts, true) + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t2_value !== (t2_value = ctx2[0].body + ""))
        set_data(t2, t2_value);
      if (dirty & 1) {
        each_value = ctx2[0].actions;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$18(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$18(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div3, t4);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 4 && div4_class_value !== (div4_class_value = "alert alert-dismissible mb-0 alert-" + ctx2[2] + " flex justify-between p-2 max-h-[70px]")) {
        attr(div4, "class", div4_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$18(ctx) {
  let a;
  let t_value = ctx[5].label + "";
  let t;
  let a_href_value;
  return {
    c() {
      a = element("a");
      t = text(t_value);
      attr(a, "class", "text-lg text-center");
      attr(a, "href", a_href_value = ctx[5].link);
      attr(a, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[5].label + ""))
        set_data(t, t_value);
      if (dirty & 1 && a_href_value !== (a_href_value = ctx2[5].link)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_fragment$4z(ctx) {
  let if_block_anchor;
  let if_block = ctx[1] && create_if_block$2z(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$2z(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$4p($$self, $$props, $$invalidate) {
  let $message, $$unsubscribe_message = noop$1, $$subscribe_message = () => ($$unsubscribe_message(), $$unsubscribe_message = subscribe(message, ($$value) => $$invalidate(0, $message = $$value)), message);
  let $flash;
  component_subscribe($$self, flash, ($$value) => $$invalidate(3, $flash = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_message());
  let message;
  let alertClass;
  const click_handler = (e) => message.destroy();
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $$subscribe_message($$invalidate(1, message = $flash));
    }
    if ($$self.$$.dirty & 1) {
      if ($message) {
        if ($message.level === "error") {
          $$invalidate(2, alertClass = "danger");
        } else if ($message.level === "warn") {
          $$invalidate(2, alertClass = "warning");
        } else {
          $$invalidate(2, alertClass = "info");
        }
      }
    }
  };
  return [$message, message, alertClass, $flash, click_handler];
}
class Notification extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4p, create_fragment$4z, safe_not_equal, {});
  }
}
const get_header_slot_changes$1 = (dirty) => ({});
const get_header_slot_context$1 = (ctx) => ({});
function fallback_block$8(ctx) {
  let div0;
  let t1;
  let div1;
  let t2_value = (ctx[2] ? ctx[2].info || ctx[2].name : "") + "";
  let t2;
  let div1_title_value;
  return {
    c() {
      div0 = element("div");
      div0.textContent = "Watchlist";
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      attr(div0, "class", "fw3 fs-2");
      attr(div1, "class", "fw1 text-sm text-truncate");
      attr(div1, "title", div1_title_value = ctx[2] ? ctx[2].info || ctx[2].name : "");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t2_value !== (t2_value = (ctx2[2] ? ctx2[2].info || ctx2[2].name : "") + ""))
        set_data(t2, t2_value);
      if (dirty & 4 && div1_title_value !== (div1_title_value = ctx2[2] ? ctx2[2].info || ctx2[2].name : "")) {
        attr(div1, "title", div1_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block$2y(ctx) {
  let search;
  let current;
  search = new Search({});
  return {
    c() {
      create_component(search.$$.fragment);
    },
    m(target, anchor) {
      mount_component(search, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(search.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(search.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(search, detaching);
    }
  };
}
function create_fragment$4y(ctx) {
  var _a;
  let notification;
  let t0;
  let div3;
  let div0;
  let t1;
  let div2;
  let t2;
  let div1;
  let t3;
  let a;
  let t5;
  let messages;
  let t6;
  let selector;
  let current;
  notification = new Notification({});
  const header_slot_template = ctx[7].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[6], get_header_slot_context$1);
  const header_slot_or_fallback = header_slot || fallback_block$8(ctx);
  let if_block = ctx[0] && create_if_block$2y();
  messages = new Messages({});
  selector = new Selector$3({
    props: {
      menuAlign: "right",
      team: (_a = ctx[3]) == null ? void 0 : _a.team
    }
  });
  return {
    c() {
      create_component(notification.$$.fragment);
      t0 = space();
      div3 = element("div");
      div0 = element("div");
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
      t1 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t2 = space();
      div1 = element("div");
      t3 = space();
      a = element("a");
      a.textContent = "Get Help";
      t5 = space();
      create_component(messages.$$.fragment);
      t6 = space();
      create_component(selector.$$.fragment);
      attr(div0, "class", "d-flex flex-column relative title-header ttu");
      set_style(div0, "top", "5px");
      set_style(div0, "line-height", "2em");
      attr(div1, "class", "flex-grow");
      attr(a, "class", "btn btn-primary btn-sm xbtn-default mr-2");
      attr(a, "href", "https://distill.io/docs/contact-us/");
      attr(a, "target", "_blank");
      attr(div2, "class", "flex-grow flex items-center border-b border-gray-300");
      set_style(div2, "border-bottom-style", "solid");
      attr(div3, "class", "flex items-center mb-10");
    },
    m(target, anchor) {
      mount_component(notification, target, anchor);
      insert(target, t0, anchor);
      insert(target, div3, anchor);
      append(div3, div0);
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(div0, null);
      }
      append(div3, t1);
      append(div3, div2);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t2);
      append(div2, div1);
      append(div2, t3);
      append(div2, a);
      append(div2, t5);
      mount_component(messages, div2, null);
      append(div2, t6);
      mount_component(selector, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(header_slot_template, ctx2[6], dirty, get_header_slot_changes$1),
            get_header_slot_context$1
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty & 4)) {
          header_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (ctx2[0]) {
        if (if_block) {
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2y();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const selector_changes = {};
      if (dirty & 8)
        selector_changes.team = (_a2 = ctx2[3]) == null ? void 0 : _a2.team;
      selector.$set(selector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(notification.$$.fragment, local);
      transition_in(header_slot_or_fallback, local);
      transition_in(if_block);
      transition_in(messages.$$.fragment, local);
      transition_in(selector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(notification.$$.fragment, local);
      transition_out(header_slot_or_fallback, local);
      transition_out(if_block);
      transition_out(messages.$$.fragment, local);
      transition_out(selector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(notification, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div3);
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
      destroy_component(messages);
      destroy_component(selector);
    }
  };
}
function instance$4o($$self, $$props, $$invalidate) {
  let $clients;
  let $client, $$unsubscribe_client = noop$1, $$subscribe_client = () => ($$unsubscribe_client(), $$unsubscribe_client = subscribe(client, ($$value) => $$invalidate(2, $client = $$value)), client);
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(3, $params = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_client());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { showSearch = true } = $$props;
  let clients = getContext("clients");
  component_subscribe($$self, clients, (value) => $$invalidate(5, $clients = value));
  let client;
  $$self.$$set = ($$props2) => {
    if ("showSearch" in $$props2)
      $$invalidate(0, showSearch = $$props2.showSearch);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      {
        $$subscribe_client($$invalidate(1, client = $clients && clients.get(clients.defaultId)));
      }
    }
  };
  return [showSearch, client, $client, $params, clients, $clients, $$scope, slots];
}
class Topbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4o, create_fragment$4y, safe_not_equal, { showSearch: 0 });
  }
}
function get_then_context(ctx) {
  ctx[3] = ctx[5][0];
  ctx[4] = ctx[5][1];
}
function create_catch_block$D(ctx) {
  return { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };
}
function create_then_block$D(ctx) {
  get_then_context(ctx);
  let div17;
  let div0;
  let t0;
  let a0;
  let t1;
  let t2;
  let t3;
  let table;
  let thead0;
  let t4;
  let thead1;
  let t10;
  let tbody;
  let tr1;
  let td0;
  let t12;
  let td1;
  let div1;
  let t13_value = ctx[3].item + "";
  let t13;
  let t14;
  let td2;
  let div2;
  let t15_value = ctx[4].item + "";
  let t15;
  let t16;
  let tr2;
  let td3;
  let t18;
  let td4;
  let div3;
  let t19_value = ctx[3].run + "";
  let t19;
  let t20;
  let td5;
  let div4;
  let t21_value = ctx[4].run + "";
  let t21;
  let t22;
  let tr3;
  let td6;
  let t24;
  let td7;
  let div5;
  let t25_value = ctx[3].sms + "";
  let t25;
  let t26;
  let td8;
  let div6;
  let t27_value = ctx[4].sms + "";
  let t27;
  let t28;
  let tr4;
  let td9;
  let t30;
  let td10;
  let div7;
  let t31_value = ctx[3].email + "";
  let t31;
  let t32;
  let td11;
  let div8;
  let t33_value = ctx[4].email + "";
  let t33;
  let t34;
  let tr5;
  let td12;
  let t36;
  let td13;
  let div9;
  let t37_value = ctx[3].action + "";
  let t37;
  let t38;
  let td14;
  let div10;
  let t39_value = ctx[4].action + "";
  let t39;
  let t40;
  let tr6;
  let td15;
  let t42;
  let td16;
  let div11;
  let t43_value = ctx[3].push + "";
  let t43;
  let t44;
  let td17;
  let div12;
  let t45_value = ctx[4].push + "";
  let t45;
  let t46;
  let tr7;
  let td18;
  let t48;
  let td19;
  let div13;
  let t49_value = ctx[3].action_macro + "";
  let t49;
  let t50;
  let td20;
  let div14;
  let t51_value = ctx[4].action_macro + "";
  let t51;
  let t52;
  let div16;
  return {
    c() {
      div17 = element("div");
      div0 = element("div");
      t0 = text("Resource usage based on your ");
      a0 = element("a");
      t1 = text("current plan");
      t2 = text(".");
      t3 = space();
      table = element("table");
      thead0 = element("thead");
      t4 = space();
      thead1 = element("thead");
      thead1.innerHTML = `<tr><th scope="col">Resource</th> 
        <th scope="col">Quantity</th> 
        <th scope="col">Usage</th></tr>`;
      t10 = space();
      tbody = element("tbody");
      tr1 = element("tr");
      td0 = element("td");
      td0.textContent = "Monitors";
      t12 = space();
      td1 = element("td");
      div1 = element("div");
      t13 = text(t13_value);
      t14 = space();
      td2 = element("td");
      div2 = element("div");
      t15 = text(t15_value);
      t16 = space();
      tr2 = element("tr");
      td3 = element("td");
      td3.textContent = "Checks";
      t18 = space();
      td4 = element("td");
      div3 = element("div");
      t19 = text(t19_value);
      t20 = space();
      td5 = element("td");
      div4 = element("div");
      t21 = text(t21_value);
      t22 = space();
      tr3 = element("tr");
      td6 = element("td");
      td6.textContent = "SMSes";
      t24 = space();
      td7 = element("td");
      div5 = element("div");
      t25 = text(t25_value);
      t26 = space();
      td8 = element("td");
      div6 = element("div");
      t27 = text(t27_value);
      t28 = space();
      tr4 = element("tr");
      td9 = element("td");
      td9.textContent = "Emails";
      t30 = space();
      td10 = element("td");
      div7 = element("div");
      t31 = text(t31_value);
      t32 = space();
      td11 = element("td");
      div8 = element("div");
      t33 = text(t33_value);
      t34 = space();
      tr5 = element("tr");
      td12 = element("td");
      td12.textContent = "Actions (webhooks)";
      t36 = space();
      td13 = element("td");
      div9 = element("div");
      t37 = text(t37_value);
      t38 = space();
      td14 = element("td");
      div10 = element("div");
      t39 = text(t39_value);
      t40 = space();
      tr6 = element("tr");
      td15 = element("td");
      td15.textContent = "Push";
      t42 = space();
      td16 = element("td");
      div11 = element("div");
      t43 = text(t43_value);
      t44 = space();
      td17 = element("td");
      div12 = element("div");
      t45 = text(t45_value);
      t46 = space();
      tr7 = element("tr");
      td18 = element("td");
      td18.textContent = "Macro Actions";
      t48 = space();
      td19 = element("td");
      div13 = element("div");
      t49 = text(t49_value);
      t50 = space();
      td20 = element("td");
      div14 = element("div");
      t51 = text(t51_value);
      t52 = space();
      div16 = element("div");
      div16.innerHTML = `Checks made using browser extensions are unlimited and not counted. <a href="https://distill.io/docs/web-monitor/cloud-local-monitors/">Learn More</a> 
    <div>In cloud, checks are counted in units of 7 seconds. If a check takes upto 7s, it is counted as
      one. If it takes more than 7s and less than 15s, it is counted as two.</div>`;
      attr(a0, "href", urlCfg.billing);
      attr(div0, "class", "ml-1 fs-5 pb-3 bg-light");
      attr(div1, "class", "xitem");
      attr(div2, "class", "xitem");
      attr(div3, "class", "xcheck");
      attr(div4, "class", "xcheck");
      attr(div5, "class", "xsms");
      attr(div6, "class", "xsms");
      attr(div7, "class", "xemail");
      attr(div8, "class", "xemail");
      attr(div9, "class", "xaction");
      attr(div10, "class", "xaction");
      attr(div11, "class", "xpush");
      attr(div12, "class", "xpush");
      attr(div13, "class", "xpush");
      attr(div14, "class", "xpush");
      attr(table, "class", "table table-bordered xblock xblock-thin");
      attr(div16, "class", "xblock");
      attr(div17, "id", "availability");
    },
    m(target, anchor) {
      insert(target, div17, anchor);
      append(div17, div0);
      append(div0, t0);
      append(div0, a0);
      append(a0, t1);
      append(div0, t2);
      append(div17, t3);
      append(div17, table);
      append(table, thead0);
      append(table, t4);
      append(table, thead1);
      append(table, t10);
      append(table, tbody);
      append(tbody, tr1);
      append(tr1, td0);
      append(tr1, t12);
      append(tr1, td1);
      append(td1, div1);
      append(div1, t13);
      append(tr1, t14);
      append(tr1, td2);
      append(td2, div2);
      append(div2, t15);
      append(tbody, t16);
      append(tbody, tr2);
      append(tr2, td3);
      append(tr2, t18);
      append(tr2, td4);
      append(td4, div3);
      append(div3, t19);
      append(tr2, t20);
      append(tr2, td5);
      append(td5, div4);
      append(div4, t21);
      append(tbody, t22);
      append(tbody, tr3);
      append(tr3, td6);
      append(tr3, t24);
      append(tr3, td7);
      append(td7, div5);
      append(div5, t25);
      append(tr3, t26);
      append(tr3, td8);
      append(td8, div6);
      append(div6, t27);
      append(tbody, t28);
      append(tbody, tr4);
      append(tr4, td9);
      append(tr4, t30);
      append(tr4, td10);
      append(td10, div7);
      append(div7, t31);
      append(tr4, t32);
      append(tr4, td11);
      append(td11, div8);
      append(div8, t33);
      append(tbody, t34);
      append(tbody, tr5);
      append(tr5, td12);
      append(tr5, t36);
      append(tr5, td13);
      append(td13, div9);
      append(div9, t37);
      append(tr5, t38);
      append(tr5, td14);
      append(td14, div10);
      append(div10, t39);
      append(tbody, t40);
      append(tbody, tr6);
      append(tr6, td15);
      append(tr6, t42);
      append(tr6, td16);
      append(td16, div11);
      append(div11, t43);
      append(tr6, t44);
      append(tr6, td17);
      append(td17, div12);
      append(div12, t45);
      append(tbody, t46);
      append(tbody, tr7);
      append(tr7, td18);
      append(tr7, t48);
      append(tr7, td19);
      append(td19, div13);
      append(div13, t49);
      append(tr7, t50);
      append(tr7, td20);
      append(td20, div14);
      append(div14, t51);
      append(div17, t52);
      append(div17, div16);
    },
    p(ctx2, dirty) {
      get_then_context(ctx2);
    },
    d(detaching) {
      if (detaching)
        detach(div17);
    }
  };
}
function create_pending_block$D(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$4x(ctx) {
  let await_block_anchor;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$D,
    then: create_then_block$D,
    catch: create_catch_block$D,
    value: 5
  };
  handle_promise(ctx[0], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function getTsMonthQuery() {
  const date = new Date();
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  return `${year}-${month}-1`;
}
function instance$4n($$self) {
  let api = getContext("api");
  async function getMonthlyUsage() {
    let usage = {
      item: 0,
      run: 0,
      sms: 0,
      email: 0,
      action: 0,
      push: 0
    };
    const res = await api(`/users/usage/monthly?ts_month=${getTsMonthQuery()}`);
    if (res.count !== 0) {
      usage = res.data[0];
    }
    const { count: count2 } = await api("/users/sieve-count");
    usage.item = count2;
    return usage;
  }
  const resPromise = Promise.all([api("/users/constraints"), getMonthlyUsage()]);
  return [resPromise];
}
class Avail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4n, create_fragment$4x, safe_not_equal, {});
  }
}
function get_each_context$17(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function get_each_context_1$c(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_catch_block$C(ctx) {
  return { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };
}
function create_then_block$C(ctx) {
  let table;
  let thead;
  let t13;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ctx[4].data;
  const get_key = (ctx2) => ctx2[5].ts;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$17(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$17(key, child_ctx));
  }
  return {
    c() {
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th>Date</th> 
      <th>Checks</th> 
      <th>Emails</th> 
      <th>SMSes</th> 
      <th>Webhooks</th> 
      <th>Push</th> 
      <th>Macro Actions</th></tr>`;
      t13 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(table, "id", "daily");
      attr(table, "class", "table table-bordered xblock xblock-thin mb-2");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, thead);
      append(table, t13);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[4].data;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, destroy_block, create_each_block$17, null, get_each_context$17);
      }
    },
    d(detaching) {
      if (detaching)
        detach(table);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_each_block_1$c(ctx) {
  let td;
  let div;
  let t_value = ctx[5][ctx[8]] + "";
  let t;
  return {
    c() {
      td = element("td");
      div = element("div");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, div);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[5][ctx2[8]] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_each_block$17(key_1, ctx) {
  let tr;
  let t;
  let each_value_1 = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$c(get_each_context_1$c(ctx, each_value_1, i2));
  }
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tr, null);
        }
      }
      append(tr, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 3) {
        each_value_1 = ctx[1];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$c(ctx, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$c(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(tr, t);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_pending_block$C(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$4w(ctx) {
  let await_block_anchor;
  let promise;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$C,
    then: create_then_block$C,
    catch: create_catch_block$C,
    value: 4
  };
  handle_promise(promise = ctx[0], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 1 && promise !== (promise = ctx[0]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$4m($$self, $$props, $$invalidate) {
  let { cycle } = $$props;
  let api = getContext("api");
  let resPromise;
  const NAMES = ["ts", "run", "email", "sms", "action", "push", "action_macro"];
  $$self.$$set = ($$props2) => {
    if ("cycle" in $$props2)
      $$invalidate(2, cycle = $$props2.cycle);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(0, resPromise = api("/users/usage/" + cycle, "GET"));
    }
  };
  return [resPromise, NAMES, cycle];
}
class Usage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4m, create_fragment$4w, safe_not_equal, { cycle: 2 });
  }
}
class Job$1 extends base.Model {
}
class Jobs extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "model", Job$1);
    __publicField(this, "url", "/jobs");
    __publicField(this, "limit", 20);
  }
}
function get_each_context$16(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  child_ctx[14] = i2;
  return child_ctx;
}
function create_if_block$2x(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ctx[4];
  const get_key = (ctx2) => ctx2[14];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$16(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$16(key, child_ctx));
  }
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", "dropdown-menu dropdown-menu-right overflow-scroll max-h-[60vh]");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 149) {
        each_value = ctx2[4];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, destroy_block, create_each_block$16, null, get_each_context$16);
      }
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_each_block$16(key_1, ctx) {
  let li;
  let a;
  let t0_value = ctx[7](ctx[14]) + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return ctx[8](ctx[14], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "class", "dropdown-item");
      attr(a, "href", href$1);
      toggle_class(li, "active", ctx[2].offset === ctx[14] * ctx[2].limit);
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16 && t0_value !== (t0_value = ctx[7](ctx[14]) + ""))
        set_data(t0, t0_value);
      if (dirty & 20) {
        toggle_class(li, "active", ctx[2].offset === ctx[14] * ctx[2].limit);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4v(ctx) {
  let div;
  let spinner;
  let t0;
  let ul;
  let li0;
  let a0;
  let t1;
  let t2;
  let i0;
  let t3;
  let t4;
  let li1;
  let a1;
  let i1;
  let t5;
  let li2;
  let a2;
  let i2;
  let current;
  let mounted;
  let dispose;
  spinner = new Spinner({
    props: {
      class: "mx-2 text-primary " + (ctx[6] ? "" : "invisible")
    }
  });
  let if_block = ctx[4].length && create_if_block$2x(ctx);
  return {
    c() {
      div = element("div");
      create_component(spinner.$$.fragment);
      t0 = space();
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      t1 = text(ctx[5]);
      t2 = space();
      i0 = element("i");
      t3 = space();
      if (if_block)
        if_block.c();
      t4 = space();
      li1 = element("li");
      a1 = element("a");
      i1 = element("i");
      t5 = space();
      li2 = element("li");
      a2 = element("a");
      i2 = element("i");
      attr(i0, "class", "fa fa-caret-down");
      attr(a0, "href", href$1);
      attr(a0, "class", "text-secondary-emphasis whitespace-nowrap page-link");
      attr(a0, "data-bs-toggle", "dropdown");
      attr(li0, "class", "page-item");
      attr(i1, "class", "fa fa-chevron-left");
      attr(a1, "class", "page-link");
      attr(a1, "href", href$1);
      attr(li1, "class", "page-item");
      toggle_class(li1, "disabled", !ctx[3].hasPrev());
      attr(i2, "class", "fa fa-chevron-right");
      attr(a2, "class", "page-link");
      attr(a2, "href", href$1);
      attr(li2, "class", "page-item");
      toggle_class(li2, "disabled", !ctx[3].hasNext());
      attr(ul, "class", "pagination pagination-sm dropdown align-items-center");
      set_style(ul, "margin", "0 5px 0 0");
      attr(div, "class", "d-flex align-items-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(spinner, div, null);
      append(div, t0);
      append(div, ul);
      append(ul, li0);
      append(li0, a0);
      append(a0, t1);
      append(a0, t2);
      append(a0, i0);
      append(li0, t3);
      if (if_block)
        if_block.m(li0, null);
      append(ul, t4);
      append(ul, li1);
      append(li1, a1);
      append(a1, i1);
      append(ul, t5);
      append(ul, li2);
      append(li2, a2);
      append(a2, i2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a1, "click", prevent_default(ctx[9])),
          listen(a2, "click", prevent_default(ctx[10]))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const spinner_changes = {};
      if (dirty & 64)
        spinner_changes.class = "mx-2 text-primary " + (ctx2[6] ? "" : "invisible");
      spinner.$set(spinner_changes);
      if (!current || dirty & 32)
        set_data(t1, ctx2[5]);
      if (ctx2[4].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$2x(ctx2);
          if_block.c();
          if_block.m(li0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 8) {
        toggle_class(li1, "disabled", !ctx2[3].hasPrev());
      }
      if (!current || dirty & 8) {
        toggle_class(li2, "disabled", !ctx2[3].hasNext());
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(spinner);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const href$1 = "";
function instance$4l($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop$1, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store2, ($$value) => $$invalidate(3, $store = $$value)), store2);
  let $syncing, $$unsubscribe_syncing = noop$1, $$subscribe_syncing = () => ($$unsubscribe_syncing(), $$unsubscribe_syncing = subscribe(syncing, ($$value) => $$invalidate(6, $syncing = $$value)), syncing);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  $$self.$$.on_destroy.push(() => $$unsubscribe_syncing());
  let { store: store2 } = $$props;
  $$subscribe_store();
  let { syncing = store2.syncing } = $$props;
  $$subscribe_syncing();
  let info = {};
  let pages = [];
  let currentRange = "0-0";
  function setCurrentRange() {
    let { count: count2, offset, total_count, limit } = info;
    $$invalidate(5, currentRange = `${offset + (count2 > 0 ? 1 : 0)} - ${Math.min(offset + limit, total_count)} of ${total_count}`);
  }
  function getRange(index2) {
    let { limit, total_count } = info;
    const offset = limit * index2;
    return `${offset + 1} - ${Math.min(offset + limit, total_count)}`;
  }
  const click_handler = (i2, e) => store2.goto(i2);
  const click_handler_1 = (e) => store2.onPrev();
  const click_handler_2 = (e) => store2.onNext();
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(0, store2 = $$props2.store));
    if ("syncing" in $$props2)
      $$subscribe_syncing($$invalidate(1, syncing = $$props2.syncing));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      {
        $$invalidate(2, info = $store.info());
        $$invalidate(4, pages = Array(info.nPages));
        setCurrentRange();
      }
    }
  };
  return [
    store2,
    syncing,
    info,
    $store,
    pages,
    currentRange,
    $syncing,
    getRange,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class ListPager extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4l, create_fragment$4v, safe_not_equal, { store: 0, syncing: 1 });
  }
}
function get_each_context$15(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_each_block$15(ctx) {
  let li;
  let a;
  let t0_value = ctx[4].label + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return ctx[3](ctx[4], ...args);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "class", "dropdown-item");
      attr(a, "href", href);
      toggle_class(a, "active", ctx[4].value == ctx[2]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t0_value !== (t0_value = ctx[4].label + ""))
        set_data(t0, t0_value);
      if (dirty & 6) {
        toggle_class(a, "active", ctx[4].value == ctx[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4u(ctx) {
  let ul1;
  let li;
  let a;
  let i2;
  let i_class_value;
  let t;
  let ul0;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    each_blocks[i3] = create_each_block$15(get_each_context$15(ctx, each_value, i3));
  }
  return {
    c() {
      ul1 = element("ul");
      li = element("li");
      a = element("a");
      i2 = element("i");
      t = space();
      ul0 = element("ul");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      attr(i2, "class", i_class_value = "fa fa-sort-amount-" + (ctx[2][0] == "-" ? "desc" : "asc"));
      attr(a, "href", href);
      attr(a, "class", "text-secondary-emphasis page-link dropdown-toggle btn btn-default btn-sm");
      attr(a, "data-bs-toggle", "dropdown");
      attr(ul0, "class", "dropdown-menu dropdown-menu-end");
      attr(ul1, "class", "pagination pagination-sm dropdown");
      set_style(ul1, "margin", "0 5px 0 0");
    },
    m(target, anchor) {
      insert(target, ul1, anchor);
      append(ul1, li);
      append(li, a);
      append(a, i2);
      append(li, t);
      append(li, ul0);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(ul0, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && i_class_value !== (i_class_value = "fa fa-sort-amount-" + (ctx2[2][0] == "-" ? "desc" : "asc"))) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & 7) {
        each_value = ctx2[1];
        let i3;
        for (i3 = 0; i3 < each_value.length; i3 += 1) {
          const child_ctx = get_each_context$15(ctx2, each_value, i3);
          if (each_blocks[i3]) {
            each_blocks[i3].p(child_ctx, dirty);
          } else {
            each_blocks[i3] = create_each_block$15(child_ctx);
            each_blocks[i3].c();
            each_blocks[i3].m(ul0, null);
          }
        }
        for (; i3 < each_blocks.length; i3 += 1) {
          each_blocks[i3].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(ul1);
      destroy_each(each_blocks, detaching);
    }
  };
}
let href = "";
function instance$4k($$self, $$props, $$invalidate) {
  let { onSort } = $$props;
  let { sortingFields } = $$props;
  let { currentFieldName } = $$props;
  const click_handler = (field, e) => onSort(field.value);
  $$self.$$set = ($$props2) => {
    if ("onSort" in $$props2)
      $$invalidate(0, onSort = $$props2.onSort);
    if ("sortingFields" in $$props2)
      $$invalidate(1, sortingFields = $$props2.sortingFields);
    if ("currentFieldName" in $$props2)
      $$invalidate(2, currentFieldName = $$props2.currentFieldName);
  };
  return [onSort, sortingFields, currentFieldName, click_handler];
}
class SortBy extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4k, create_fragment$4u, safe_not_equal, {
      onSort: 0,
      sortingFields: 1,
      currentFieldName: 2
    });
  }
}
function get_each_context$14(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_if_block_7$b(ctx) {
  let a;
  let t_value = ctx[3].sieve_name + "";
  let t;
  let a_href_value;
  let a_title_value;
  return {
    c() {
      var _a;
      a = element("a");
      t = text(t_value);
      attr(a, "target", "_blank");
      attr(a, "href", a_href_value = `${urlCfg.app}/#/w/${(_a = ctx[4]) == null ? void 0 : _a.team}/sieve/detail/${ctx[3].sieve_id}.id`);
      attr(a, "title", a_title_value = ctx[3].sieve_name);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      var _a;
      if (dirty & 8 && t_value !== (t_value = ctx2[3].sieve_name + ""))
        set_data(t, t_value);
      if (dirty & 24 && a_href_value !== (a_href_value = `${urlCfg.app}/#/w/${(_a = ctx2[4]) == null ? void 0 : _a.team}/sieve/detail/${ctx2[3].sieve_id}.id`)) {
        attr(a, "href", a_href_value);
      }
      if (dirty & 8 && a_title_value !== (a_title_value = ctx2[3].sieve_name)) {
        attr(a, "title", a_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_else_block_2$6(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Success";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$2w(ctx) {
  let div3;
  let a;
  let t0_value = ctx[2].message + "";
  let t0;
  let span0;
  let t1;
  let div2;
  let div0;
  let t3;
  let div1;
  let label;
  let t5;
  let span1;
  let t6_value = (ctx[2].message || "NA") + "";
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[2].attemptsMade)
      return create_if_block_6$j;
    return create_else_block_1$j;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[2].statusCode && create_if_block_5$p(ctx);
  let if_block2 = ctx[2].body && create_if_block_4$w(ctx);
  let if_block3 = ctx[2].cause && create_if_block_1$1C(ctx);
  return {
    c() {
      div3 = element("div");
      a = element("a");
      t0 = text(t0_value);
      span0 = element("span");
      span0.innerHTML = `<i class="xcaret fa fa-caret-down"></i>`;
      t1 = space();
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "Error Details";
      t3 = space();
      div1 = element("div");
      label = element("label");
      label.textContent = "Message:";
      t5 = space();
      span1 = element("span");
      t6 = text(t6_value);
      t7 = space();
      if_block0.c();
      t8 = space();
      if (if_block1)
        if_block1.c();
      t9 = space();
      if (if_block2)
        if_block2.c();
      t10 = space();
      if (if_block3)
        if_block3.c();
      attr(span0, "class", "ms-1");
      attr(a, "title", "Click to view the error details");
      attr(a, "class", "pointer");
      attr(a, "data-bs-toggle", "dropdown");
      attr(a, "aria-haspopup", "true");
      attr(a, "aria-expanded", "false");
      toggle_class(a, "red", ctx[5]);
      attr(div0, "class", "gray f5 lh-copy");
      attr(div2, "class", "dropdown-menu dropdown-menu-end p-2");
      attr(div3, "class", "dropdown clearfix");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, a);
      append(a, t0);
      append(a, span0);
      append(div3, t1);
      append(div3, div2);
      append(div2, div0);
      append(div2, t3);
      append(div2, div1);
      append(div1, label);
      append(div1, t5);
      append(div1, span1);
      append(span1, t6);
      append(div2, t7);
      if_block0.m(div2, null);
      append(div2, t8);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t9);
      if (if_block2)
        if_block2.m(div2, null);
      append(div2, t10);
      if (if_block3)
        if_block3.m(div2, null);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t0_value !== (t0_value = ctx2[2].message + ""))
        set_data(t0, t0_value);
      if (dirty & 4 && t6_value !== (t6_value = (ctx2[2].message || "NA") + ""))
        set_data(t6, t6_value);
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div2, t8);
        }
      }
      if (ctx2[2].statusCode) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5$p(ctx2);
          if_block1.c();
          if_block1.m(div2, t9);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[2].body) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_4$w(ctx2);
          if_block2.c();
          if_block2.m(div2, t10);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (ctx2[2].cause) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_1$1C(ctx2);
          if_block3.c();
          if_block3.m(div2, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
}
function create_else_block_1$j(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<label>Attempts:</label> 
              <span>1</span>`;
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_6$j(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[2].attemptsMade + 1 + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Attempts:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t2_value !== (t2_value = ctx2[2].attemptsMade + 1 + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_5$p(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[2].statusCode + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Status Code:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t2_value !== (t2_value = ctx2[2].statusCode + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4$w(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[2].body + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Body:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t2_value !== (t2_value = ctx2[2].body + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$1C(ctx) {
  let div;
  let t1;
  let if_block_anchor;
  function select_block_type_2(ctx2, dirty) {
    if (typeof ctx2[2].cause === "string")
      return create_if_block_2$10;
    return create_else_block$1o;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      div.textContent = "Cause";
      t1 = space();
      if_block.c();
      if_block_anchor = empty();
      attr(div, "class", "gray f5 lh-copy");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t1, anchor);
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$1o(ctx) {
  let each_1_anchor;
  let each_value = Object.keys(ctx[2].cause);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$14(get_each_context$14(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        each_value = Object.keys(ctx2[2].cause);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$14(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$14(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_2$10(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[2].cause + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Message:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t2_value !== (t2_value = ctx2[2].cause + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3$O(ctx) {
  let div;
  let label;
  let t0_value = ctx[6] + "";
  let t0;
  let t1;
  let t2;
  let span;
  let t3_value = (typeof ctx[2].cause[ctx[6]] === "string" ? ctx[2].cause[ctx[6]] : JSON.stringify(ctx[2].cause[ctx[6]])) + "";
  let t3;
  let t4;
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = text(":");
      t2 = space();
      span = element("span");
      t3 = text(t3_value);
      t4 = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      append(label, t1);
      append(div, t2);
      append(div, span);
      append(span, t3);
      append(div, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t0_value !== (t0_value = ctx2[6] + ""))
        set_data(t0, t0_value);
      if (dirty & 4 && t3_value !== (t3_value = (typeof ctx2[2].cause[ctx2[6]] === "string" ? ctx2[2].cause[ctx2[6]] : JSON.stringify(ctx2[2].cause[ctx2[6]])) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$14(ctx) {
  let if_block_anchor;
  let if_block = ctx[6] !== "stack" && create_if_block_3$O(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[6] !== "stack") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$O(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$4t(ctx) {
  let tr;
  let td0;
  let div0;
  let t0_value = toISOString(ctx[3].ts) + "";
  let t0;
  let t1;
  let td1;
  let t2;
  let td2;
  let div1;
  let t3_value = ctx[3].category + "";
  let t3;
  let t4;
  let td3;
  let div2;
  let t5_value = ctx[1].get(ctx[3].type) + "";
  let t5;
  let t6;
  let td4;
  let if_block0 = ctx[3].sieve_id && create_if_block_7$b(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return create_if_block$2w;
    return create_else_block_2$6;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      if (if_block0)
        if_block0.c();
      t2 = space();
      td2 = element("td");
      div1 = element("div");
      t3 = text(t3_value);
      t4 = space();
      td3 = element("td");
      div2 = element("div");
      t5 = text(t5_value);
      t6 = space();
      td4 = element("td");
      if_block1.c();
      attr(td1, "class", "mw5 truncate");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, div0);
      append(div0, t0);
      append(tr, t1);
      append(tr, td1);
      if (if_block0)
        if_block0.m(td1, null);
      append(tr, t2);
      append(tr, td2);
      append(td2, div1);
      append(div1, t3);
      append(tr, t4);
      append(tr, td3);
      append(td3, div2);
      append(div2, t5);
      append(tr, t6);
      append(tr, td4);
      if_block1.m(td4, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 8 && t0_value !== (t0_value = toISOString(ctx2[3].ts) + ""))
        set_data(t0, t0_value);
      if (ctx2[3].sieve_id) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_7$b(ctx2);
          if_block0.c();
          if_block0.m(td1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 8 && t3_value !== (t3_value = ctx2[3].category + ""))
        set_data(t3, t3_value);
      if (dirty & 10 && t5_value !== (t5_value = ctx2[1].get(ctx2[3].type) + ""))
        set_data(t5, t5_value);
      if_block1.p(ctx2, dirty);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
      if (if_block0)
        if_block0.d();
      if_block1.d();
    }
  };
}
function instance$4j($$self, $$props, $$invalidate) {
  let $job, $$unsubscribe_job = noop$1, $$subscribe_job = () => ($$unsubscribe_job(), $$unsubscribe_job = subscribe(job, ($$value) => $$invalidate(3, $job = $$value)), job);
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(4, $params = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_job());
  let { job } = $$props;
  $$subscribe_job();
  let { jobTypesMap } = $$props;
  let { errorObj = $job.err } = $$props;
  let hasError = !!errorObj;
  $$self.$$set = ($$props2) => {
    if ("job" in $$props2)
      $$subscribe_job($$invalidate(0, job = $$props2.job));
    if ("jobTypesMap" in $$props2)
      $$invalidate(1, jobTypesMap = $$props2.jobTypesMap);
    if ("errorObj" in $$props2)
      $$invalidate(2, errorObj = $$props2.errorObj);
  };
  return [job, jobTypesMap, errorObj, $job, $params, hasError];
}
class Log$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4j, create_fragment$4t, safe_not_equal, { job: 0, jobTypesMap: 1, errorObj: 2 });
  }
}
const { Map: Map_1 } = globals;
function get_each_context$13(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  return child_ctx;
}
function get_each_context_1$b(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  return child_ctx;
}
function create_each_block_1$b(ctx) {
  let option;
  let t_value = ctx[15].name + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[15].value;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block$2v(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$1B, create_else_block$1n];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].models.length > 0)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$1n(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td colspan="5">No jobs were found.</td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_if_block_1$1B(ctx) {
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let each_1_anchor;
  let current;
  let each_value = ctx[2].models;
  const get_key = (ctx2) => ctx2[12].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$13(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$13(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 68) {
        each_value = ctx2[2].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$13, each_1_anchor, get_each_context$13);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$13(key_1, ctx) {
  let first2;
  let job;
  let current;
  job = new Log$1({
    props: {
      job: ctx[12],
      jobTypesMap: ctx[6]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(job.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(job, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const job_changes = {};
      if (dirty & 4)
        job_changes.job = ctx[12];
      job.$set(job_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(job.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(job.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(job, detaching);
    }
  };
}
function create_fragment$4s(ctx) {
  let div3;
  let div2;
  let div0;
  let t3;
  let div1;
  let select2;
  let option;
  let t5;
  let listpager;
  let t6;
  let sortby;
  let t7;
  let table;
  let thead;
  let t15;
  let tbody;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ctx[5];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$b(get_each_context_1$b(ctx, each_value_1, i2));
  }
  listpager = new ListPager({ props: { store: ctx[1] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[9],
      sortingFields: ctx[4],
      currentFieldName: ctx[2].orderBy
    }
  });
  let if_block = !ctx[3] && create_if_block$2v(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3>Logs</h3> 
      <h6>This section contains the log of all actions. It includes change alerts as well as verification messages.</h6>`;
      t3 = space();
      div1 = element("div");
      select2 = element("select");
      option = element("option");
      option.textContent = "All(Job Types)";
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t5 = space();
      create_component(listpager.$$.fragment);
      t6 = space();
      create_component(sortby.$$.fragment);
      t7 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="bg-gray-200"><th style="width: 50%;" colspan="2">Date</th> 
      <th>Category</th> 
      <th>Type</th> 
      <th>Status</th></tr>`;
      t15 = space();
      tbody = element("tbody");
      if (if_block)
        if_block.c();
      set_style(div0, "flex", "1");
      option.__value = "all";
      option.value = option.__value;
      attr(select2, "id", "job-type-selection");
      attr(select2, "class", "pa1 btn-sm");
      attr(select2, "title", "Select Job Types");
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[10].call(select2));
      attr(div1, "class", "mb0 pa1");
      attr(div2, "class", "card-header flex items-center");
      attr(table, "class", "table");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t3);
      append(div2, div1);
      append(div1, select2);
      append(select2, option);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      select_option(select2, ctx[0], true);
      append(div2, t5);
      mount_component(listpager, div2, null);
      append(div2, t6);
      mount_component(sortby, div2, null);
      append(div3, t7);
      append(div3, table);
      append(table, thead);
      append(table, t15);
      append(table, tbody);
      if (if_block)
        if_block.m(tbody, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(select2, "change", ctx[10]),
          listen(select2, "change", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 32) {
        each_value_1 = ctx2[5];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$b(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$b(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & 33) {
        select_option(select2, ctx2[0]);
      }
      const listpager_changes = {};
      if (dirty & 2)
        listpager_changes.store = ctx2[1];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty & 4)
        sortby_changes.currentFieldName = ctx2[2].orderBy;
      sortby.$set(sortby_changes);
      if (!ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2v(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(tbody, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_each(each_blocks, detaching);
      destroy_component(listpager);
      destroy_component(sortby);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4i($$self, $$props, $$invalidate) {
  let $store;
  let $syncingLogs;
  let selectedJobType = "all";
  let sortingFields = [
    { value: "-ts", label: "Newest First" },
    { value: "ts", label: "Oldest First" }
  ];
  const jobTypes = [
    {
      name: "Macro Action",
      value: "action_macro"
    },
    {
      name: "Webhook Action",
      value: "action_webhook"
    },
    {
      name: "Push Action",
      value: "action_push"
    },
    {
      name: "Discord Action",
      value: "action_discord"
    },
    { name: "Email", value: "email" },
    { name: "SMS", value: "sms" },
    { name: "Slack", value: "action_slack" },
    {
      name: "MS Teams Action",
      value: "action_teams"
    }
  ];
  const jobTypesMap = new Map(jobTypes.map((i2) => [i2.value, i2.name]));
  let store2 = getContext("store");
  component_subscribe($$self, store2, (value) => $$invalidate(2, $store = value));
  let syncingLogs = store2.syncing;
  component_subscribe($$self, syncingLogs, (value) => $$invalidate(3, $syncingLogs = value));
  store2.setQuery({ "state": 0 });
  async function onJobTypeChange(e) {
    const query = { "state": 0 };
    if (selectedJobType !== "all") {
      query.type = selectedJobType;
    }
    store2.setQuery(query);
    return await store2.goto(0, { reset: true });
  }
  async function onSort(by) {
    $$invalidate(1, store2.orderBy = by, store2);
    await store2.fetch({ reset: true });
  }
  function select_change_handler() {
    selectedJobType = select_value(this);
    $$invalidate(0, selectedJobType);
    $$invalidate(5, jobTypes);
  }
  const change_handler = (e) => onJobTypeChange();
  return [
    selectedJobType,
    store2,
    $store,
    $syncingLogs,
    sortingFields,
    jobTypes,
    jobTypesMap,
    syncingLogs,
    onJobTypeChange,
    onSort,
    select_change_handler,
    change_handler
  ];
}
class List$8 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4i, create_fragment$4s, safe_not_equal, {});
  }
}
function create_fragment$4r(ctx) {
  let list;
  let current;
  list = new List$8({});
  return {
    c() {
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
    }
  };
}
function instance$4h($$self, $$props, $$invalidate) {
  let { api = getContext("api") } = $$props;
  let { user = getContext("user") } = $$props;
  let store2 = new Jobs([], { orderBy: "-ts" });
  store2.setQuery({ state: "0" });
  setContext("store", store2);
  onMount(async () => {
    await store2.fetch();
  });
  $$self.$$set = ($$props2) => {
    if ("api" in $$props2)
      $$invalidate(0, api = $$props2.api);
    if ("user" in $$props2)
      $$invalidate(1, user = $$props2.user);
  };
  return [api, user];
}
class Logs extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4h, create_fragment$4r, safe_not_equal, { api: 0, user: 1 });
  }
}
function create_if_block$2u(ctx) {
  let previous_key = ctx[0];
  let key_block_anchor;
  let current;
  let key_block = create_key_block$8(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$8(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_if_block_3$N(ctx) {
  let usage;
  let current;
  usage = new Usage({ props: { cycle: ctx[2] } });
  return {
    c() {
      create_component(usage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(usage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const usage_changes = {};
      if (dirty & 4)
        usage_changes.cycle = ctx2[2];
      usage.$set(usage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(usage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(usage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(usage, detaching);
    }
  };
}
function create_if_block_2$$(ctx) {
  let log;
  let current;
  log = new Logs({});
  return {
    c() {
      create_component(log.$$.fragment);
    },
    m(target, anchor) {
      mount_component(log, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(log.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(log.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(log, detaching);
    }
  };
}
function create_if_block_1$1A(ctx) {
  let avail;
  let current;
  avail = new Avail({});
  return {
    c() {
      create_component(avail.$$.fragment);
    },
    m(target, anchor) {
      mount_component(avail, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(avail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(avail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(avail, detaching);
    }
  };
}
function create_key_block$8(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_1$1A, create_if_block_2$$, create_if_block_3$N];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2] === "availability")
      return 0;
    if (ctx2[2] === "logs")
      return 1;
    if (ctx2[2] === "daily" || ctx2[2] === "monthly")
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "col-sm-9");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_default_slot$1h(ctx) {
  let div2;
  let div1;
  let div0;
  let ul;
  let a0;
  let t0;
  let i0;
  let a0_href_value;
  let t1;
  let a1;
  let t2;
  let i1;
  let a1_href_value;
  let t3;
  let a2;
  let t4;
  let i2;
  let a2_href_value;
  let t5;
  let a3;
  let t6;
  let i3;
  let a3_href_value;
  let t7;
  let current;
  let if_block = ctx[1] && create_if_block$2u(ctx);
  return {
    c() {
      var _a, _b, _c, _d;
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      ul = element("ul");
      a0 = element("a");
      t0 = text("Available Resources");
      i0 = element("i");
      t1 = space();
      a1 = element("a");
      t2 = text("Daily Usage");
      i1 = element("i");
      t3 = space();
      a2 = element("a");
      t4 = text("Monthly Usage");
      i2 = element("i");
      t5 = space();
      a3 = element("a");
      t6 = text("Logs");
      i3 = element("i");
      t7 = space();
      if (if_block)
        if_block.c();
      attr(i0, "class", "fa fa-chevron-right right");
      attr(a0, "href", a0_href_value = "#/u/" + ((_a = ctx[1]) == null ? void 0 : _a.team) + "/usage/availability/");
      attr(a0, "class", "list-group-item");
      toggle_class(a0, "active", ctx[2] === "availability");
      attr(i1, "class", "fa fa-chevron-right right");
      attr(a1, "href", a1_href_value = "#/u/" + ((_b = ctx[1]) == null ? void 0 : _b.team) + "/usage/daily/");
      attr(a1, "class", "list-group-item");
      toggle_class(a1, "active", ctx[2] === "daily");
      attr(i2, "class", "fa fa-chevron-right right");
      attr(a2, "href", a2_href_value = "#/u/" + ((_c = ctx[1]) == null ? void 0 : _c.team) + "/usage/monthly/");
      attr(a2, "class", "list-group-item");
      toggle_class(a2, "active", ctx[2] === "monthly");
      attr(i3, "class", "fa fa-chevron-right right");
      attr(a3, "href", a3_href_value = "#/u/" + ((_d = ctx[1]) == null ? void 0 : _d.team) + "/usage/logs/");
      attr(a3, "class", "list-group-item");
      toggle_class(a3, "active", ctx[2] === "logs");
      attr(ul, "id", "sidebar");
      attr(ul, "class", "list-group");
      attr(div0, "class", "col-sm-3");
      attr(div1, "class", "row");
      attr(div2, "class", "container");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, ul);
      append(ul, a0);
      append(a0, t0);
      append(a0, i0);
      append(ul, t1);
      append(ul, a1);
      append(a1, t2);
      append(a1, i1);
      append(ul, t3);
      append(ul, a2);
      append(a2, t4);
      append(a2, i2);
      append(ul, t5);
      append(ul, a3);
      append(a3, t6);
      append(a3, i3);
      append(div1, t7);
      if (if_block)
        if_block.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a, _b, _c, _d;
      if (!current || dirty & 2 && a0_href_value !== (a0_href_value = "#/u/" + ((_a = ctx2[1]) == null ? void 0 : _a.team) + "/usage/availability/")) {
        attr(a0, "href", a0_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a0, "active", ctx2[2] === "availability");
      }
      if (!current || dirty & 2 && a1_href_value !== (a1_href_value = "#/u/" + ((_b = ctx2[1]) == null ? void 0 : _b.team) + "/usage/daily/")) {
        attr(a1, "href", a1_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a1, "active", ctx2[2] === "daily");
      }
      if (!current || dirty & 2 && a2_href_value !== (a2_href_value = "#/u/" + ((_c = ctx2[1]) == null ? void 0 : _c.team) + "/usage/monthly/")) {
        attr(a2, "href", a2_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a2, "active", ctx2[2] === "monthly");
      }
      if (!current || dirty & 2 && a3_href_value !== (a3_href_value = "#/u/" + ((_d = ctx2[1]) == null ? void 0 : _d.team) + "/usage/logs/")) {
        attr(a3, "href", a3_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a3, "active", ctx2[2] === "logs");
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2u(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block)
        if_block.d();
    }
  };
}
function create_header_slot$k(ctx) {
  let svlelte_fragment;
  return {
    c() {
      svlelte_fragment = element("svlelte:fragment");
      svlelte_fragment.innerHTML = `<div class="inline-block fw4 f2">Usage</div>`;
      attr(svlelte_fragment, "slot", "header");
    },
    m(target, anchor) {
      insert(target, svlelte_fragment, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(svlelte_fragment);
    }
  };
}
function create_topbar_slot$8(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({
    props: {
      showSearch: false,
      $$slots: { header: [create_header_slot$k] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (dirty & 8) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topbar.$set(topbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$4q(ctx) {
  let t;
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$8],
        default: [create_default_slot$1h]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(layout.$$.fragment);
      document.title = "Usage | Distill.io";
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 15) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(layout, detaching);
    }
  };
}
function instance$4g($$self, $$props, $$invalidate) {
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(1, $params = $$value));
  let module;
  let identityId;
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      {
        $$invalidate(2, module = $params == null ? void 0 : $params.module);
        $$invalidate(0, identityId = $params == null ? void 0 : $params.team);
        Api.setIdentityId(identityId == 0 || !identityId ? null : identityId);
      }
    }
  };
  return [identityId, $params, module];
}
class Usage_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4g, create_fragment$4q, safe_not_equal, {});
  }
}
var browser = Worker;
class DiffWorker {
  constructor({ url, module = true } = {}) {
    this.url = url;
    this.module = module;
    this.promises = {};
    this.ready = false;
    this.messageCounter = 0;
    this.initCalled = false;
  }
  async init() {
    if (this.initCalled)
      return;
    this.initCalled = true;
    this.worker = new browser(this.url, { type: this.module ? "module" : "classic" });
    this.worker.onerror = (error2) => {
      console.log(`Worker error: ${error2.message}`);
      throw error2;
    };
    this.attachListener();
    await this.ping();
    this.ready = true;
  }
  attachListener() {
    this.worker.addEventListener("message", (event) => {
      const [id2, result2] = event.data;
      const { resolve, reject: reject2 } = this.promises[id2];
      delete this.promises[id2];
      if (result2.error) {
        return reject2(new Error(result2.error));
      }
      resolve(result2);
    });
  }
  async postMessage(args) {
    const id2 = this.messageCounter++;
    args.push(id2);
    this.worker.postMessage(args);
    return new Promise((resolve, reject2) => this.promises[id2] = { resolve, reject: reject2 });
  }
  async diff(data1, data2, opts) {
    return this.postMessage(["diff", [data1, data2, opts]]);
  }
  async diffAndRender(data1, data2, opts) {
    return this.postMessage(["diffAndRender", [data1, data2, opts]]);
  }
  async diffAndRenderEmail(data1, data2, opts) {
    return this.postMessage(["diffAndRenderEmail", [data1, data2, opts]]);
  }
  async diffAndRenderForSummary(data1, data2, opts) {
    return this.postMessage(["diffAndRenderForSummary", [data1, data2, opts]]);
  }
  async ping() {
    return this.postMessage(["ping", null]);
  }
}
globalThis.DiffWorker = DiffWorker;
globalThis.DIFF_DELETE = -1;
globalThis.DIFF_INSERT = 1;
globalThis.DIFF_EQUAL = 0;
const PUBLIC_VERSION = "4";
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
Object.freeze({
  none: "none",
  single: "single",
  multi: "multi"
});
const CheckState = Object.freeze({
  none: "none",
  indeterminate: "indeterminate",
  selected: "selected"
});
class BaseNode {
  constructor(id2, label, parent2 = null) {
    __publicField(this, "_showExpandedMetaView", false);
    if (this.constructor === BaseNode) {
      throw new Error("unable to instantiate the abstract class");
    }
    this.id = id2;
    this.label = label;
    this.children = null;
    this.parent = parent2;
    this._expanded = false;
    this.selected = false;
    this.checkState = CheckState.none;
    this.listeners = [];
    this.checkable = false;
    this.disabled = false;
    this.selectable = false;
    this.loading = false;
  }
  subscribe(listener) {
    this.listeners.push(listener);
    listener(this);
    return () => {
      this.listeners.splice(this.listeners.indexOf(listener), 1);
    };
  }
  notify() {
    for (let listener of this.listeners) {
      listener(this);
    }
  }
  getId() {
    return this.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(label) {
    this.label = label;
    this.notify();
  }
  getChildCount() {
    return this.children ? this.children.length : 0;
  }
  async getChildren() {
    return this.children ? this.children : [];
  }
  setChildren(children) {
    this.children = children;
  }
  pushChild(child) {
    this.children.push(child);
  }
  getParent() {
    return this.parent;
  }
  setParent(parent2) {
    this.parent = parent2;
  }
  isExpanded() {
    return this._expanded;
  }
  setExpanded(state) {
    if (this.isExpandable() && this._expanded !== state) {
      this._expanded = state;
      this.notify();
    }
    if (state && this.parent) {
      this.parent.setExpanded(true);
    }
  }
  isExpandable() {
    return this.children ? this.children.length > 0 : false;
  }
  isSelectable() {
    return this.selectable && !this.disabled;
  }
  setSelectable(selectable) {
    this.selectable = selectable;
  }
  isLabelEditable() {
    return false;
  }
  editLabel(newLabelValue) {
  }
  getCheckState() {
    return this.checkState;
  }
  setCheckState(checkState) {
    this.checkState = checkState;
    this.notify();
  }
  isDisabled() {
    return this.disabled;
  }
  setDisabled(disabled) {
    this.disabled = disabled;
  }
  isCheckable() {
    return this.checkable && !this.disabled;
  }
  setCheckable(checkable) {
    this.checkable = checkable;
  }
  isLoading() {
    return this.loading;
  }
  setLoading(state) {
    this.loading = state;
    this.notify();
  }
  isRoot() {
    return !this.parent;
  }
  getRoot() {
    let node = this;
    let root2 = node;
    while (node.parent) {
      root2 = node.parent;
      node = node.parent;
    }
    return root2;
  }
  checkAllChild(state) {
    this.checkState = state;
    if (!this.children) {
      return;
    }
    for (let child of this.children) {
      child.checkState = state;
      child.checkAllChild(state);
    }
  }
  checkAllParent(state) {
    if (this.parent === null)
      return;
    let siblings = this.getSiblings();
    let countOfNone = 0, partial2 = false;
    const checkableSiblings = siblings.filter((s) => s.isCheckable());
    for (let sibling of checkableSiblings) {
      if (sibling.checkState === CheckState.none) {
        countOfNone++;
      } else if (sibling.checkState === CheckState.indeterminate) {
        partial2 = true;
        break;
      }
    }
    if (partial2 || countOfNone > 0 && countOfNone < checkableSiblings.length) {
      this.parent.checkState = CheckState.indeterminate;
    } else if (countOfNone === 0) {
      this.parent.checkState = CheckState.selected;
    } else {
      this.parent.checkState = CheckState.none;
    }
    this.parent.checkAllParent(state);
  }
  checkAll(state) {
    this.checkAllChild(state);
    this.checkAllParent(state);
    this.checkState = state;
    this.getRoot().notify();
  }
  expandedAll(state, root2) {
    root2._expanded = state;
    for (let child of parent.children) {
      child._expanded = state;
      this.expandedAll(state, child);
    }
    this.notify();
  }
  getSelected() {
    return this.selected;
  }
  setSelected(selected) {
    this.selected = selected;
    this.notify();
  }
  getSiblings() {
    if (this.parent === null)
      return null;
    if (this.parent.getChildCount() > 0)
      return this.parent.children;
    return null;
  }
  findNextSibling() {
    let siblings = this.getSiblings();
    if (!siblings)
      return null;
    const index2 = siblings.indexOf(this);
    return siblings[index2 + 1] || this.parent.findNextSibling();
  }
  findPreviousSibling() {
    let siblings = this.getSiblings();
    if (!siblings)
      return null;
    const index2 = siblings.indexOf(this);
    return siblings[index2 - 1] || null;
  }
  findInnermostChild() {
    let childCount = this.getChildCount();
    if (childCount === 0 || (!this.isExpanded() || this.isLoading()))
      return this;
    return this.children[childCount - 1].findInnermostChild();
  }
  selectNext() {
    let next2;
    if (this.isExpanded() && !this.isLoading() && this.getChildCount() > 0) {
      next2 = this.children[0];
    } else {
      next2 = this.findNextSibling();
    }
    if (!next2) {
      return null;
    } else if (next2.isSelectable()) {
      this.setSelected(false);
      next2.setSelected(true);
      return next2;
    } else {
      next2 = next2.selectNext();
      if (next2) {
        this.setSelected(false);
        return next2;
      } else {
        return null;
      }
    }
  }
  selectPrevious() {
    let previous;
    let previousSibling = this.findPreviousSibling();
    if (previousSibling) {
      if (previousSibling.isExpanded() && !previousSibling.isLoading()) {
        previous = previousSibling.findInnermostChild();
      } else {
        previous = previousSibling;
      }
    } else {
      previous = this.parent;
    }
    if (!previous) {
      return null;
    } else if (previous.isSelectable()) {
      this.setSelected(false);
      previous.setSelected(true);
      return previous;
    } else {
      const selectedAncestor = previous.selectPrevious();
      if (selectedAncestor) {
        this.setSelected(false);
        return selectedAncestor;
      } else {
        return null;
      }
    }
  }
  getNodeLevel() {
    if (!this.parent)
      return 0;
    return 1 + this.parent.getNodeLevel();
  }
  set showExpandedMetaView(value) {
    this._showExpandedMetaView = value;
    this.notify();
  }
  get showExpandedMetaView() {
    return this._showExpandedMetaView;
  }
}
const types = {
  ARRAY: "Array",
  ARRAY_OF_OBJECTS: "ArrayOfObjects",
  OBJECT: "Object",
  NUMBER: "Number",
  BOOLEAN: "Boolean",
  STRING: "String",
  NULL: "Null",
  UNDEFINED: "Undefined",
  PRIMITIVE: "Primitive"
};
function jsonType(json) {
  const type = Object.prototype.toString.call(json).slice(8, -1);
  if (type === "Object") {
    if (typeof json[Symbol.iterator] === "function") {
      return "Iterable";
    }
    return json.constructor.name;
  }
  return type;
}
function isPrimitive(value) {
  return isPrimitiveType(jsonType(value));
}
function isPrimitiveType(type) {
  switch (type) {
    case types.NUMBER:
    case types.BOOLEAN:
    case types.STRING:
    case types.PRIMITIVE:
    case types.NULL:
    case types.UNDEFINED:
      return true;
    case types.ARRAY:
    case types.ARRAY_OF_OBJECTS:
    case types.OBJECT:
      return false;
  }
}
class DiffTreeNode extends BaseNode {
  constructor({
    id: id2,
    label,
    parent: parent2 = null,
    type,
    value,
    oldValue = null,
    oldType = null,
    changeType,
    dirty = false,
    depth = 0
  } = {}) {
    super(id2, label, parent2);
    this.checkable = false;
    this.selectable = false;
    this.disabled = false;
    this._expanded = true;
    this.type = type;
    this.value = value;
    this.dirty = dirty;
    this.oldValue = oldValue;
    this.oldType = oldType;
    this.changeType = changeType;
    this.children = null;
    this.depth = depth;
  }
  getChildren() {
    return this.children || [];
  }
  isLeaf() {
    return this.getChildren().length === 0;
  }
  getValue() {
    switch (this.type) {
      case types.STRING:
        return this.value;
      default:
        return this.getPrettyValue();
    }
  }
  getPrettyValue(opts) {
    return this.getPretty({ value: this.value, type: this.type, ...opts });
  }
  getPrettyOldValue(opts) {
    return this.getPretty({ value: this.oldValue, type: this.oldType, ...opts });
  }
  getPretty({ value, type, trim = false }) {
    if (value === void 0) {
      return "";
    }
    if (!this.parent) {
      return this.value;
    }
    switch (type) {
      case types.STRING:
        value = firstValue(value);
        if (trim && value.length > 100) {
          return value.replace(/\s/g, " ").substring(0, 100) + `...`;
        } else {
          return value;
        }
      case types.NUMBER:
        return firstValue(value);
      case types.ARRAY:
      case types.OBJECT:
        return "";
      case types.BOOLEAN:
      default:
        return value;
    }
  }
  static parse(node, parent2 = null) {
    const curr = new DiffTreeNode();
    Object.assign(curr, node);
    curr.parent = parent2;
    if (node.children) {
      curr.children = node.children.map((child) => DiffTreeNode.parse(child, curr));
    }
    return curr;
  }
  stringify() {
    structuredClone(this);
  }
  toJSON() {
    return {
      id: this.id,
      label: this.label,
      type: this.type,
      value: this.value,
      oldValue: this.oldValue,
      oldType: this.oldType,
      changeType: this.changeType,
      dirty: this.dirty,
      depth: this.depth,
      children: this.children ? this.children.map((child) => child.toJSON()) : []
    };
  }
}
const ChangeType = {
  ADDED: "added",
  DELETED: "deleted",
  VALUE_CHANGED: "value_changed"
};
function firstValue(arrayOrValue) {
  if (arrayOrValue !== 0 && !arrayOrValue) {
    return "";
  }
  if (Array.isArray(arrayOrValue) && arrayOrValue.length > 0) {
    for (let i2 = 0; i2 < arrayOrValue.length; i2++) {
      if (arrayOrValue[i2]) {
        return arrayOrValue[i2];
      }
    }
    return arrayOrValue[0];
  }
  return arrayOrValue;
}
function isArrayDiff(item) {
  return !(jsonType(item) !== types.ARRAY || !(item.length === 2 || item.length === 1 && item[0] === " ") || !(typeof item[0] === "string") || item[0].length !== 1 || ![" ", "-", "+", "~"].includes(item[0]));
}
class ComputeDiff {
  constructor() {
    this.count = 0;
    this.maxDepth = 0;
    this.additions = 0;
    this.deletions = 0;
    this.jsonDiffToNode = this.jsonDiffToNode.bind(this);
  }
  updateDiffCount(changeType) {
    switch (changeType) {
      case ChangeType.ADDED:
        this.additions++;
        break;
      case ChangeType.DELETED:
        this.deletions++;
        break;
      case ChangeType.VALUE_CHANGED:
        this.additions++;
        this.deletions++;
        break;
    }
  }
  generateTree(json, root2, value) {
    const diffRoot = this.jsonDiffToNode(json, root2, null, value);
    Object.assign(diffRoot, { maxDepth: this.maxDepth, additions: this.additions, deletions: this.deletions });
    return diffRoot;
  }
  jsonDiffToNode(json, label, parent2, value, changeType, depth = 0) {
    let type = jsonType(json);
    let newNode;
    let oldValue;
    let oldType;
    let change;
    let dirty = false;
    if (this.maxDepth < depth) {
      this.maxDepth = depth;
    }
    if (jsonType(label) === types.STRING) {
      if (change = label.match(/^(.*)__deleted$/)) {
        label = change[1];
        dirty = true;
        changeType = ChangeType.DELETED;
      } else if (change = label.match(/^(.*)__added$/)) {
        label = change[1];
        dirty = true;
        changeType = ChangeType.ADDED;
      }
    }
    switch (type) {
      case types.ARRAY:
        newNode = new DiffTreeNode({
          id: this.count++,
          label,
          parent: parent2,
          type,
          value,
          changeType
        });
        this.updateDiffCount(changeType);
        let looksLikeDiff = true;
        for (const item of json) {
          if (!isArrayDiff(item)) {
            looksLikeDiff = false;
          }
        }
        if (looksLikeDiff) {
          newNode.children = [];
          let add_count = 0, delete_count = 0;
          for (let index2 in json) {
            let [op, value2] = json[index2];
            if (value2 === void 0) {
              continue;
            }
            if (op === "~") {
              op = " ";
            }
            switch (op) {
              case "+":
                add_count++;
                newNode.children.push(
                  this.jsonDiffToNode(value2, index2 - delete_count, newNode, value2, ChangeType.ADDED, depth + 1)
                );
                break;
              case "-":
                newNode.children.push(
                  this.jsonDiffToNode(value2, index2 - add_count, newNode, value2, ChangeType.DELETED, depth + 1)
                );
                delete_count++;
                break;
              case " ":
              default:
                newNode.children.push(
                  this.jsonDiffToNode(value2, index2 - delete_count, newNode, value2, void 0, depth + 1)
                );
            }
          }
        } else {
          newNode.children = json.map(
            (value2, index2) => this.jsonDiffToNode(value2, index2, newNode, value2, changeType, depth + 1)
          );
        }
        break;
      case types.OBJECT:
        if ("__old" in json && "__new" in json && Object.keys(json).length === 2) {
          dirty = true;
          oldValue = json.__old;
          value = json.__new;
          oldType = jsonType(oldValue);
          type = jsonType(value);
          changeType = ChangeType.VALUE_CHANGED;
          this.updateDiffCount(changeType);
          if (!isPrimitive(oldValue) || !isPrimitive(value)) {
            newNode = new DiffTreeNode({
              id: this.count++,
              label,
              parent: parent2,
              type,
              value,
              oldValue,
              oldType,
              changeType
            });
            newNode.children = [];
            newNode.children.push(
              this.jsonDiffToNode(oldValue, void 0, newNode, oldValue, ChangeType.DELETED, depth + 1)
            );
            newNode.children.push(this.jsonDiffToNode(value, void 0, newNode, value, ChangeType.ADDED, depth));
          } else {
            newNode = this.createLeafNode({ label, parent: parent2, type, value, oldValue, oldType, dirty, changeType });
          }
        } else {
          newNode = new DiffTreeNode({
            id: this.count++,
            label,
            parent: parent2,
            type,
            value,
            changeType
          });
          this.updateDiffCount(changeType);
          newNode.children = Object.keys(json).map(
            (key) => this.jsonDiffToNode(json[key], key, newNode, json[key], changeType, depth + 1)
          );
        }
        break;
      case types.NUMBER:
      case types.BOOLEAN:
      case types.STRING:
      case types.PRIMITIVE:
      default:
        this.updateDiffCount(changeType);
        newNode = this.createLeafNode({ label, parent: parent2, type, value, oldValue, oldType, dirty, changeType });
    }
    return newNode;
  }
  createLeafNode(data) {
    let { parent: parent2, changeType } = data;
    if (changeType) {
      let p = parent2;
      data.dirty = true;
      while (p) {
        if (p.dirty)
          break;
        p.dirty = true;
        p = p.parent;
      }
    }
    return new DiffTreeNode({
      id: this.count++,
      ...data
    });
  }
}
function pruneByChangeType(node, changeType) {
  (function prune(node2) {
    let index2 = 0;
    let children = node2.getChildren();
    let length = children.length;
    while (index2 < length) {
      let curr = children[index2];
      if (curr.changeType === changeType) {
        children.splice(index2, 1);
        index2--;
        length--;
      } else if (curr.changeType === ChangeType.VALUE_CHANGED && curr.isLeaf()) {
        if (changeType === ChangeType.ADDED) {
          curr.value = void 0;
        } else {
          curr.oldValue = void 0;
        }
      } else {
        prune(curr);
      }
      index2++;
    }
  })(node);
}
function removeDeletions(node) {
  pruneByChangeType(node, ChangeType.DELETED);
}
function removeAdditions(node) {
  pruneByChangeType(node, ChangeType.ADDED);
}
function generateTree(obj, options = {}) {
  let { pruneDeletions = false, pruneAdditions = false, root: root2 = "~", value } = options;
  const diff2 = new ComputeDiff();
  const diffNode = diff2.generateTree(obj, root2, value);
  if (pruneDeletions) {
    removeDeletions(diffNode);
  }
  if (pruneAdditions) {
    removeAdditions(diffNode);
  }
  return diffNode;
}
function cloneJsonDiff(root2) {
  const diffClone = function clone2(diffNode, parent2 = null) {
    let newNode = new DiffTreeNode(diffNode);
    newNode.parent = parent2;
    newNode.children = [];
    for (const child of diffNode.getChildren()) {
      newNode.children.push(clone2(child, newNode));
    }
    return newNode;
  }(root2);
  const { maxDepth, additions, deletions } = root2;
  Object.assign(diffClone, { maxDepth, additions, deletions });
  return diffClone;
}
function snipJsonDiff(node) {
  let index2 = 0;
  let children = node.getChildren();
  let length = children.length;
  while (index2 < length) {
    let curr = children[index2];
    if (curr.dirty === false) {
      children.splice(index2, 1);
      index2--;
      length--;
    } else {
      snipJsonDiff(curr);
    }
    index2++;
  }
}
function getChanges(node, changeType) {
  function getDiff2(node2, base2 = {}) {
    if (!node2.isLeaf()) {
      if (node2.changeType === ChangeType.VALUE_CHANGED) {
        let index2 = 0;
        if (node2.changeType === ChangeType.VALUE_CHANGED && changeType === ChangeType.ADDED) {
          index2 = 1;
        }
        base2[node2.label] = getDiff2(node2.getChildren()[index2]);
      } else {
        base2[node2.label] = {};
        if (node2.type === types.ARRAY) {
          base2[node2.label] = [];
        }
        node2.getChildren().forEach((child) => getDiff2(child, base2[node2.label]));
      }
    } else {
      if (jsonType(base2) === types.ARRAY) {
        base2.push(node2.value);
      } else {
        if (node2.parent.type === types.ARRAY) {
          base2 = node2.value;
        } else {
          base2[node2.label] = node2.value;
          if (node2.changeType === ChangeType.VALUE_CHANGED && changeType === ChangeType.DELETED) {
            base2[node2.label] = node2.oldValue;
          }
        }
      }
    }
    return base2;
  }
  let changes = [];
  (function treeTraversal(node2) {
    if (node2.changeType === changeType || node2.changeType === ChangeType.VALUE_CHANGED) {
      changes.push(getDiff2(node2));
    } else {
      node2.getChildren().forEach((child) => treeTraversal(child));
    }
  })(node);
  return changes.reduce((prev, curr) => [prev, JSON.stringify(curr)].join(" "), "");
}
var diffTree = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DiffTreeNode,
  ChangeType,
  removeDeletions,
  removeAdditions,
  generateTree,
  cloneJsonDiff,
  snipJsonDiff,
  getChanges
}, Symbol.toStringTag, { value: "Module" }));
const worker = new DiffWorker({ url: `/lib/worker.mjs` });
async function initializeWorker() {
  if (!worker.ready) {
    await worker.init();
  }
}
async function diffFeed(oldData, newData, selectedDiffContentMode = C$1.DIFF_MODE_VISUAL) {
  await initializeWorker();
  let diff2;
  let newFeedCount = 0;
  let updatedFeedCount = 0;
  let deletedFeedCount = 0;
  switch (selectedDiffContentMode) {
    case C$1.DIFF_MODE_VISUAL: {
      if (oldData.data === newData.data) {
        diff2 = JSON.parse(newData.data).entries;
      } else {
        const feedDiffResult = await worker.diff(oldData.data, newData.data, { type: "feed" });
        diff2 = feedDiffResult.changes;
        newFeedCount = feedDiffResult.newEntries;
        updatedFeedCount = feedDiffResult.updatedEntries;
        deletedFeedCount = feedDiffResult.deletedEntries;
      }
      break;
    }
    case C$1.DIFF_MODE_TEXT: {
      if (oldData.text === newData.text) {
        diff2 = htmlEscape(newData.text);
      } else {
        diff2 = await worker.diffAndRender(oldData.text, newData.text, { type: "text" });
        newFeedCount = getCount(diff2, "<ins");
        updatedFeedCount = getCount(diff2, "<del");
      }
      break;
    }
    case C$1.DIFF_MODE_SOURCE: {
      if (oldData.data === newData.data) {
        diff2 = "<html><body><span>" + htmlEscape(newData.data) + "</span></body></html>";
      } else {
        diff2 = await worker.diffAndRender(oldData.data, newData.data, { type: "text" });
        newFeedCount = getCount(diff2, "<ins");
        updatedFeedCount = getCount(diff2, "<del");
      }
      break;
    }
  }
  return { diff: diff2, newFeedCount, updatedFeedCount, deletedFeedCount };
}
async function diffHTMLAndRender(oldData, newData, selectedDiffContentMode = C$1.DIFF_MODE_VISUAL) {
  await initializeWorker();
  let diff2;
  let additions = 0;
  let deletions = 0;
  switch (selectedDiffContentMode) {
    case C$1.DIFF_MODE_VISUAL: {
      if (oldData.data === newData.data) {
        diff2 = newData.data;
      } else {
        diff2 = await worker.diffAndRender(oldData.data, newData.data, { type: "html" });
        additions = getCount(diff2, "diffMark inserted");
        deletions = getCount(diff2, "diffMark removed");
      }
      break;
    }
    case C$1.DIFF_MODE_TEXT: {
      if (oldData.text === newData.text) {
        diff2 = htmlEscape(newData.text);
      } else {
        diff2 = await worker.diffAndRender(oldData.text, newData.text, { type: "text" });
        diff2 = diff2.replace(/\&para;/g, "");
        additions = getCount(diff2, "<ins");
        deletions = getCount(diff2, "<del");
      }
      break;
    }
    case C$1.DIFF_MODE_SOURCE: {
      if (oldData.data === newData.data) {
        diff2 = "<html><body><span>" + htmlEscape(newData.data) + "</span></body></html>";
      } else {
        diff2 = await worker.diffAndRender(oldData.data, newData.data, { type: "text" });
        diff2 = diff2.replace(/\&para;/g, "");
        additions = getCount(diff2, "<ins");
        deletions = getCount(diff2, "<del");
      }
      break;
    }
  }
  return { diff: diff2, additions, deletions };
}
async function diffJson(oldText, newText, full = true) {
  await initializeWorker();
  const { diff: diff2 } = await worker.diff(oldText, newText, { type: "json", diffOpts: { full } });
  const diffNodeTree = createDiffNodeTree(diff2);
  return { diff: diffNodeTree };
}
function createDiffNodeTree(diff2, parent2 = null) {
  if (!diff2) {
    return null;
  }
  const node = new DiffTreeNode(diff2);
  Object.assign(node, diff2);
  node.parent = parent2;
  if (diff2.children) {
    node.children = diff2.children.map((child) => createDiffNodeTree(child, node));
  }
  return node;
}
async function diffSitemap(oldData, newData) {
  const { crawler_id: crawlerId, job_id: jobId1 } = newData;
  const { job_id: jobId2 } = oldData;
  let diffEndpoint = `/crawlers/data/${crawlerId}/diff/${jobId1}`;
  if (jobId2) {
    diffEndpoint += `?id2=${jobId2}`;
  }
  const diffData = await Api.api(diffEndpoint);
  const { summary, diff: diff2 } = diffData;
  return { diff: diff2, ...summary };
}
function htmlEscape(str) {
  return str.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;");
}
function getCount(diff2, selector) {
  const pattern = new RegExp(selector, "g");
  return (diff2.match(pattern) || []).length;
}
function initStore() {
  const { subscribe: subscribe2, set, update } = writable({
    sieve_data: null,
    data1: null,
    data2: null,
    diff: null,
    additions: 0,
    deletions: 0,
    updations: 0,
    type: null,
    uri: null,
    diffing: true,
    diffError: null,
    sieve: null,
    diffContentMode: null
  });
  store = {
    subscribe: subscribe2,
    set,
    fetchSieveData: async function(sieveDataId1, sieveDataId2) {
      const { sieve } = get_store_value(this);
      const sieveId = sieve.get("id");
      const query = { _opt: { only: ["id", "ts"] } };
      try {
        const { data } = await Api.api(`/sieves/${sieveId}/data`, query);
        let index2 = -1, index22 = -1;
        if (!sieveDataId1 && !sieveDataId2) {
          index2 = 0;
          index22 = 0;
        } else if (sieveDataId1 && sieveDataId2) {
          index2 = data.findIndex((dat) => dat.id === sieveDataId1);
          index22 = data.findIndex((dat) => dat.id === sieveDataId2);
        } else if (sieveDataId1 && !sieveDataId2) {
          index2 = data.findIndex((dat) => dat.id === sieveDataId1);
          index22 = index2 + 1;
        } else if (!sieveDataId1 && sieveDataId2) {
          index22 = data.findIndex((dat) => dat.id === sieveDataId2);
          index2 = index22 - 1;
        }
        const [data2, data1] = await Promise.all([this.getSieveData(data[index2].id), this.getSieveData(data[index22].id)]);
        await this.init({ sieve_data: data, data1, data2 });
        if (index2 === -1 || index22 === -1) {
          this.setErrorMessage(TXT("m_invalid_sieve_data_id_explore_diff"));
        }
      } catch (e) {
        console.error(`error while fetching sieve data for the sieve`, sieveId, e);
      }
    },
    init: async function(data) {
      const { sieve } = get_store_value(this);
      this.updateStore({ ...data, diffContentMode: sieve.getDiffMode() });
      if (data.data1 && data.data2) {
        await this.updateDiff(data);
      }
    },
    getSieveData: async function(sieveDataId) {
      const currStore = get_store_value(this);
      return await Api.api(`/sieves/${currStore.sieve.get("id")}/data/${sieveDataId}`);
    },
    updateData1ById: async function(id2) {
      const currStore = get_store_value(this);
      const data1 = await this.getSieveData(id2);
      this.updateDiff({ data1, data2: currStore.data2 });
    },
    updateData2ById: async function(id2) {
      const currStore = get_store_value(this);
      const data2 = await this.getSieveData(id2);
      this.updateDiff({ data1: currStore.data1, data2 });
    },
    updateDiff: async function({ data1, data2 }) {
      let diffData = null;
      try {
        this.updateStore({ diff: void 0, diffing: true, diffError: null });
        diffData = await this.getDiff(data1, data2);
        this.updateStore({ ...diffData, data1, data2 });
      } catch (e) {
        this.updateStore({ diffError: e });
        console.error("error while generating the diff", e);
      } finally {
        this.updateStore({ diffing: false });
      }
    },
    updateDiffContentMode: async function(diffContentMode = C$1.DIFF_MODE_VISUAL) {
      const currStore = get_store_value(this);
      this.updateStore({ diff: void 0, diffContentMode });
      if (currStore.data1 && currStore.data2) {
        await this.updateDiff({
          data1: currStore.data1,
          data2: currStore.data2
        });
      }
    },
    setErrorMessage: function(errorMessage) {
      this.updateStore({ errorMessage });
    },
    getDiff: async function(data1, data2) {
      const { type, diffContentMode } = get_store_value(this);
      let content1 = data1.data;
      let content2 = data2.data;
      let diff2, additions = 0, updations = 0, deletions = 0;
      switch (type) {
        case C$1.TYPE_DOC:
        case C$1.TYPE_HTML:
        case C$1.TYPE_PDF_HTML:
          try {
            ({ diff: diff2, additions, deletions } = await diffHTMLAndRender(data1, data2, diffContentMode));
          } catch (e) {
            diff2 = content2;
            console.error("error while generating the diff", e);
          }
          break;
        case C$1.TYPE_JSON:
          if (diffContentMode !== C$1.DIFF_MODE_DATA && data1.snapshot && data2.snapshot) {
            try {
              ({ diff: diff2, additions, deletions } = await diffHTMLAndRender({ data: data1.snapshot }, { data: data2.snapshot }, diffContentMode));
            } catch (e) {
              diff2 = content2;
              console.error("error while generating the diff", e);
            }
          } else {
            if (diffContentMode !== C$1.DIFF_MODE_DATA) {
              this.updateStore({ diffContentMode: C$1.DIFF_MODE_DATA });
            }
            if (typeof content1 === "string") {
              content1 = JSON.parse(content1);
              data1.data = content1;
            }
            if (typeof content2 === "string") {
              content2 = JSON.parse(content2);
              data2.data = content2;
            }
            ({ diff: diff2 } = await diffJson(content1, content2));
            ({ additions, deletions } = diff2);
          }
          break;
        case C$1.TYPE_XML:
          ({ diff: diff2, additions, deletions } = await diffHTMLAndRender(data1, data2, diffContentMode));
          break;
        case C$1.TYPE_SITEMAP:
          if (typeof content1 === "string") {
            content1 = JSON.parse(content1);
            data1.data = content1;
          }
          if (typeof content2 === "string") {
            content2 = JSON.parse(content2);
            data2.data = content2;
          }
          ({ diff: diff2, additions, deletions } = await diffSitemap(content1, content2));
          break;
        case C$1.TYPE_FEED:
          let newFeedCount, updatedFeedCount, deletedFeedCount = 0;
          ({ diff: diff2, newFeedCount, updatedFeedCount, deletedFeedCount } = await diffFeed(data1, data2, diffContentMode));
          additions = newFeedCount;
          deletions = deletedFeedCount;
          updations = updatedFeedCount;
          break;
      }
      return { diff: diff2, additions, deletions, updations };
    },
    updateStore: function(obj) {
      update((value) => {
        return { ...value, ...obj };
      });
    }
  };
  return store;
}
function destroyStore() {
  store = void 0;
}
let store;
function get_each_context$12(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_each_block$12(ctx) {
  let option;
  let t_value = new Date(ctx[8].ts).toLocaleString() + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[8].id;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = new Date(ctx2[8].ts).toLocaleString() + ""))
        set_data(t, t_value);
      if (dirty & 2 && option_value_value !== (option_value_value = ctx2[8].id)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$4p(ctx) {
  let div;
  let select2;
  let select_class_value;
  let mounted;
  let dispose;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$12(get_each_context$12(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      select2 = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(select2, "class", select_class_value = "form-select " + ctx[2]);
      attr(select2, "title", ctx[3]);
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[6].call(select2));
      attr(div, "class", ctx[4]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, select2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      select_option(select2, ctx[0], true);
      if (!mounted) {
        dispose = [
          listen(select2, "change", ctx[6]),
          listen(select2, "change", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$12(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$12(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 4 && select_class_value !== (select_class_value = "form-select " + ctx2[2])) {
        attr(select2, "class", select_class_value);
      }
      if (dirty & 8) {
        attr(select2, "title", ctx2[3]);
      }
      if (dirty & 3) {
        select_option(select2, ctx2[0]);
      }
      if (dirty & 16) {
        attr(div, "class", ctx2[4]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$4f($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { timestamps } = $$props;
  let { value } = $$props;
  let { selectClass = "" } = $$props;
  let { title } = $$props;
  let { class: classes = "" } = $$props;
  function select_change_handler() {
    value = select_value(this);
    $$invalidate(0, value);
    $$invalidate(1, timestamps);
  }
  const change_handler = (e) => dispatch("change", { value: e.target.value });
  $$self.$$set = ($$props2) => {
    if ("timestamps" in $$props2)
      $$invalidate(1, timestamps = $$props2.timestamps);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("selectClass" in $$props2)
      $$invalidate(2, selectClass = $$props2.selectClass);
    if ("title" in $$props2)
      $$invalidate(3, title = $$props2.title);
    if ("class" in $$props2)
      $$invalidate(4, classes = $$props2.class);
  };
  return [
    value,
    timestamps,
    selectClass,
    title,
    classes,
    dispatch,
    select_change_handler,
    change_handler
  ];
}
class DateSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4f, create_fragment$4p, safe_not_equal, {
      timestamps: 1,
      value: 0,
      selectClass: 2,
      title: 3,
      class: 4
    });
  }
}
function create_else_block_1$i(ctx) {
  let t;
  return {
    c() {
      t = text("+");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$_(ctx) {
  let t;
  return {
    c() {
      t = text("new,");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$1z(ctx) {
  let span;
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(ctx[2]);
      t1 = text(" updated,");
      attr(span, "class", "text-secondary-700 font-bold");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t0, ctx2[2]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_else_block$1m(ctx) {
  let t;
  return {
    c() {
      t = text("-");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$2t(ctx) {
  let t;
  return {
    c() {
      t = text("deleted");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$4o(ctx) {
  let div;
  let span0;
  let t0;
  let t1;
  let t2;
  let t3;
  let span1;
  let t4;
  let t5;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3] === C$1.TYPE_FEED)
      return create_if_block_2$_;
    return create_else_block_1$i;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[3] === C$1.TYPE_FEED && create_if_block_1$1z(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3] === C$1.TYPE_FEED)
      return create_if_block$2t;
    return create_else_block$1m;
  }
  let current_block_type_1 = select_block_type_1(ctx);
  let if_block2 = current_block_type_1(ctx);
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = text(ctx[0]);
      t1 = space();
      if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      span1 = element("span");
      t4 = text(ctx[1]);
      t5 = space();
      if_block2.c();
      attr(span0, "class", "text-green-700 font-bold");
      attr(span1, "class", "text-red-700 font-bold");
      attr(div, "class", ctx[4]);
      attr(div, "title", TXT("l_diff_stats"));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(span0, t0);
      append(span0, t1);
      if_block0.m(span0, null);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t3);
      append(div, span1);
      append(span1, t4);
      append(span1, t5);
      if_block2.m(span1, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t0, ctx2[0]);
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(span0, null);
        }
      }
      if (ctx2[3] === C$1.TYPE_FEED) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$1z(ctx2);
          if_block1.c();
          if_block1.m(div, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 2)
        set_data(t4, ctx2[1]);
      if (current_block_type_1 !== (current_block_type_1 = select_block_type_1(ctx2))) {
        if_block2.d(1);
        if_block2 = current_block_type_1(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(span1, null);
        }
      }
      if (dirty & 16) {
        attr(div, "class", ctx2[4]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if_block2.d();
    }
  };
}
function instance$4e($$self, $$props, $$invalidate) {
  let { additions } = $$props;
  let { deletions } = $$props;
  let { updations } = $$props;
  let { dataType } = $$props;
  let { class: classes = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("additions" in $$props2)
      $$invalidate(0, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(1, deletions = $$props2.deletions);
    if ("updations" in $$props2)
      $$invalidate(2, updations = $$props2.updations);
    if ("dataType" in $$props2)
      $$invalidate(3, dataType = $$props2.dataType);
    if ("class" in $$props2)
      $$invalidate(4, classes = $$props2.class);
  };
  return [additions, deletions, updations, dataType, classes];
}
class DiffStats extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4e, create_fragment$4o, safe_not_equal, {
      additions: 0,
      deletions: 1,
      updations: 2,
      dataType: 3,
      class: 4
    });
  }
}
var ExploreDiffHeader_svelte_svelte_type_style_lang = "";
function create_if_block_6$i(ctx) {
  let div;
  let button0;
  let t0_value = TXT("a_side_by_side_diff") + "";
  let t0;
  let button0_class_value;
  let t1;
  let button1;
  let t2_value = TXT("a_inline_diff") + "";
  let t2;
  let button1_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      attr(button0, "class", button0_class_value = "btn btn-default flex-grow " + (!ctx[0] ? "btn-primary min-w-0 active" : ""));
      attr(button1, "class", button1_class_value = "btn btn-default flex-grow " + (ctx[0] ? "btn-primary min-w-0 active" : ""));
      attr(div, "class", "btn-group btn-toggle flex btn-group-sm");
      attr(div, "role", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[14]),
          listen(button1, "click", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && button0_class_value !== (button0_class_value = "btn btn-default flex-grow " + (!ctx2[0] ? "btn-primary min-w-0 active" : ""))) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty & 1 && button1_class_value !== (button1_class_value = "btn btn-default flex-grow " + (ctx2[0] ? "btn-primary min-w-0 active" : ""))) {
        attr(button1, "class", button1_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_5$o(ctx) {
  let div;
  let button0;
  let t0_value = TXT("a_styled_page") + "";
  let t0;
  let button0_class_value;
  let t1;
  let button1;
  let t2_value = TXT("a_unstyled_page") + "";
  let t2;
  let button1_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      attr(button0, "class", button0_class_value = "btn btn-default " + (ctx[1] ? "btn-primary min-w-0 active" : ""));
      attr(button1, "class", button1_class_value = "btn btn-default " + (!ctx[1] ? "btn-primary min-w-0 active" : ""));
      attr(div, "class", "btn-group btn-toggle no-wrap flex conceal btn-group-sm svelte-gdbbe6");
      attr(div, "role", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[16]),
          listen(button1, "click", ctx[17])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && button0_class_value !== (button0_class_value = "btn btn-default " + (ctx2[1] ? "btn-primary min-w-0 active" : ""))) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty & 2 && button1_class_value !== (button1_class_value = "btn btn-default " + (!ctx2[1] ? "btn-primary min-w-0 active" : ""))) {
        attr(button1, "class", button1_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_catch_block_1(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block_1(ctx) {
  var _a, _b;
  let show_if = ctx[9].diffContentMode && (ctx[6] !== C$1.TYPE_JSON || !isStaticDatasource(ctx[7]) && ctx[9].data1.snapshot && ctx[9].data2.snapshot);
  let t0;
  let div1;
  let dateselect0;
  let t1;
  let div0;
  let t2;
  let dateselect1;
  let t3;
  let a;
  let i1;
  let a_href_value;
  let current;
  let if_block = show_if && create_if_block_1$1y(ctx);
  dateselect0 = new DateSelect({
    props: {
      timestamps: ctx[9].sieve_data,
      value: (_a = ctx[9].data1) == null ? void 0 : _a.id,
      title: TXT("l_sieve_to_compare")
    }
  });
  dateselect0.$on("change", ctx[22]);
  dateselect1 = new DateSelect({
    props: {
      timestamps: ctx[9].sieve_data,
      value: (_b = ctx[9].data2) == null ? void 0 : _b.id,
      title: TXT("l_sieve_to_compare_with")
    }
  });
  dateselect1.$on("change", ctx[23]);
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      div1 = element("div");
      create_component(dateselect0.$$.fragment);
      t1 = space();
      div0 = element("div");
      div0.innerHTML = `<i class="fa fa-arrow-right"></i>`;
      t2 = space();
      create_component(dateselect1.$$.fragment);
      t3 = space();
      a = element("a");
      i1 = element("i");
      attr(div0, "class", "flex items-center");
      attr(div1, "class", "flex items-center gap-2");
      attr(i1, "class", "fa fa-external-link");
      attr(a, "href", a_href_value = ctx[9].uri);
      attr(a, "class", "btn btn-default");
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      mount_component(dateselect0, div1, null);
      append(div1, t1);
      append(div1, div0);
      append(div1, t2);
      mount_component(dateselect1, div1, null);
      insert(target, t3, anchor);
      insert(target, a, anchor);
      append(a, i1);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & 704)
        show_if = ctx2[9].diffContentMode && (ctx2[6] !== C$1.TYPE_JSON || !isStaticDatasource(ctx2[7]) && ctx2[9].data1.snapshot && ctx2[9].data2.snapshot);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1y(ctx2);
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const dateselect0_changes = {};
      if (dirty & 512)
        dateselect0_changes.timestamps = ctx2[9].sieve_data;
      if (dirty & 512)
        dateselect0_changes.value = (_a2 = ctx2[9].data1) == null ? void 0 : _a2.id;
      dateselect0.$set(dateselect0_changes);
      const dateselect1_changes = {};
      if (dirty & 512)
        dateselect1_changes.timestamps = ctx2[9].sieve_data;
      if (dirty & 512)
        dateselect1_changes.value = (_b2 = ctx2[9].data2) == null ? void 0 : _b2.id;
      dateselect1.$set(dateselect1_changes);
      if (!current || dirty & 512 && a_href_value !== (a_href_value = ctx2[9].uri)) {
        attr(a, "href", a_href_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(dateselect0.$$.fragment, local);
      transition_in(dateselect1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dateselect0.$$.fragment, local);
      transition_out(dateselect1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      destroy_component(dateselect0);
      destroy_component(dateselect1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block_1$1y(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let button;
  let t3_value = TXT("l_source") + "";
  let t3;
  let button_class_value;
  let mounted;
  let dispose;
  let if_block0 = ctx[6] === C$1.TYPE_JSON && create_if_block_4$v(ctx);
  let if_block1 = ctx[6] !== C$1.TYPE_XML && create_if_block_3$M(ctx);
  let if_block2 = ctx[6] !== C$1.TYPE_JSON && create_if_block_2$Z(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      button = element("button");
      t3 = text(t3_value);
      attr(button, "class", button_class_value = "btn btn-default flex-grow " + (C$1.DIFF_MODE_SOURCE === ctx[9].diffContentMode ? "btn-primary min-w-0 active" : ""));
      attr(div, "class", "btn-group btn-toggle flex btn-group-sm");
      attr(div, "role", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append(div, t2);
      append(div, button);
      append(button, t3);
      if (!mounted) {
        dispose = listen(button, "click", ctx[21]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[6] === C$1.TYPE_JSON) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4$v(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[6] !== C$1.TYPE_XML) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_3$M(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[6] !== C$1.TYPE_JSON) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_2$Z(ctx2);
          if_block2.c();
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty & 512 && button_class_value !== (button_class_value = "btn btn-default flex-grow " + (C$1.DIFF_MODE_SOURCE === ctx2[9].diffContentMode ? "btn-primary min-w-0 active" : ""))) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$v(ctx) {
  let button;
  let t_value = TXT("l_data") + "";
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", button_class_value = "btn btn-default flex-grow " + (C$1.DIFF_MODE_DATA === ctx[9].diffContentMode ? "btn-primary min-w-0 active" : ""));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[18]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 512 && button_class_value !== (button_class_value = "btn btn-default flex-grow " + (C$1.DIFF_MODE_DATA === ctx2[9].diffContentMode ? "btn-primary min-w-0 active" : ""))) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$M(ctx) {
  let button;
  let t_value = TXT("l_visual") + "";
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", button_class_value = "btn btn-default flex-grow " + (C$1.DIFF_MODE_VISUAL === ctx[9].diffContentMode ? "btn-primary min-w-0 active" : ""));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[19]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 512 && button_class_value !== (button_class_value = "btn btn-default flex-grow " + (C$1.DIFF_MODE_VISUAL === ctx2[9].diffContentMode ? "btn-primary min-w-0 active" : ""))) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$Z(ctx) {
  let button;
  let t_value = TXT("l_text") + "";
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", button_class_value = "btn btn-default flex-grow " + (C$1.DIFF_MODE_TEXT === ctx[9].diffContentMode ? "btn-primary min-w-0 active" : ""));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[20]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 512 && button_class_value !== (button_class_value = "btn btn-default flex-grow " + (C$1.DIFF_MODE_TEXT === ctx2[9].diffContentMode ? "btn-primary min-w-0 active" : ""))) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_pending_block_1(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_catch_block$B(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$B(ctx) {
  let div;
  let diffstats;
  let current;
  diffstats = new DiffStats({
    props: {
      additions: ctx[9].additions,
      deletions: ctx[9].deletions,
      updations: ctx[9].updations,
      dataType: ctx[6],
      class: "bg-white border-[1px] border-[#cccccc] border-solid p-2 rounded-md "
    }
  });
  return {
    c() {
      div = element("div");
      create_component(diffstats.$$.fragment);
      attr(div, "class", "flex mr-5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(diffstats, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const diffstats_changes = {};
      if (dirty & 512)
        diffstats_changes.additions = ctx2[9].additions;
      if (dirty & 512)
        diffstats_changes.deletions = ctx2[9].deletions;
      if (dirty & 512)
        diffstats_changes.updations = ctx2[9].updations;
      if (dirty & 64)
        diffstats_changes.dataType = ctx2[6];
      diffstats.$set(diffstats_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffstats.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffstats.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(diffstats);
    }
  };
}
function create_pending_block$B(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_if_block$2s(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      attr(button, "class", "btn-close");
      attr(button, "title", TXT("a_close"));
      attr(div, "class", "flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[24]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4n(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let promise_1;
  let t2;
  let div1;
  let promise_2;
  let t3;
  let div2_class_value;
  let current;
  let if_block0 = ctx[2] && create_if_block_6$i(ctx);
  let if_block1 = ctx[3] && create_if_block_5$o(ctx);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block_1,
    value: 27,
    blocks: [, , ,]
  };
  handle_promise(promise_1 = ctx[5], info);
  let info_1 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$B,
    then: create_then_block$B,
    catch: create_catch_block$B,
    value: 27,
    blocks: [, , ,]
  };
  handle_promise(promise_2 = ctx[5], info_1);
  let if_block2 = ctx[4] && create_if_block$2s(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      info.block.c();
      t2 = space();
      div1 = element("div");
      info_1.block.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "flex gap-4 no-wrap");
      attr(div1, "class", "flex items-center");
      attr(div2, "class", div2_class_value = "card-header px-3 py-2 xpanel-heading-alt flex justify-between gap-8 items-stretch no-wrap " + ctx[8] + " svelte-gdbbe6");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append(div0, t1);
      info.block.m(div0, info.anchor = null);
      info.mount = () => div0;
      info.anchor = null;
      append(div2, t2);
      append(div2, div1);
      info_1.block.m(div1, info_1.anchor = null);
      info_1.mount = () => div1;
      info_1.anchor = t3;
      append(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (ctx[2]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_6$i(ctx);
          if_block0.c();
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx[3]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_5$o(ctx);
          if_block1.c();
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      info.ctx = ctx;
      if (dirty & 32 && promise_1 !== (promise_1 = ctx[5]) && handle_promise(promise_1, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
      info_1.ctx = ctx;
      if (dirty & 32 && promise_2 !== (promise_2 = ctx[5]) && handle_promise(promise_2, info_1))
        ;
      else {
        update_await_block_branch(info_1, ctx, dirty);
      }
      if (ctx[4]) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block$2s(ctx);
          if_block2.c();
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & 256 && div2_class_value !== (div2_class_value = "card-header px-3 py-2 xpanel-heading-alt flex justify-between gap-8 items-stretch no-wrap " + ctx[8] + " svelte-gdbbe6")) {
        attr(div2, "class", div2_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      transition_in(info_1.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info_1.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      info.block.d();
      info.token = null;
      info = null;
      info_1.block.d();
      info_1.token = null;
      info_1 = null;
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$4d($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(9, $store = $$value));
  const moment2 = window.moment;
  const dispatch = createEventDispatcher();
  let { showDiffMode = true } = $$props;
  let { showStyleMode = true } = $$props;
  let { showCloseButton = false } = $$props;
  let { inlined = false } = $$props;
  let { withStyle } = $$props;
  let { promise } = $$props;
  let { dataType } = $$props;
  let { datasourceId } = $$props;
  let { sieve } = $$props;
  let { class: classes = "" } = $$props;
  function markReadUntil() {
    var _a;
    const newTsView = moment2.max(moment2(((_a = $store.data1) == null ? void 0 : _a.ts_mod) || 0), moment2($store.data2.ts_mod));
    sieve.markReadUntil(newTsView);
  }
  function showDiffInline(value) {
    $$invalidate(0, inlined = value);
  }
  function showStyled(value) {
    $$invalidate(1, withStyle = value);
  }
  const click_handler = () => showDiffInline(false);
  const click_handler_1 = () => showDiffInline(true);
  const click_handler_2 = () => showStyled(true);
  const click_handler_3 = () => showStyled(false);
  const click_handler_4 = () => store.updateDiffContentMode(C$1.DIFF_MODE_DATA);
  const click_handler_5 = () => store.updateDiffContentMode(C$1.DIFF_MODE_VISUAL);
  const click_handler_6 = () => store.updateDiffContentMode(C$1.DIFF_MODE_TEXT);
  const click_handler_7 = () => store.updateDiffContentMode(C$1.DIFF_MODE_SOURCE);
  const change_handler = (e) => store.updateData1ById(e.detail.value);
  const change_handler_1 = (e) => store.updateData2ById(e.detail.value);
  const click_handler_8 = () => dispatch("close");
  $$self.$$set = ($$props2) => {
    if ("showDiffMode" in $$props2)
      $$invalidate(2, showDiffMode = $$props2.showDiffMode);
    if ("showStyleMode" in $$props2)
      $$invalidate(3, showStyleMode = $$props2.showStyleMode);
    if ("showCloseButton" in $$props2)
      $$invalidate(4, showCloseButton = $$props2.showCloseButton);
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
    if ("withStyle" in $$props2)
      $$invalidate(1, withStyle = $$props2.withStyle);
    if ("promise" in $$props2)
      $$invalidate(5, promise = $$props2.promise);
    if ("dataType" in $$props2)
      $$invalidate(6, dataType = $$props2.dataType);
    if ("datasourceId" in $$props2)
      $$invalidate(7, datasourceId = $$props2.datasourceId);
    if ("sieve" in $$props2)
      $$invalidate(13, sieve = $$props2.sieve);
    if ("class" in $$props2)
      $$invalidate(8, classes = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      $store.data1, $store.data2, markReadUntil();
    }
  };
  return [
    inlined,
    withStyle,
    showDiffMode,
    showStyleMode,
    showCloseButton,
    promise,
    dataType,
    datasourceId,
    classes,
    $store,
    dispatch,
    showDiffInline,
    showStyled,
    sieve,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    click_handler_7,
    change_handler,
    change_handler_1,
    click_handler_8
  ];
}
class ExploreDiffHeader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4d, create_fragment$4n, safe_not_equal, {
      showDiffMode: 2,
      showStyleMode: 3,
      showCloseButton: 4,
      inlined: 0,
      withStyle: 1,
      promise: 5,
      dataType: 6,
      datasourceId: 7,
      sieve: 13,
      class: 8
    });
  }
}
function create_else_block$1l(ctx) {
  let span;
  let t0;
  let t1;
  let if_block_anchor;
  let if_block = ctx[2] && create_if_block_1$1x(ctx);
  return {
    c() {
      span = element("span");
      t0 = text(ctx[0]);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t0, ctx2[0]);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1x(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$2r(ctx) {
  let span;
  let t0_value = ctx[0].replace(/\s/g, " ").substring(0, ctx[1]) + "";
  let t0;
  let t1;
  let t2;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text("...");
      t2 = space();
      button = element("button");
      button.textContent = ">>";
      attr(button, "class", "btn btn-default btn-sm py-[2px] px-[4px] shadow-sm bg-[#eee] font-bold");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      insert(target, t2, anchor);
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 3 && t0_value !== (t0_value = ctx2[0].replace(/\s/g, " ").substring(0, ctx2[1]) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$1x(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "<<";
      attr(button, "class", "btn btn-default btn-sm py-[2px] px-[4px] shadow-sm bg-[#eee] font-bold");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4m(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2] && !ctx2[3])
      return create_if_block$2r;
    return create_else_block$1l;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$4c($$self, $$props, $$invalidate) {
  let { content } = $$props;
  let { limit = 100 } = $$props;
  let limitExceeded = false;
  let showMore = false;
  const click_handler = () => $$invalidate(3, showMore = true);
  const click_handler_1 = () => $$invalidate(3, showMore = false);
  $$self.$$set = ($$props2) => {
    if ("content" in $$props2)
      $$invalidate(0, content = $$props2.content);
    if ("limit" in $$props2)
      $$invalidate(1, limit = $$props2.limit);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      if (typeof content === "string") {
        $$invalidate(2, limitExceeded = content.length > limit);
      }
    }
  };
  return [content, limit, limitExceeded, showMore, click_handler, click_handler_1];
}
class NodeValue extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4c, create_fragment$4m, safe_not_equal, { content: 0, limit: 1 });
  }
}
function create_fragment$4l(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "#183a90");
      attr(path, "d", "M25.198,6.273c-0.014,0.23-0.045,0.389-0.087,0.467c-0.045,0.084-0.176,0.145-0.392,0.183 c-0.469,0.104-0.781-0.074-0.935-0.533C23.239,4.7,22.59,3.578,21.84,3.016c-1.041-0.773-2.862-1.161-5.469-1.161 c-1.054,0-1.633,0.115-1.734,0.343c-0.036,0.075-0.057,0.184-0.057,0.324v18.999c0,0.812,0.188,1.383,0.571,1.709 c0.382,0.32,1.069,0.731,2.201,0.999c0.483,0.103,0.97,0.2,1.034,0.239c0.46,0,0.504,1.057-0.376,1.057 c-0.025,0.016-10.375-0.008-10.375-0.008s-0.723-0.439-0.074-1.023c0.271-0.121,0.767-0.343,0.767-0.343s1.83-0.614,2.211-1.009 c0.434-0.445,0.648-1.164,0.648-2.154V2.521c0-0.369-0.229-0.585-0.687-0.647c-0.049-0.015-0.425-0.02-1.122-0.02 c-2.415,0-4.191,0.418-5.338,1.259C3.176,3.735,2.411,4.877,1.737,6.545C1.52,7.065,1.22,7.234,0.84,7.058 C0.408,6.957,0.251,6.719,0.363,6.353c0.445-1.374,0.668-3.31,0.668-5.814c0-0.292,0.387-0.586,1.163-0.533L23.56,0.064 c0.709-0.104,1.096,0.012,1.16,0.343C25.076,2.096,25.234,4.052,25.198,6.273z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "70%");
      attr(svg, "height", "90%");
      attr(svg, "viewBox", "0 0 25 25");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class StringSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4l, safe_not_equal, {});
  }
}
function create_fragment$4k(ctx) {
  let svg;
  let g1;
  let g0;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g1 = svg_element("g");
      g0 = svg_element("g");
      path = svg_element("path");
      attr(path, "fill", "#41b310");
      attr(path, "d", "M17.2881302,2.00089344 L17.3894,2.01308 C17.7964,2.09007 18.064,2.48242 17.987,2.88941 L17.987,2.88941 L17.0214,7.99404 L21.2496,7.99207 C21.6639,7.99187 21.9998,8.3275 21.9999999,8.74172 C21.9999999,9.15593 21.6646,9.49187 21.2503,9.49207 L21.2503,9.49207 L16.7376,9.49417 L15.7919,14.4939 L20.2496,14.4918 C20.6639,14.4916 20.9998,14.8273 20.9999999,15.2415 C21.0002,15.6557 20.6646,15.9916 20.2503,15.9918 L20.2503,15.9918 L15.5081,15.994 L14.4869,21.3924 C14.41,21.7994 14.0176,22.0669 13.6106,21.9899 C13.2036,21.9129 12.9361,21.5206 13.0131,21.1136 L13.0131,21.1136 L13.9814,15.9948 L8.50742,15.9973 L7.48688,21.3924 C7.4099,21.7994 7.01755,22.0669 6.61055,21.9899 C6.20356,21.9129 5.93603,21.5206 6.01302,21.1136 L6.01302,21.1136 L6.98068,15.998 L2.75035,16 C2.33614,16.0002 1.99999992,15.6646 1.99999992,15.2503 C1.99999992,14.8361 2.33544,14.5002 2.74965,14.5 L2.74965,14.5 L7.26445,14.4979 L8.2102,9.49816 L3.75035,9.50024 C3.33614,9.50044 3.00019,9.16481 2.99999992,8.75059 C2.99981,8.33638 3.33544,8.00044 3.74965,8.00024 L3.74965,8.00024 L8.49396,7.99803 L9.51305,2.61062 C9.59003,2.20362 9.98238,1.9361 10.3894,2.01308 C10.7964,2.09007 11.0639,2.48242 10.9869,2.88941 L10.9869,2.88941 L10.0207,7.99731 L15.4946,7.99476 L16.5131,2.61062 C16.5901,2.20362 16.9824,1.9361 17.3894,2.01308 Z M15.2109,9.49489 L9.73693,9.49745 L8.79118,14.4972 L14.2651,14.4946 L15.2109,9.49489 Z");
      attr(g0, "id", "ic_fluent_number_symbol_24_regular");
      attr(g0, "fill", "#212121");
      attr(g0, "fill-rule", "nonzero");
      attr(g1, "stroke", "none");
      attr(g1, "stroke-width", "1");
      attr(g1, "fill", "none");
      attr(g1, "fill-rule", "evenodd");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g1);
      append(g1, g0);
      append(g0, path);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class NumberSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4k, safe_not_equal, {});
  }
}
function create_fragment$4j(ctx) {
  let svg;
  let g;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "fill", "#0cc8d2");
      attr(path1, "d", "M9 3v2H6v14h3v2H4V3h5zm6 0h5v18h-5v-2h3V5h-3V3z");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, path0);
      append(g, path1);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class ArraySVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4j, safe_not_equal, {});
  }
}
function create_fragment$4i(ctx) {
  let svg;
  let g;
  let t;
  let path0;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      t = text("null\n    ");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "fill", "none");
      attr(path0, "d", "M0 0h24v24H0z");
      attr(path1, "fill", "#bf3126");
      attr(path1, "d", "M4 18v-3.7a1.5 1.5 0 0 0-1.5-1.5H2v-1.6h.5A1.5 1.5 0 0 0 4 9.7V6a3 3 0 0 1 3-3h1v2H7a1 1 0 0 0-1 1v4.1A2 2 0 0 1 4.626 12 2 2 0 0 1 6 13.9V18a1 1 0 0 0 1 1h1v2H7a3 3 0 0 1-3-3zm16-3.7V18a3 3 0 0 1-3 3h-1v-2h1a1 1 0 0 0 1-1v-4.1a2 2 0 0 1 1.374-1.9A2 2 0 0 1 18 10.1V6a1 1 0 0 0-1-1h-1V3h1a3 3 0 0 1 3 3v3.7a1.5 1.5 0 0 0 1.5 1.5h.5v1.6h-.5a1.5 1.5 0 0 0-1.5 1.5z");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, t);
      append(g, path0);
      append(g, path1);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class ObjectSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4i, safe_not_equal, {});
  }
}
function create_fragment$4h(ctx) {
  let svg;
  let defs2;
  let style;
  let t;
  let path;
  let circle;
  let rect;
  return {
    c() {
      svg = svg_element("svg");
      defs2 = svg_element("defs");
      style = svg_element("style");
      t = text(".cls-1{fill:none}");
      path = svg_element("path");
      circle = svg_element("circle");
      rect = svg_element("rect");
      attr(path, "fill", "#ec8f0c");
      attr(path, "d", "M23,23a7,7,0,1,1,7-7A7.0078,7.0078,0,0,1,23,23Zm0-12a5,5,0,1,0,5,5A5.0055,5.0055,0,0,0,23,11Z");
      attr(circle, "fill", "#ec8f0c");
      attr(circle, "cx", "9");
      attr(circle, "cy", "16");
      attr(circle, "r", "7");
      attr(rect, "id", "_Transparent_Rectangle_");
      attr(rect, "data-name", "<Transparent Rectangle>");
      attr(rect, "class", "cls-1");
      attr(rect, "width", "32");
      attr(rect, "height", "32");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "120%");
      attr(svg, "height", "120%");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, defs2);
      append(defs2, style);
      append(style, t);
      append(svg, path);
      append(svg, circle);
      append(svg, rect);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class BooleanSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4h, safe_not_equal, {});
  }
}
function create_else_block$1k(ctx) {
  let objectsvg;
  let current;
  objectsvg = new ObjectSVG({});
  return {
    c() {
      create_component(objectsvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(objectsvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(objectsvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(objectsvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(objectsvg, detaching);
    }
  };
}
function create_if_block_3$L(ctx) {
  let arraytypesvg;
  let current;
  arraytypesvg = new ArraySVG({});
  return {
    c() {
      create_component(arraytypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(arraytypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(arraytypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arraytypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(arraytypesvg, detaching);
    }
  };
}
function create_if_block_2$Y(ctx) {
  let booleantypesvg;
  let current;
  booleantypesvg = new BooleanSVG({});
  return {
    c() {
      create_component(booleantypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(booleantypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(booleantypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(booleantypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(booleantypesvg, detaching);
    }
  };
}
function create_if_block_1$1w(ctx) {
  let numbertypesvg;
  let current;
  numbertypesvg = new NumberSVG({});
  return {
    c() {
      create_component(numbertypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numbertypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(numbertypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numbertypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numbertypesvg, detaching);
    }
  };
}
function create_if_block$2q(ctx) {
  let stringtypesvg;
  let current;
  stringtypesvg = new StringSVG({});
  return {
    c() {
      create_component(stringtypesvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(stringtypesvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(stringtypesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(stringtypesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(stringtypesvg, detaching);
    }
  };
}
function create_fragment$4g(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block$2q,
    create_if_block_1$1w,
    create_if_block_2$Y,
    create_if_block_3$L,
    create_else_block$1k
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === types$1.STRING)
      return 0;
    if (ctx2[0] === types$1.NUMBER)
      return 1;
    if (ctx2[0] === types$1.BOOLEAN)
      return 2;
    if (ctx2[0] === types$1.ARRAY || ctx2[0] === types$1.ARRAY_OF_OBJECTS)
      return 3;
    return 4;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$4b($$self, $$props, $$invalidate) {
  let { type } = $$props;
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
  };
  return [type];
}
class TypeSVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4b, create_fragment$4g, safe_not_equal, { type: 0 });
  }
}
function create_fragment$4f(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      attr(rect, "fill", "white");
      attr(rect, "fill-opacity", "0.01");
      attr(path, "d", "M24 33C28.9706 33 33 28.9706 33 24C33 19.0294 28.9706 15 24 15C19.0294 15 15 19.0294 15 24C15 28.9706 19.0294 33 24 33Z");
      attr(path, "fill", "blue");
      attr(path, "stroke", "blue");
      attr(path, "stroke-width", "4");
      attr(svg, "viewBox", "0 0 64 64");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, rect);
      append(svg, path);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class DirtySVG extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$4f, safe_not_equal, {});
  }
}
var diff$1 = "";
const diffObj = {};
const DIFF_TYPE = {
  TEXT: "text",
  HTML: "html",
  JSON: "json",
  FEED: "feed"
};
async function diffAndRender(data1, data2, opts = {}) {
  const { type = DIFF_TYPE.TEXT, ...otherOpts } = opts;
  const diffObj2 = await getDiffObj(type);
  return await diffObj2.diffAndRender(data1, data2, otherOpts);
}
async function getDiffObj(type) {
  let obj = diffObj[type];
  if (!obj) {
    const DiffCls = await getClass(type);
    obj = new DiffCls();
    diffObj[type] = obj;
  }
  return obj;
}
async function getClass(type) {
  switch (type) {
    case DIFF_TYPE.HTML:
      return (await __vitePreload(() => import("./html-diff.f4fc7816.js"), true ? ["assets/html-diff.f4fc7816.js","assets/json-parser.7cb2f04e.js","assets/json-parser.f1628d7e.css","assets/service.04a32097.js","assets/index.21aef151.js","assets/index.821ff0ec.js","assets/index-default.0d44a930.js","assets/text-diff.a599c955.js","assets/utils.fb792079.js"] : void 0)).default;
    case DIFF_TYPE.FEED:
      return (await __vitePreload(() => import("./feed-diff.9e10c6e3.js"), true ? ["assets/feed-diff.9e10c6e3.js","assets/service.04a32097.js","assets/index-default.0d44a930.js","assets/utils.fb792079.js","assets/index.21aef151.js","assets/json-parser.7cb2f04e.js","assets/json-parser.f1628d7e.css","assets/Message.fcbba7db.js","assets/SchemaKeyTree.96209fd8.js","assets/SchemaKeyTree.9a96e0c5.css","assets/Card.0607fce4.js"] : void 0)).default;
    case DIFF_TYPE.JSON:
      return (await __vitePreload(() => import("./json-diff.3f621404.js"), true ? ["assets/json-diff.3f621404.js","assets/service.04a32097.js","assets/index.21aef151.js","assets/json-parser.7cb2f04e.js","assets/json-parser.f1628d7e.css","assets/Message.fcbba7db.js","assets/SchemaKeyTree.96209fd8.js","assets/SchemaKeyTree.9a96e0c5.css","assets/Card.0607fce4.js"] : void 0)).default;
    case "summary":
      return (await __vitePreload(() => import("./text-diff-for-summary.5f4714ff.js"), true ? ["assets/text-diff-for-summary.5f4714ff.js","assets/html-diff.f4fc7816.js","assets/json-parser.7cb2f04e.js","assets/json-parser.f1628d7e.css","assets/service.04a32097.js","assets/index.21aef151.js","assets/index.821ff0ec.js","assets/index-default.0d44a930.js","assets/text-diff.a599c955.js","assets/utils.fb792079.js","assets/load-parse.47abd3e8.js"] : void 0)).default;
    case DIFF_TYPE.TEXT:
    default:
      return (await __vitePreload(() => import("./text-diff.a599c955.js").then(function(n) {
        return n.t;
      }), true ? ["assets/text-diff.a599c955.js","assets/service.04a32097.js","assets/utils.fb792079.js"] : void 0)).default;
  }
}
function create_fragment$4e(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      set_style(div, "overflow-wrap", "anywhere");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = ctx[0];
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        div.innerHTML = ctx2[0];
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$4a($$self, $$props, $$invalidate) {
  let { content1 } = $$props;
  let { content2 } = $$props;
  let { snipped } = $$props;
  let { view1TreeMode } = $$props;
  let textDiff;
  async function getTextDiff(content12, content22) {
    if (!content12 && content22) {
      if (content12 === "") {
        $$invalidate(0, textDiff = view1TreeMode ? "" : `<span style="background:#bbffbb">${content22}</span>`);
      } else {
        $$invalidate(0, textDiff = content22);
      }
      return;
    }
    try {
      $$invalidate(0, textDiff = await diffAndRender(content12, content22));
      setDiffStyles();
    } catch (e) {
      console.error("error while computing text diff", e);
      $$invalidate(0, textDiff = content22);
    }
  }
  function setDiffStyles() {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = textDiff;
    const snipElements = tempDiv.querySelectorAll(".snip");
    snipElements.forEach((s) => {
      let nonDiffHideElement = s.previousElementSibling;
      let nonDiffHideElementExists = nonDiffHideElement && nonDiffHideElement.classList.contains("nonDiffHide");
      if (nonDiffHideElementExists) {
        if (snipped) {
          document.addEventListener("click", function(event) {
            if (event.target.classList.contains("snip")) {
              event.preventDefault();
              const nonDiffHideElement2 = event.target.previousElementSibling;
              nonDiffHideElement2.style.display = "inline";
              event.target.style.display = "none";
            }
          });
        }
      }
    });
    $$invalidate(0, textDiff = tempDiv.innerHTML);
  }
  $$self.$$set = ($$props2) => {
    if ("content1" in $$props2)
      $$invalidate(1, content1 = $$props2.content1);
    if ("content2" in $$props2)
      $$invalidate(2, content2 = $$props2.content2);
    if ("snipped" in $$props2)
      $$invalidate(3, snipped = $$props2.snipped);
    if ("view1TreeMode" in $$props2)
      $$invalidate(4, view1TreeMode = $$props2.view1TreeMode);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      getTextDiff(content1, content2);
    }
    if ($$self.$$.dirty & 8) {
      setDiffStyles();
    }
  };
  return [textDiff, content1, content2, snipped, view1TreeMode];
}
class TextView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4a, create_fragment$4e, safe_not_equal, {
      content1: 1,
      content2: 2,
      snipped: 3,
      view1TreeMode: 4
    });
  }
}
function create_if_block$2p(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "copy";
      set_style(span, "margin-left", "3px");
      set_style(span, "font-family", "var(--bs-body-font-family)");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot$1g(ctx) {
  let div;
  let button;
  let t0;
  let pre;
  let t1;
  let mounted;
  let dispose;
  let if_block = !ctx[1] && create_if_block$2p();
  return {
    c() {
      div = element("div");
      button = element("button");
      if (if_block)
        if_block.c();
      t0 = space();
      pre = element("pre");
      t1 = text(ctx[0]);
      attr(button, "title", "Copy to clipboard");
      set_style(button, "top", "0px");
      set_style(button, "right", "5px");
      set_style(button, "float", "right");
      set_style(button, "min-width", "30px");
      set_style(button, "margin-top", "-50px");
      attr(button, "class", "fa position-sticky float-end text-secondary btn btn-default btn-sm");
      toggle_class(button, "fa-check", ctx[1]);
      toggle_class(button, "fa-clipboard", !ctx[1]);
      attr(pre, "class", "whitespace-pre-wrap bg-white mb-0");
      set_style(pre, "clear", "both");
      attr(div, "class", "py-2 ps-3 overflow-auto position-relative");
      set_style(div, "max-height", "500px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (if_block)
        if_block.m(button, null);
      append(div, t0);
      append(div, pre);
      append(pre, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!ctx2[1]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$2p();
          if_block.c();
          if_block.m(button, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 2) {
        toggle_class(button, "fa-check", ctx2[1]);
      }
      if (dirty & 2) {
        toggle_class(button, "fa-clipboard", !ctx2[1]);
      }
      if (dirty & 1)
        set_data(t1, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4d(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      title: "View JSON",
      bodyStyle: "padding: 0;",
      $$slots: { default: [create_default_slot$1g] },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[3]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 19) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$49($$self, $$props, $$invalidate) {
  let { json } = $$props;
  let copied = false;
  if (typeof json === "string") {
    json = JSON.parse(json);
  }
  json = JSON.stringify(json, null, 2);
  async function copyToClipboard() {
    try {
      await navigator.clipboard.writeText(json);
      $$invalidate(1, copied = true);
      setTimeout(() => $$invalidate(1, copied = false), 2e3);
    } catch (err) {
      console.error("Error copying text: ", err);
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("json" in $$props2)
      $$invalidate(0, json = $$props2.json);
  };
  return [json, copied, copyToClipboard, close_handler];
}
class ViewJSONModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$49, create_fragment$4d, safe_not_equal, { json: 0 });
  }
}
var DiffJsonView_svelte_svelte_type_style_lang = "";
function create_catch_block$A(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$A(ctx) {
  let div1;
  let div0;
  let t;
  let treeview;
  let div1_class_value;
  let current;
  let if_block = ctx[12] && create_if_block_6$h(ctx);
  treeview = new TreeView$1({
    props: {
      showRoot: false,
      root: ctx[0],
      size: "medium",
      class: " bg-white bb bl br bt border-bootstrap-border " + ctx[10],
      nodeAction: ctx[16],
      $$slots: {
        meta: [
          create_meta_slot$1,
          ({ node }) => ({ 40: node }),
          ({ node }) => [0, node ? 512 : 0]
        ],
        icon: [
          create_icon_slot$1,
          ({ node }) => ({ 40: node }),
          ({ node }) => [0, node ? 512 : 0]
        ],
        label: [
          create_label_slot$3,
          ({ node }) => ({ 40: node }),
          ({ node }) => [0, node ? 512 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      create_component(treeview.$$.fragment);
      attr(div0, "class", "w-full h-full json-diff-tree-view-item svelte-1gpndc3");
      set_style(div0, "--removed", ctx[5] ? "none" : "inline");
      set_style(div0, "--inserted", ctx[6] ? "none" : "inline");
      set_style(div0, "--removeRow", ctx[5] ? "none" : "flex");
      set_style(div0, "--insertRow", ctx[6] ? "none" : "flex");
      set_style(div0, "--nonDiffHide", ctx[4] ? "inline" : "none");
      set_style(div0, "--snip", ctx[4] ? "none" : "inline");
      attr(div1, "class", div1_class_value = null_to_empty(ctx[13]) + " svelte-1gpndc3");
      set_style(div1, "--tv-key-width", ctx[15]());
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div0, t);
      mount_component(treeview, div0, null);
      ctx[26](div1);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[12]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_6$h(ctx2);
          if_block.c();
          if_block.m(div0, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const treeview_changes = {};
      if (dirty[0] & 1)
        treeview_changes.root = ctx2[0];
      if (dirty[0] & 1024)
        treeview_changes.class = " bg-white bb bl br bt border-bootstrap-border " + ctx2[10];
      if (dirty[0] & 2960 | dirty[1] & 1536) {
        treeview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeview.$set(treeview_changes);
      if (!current || dirty[0] & 32) {
        set_style(div0, "--removed", ctx2[5] ? "none" : "inline");
      }
      if (!current || dirty[0] & 64) {
        set_style(div0, "--inserted", ctx2[6] ? "none" : "inline");
      }
      if (!current || dirty[0] & 32) {
        set_style(div0, "--removeRow", ctx2[5] ? "none" : "flex");
      }
      if (!current || dirty[0] & 64) {
        set_style(div0, "--insertRow", ctx2[6] ? "none" : "flex");
      }
      if (!current || dirty[0] & 16) {
        set_style(div0, "--nonDiffHide", ctx2[4] ? "inline" : "none");
      }
      if (!current || dirty[0] & 16) {
        set_style(div0, "--snip", ctx2[4] ? "none" : "inline");
      }
      if (!current || dirty[0] & 8192 && div1_class_value !== (div1_class_value = null_to_empty(ctx2[13]) + " svelte-1gpndc3")) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(treeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      destroy_component(treeview);
      ctx[26](null);
    }
  };
}
function create_if_block_6$h(ctx) {
  let div;
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      a = element("a");
      a.textContent = "View JSON";
      attr(a, "href", "#");
      set_style(a, "font-size", "0.8rem");
      attr(div, "class", "d-flex justify-content-end");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      if (!mounted) {
        dispose = listen(a, "click", ctx[25]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_label_slot$3(ctx) {
  let div;
  let t_value = (ctx[40].label !== void 0 ? ctx[40].label : "") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "slot", "label");
      attr(div, "class", "xbreak-long-words xpadding svelte-1gpndc3");
      toggle_class(div, "inserted", ctx[40].changeType === ChangeType.ADDED && ctx[40].label !== void 0);
      toggle_class(div, "removed", ctx[40].changeType === ChangeType.DELETED && ctx[40].label !== void 0);
      toggle_class(div, "xdiff", ctx[40].changeType);
      toggle_class(div, "opacity-0", ctx[40].changeType === ChangeType.ADDED && ctx[8] || ctx[40].changeType === ChangeType.DELETED && ctx[7]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[1] & 512 && t_value !== (t_value = (ctx2[40].label !== void 0 ? ctx2[40].label : "") + ""))
        set_data(t, t_value);
      if (dirty[1] & 512) {
        toggle_class(div, "inserted", ctx2[40].changeType === ChangeType.ADDED && ctx2[40].label !== void 0);
      }
      if (dirty[1] & 512) {
        toggle_class(div, "removed", ctx2[40].changeType === ChangeType.DELETED && ctx2[40].label !== void 0);
      }
      if (dirty[1] & 512) {
        toggle_class(div, "xdiff", ctx2[40].changeType);
      }
      if (dirty[0] & 384 | dirty[1] & 512) {
        toggle_class(div, "opacity-0", ctx2[40].changeType === ChangeType.ADDED && ctx2[8] || ctx2[40].changeType === ChangeType.DELETED && ctx2[7]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4$u(ctx) {
  let div;
  let current;
  let if_block = ctx[40].dirty && create_if_block_5$n();
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "xdirty svelte-1gpndc3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[40].dirty) {
        if (if_block) {
          if (dirty[1] & 512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$n();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_5$n(ctx) {
  let dirtysvg;
  let current;
  dirtysvg = new DirtySVG({});
  return {
    c() {
      create_component(dirtysvg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dirtysvg, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(dirtysvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dirtysvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dirtysvg, detaching);
    }
  };
}
function create_icon_slot$1(ctx) {
  let div1;
  let t;
  let div0;
  let typesvg;
  let div0_title_value;
  let current;
  let if_block = ctx[9] && ctx[4] && create_if_block_4$u(ctx);
  typesvg = new TypeSVG({ props: { type: ctx[40].type } });
  return {
    c() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      create_component(typesvg.$$.fragment);
      attr(div0, "class", "tv-svg");
      attr(div0, "title", div0_title_value = ctx[40].type);
      attr(div1, "slot", "icon");
      attr(div1, "class", "tv-flex tv-svg-parent");
      toggle_class(div1, "opacity-0", ctx[40].changeType === ChangeType.ADDED && ctx[8] || ctx[40].changeType === ChangeType.DELETED && ctx[7]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t);
      append(div1, div0);
      mount_component(typesvg, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[9] && ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 528) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_4$u(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const typesvg_changes = {};
      if (dirty[1] & 512)
        typesvg_changes.type = ctx2[40].type;
      typesvg.$set(typesvg_changes);
      if (!current || dirty[1] & 512 && div0_title_value !== (div0_title_value = ctx2[40].type)) {
        attr(div0, "title", div0_title_value);
      }
      if (!current || dirty[0] & 384 | dirty[1] & 512) {
        toggle_class(div1, "opacity-0", ctx2[40].changeType === ChangeType.ADDED && ctx2[8] || ctx2[40].changeType === ChangeType.DELETED && ctx2[7]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(typesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(typesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      destroy_component(typesvg);
    }
  };
}
function create_else_block$1j(ctx) {
  let show_if = ctx[40].changeType === ChangeType.VALUE_CHANGED && ctx[40].isLeaf() && ctx[40].oldValue !== void 0 && !ctx[7];
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = show_if && create_if_block_3$K(ctx);
  let if_block1 = !(ctx[40].changeType === ChangeType.VALUE_CHANGED && ctx[8]) && create_if_block_2$X(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128 | dirty[1] & 512)
        show_if = ctx2[40].changeType === ChangeType.VALUE_CHANGED && ctx2[40].isLeaf() && ctx2[40].oldValue !== void 0 && !ctx2[7];
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 128 | dirty[1] & 512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$K(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!(ctx2[40].changeType === ChangeType.VALUE_CHANGED && ctx2[8])) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 256 | dirty[1] & 512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$X(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_if_block_1$1v(ctx) {
  let textview;
  let current;
  textview = new TextView({
    props: {
      content1: ctx[40].getPrettyOldValue(),
      content2: ctx[40].getPrettyValue(),
      snipped: !ctx[4],
      view1TreeMode: ctx[11]
    }
  });
  return {
    c() {
      create_component(textview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(textview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const textview_changes = {};
      if (dirty[1] & 512)
        textview_changes.content1 = ctx2[40].getPrettyOldValue();
      if (dirty[1] & 512)
        textview_changes.content2 = ctx2[40].getPrettyValue();
      if (dirty[0] & 16)
        textview_changes.snipped = !ctx2[4];
      if (dirty[0] & 2048)
        textview_changes.view1TreeMode = ctx2[11];
      textview.$set(textview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(textview, detaching);
    }
  };
}
function create_if_block_3$K(ctx) {
  let div;
  let nodevalue;
  let current;
  nodevalue = new NodeValue({
    props: {
      content: ctx[40].getPrettyOldValue()
    }
  });
  return {
    c() {
      div = element("div");
      create_component(nodevalue.$$.fragment);
      attr(div, "class", "xbreak-long-words removed flex-grow xpadding svelte-1gpndc3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(nodevalue, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const nodevalue_changes = {};
      if (dirty[1] & 512)
        nodevalue_changes.content = ctx2[40].getPrettyOldValue();
      nodevalue.$set(nodevalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nodevalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodevalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(nodevalue);
    }
  };
}
function create_if_block_2$X(ctx) {
  let div;
  let nodevalue;
  let current;
  nodevalue = new NodeValue({
    props: {
      content: ctx[40].getPrettyValue()
    }
  });
  return {
    c() {
      div = element("div");
      create_component(nodevalue.$$.fragment);
      attr(div, "class", "xbreak-long-words flex-grow xpadding svelte-1gpndc3");
      toggle_class(div, "inserted", (ctx[40].changeType === ChangeType.ADDED || ctx[40].changeType === ChangeType.VALUE_CHANGED) && ctx[40].isLeaf() && ctx[40].value !== void 0);
      toggle_class(div, "removed", ctx[40].changeType === ChangeType.DELETED && ctx[40].isLeaf());
      toggle_class(div, "opacity-0", ctx[40].changeType && ctx[40].changeType === ChangeType.ADDED && ctx[8] || ctx[40].changeType === ChangeType.DELETED && ctx[7]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(nodevalue, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const nodevalue_changes = {};
      if (dirty[1] & 512)
        nodevalue_changes.content = ctx2[40].getPrettyValue();
      nodevalue.$set(nodevalue_changes);
      if (!current || dirty[1] & 512) {
        toggle_class(div, "inserted", (ctx2[40].changeType === ChangeType.ADDED || ctx2[40].changeType === ChangeType.VALUE_CHANGED) && ctx2[40].isLeaf() && ctx2[40].value !== void 0);
      }
      if (!current || dirty[1] & 512) {
        toggle_class(div, "removed", ctx2[40].changeType === ChangeType.DELETED && ctx2[40].isLeaf());
      }
      if (!current || dirty[0] & 384 | dirty[1] & 512) {
        toggle_class(div, "opacity-0", ctx2[40].changeType && ctx2[40].changeType === ChangeType.ADDED && ctx2[8] || ctx2[40].changeType === ChangeType.DELETED && ctx2[7]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(nodevalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodevalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(nodevalue);
    }
  };
}
function create_meta_slot$1(ctx) {
  let div;
  let show_if;
  let current_block_type_index;
  let if_block;
  let div_title_value;
  let current;
  const if_block_creators = [create_if_block_1$1v, create_else_block$1j];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a, _b;
    if (dirty[1] & 512)
      show_if = null;
    if (show_if == null)
      show_if = !!(ctx2[40].type === "String" && (((_a = ctx2[40].getPrettyValue()) == null ? void 0 : _a.length) > 50 || ((_b = ctx2[40].getPrettyOldValue()) == null ? void 0 : _b.length) > 50));
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "slot", "meta");
      attr(div, "title", div_title_value = ctx[40].getValue());
      attr(div, "class", "flex gap-2 xl:flex-1");
      toggle_class(div, "xdiffMeta", ctx[40].changeType === ChangeType.VALUE_CHANGED && ctx[40].oldValue !== void 0 && ctx[40].value !== void 0);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty[1] & 512 && div_title_value !== (div_title_value = ctx2[40].getValue())) {
        attr(div, "title", div_title_value);
      }
      if (!current || dirty[1] & 512) {
        toggle_class(div, "xdiffMeta", ctx2[40].changeType === ChangeType.VALUE_CHANGED && ctx2[40].oldValue !== void 0 && ctx2[40].value !== void 0);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_pending_block$A(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_if_block$2o(ctx) {
  let viewjsonmodal;
  let current;
  viewjsonmodal = new ViewJSONModal({ props: { json: ctx[3] } });
  viewjsonmodal.$on("close", ctx[27]);
  return {
    c() {
      create_component(viewjsonmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(viewjsonmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const viewjsonmodal_changes = {};
      if (dirty[0] & 8)
        viewjsonmodal_changes.json = ctx2[3];
      viewjsonmodal.$set(viewjsonmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(viewjsonmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewjsonmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(viewjsonmodal, detaching);
    }
  };
}
function create_fragment$4c(ctx) {
  let promise;
  let t;
  let if_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$A,
    then: create_then_block$A,
    catch: create_catch_block$A,
    value: 39,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[1], info);
  let if_block = ctx[14] && create_if_block$2o(ctx);
  return {
    c() {
      info.block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      info.block.m(target, info.anchor = anchor);
      info.mount = () => t.parentNode;
      info.anchor = t;
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty[0] & 2 && promise !== (promise = ctx[1]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
      if (ctx[14]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 16384) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2o(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      info.block.d(detaching);
      info.token = null;
      info = null;
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$48($$self, $$props, $$invalidate) {
  let { oldData } = $$props;
  let { newData } = $$props;
  let { diff: diff2 } = $$props;
  let { jsonDiffPromise } = $$props;
  let { full = true } = $$props;
  let { pruneDeletions = false } = $$props;
  let { pruneAdditions = false } = $$props;
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { hideDeletions = false } = $$props;
  let { hideAdditions = false } = $$props;
  let { showDirty = false } = $$props;
  let { treeViewClass = "" } = $$props;
  let { scrollToFirstDiff = false } = $$props;
  let { diffNavigation = false } = $$props;
  let { diffView } = $$props;
  const goToNextDiff = () => goToDiff(STEP.NEXT);
  const goToPrevDiff = () => goToDiff(STEP.PREV);
  let { view1TreeMode = false } = $$props;
  let { showViewJSONButton = false } = $$props;
  const dispatch = createEventDispatcher();
  let { class: classes = "" } = $$props;
  let maxDepth;
  let diffs = { nodes: [], curr: null };
  let currDiff;
  let computeDiff = oldData && newData;
  let showJSONModal = false;
  const STEP = { NEXT: 1, PREV: -1 };
  async function getDiff2(oldData2, newData2, full2) {
    $$invalidate(0, { diff: diff2 } = await diffJson(oldData2, newData2, full2), diff2);
    $$invalidate(17, { maxDepth, additions, deletions } = diff2, additions, $$invalidate(18, deletions));
  }
  function getDiffNodes2() {
    let nodes = [];
    (function getNodes(node) {
      if (node.changeType) {
        nodes.push(node);
      }
      node.getChildren().forEach((child) => getNodes(child));
    })(diff2);
    diffs.nodes = nodes;
    diffs.curr = null;
  }
  function goToDiff(step) {
    var _a;
    let { nodes, curr } = diffs;
    const length = nodes.length;
    if (length === 0 || length === 1 && nodes[0].getSelected()) {
      return;
    }
    if (curr === null) {
      if (step === STEP.NEXT) {
        curr = -1;
      } else {
        curr = length;
      }
    }
    let next2 = curr + step;
    if (next2 < 0) {
      next2 = length - 1;
    } else if (next2 >= length) {
      next2 = 0;
    }
    (_a = nodes[curr]) == null ? void 0 : _a.setSelected(false);
    nodes[next2].setSelected(true);
    diffs.curr = next2;
  }
  function goToFirstDiff() {
    const firstDiffNode = diffs.nodes[0];
    if (firstDiffNode) {
      diffs.curr = 0;
      firstDiffNode.setSelected(true);
    }
  }
  async function processDiff() {
    $$invalidate(24, currDiff = diff2);
    if (!computeDiff) {
      let diffClone = cloneJsonDiff(diff2);
      $$invalidate(17, { maxDepth, additions, deletions } = diffClone, additions, $$invalidate(18, deletions));
      $$invalidate(0, diff2 = diffClone);
      $$invalidate(24, currDiff = diff2);
    }
    if (diffNavigation) {
      getDiffNodes2();
      if (scrollToFirstDiff) {
        await tick();
        goToFirstDiff();
      }
    }
  }
  function getDepth() {
    let minWidth = 30, upper_bound = 40;
    let depth = minWidth + 2 * maxDepth;
    return `${depth > upper_bound ? upper_bound : depth}%`;
  }
  const actionFn = (elRef, node) => {
    dispatch("load");
    return {
      update: (node2) => {
        if (node2.getSelected()) {
          elRef.scrollIntoView({ behaviour: "smooth", block: "center" });
        }
      }
    };
  };
  const click_handler = () => $$invalidate(14, showJSONModal = true);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      diffView = $$value;
      $$invalidate(2, diffView);
    });
  }
  const close_handler = () => $$invalidate(14, showJSONModal = false);
  $$self.$$set = ($$props2) => {
    if ("oldData" in $$props2)
      $$invalidate(19, oldData = $$props2.oldData);
    if ("newData" in $$props2)
      $$invalidate(3, newData = $$props2.newData);
    if ("diff" in $$props2)
      $$invalidate(0, diff2 = $$props2.diff);
    if ("jsonDiffPromise" in $$props2)
      $$invalidate(1, jsonDiffPromise = $$props2.jsonDiffPromise);
    if ("full" in $$props2)
      $$invalidate(4, full = $$props2.full);
    if ("pruneDeletions" in $$props2)
      $$invalidate(5, pruneDeletions = $$props2.pruneDeletions);
    if ("pruneAdditions" in $$props2)
      $$invalidate(6, pruneAdditions = $$props2.pruneAdditions);
    if ("additions" in $$props2)
      $$invalidate(17, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(18, deletions = $$props2.deletions);
    if ("hideDeletions" in $$props2)
      $$invalidate(7, hideDeletions = $$props2.hideDeletions);
    if ("hideAdditions" in $$props2)
      $$invalidate(8, hideAdditions = $$props2.hideAdditions);
    if ("showDirty" in $$props2)
      $$invalidate(9, showDirty = $$props2.showDirty);
    if ("treeViewClass" in $$props2)
      $$invalidate(10, treeViewClass = $$props2.treeViewClass);
    if ("scrollToFirstDiff" in $$props2)
      $$invalidate(20, scrollToFirstDiff = $$props2.scrollToFirstDiff);
    if ("diffNavigation" in $$props2)
      $$invalidate(21, diffNavigation = $$props2.diffNavigation);
    if ("diffView" in $$props2)
      $$invalidate(2, diffView = $$props2.diffView);
    if ("view1TreeMode" in $$props2)
      $$invalidate(11, view1TreeMode = $$props2.view1TreeMode);
    if ("showViewJSONButton" in $$props2)
      $$invalidate(12, showViewJSONButton = $$props2.showViewJSONButton);
    if ("class" in $$props2)
      $$invalidate(13, classes = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 524312) {
      computeDiff && $$invalidate(1, jsonDiffPromise = getDiff2(oldData, newData, full));
    }
    if ($$self.$$.dirty[0] & 16777217) {
      if (diff2 !== currDiff) {
        processDiff();
      }
    }
  };
  return [
    diff2,
    jsonDiffPromise,
    diffView,
    newData,
    full,
    pruneDeletions,
    pruneAdditions,
    hideDeletions,
    hideAdditions,
    showDirty,
    treeViewClass,
    view1TreeMode,
    showViewJSONButton,
    classes,
    showJSONModal,
    getDepth,
    actionFn,
    additions,
    deletions,
    oldData,
    scrollToFirstDiff,
    diffNavigation,
    goToNextDiff,
    goToPrevDiff,
    currDiff,
    click_handler,
    div1_binding,
    close_handler
  ];
}
class DiffJsonView extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$48,
      create_fragment$4c,
      safe_not_equal,
      {
        oldData: 19,
        newData: 3,
        diff: 0,
        jsonDiffPromise: 1,
        full: 4,
        pruneDeletions: 5,
        pruneAdditions: 6,
        additions: 17,
        deletions: 18,
        hideDeletions: 7,
        hideAdditions: 8,
        showDirty: 9,
        treeViewClass: 10,
        scrollToFirstDiff: 20,
        diffNavigation: 21,
        diffView: 2,
        goToNextDiff: 22,
        goToPrevDiff: 23,
        view1TreeMode: 11,
        showViewJSONButton: 12,
        class: 13
      },
      null,
      [-1, -1]
    );
  }
  get oldData() {
    return this.$$.ctx[19];
  }
  set oldData(oldData) {
    this.$$set({ oldData });
    flush();
  }
  get newData() {
    return this.$$.ctx[3];
  }
  set newData(newData) {
    this.$$set({ newData });
    flush();
  }
  get diff() {
    return this.$$.ctx[0];
  }
  set diff(diff2) {
    this.$$set({ diff: diff2 });
    flush();
  }
  get jsonDiffPromise() {
    return this.$$.ctx[1];
  }
  set jsonDiffPromise(jsonDiffPromise) {
    this.$$set({ jsonDiffPromise });
    flush();
  }
  get full() {
    return this.$$.ctx[4];
  }
  set full(full) {
    this.$$set({ full });
    flush();
  }
  get pruneDeletions() {
    return this.$$.ctx[5];
  }
  set pruneDeletions(pruneDeletions) {
    this.$$set({ pruneDeletions });
    flush();
  }
  get pruneAdditions() {
    return this.$$.ctx[6];
  }
  set pruneAdditions(pruneAdditions) {
    this.$$set({ pruneAdditions });
    flush();
  }
  get additions() {
    return this.$$.ctx[17];
  }
  set additions(additions) {
    this.$$set({ additions });
    flush();
  }
  get deletions() {
    return this.$$.ctx[18];
  }
  set deletions(deletions) {
    this.$$set({ deletions });
    flush();
  }
  get hideDeletions() {
    return this.$$.ctx[7];
  }
  set hideDeletions(hideDeletions) {
    this.$$set({ hideDeletions });
    flush();
  }
  get hideAdditions() {
    return this.$$.ctx[8];
  }
  set hideAdditions(hideAdditions) {
    this.$$set({ hideAdditions });
    flush();
  }
  get showDirty() {
    return this.$$.ctx[9];
  }
  set showDirty(showDirty) {
    this.$$set({ showDirty });
    flush();
  }
  get treeViewClass() {
    return this.$$.ctx[10];
  }
  set treeViewClass(treeViewClass) {
    this.$$set({ treeViewClass });
    flush();
  }
  get scrollToFirstDiff() {
    return this.$$.ctx[20];
  }
  set scrollToFirstDiff(scrollToFirstDiff) {
    this.$$set({ scrollToFirstDiff });
    flush();
  }
  get diffNavigation() {
    return this.$$.ctx[21];
  }
  set diffNavigation(diffNavigation) {
    this.$$set({ diffNavigation });
    flush();
  }
  get diffView() {
    return this.$$.ctx[2];
  }
  set diffView(diffView) {
    this.$$set({ diffView });
    flush();
  }
  get goToNextDiff() {
    return this.$$.ctx[22];
  }
  get goToPrevDiff() {
    return this.$$.ctx[23];
  }
  get view1TreeMode() {
    return this.$$.ctx[11];
  }
  set view1TreeMode(view1TreeMode) {
    this.$$set({ view1TreeMode });
    flush();
  }
  get showViewJSONButton() {
    return this.$$.ctx[12];
  }
  set showViewJSONButton(showViewJSONButton) {
    this.$$set({ showViewJSONButton });
    flush();
  }
  get class() {
    return this.$$.ctx[13];
  }
  set class(classes) {
    this.$$set({ class: classes });
    flush();
  }
}
function create_fragment$4b(ctx) {
  let div;
  let button0;
  let i0;
  let button0_disabled_value;
  let t;
  let button1;
  let i1;
  let button1_disabled_value;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      i0 = element("i");
      t = space();
      button1 = element("button");
      i1 = element("i");
      attr(i0, "class", "fa fa-chevron-up");
      attr(button0, "class", "btn btn-default");
      attr(button0, "title", "Previous Diff");
      button0.disabled = button0_disabled_value = ctx[4] || ctx[2];
      attr(i1, "class", "fa fa-chevron-down");
      attr(button1, "class", "btn btn-default");
      attr(button1, "title", "Next Diff");
      button1.disabled = button1_disabled_value = ctx[4] || ctx[3];
      attr(div, "class", div_class_value = "btn-group flex flex-nowrap " + ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, i0);
      append(div, t);
      append(div, button1);
      append(button1, i1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(ctx[0]))
              ctx[0].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & 20 && button0_disabled_value !== (button0_disabled_value = ctx[4] || ctx[2])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & 24 && button1_disabled_value !== (button1_disabled_value = ctx[4] || ctx[3])) {
        button1.disabled = button1_disabled_value;
      }
      if (dirty & 32 && div_class_value !== (div_class_value = "btn-group flex flex-nowrap " + ctx[5])) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$47($$self, $$props, $$invalidate) {
  let { nextFn } = $$props;
  let { prevFn } = $$props;
  let { nextDisabled = false } = $$props;
  let { prevDisabled = false } = $$props;
  let { disableButtons = false } = $$props;
  let { class: classes = "" } = $$props;
  createEventDispatcher();
  $$self.$$set = ($$props2) => {
    if ("nextFn" in $$props2)
      $$invalidate(0, nextFn = $$props2.nextFn);
    if ("prevFn" in $$props2)
      $$invalidate(1, prevFn = $$props2.prevFn);
    if ("nextDisabled" in $$props2)
      $$invalidate(2, nextDisabled = $$props2.nextDisabled);
    if ("prevDisabled" in $$props2)
      $$invalidate(3, prevDisabled = $$props2.prevDisabled);
    if ("disableButtons" in $$props2)
      $$invalidate(4, disableButtons = $$props2.disableButtons);
    if ("class" in $$props2)
      $$invalidate(5, classes = $$props2.class);
  };
  return [nextFn, prevFn, nextDisabled, prevDisabled, disableButtons, classes];
}
class NavigateDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$47, create_fragment$4b, safe_not_equal, {
      nextFn: 0,
      prevFn: 1,
      nextDisabled: 2,
      prevDisabled: 3,
      disableButtons: 4,
      class: 5
    });
  }
}
function create_fragment$4a(ctx) {
  let ul;
  let li0;
  let navigatediff;
  let t0;
  let li1;
  let a0;
  let t2;
  let li2;
  let a1;
  let t4;
  let li3;
  let ul_class_value;
  let current;
  let mounted;
  let dispose;
  navigatediff = new NavigateDiff({
    props: {
      nextFn: ctx[1],
      prevFn: ctx[2],
      disableButtons: ctx[4].disableButtons
    }
  });
  return {
    c() {
      ul = element("ul");
      li0 = element("li");
      create_component(navigatediff.$$.fragment);
      t0 = space();
      li1 = element("li");
      a0 = element("a");
      a0.textContent = `${TXT("l_tree")}`;
      t2 = space();
      li2 = element("li");
      a1 = element("a");
      a1.textContent = `${TXT("l_raw")}`;
      t4 = space();
      li3 = element("li");
      attr(li0, "class", "m-0 pl-2 mr-3 ");
      attr(a0, "class", "nav-link");
      toggle_class(a0, "active", ctx[0]);
      attr(li1, "class", "nav-item");
      attr(a1, "class", "nav-link");
      toggle_class(a1, "active", !ctx[0]);
      attr(li2, "class", "nav-item");
      attr(li3, "class", "flex-1");
      attr(ul, "class", ul_class_value = "nav nav-tabs sticky top-[-13px] bg-white flex w-full " + ctx[3]);
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      append(ul, li0);
      mount_component(navigatediff, li0, null);
      append(ul, t0);
      append(ul, li1);
      append(li1, a0);
      append(ul, t2);
      append(ul, li2);
      append(li2, a1);
      append(ul, t4);
      append(ul, li3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[5]),
          listen(a1, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const navigatediff_changes = {};
      if (dirty & 2)
        navigatediff_changes.nextFn = ctx2[1];
      if (dirty & 4)
        navigatediff_changes.prevFn = ctx2[2];
      if (dirty & 16)
        navigatediff_changes.disableButtons = ctx2[4].disableButtons;
      navigatediff.$set(navigatediff_changes);
      if (!current || dirty & 1) {
        toggle_class(a0, "active", ctx2[0]);
      }
      if (!current || dirty & 1) {
        toggle_class(a1, "active", !ctx2[0]);
      }
      if (!current || dirty & 8 && ul_class_value !== (ul_class_value = "nav nav-tabs sticky top-[-13px] bg-white flex w-full " + ctx2[3])) {
        attr(ul, "class", ul_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      destroy_component(navigatediff);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$46($$self, $$props, $$invalidate) {
  const omit_props_names = ["treeViewMode", "goToNextDiff", "goToPrevDiff", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { treeViewMode = true } = $$props;
  let { goToNextDiff } = $$props;
  let { goToPrevDiff } = $$props;
  let { class: classes = "" } = $$props;
  const click_handler = () => $$invalidate(0, treeViewMode = true);
  const click_handler_1 = () => $$invalidate(0, treeViewMode = false);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("treeViewMode" in $$new_props)
      $$invalidate(0, treeViewMode = $$new_props.treeViewMode);
    if ("goToNextDiff" in $$new_props)
      $$invalidate(1, goToNextDiff = $$new_props.goToNextDiff);
    if ("goToPrevDiff" in $$new_props)
      $$invalidate(2, goToPrevDiff = $$new_props.goToPrevDiff);
    if ("class" in $$new_props)
      $$invalidate(3, classes = $$new_props.class);
  };
  return [
    treeViewMode,
    goToNextDiff,
    goToPrevDiff,
    classes,
    $$restProps,
    click_handler,
    click_handler_1
  ];
}
class JSONDiffHeader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$46, create_fragment$4a, safe_not_equal, {
      treeViewMode: 0,
      goToNextDiff: 1,
      goToPrevDiff: 2,
      class: 3
    });
  }
}
var JSONSideBySideDiff_svelte_svelte_type_style_lang = "";
function create_else_block_1$h(ctx) {
  let pre;
  let t_value = JSON.stringify(ctx[6].data1.data, null, 2) + "";
  let t;
  return {
    c() {
      pre = element("pre");
      t = text(t_value);
      attr(pre, "class", "overflow-auto whitespace-pre-wrap border-top-0 bg-white svelte-1nksjwa");
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, t);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = JSON.stringify(ctx2[6].data1.data, null, 2) + ""))
        set_data(t, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(pre);
    }
  };
}
function create_if_block_1$1u(ctx) {
  let diffjsonview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  function diffjsonview_goToNextDiff_binding(value) {
    ctx[8](value);
  }
  function diffjsonview_goToPrevDiff_binding(value) {
    ctx[9](value);
  }
  let diffjsonview_props = {
    diff: ctx[6].diff,
    pruneAdditions: true,
    class: "flex-grow",
    treeViewClass: "border-t-0",
    diffNavigation: true,
    view1TreeMode: ctx[0]
  };
  if (ctx[1] !== void 0) {
    diffjsonview_props.goToNextDiff = ctx[1];
  }
  if (ctx[2] !== void 0) {
    diffjsonview_props.goToPrevDiff = ctx[2];
  }
  diffjsonview = new DiffJsonView({ props: diffjsonview_props });
  binding_callbacks.push(() => bind$1(diffjsonview, "goToNextDiff", diffjsonview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(diffjsonview, "goToPrevDiff", diffjsonview_goToPrevDiff_binding));
  return {
    c() {
      create_component(diffjsonview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffjsonview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffjsonview_changes = {};
      if (dirty & 64)
        diffjsonview_changes.diff = ctx2[6].diff;
      if (dirty & 1)
        diffjsonview_changes.view1TreeMode = ctx2[0];
      if (!updating_goToNextDiff && dirty & 2) {
        updating_goToNextDiff = true;
        diffjsonview_changes.goToNextDiff = ctx2[1];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 4) {
        updating_goToPrevDiff = true;
        diffjsonview_changes.goToPrevDiff = ctx2[2];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffjsonview.$set(diffjsonview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffjsonview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffjsonview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffjsonview, detaching);
    }
  };
}
function create_else_block$1i(ctx) {
  let pre;
  let t_value = JSON.stringify(ctx[6].data2.data, null, 2) + "";
  let t;
  return {
    c() {
      pre = element("pre");
      t = text(t_value);
      attr(pre, "class", "overflow-auto whitespace-pre-wrap border-top-0 bg-white svelte-1nksjwa");
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, t);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t_value !== (t_value = JSON.stringify(ctx2[6].data2.data, null, 2) + ""))
        set_data(t, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(pre);
    }
  };
}
function create_if_block$2n(ctx) {
  let diffjsonview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  function diffjsonview_goToNextDiff_binding_1(value) {
    ctx[11](value);
  }
  function diffjsonview_goToPrevDiff_binding_1(value) {
    ctx[12](value);
  }
  let diffjsonview_props = {
    diff: ctx[6].diff,
    pruneDeletions: true,
    class: "flex-grow",
    treeViewClass: "border-t-0",
    diffNavigation: true
  };
  if (ctx[4] !== void 0) {
    diffjsonview_props.goToNextDiff = ctx[4];
  }
  if (ctx[5] !== void 0) {
    diffjsonview_props.goToPrevDiff = ctx[5];
  }
  diffjsonview = new DiffJsonView({ props: diffjsonview_props });
  binding_callbacks.push(() => bind$1(diffjsonview, "goToNextDiff", diffjsonview_goToNextDiff_binding_1));
  binding_callbacks.push(() => bind$1(diffjsonview, "goToPrevDiff", diffjsonview_goToPrevDiff_binding_1));
  return {
    c() {
      create_component(diffjsonview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffjsonview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffjsonview_changes = {};
      if (dirty & 64)
        diffjsonview_changes.diff = ctx2[6].diff;
      if (!updating_goToNextDiff && dirty & 16) {
        updating_goToNextDiff = true;
        diffjsonview_changes.goToNextDiff = ctx2[4];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 32) {
        updating_goToPrevDiff = true;
        diffjsonview_changes.goToPrevDiff = ctx2[5];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffjsonview.$set(diffjsonview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffjsonview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffjsonview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffjsonview, detaching);
    }
  };
}
function create_fragment$49(ctx) {
  let div0;
  let jsondiffheader0;
  let updating_treeViewMode;
  let t0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let div1;
  let jsondiffheader1;
  let updating_treeViewMode_1;
  let t2;
  let current_block_type_index_1;
  let if_block1;
  let current;
  function jsondiffheader0_treeViewMode_binding(value) {
    ctx[7](value);
  }
  let jsondiffheader0_props = {
    disableButtons: !ctx[0],
    goToNextDiff: ctx[1],
    goToPrevDiff: ctx[2]
  };
  if (ctx[0] !== void 0) {
    jsondiffheader0_props.treeViewMode = ctx[0];
  }
  jsondiffheader0 = new JSONDiffHeader({ props: jsondiffheader0_props });
  binding_callbacks.push(() => bind$1(jsondiffheader0, "treeViewMode", jsondiffheader0_treeViewMode_binding));
  const if_block_creators = [create_if_block_1$1u, create_else_block_1$h];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function jsondiffheader1_treeViewMode_binding(value) {
    ctx[10](value);
  }
  let jsondiffheader1_props = {
    disableButtons: !ctx[3],
    goToNextDiff: ctx[4],
    goToPrevDiff: ctx[5]
  };
  if (ctx[3] !== void 0) {
    jsondiffheader1_props.treeViewMode = ctx[3];
  }
  jsondiffheader1 = new JSONDiffHeader({ props: jsondiffheader1_props });
  binding_callbacks.push(() => bind$1(jsondiffheader1, "treeViewMode", jsondiffheader1_treeViewMode_binding));
  const if_block_creators_1 = [create_if_block$2n, create_else_block$1i];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_1(ctx);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  return {
    c() {
      div0 = element("div");
      create_component(jsondiffheader0.$$.fragment);
      t0 = space();
      if_block0.c();
      t1 = space();
      div1 = element("div");
      create_component(jsondiffheader1.$$.fragment);
      t2 = space();
      if_block1.c();
      attr(div0, "class", "flex flex-column flex-1 pl-10 pr-10");
      attr(div1, "class", "flex flex-column flex-1 pl-10 pr-10");
      set_style(div1, "border-left", "2px solid black");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(jsondiffheader0, div0, null);
      append(div0, t0);
      if_blocks[current_block_type_index].m(div0, null);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      mount_component(jsondiffheader1, div1, null);
      append(div1, t2);
      if_blocks_1[current_block_type_index_1].m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const jsondiffheader0_changes = {};
      if (dirty & 1)
        jsondiffheader0_changes.disableButtons = !ctx2[0];
      if (dirty & 2)
        jsondiffheader0_changes.goToNextDiff = ctx2[1];
      if (dirty & 4)
        jsondiffheader0_changes.goToPrevDiff = ctx2[2];
      if (!updating_treeViewMode && dirty & 1) {
        updating_treeViewMode = true;
        jsondiffheader0_changes.treeViewMode = ctx2[0];
        add_flush_callback(() => updating_treeViewMode = false);
      }
      jsondiffheader0.$set(jsondiffheader0_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, null);
      }
      const jsondiffheader1_changes = {};
      if (dirty & 8)
        jsondiffheader1_changes.disableButtons = !ctx2[3];
      if (dirty & 16)
        jsondiffheader1_changes.goToNextDiff = ctx2[4];
      if (dirty & 32)
        jsondiffheader1_changes.goToPrevDiff = ctx2[5];
      if (!updating_treeViewMode_1 && dirty & 8) {
        updating_treeViewMode_1 = true;
        jsondiffheader1_changes.treeViewMode = ctx2[3];
        add_flush_callback(() => updating_treeViewMode_1 = false);
      }
      jsondiffheader1.$set(jsondiffheader1_changes);
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block1 = if_blocks_1[current_block_type_index_1];
        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(jsondiffheader0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(jsondiffheader1.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(jsondiffheader0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(jsondiffheader1.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(jsondiffheader0);
      if_blocks[current_block_type_index].d();
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      destroy_component(jsondiffheader1);
      if_blocks_1[current_block_type_index_1].d();
    }
  };
}
function instance$45($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(6, $store = $$value));
  let view1TreeMode = true;
  let view1GoToNextDiff;
  let view1GoToPrevDiff;
  let view2TreeMode = true;
  let view2GoToNextDiff;
  let view2GoToPrevDiff;
  function jsondiffheader0_treeViewMode_binding(value) {
    view1TreeMode = value;
    $$invalidate(0, view1TreeMode);
  }
  function diffjsonview_goToNextDiff_binding(value) {
    view1GoToNextDiff = value;
    $$invalidate(1, view1GoToNextDiff);
  }
  function diffjsonview_goToPrevDiff_binding(value) {
    view1GoToPrevDiff = value;
    $$invalidate(2, view1GoToPrevDiff);
  }
  function jsondiffheader1_treeViewMode_binding(value) {
    view2TreeMode = value;
    $$invalidate(3, view2TreeMode);
  }
  function diffjsonview_goToNextDiff_binding_1(value) {
    view2GoToNextDiff = value;
    $$invalidate(4, view2GoToNextDiff);
  }
  function diffjsonview_goToPrevDiff_binding_1(value) {
    view2GoToPrevDiff = value;
    $$invalidate(5, view2GoToPrevDiff);
  }
  return [
    view1TreeMode,
    view1GoToNextDiff,
    view1GoToPrevDiff,
    view2TreeMode,
    view2GoToNextDiff,
    view2GoToPrevDiff,
    $store,
    jsondiffheader0_treeViewMode_binding,
    diffjsonview_goToNextDiff_binding,
    diffjsonview_goToPrevDiff_binding,
    jsondiffheader1_treeViewMode_binding,
    diffjsonview_goToNextDiff_binding_1,
    diffjsonview_goToPrevDiff_binding_1
  ];
}
class JSONSideBySideDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$45, create_fragment$49, safe_not_equal, {});
  }
}
function create_fragment$48(ctx) {
  let div1;
  let div0;
  let navigatediff;
  let t;
  let diffjsonview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  navigatediff = new NavigateDiff({
    props: {
      nextFn: ctx[0],
      prevFn: ctx[1]
    }
  });
  function diffjsonview_goToNextDiff_binding(value) {
    ctx[3](value);
  }
  function diffjsonview_goToPrevDiff_binding(value) {
    ctx[4](value);
  }
  let diffjsonview_props = {
    scrollToFirstDiff: true,
    diff: ctx[2].diff,
    diffNavigation: true
  };
  if (ctx[0] !== void 0) {
    diffjsonview_props.goToNextDiff = ctx[0];
  }
  if (ctx[1] !== void 0) {
    diffjsonview_props.goToPrevDiff = ctx[1];
  }
  diffjsonview = new DiffJsonView({ props: diffjsonview_props });
  binding_callbacks.push(() => bind$1(diffjsonview, "goToNextDiff", diffjsonview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(diffjsonview, "goToPrevDiff", diffjsonview_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff.$$.fragment);
      t = space();
      create_component(diffjsonview.$$.fragment);
      attr(div0, "class", "flex mb-3 sticky top-0 bg-transparent");
      attr(div1, "class", "flex-grow pl-10 pr-10 flex flex-column");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff, div0, null);
      append(div1, t);
      mount_component(diffjsonview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff_changes = {};
      if (dirty & 1)
        navigatediff_changes.nextFn = ctx2[0];
      if (dirty & 2)
        navigatediff_changes.prevFn = ctx2[1];
      navigatediff.$set(navigatediff_changes);
      const diffjsonview_changes = {};
      if (dirty & 4)
        diffjsonview_changes.diff = ctx2[2].diff;
      if (!updating_goToNextDiff && dirty & 1) {
        updating_goToNextDiff = true;
        diffjsonview_changes.goToNextDiff = ctx2[0];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 2) {
        updating_goToPrevDiff = true;
        diffjsonview_changes.goToPrevDiff = ctx2[1];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffjsonview.$set(diffjsonview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff.$$.fragment, local);
      transition_in(diffjsonview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff.$$.fragment, local);
      transition_out(diffjsonview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff);
      destroy_component(diffjsonview);
    }
  };
}
function instance$44($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(2, $store = $$value));
  let goToNextDiff;
  let goToPrevDiff;
  function diffjsonview_goToNextDiff_binding(value) {
    goToNextDiff = value;
    $$invalidate(0, goToNextDiff);
  }
  function diffjsonview_goToPrevDiff_binding(value) {
    goToPrevDiff = value;
    $$invalidate(1, goToPrevDiff);
  }
  return [
    goToNextDiff,
    goToPrevDiff,
    $store,
    diffjsonview_goToNextDiff_binding,
    diffjsonview_goToPrevDiff_binding
  ];
}
class JSONInlineDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$44, create_fragment$48, safe_not_equal, {});
  }
}
function create_else_block$1h(ctx) {
  let jsonsidebysidediff;
  let current;
  jsonsidebysidediff = new JSONSideBySideDiff({});
  return {
    c() {
      create_component(jsonsidebysidediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonsidebysidediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(jsonsidebysidediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonsidebysidediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonsidebysidediff, detaching);
    }
  };
}
function create_if_block$2m(ctx) {
  let jsoninlinediff;
  let current;
  jsoninlinediff = new JSONInlineDiff({});
  return {
    c() {
      create_component(jsoninlinediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsoninlinediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(jsoninlinediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsoninlinediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsoninlinediff, detaching);
    }
  };
}
function create_fragment$47(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$2m, create_else_block$1h];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex items-stretch h-full");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$43($$self, $$props, $$invalidate) {
  let { inlined = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
  };
  return [inlined];
}
class ExploreJSONDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$43, create_fragment$47, safe_not_equal, { inlined: 0 });
  }
}
var diffStyles = ".removed,tr>td.removed{background:#fbb!important}.inserted,tr>td.inserted{background:#bfb!important}.xhighlighted{outline:2px solid blue}";
function create_if_block_2$W(ctx) {
  let div;
  let span;
  let t0;
  let t1_value = ctx[7].data_type === C$1.TYPE_HTML ? "'Text'" : "'Data'";
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text("No visual change found. Use the ");
      t1 = text(t1_value);
      t2 = text(" mode to view changes.");
      attr(span, "class", "alert alert-warning py-2");
      attr(div, "class", "ml3 mb2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128 && t1_value !== (t1_value = ctx2[7].data_type === C$1.TYPE_HTML ? "'Text'" : "'Data'"))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$1t(ctx) {
  let div;
  let span;
  let t0;
  let t1_value = ctx[5].message + "";
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text("Cannot perform the diff: ");
      t1 = text(t1_value);
      t2 = text(".");
      attr(span, "class", "alert alert-danger py-2");
      attr(div, "class", "ml3 mb2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32 && t1_value !== (t1_value = ctx2[5].message + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$2l(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span class="py-1">Diffing...</span>`;
      attr(div, "class", "ml3 mb2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$46(ctx) {
  let t;
  let div;
  let iframe_1;
  let iframe_1_class_value;
  let iframe_1_scrolling_value;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return create_if_block$2l;
    if (ctx2[5])
      return create_if_block_1$1t;
    if (ctx2[8] === C$1.DIFF_MODE_VISUAL && (ctx2[1] === 0 && ctx2[2] === 0) && ctx2[6] !== ctx2[7])
      return create_if_block_2$W;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      iframe_1 = element("iframe");
      attr(iframe_1, "title", "");
      attr(iframe_1, "class", iframe_1_class_value = "w-full border-none " + ctx[9]);
      attr(iframe_1, "style", ctx[11]);
      attr(iframe_1, "scrolling", iframe_1_scrolling_value = ctx[10] ? "" : "no");
      attr(iframe_1, "srcdoc", ctx[0]);
      set_style(iframe_1, "height", ctx[13]);
      attr(div, "class", ctx[12]);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      append(div, iframe_1);
      ctx[25](iframe_1);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      }
      if (dirty[0] & 512 && iframe_1_class_value !== (iframe_1_class_value = "w-full border-none " + ctx2[9])) {
        attr(iframe_1, "class", iframe_1_class_value);
      }
      if (dirty[0] & 2048) {
        attr(iframe_1, "style", ctx2[11]);
      }
      if (dirty[0] & 1024 && iframe_1_scrolling_value !== (iframe_1_scrolling_value = ctx2[10] ? "" : "no")) {
        attr(iframe_1, "scrolling", iframe_1_scrolling_value);
      }
      if (dirty[0] & 1) {
        attr(iframe_1, "srcdoc", ctx2[0]);
      }
      const style_changed = dirty[0] & 2048;
      if (style_changed || dirty[0] & 10240) {
        set_style(iframe_1, "height", ctx2[13]);
      }
      if (dirty[0] & 4096) {
        attr(div, "class", ctx2[12]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      ctx[25](null);
    }
  };
}
const highlightClass$3 = "xhighlighted";
function waitFor2AnimationFrames() {
  return new Promise((resolve) => {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        resolve();
      });
    });
  });
}
function wait$2(timeout) {
  return new Promise((resolve) => setTimeout(resolve, timeout));
}
function getDiffNodes$2(parentEl, diffs, options = {}) {
  let { selector } = options;
  diffs.nodes = [];
  diffs.curr = null;
  diffs.nodes = Array.from(parentEl.querySelectorAll(selector));
}
function instance$42($$self, $$props, $$invalidate) {
  let { oldData } = $$props;
  let { newData } = $$props;
  let { diff: diff2 } = $$props;
  let { uri } = $$props;
  let { selectedDiffContentMode } = $$props;
  let { showInserted = true } = $$props;
  let { showRemoved = true } = $$props;
  let { withStyle = true } = $$props;
  let { snipped = false } = $$props;
  let { iframeClass = "" } = $$props;
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { scrollToFirstDiff = false } = $$props;
  let { diffNavigation = false } = $$props;
  let { showScrollBar } = $$props;
  let { dynamicHeight = true } = $$props;
  let { iframe } = $$props;
  let { iframeStyle = "" } = $$props;
  const goToNextDiff = () => goToDiff(STEP.NEXT);
  const goToPrevDiff = () => goToDiff(STEP.PREV);
  let { diffing = true } = $$props;
  let { diffError = null } = $$props;
  const dispatch = createEventDispatcher();
  const STEP = { NEXT: 1, PREV: -1 };
  let { class: classes = "" } = $$props;
  let styleSheets;
  let styledElements;
  let intervals = [];
  let selectors = [];
  if (showRemoved) {
    selectors.push(".removed");
  }
  if (showInserted) {
    selectors.push(".inserted");
  }
  let selector = selectors.join(",");
  let styles;
  let prevHeight = 0;
  let loaded = false;
  let parentEl;
  let height = "40px";
  let diffs = { nodes: [], curr: null };
  let requestAnimationFramePromiseIsResolved = false;
  onMount(() => {
    $$invalidate(3, iframe.onload = onLoad, iframe);
    return () => {
      intervals.forEach((interval) => clearInterval(interval));
    };
  });
  async function onLoad() {
    parentEl = iframe.contentWindow.document;
    styleSheets = void 0;
    styledElements = void 0;
    resetHighlighting();
    setDiffStyles();
    if (dynamicHeight) {
      const resourceCount = await waitForResourceLoad();
      if (resourceCount > 0) {
        requestAnimationFramePromiseIsResolved = false;
        waitFor2AnimationFrames().then(() => {
          requestAnimationFramePromiseIsResolved = true;
        });
        startInterval();
      }
    }
    updateLinks();
    if (diffNavigation) {
      getDiffNodes$2(parentEl, diffs, { selector });
      if (scrollToFirstDiff) {
        goToFirstDiff();
      }
    }
    $$invalidate(24, loaded = true);
    dispatch("load");
  }
  async function waitForResourceLoad() {
    const contentEls = Array.from(iframe.contentWindow.document.querySelectorAll('link[rel="stylesheet"], img'));
    const checkPromise = new Promise((resolve) => {
      let elsLoaded = 0;
      contentEls.forEach((el2) => {
        if (el2.complete || el2.sheet) {
          elsLoaded++;
        } else {
          const listener = () => {
            elsLoaded++;
            setIframeHeight();
            el2.removeEventListener("load", listener);
            el2.removeEventListener("error", listener);
            if (elsLoaded === contentEls.length) {
              resolve();
            }
          };
          ["load", "error"].forEach((evt) => {
            el2.addEventListener(evt, listener);
          });
        }
      });
      if (elsLoaded === contentEls.length) {
        resolve();
      }
      setIframeHeight();
    });
    await Promise.race([wait$2(15 * 1e3), checkPromise]);
    return contentEls.length;
  }
  function startInterval() {
    const interval = setInterval(() => setIframeHeight(), 2e3);
    intervals.push(interval);
  }
  function removeElements(selector2) {
    Array.from(parentEl.querySelectorAll(selector2)).forEach((el2) => el2.remove());
  }
  function showHiddenDiffs() {
    const diffDetailsTags = parentEl.querySelectorAll("details:has(.inserted),details:has(.removed)");
    diffDetailsTags.forEach((el2) => {
      el2.setAttribute("open", "");
    });
  }
  function computeStyle() {
    if (selectedDiffContentMode === C$1.DIFF_MODE_VISUAL) {
      if (showInserted) {
        removeElements("style.diffMark.removed");
      } else if (showRemoved) {
        removeElements("style.diffMark.inserted");
      }
    }
    if (selectedDiffContentMode !== C$1.DIFF_MODE_VISUAL) {
      let snipElements = parentEl.querySelectorAll(".snip");
      snipElements.forEach((s) => {
        let nonDiffHideElement = s.previousElementSibling;
        let nonDiffHideElementExists = nonDiffHideElement && nonDiffHideElement.classList.contains("nonDiffHide");
        if (nonDiffHideElementExists) {
          if (snipped) {
            let clickHandler = function(event) {
              event.preventDefault();
              nonDiffHideElement.style.display = "inline";
              s.style.display = "none";
              setIframeHeight();
              s.removeEventListener("click", clickHandler);
            };
            s.addEventListener("click", clickHandler);
          } else {
            nonDiffHideElement.removeAttribute("style");
            s.removeAttribute("style");
          }
        }
      });
    }
    styles = `
    ${diffStyles}
    span.inserted,
    span.removed {
      padding: 1px 4px;
    }
    a.removed,
    a .removed {
      color: #008;
    }
    a.diffMark > * {
      background-color: inherit;
    }
    img.inserted {
      border: solid 2px green;
      background-color: transparent;
      padding: 2px;
    }
    img.removed {
      border: solid 2px red;
      background-color: transparent;
      padding: 2px;
    }
    [hidden] {
      display:block;
    }
    .xdistill-hide {display: none !important}
    body {
     padding: 0px;
    }
    td {
     padding: 10px;
    }
    ins, del {
      text-decoration: none;
    }

   [distill-tag] {
     position: relative;
    }

   [distill-tag]:hover::before {
      position: absolute;
      top: -1.1rem;
      content: attr(distill-tag);
      border-radius: 10px;
      background-color: #333;
      color: white;
      font-size: 8px;
      padding: 0.35em 0.65em;
    }
  ${snipped ? ".nonDiffHide{display:none;}" : ".snip{display:none;}"}
  ${!showRemoved ? ".removed{display:none;}" : ""}
  ${!showInserted ? ".inserted{display:none}" : ""}
   `;
  }
  function goToDiff(step) {
    let { nodes, curr } = diffs;
    const length = nodes.length;
    if (length === 0) {
      return;
    }
    if (curr === null) {
      if (step === STEP.NEXT) {
        curr = -1;
      } else {
        curr = length;
      }
    }
    let next2 = curr + step;
    if (next2 < 0) {
      next2 = length - 1;
    } else if (next2 >= length) {
      next2 = 0;
    }
    const currDiff = nodes[curr];
    const nextDiff = nodes[next2];
    currDiff == null ? void 0 : currDiff.classList.remove(highlightClass$3);
    nextDiff.classList.add(highlightClass$3);
    nextDiff.scrollIntoView({ behaviour: "smooth", block: "center" });
    diffs.curr = next2;
  }
  function goToFirstDiff() {
    const firstDiffEl = diffs.nodes[0];
    if (firstDiffEl) {
      diffs.curr = 0;
      firstDiffEl.scrollIntoView({ behaviour: "smooth", block: "center" });
      firstDiffEl.classList.add(highlightClass$3);
    }
  }
  function updateLinks() {
    const baseURIMatch = diff2 == null ? void 0 : diff2.match(/<base\s*href=\"(.*?)\"/);
    let baseURI;
    if (baseURIMatch) {
      baseURI = baseURIMatch[1];
    } else {
      baseURI = uri;
    }
    const base2 = parentEl.createElement("base");
    base2.setAttribute("href", baseURI);
    (parentEl.head || parentEl.documentElement).prepend(base2);
    parentEl.querySelectorAll("a[href]").forEach((el2) => {
      el2.setAttribute("target", "_blank");
      el2.setAttribute("rel", "noopener");
    });
  }
  function resetHighlighting() {
    Array.from(parentEl.querySelectorAll(`.${highlightClass$3}`)).map((el2) => el2.classList.remove(highlightClass$3));
  }
  function setIframeHeight(forceStyle = false) {
    if (requestAnimationFramePromiseIsResolved && !forceStyle) {
      return;
    }
    const doc = iframe.contentWindow.document;
    const html2 = doc.documentElement;
    const body = doc.body;
    let h = Math.max(body.scrollHeight, body.offsetHeight, html2.clientHeight, html2.scrollHeight, html2.offsetHeight);
    if (h > prevHeight * 1.03) {
      h = h * 1.02;
      prevHeight = h;
      $$invalidate(13, height = h + "px");
    }
  }
  async function getDiff2() {
    try {
      $$invalidate(5, diffError = null);
      $$invalidate(4, diffing = true);
      $$invalidate(0, { diff: diff2, additions, deletions } = await diffHTMLAndRender(oldData, newData, selectedDiffContentMode), diff2, $$invalidate(1, additions), $$invalidate(2, deletions));
    } catch (e) {
      $$invalidate(5, diffError = e);
      console.error("error while getting the diff", oldData.id, newData.id, e);
      $$invalidate(0, diff2 = newData.data);
      $$invalidate(1, additions = 0);
      $$invalidate(2, deletions = 0);
    } finally {
      $$invalidate(4, diffing = false);
    }
    if (!diff2.includes("<base")) {
      $$invalidate(0, diff2 = `<base href="${uri}"/> ${diff2}`);
    }
  }
  function setDiffStyles() {
    let styleEl = parentEl.querySelector("style.xdistill");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.classList.add("xdistill");
      parentEl.querySelector("head").appendChild(styleEl);
    }
    computeStyle();
    styleEl.innerHTML = styles;
    setIframeHeight();
  }
  function toggleStyle(withStyle2) {
    if (withStyle2) {
      styleSheets && styleSheets.forEach((style) => parentEl.querySelector("head").appendChild(style));
      styledElements && styledElements.forEach(([element2, style]) => {
        element2.setAttribute("style", style);
      });
    } else {
      styleSheets = Array.from(parentEl.querySelectorAll("link[rel=stylesheet],style:not(.xdistill)"));
      styleSheets.forEach((style) => style.remove());
      styledElements = Array.from(parentEl.querySelectorAll("[style]")).map((element2) => {
        let data = [element2, element2.getAttribute("style")];
        element2.removeAttribute("style");
        return data;
      });
    }
    setIframeHeight(true);
  }
  function iframe_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iframe = $$value;
      $$invalidate(3, iframe);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("oldData" in $$props2)
      $$invalidate(6, oldData = $$props2.oldData);
    if ("newData" in $$props2)
      $$invalidate(7, newData = $$props2.newData);
    if ("diff" in $$props2)
      $$invalidate(0, diff2 = $$props2.diff);
    if ("uri" in $$props2)
      $$invalidate(14, uri = $$props2.uri);
    if ("selectedDiffContentMode" in $$props2)
      $$invalidate(8, selectedDiffContentMode = $$props2.selectedDiffContentMode);
    if ("showInserted" in $$props2)
      $$invalidate(15, showInserted = $$props2.showInserted);
    if ("showRemoved" in $$props2)
      $$invalidate(16, showRemoved = $$props2.showRemoved);
    if ("withStyle" in $$props2)
      $$invalidate(17, withStyle = $$props2.withStyle);
    if ("snipped" in $$props2)
      $$invalidate(18, snipped = $$props2.snipped);
    if ("iframeClass" in $$props2)
      $$invalidate(9, iframeClass = $$props2.iframeClass);
    if ("additions" in $$props2)
      $$invalidate(1, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(2, deletions = $$props2.deletions);
    if ("scrollToFirstDiff" in $$props2)
      $$invalidate(19, scrollToFirstDiff = $$props2.scrollToFirstDiff);
    if ("diffNavigation" in $$props2)
      $$invalidate(20, diffNavigation = $$props2.diffNavigation);
    if ("showScrollBar" in $$props2)
      $$invalidate(10, showScrollBar = $$props2.showScrollBar);
    if ("dynamicHeight" in $$props2)
      $$invalidate(21, dynamicHeight = $$props2.dynamicHeight);
    if ("iframe" in $$props2)
      $$invalidate(3, iframe = $$props2.iframe);
    if ("iframeStyle" in $$props2)
      $$invalidate(11, iframeStyle = $$props2.iframeStyle);
    if ("diffing" in $$props2)
      $$invalidate(4, diffing = $$props2.diffing);
    if ("diffError" in $$props2)
      $$invalidate(5, diffError = $$props2.diffError);
    if ("class" in $$props2)
      $$invalidate(12, classes = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1) {
      $$invalidate(24, loaded = false);
    }
    if ($$self.$$.dirty[0] & 16908288) {
      loaded && toggleStyle(withStyle);
    }
    if ($$self.$$.dirty[0] & 448) {
      oldData && newData && selectedDiffContentMode && getDiff2();
    }
    if ($$self.$$.dirty[0] & 17137665) {
      loaded && setDiffStyles();
    }
    if ($$self.$$.dirty[0] & 16777216) {
      loaded && showHiddenDiffs();
    }
  };
  return [
    diff2,
    additions,
    deletions,
    iframe,
    diffing,
    diffError,
    oldData,
    newData,
    selectedDiffContentMode,
    iframeClass,
    showScrollBar,
    iframeStyle,
    classes,
    height,
    uri,
    showInserted,
    showRemoved,
    withStyle,
    snipped,
    scrollToFirstDiff,
    diffNavigation,
    dynamicHeight,
    goToNextDiff,
    goToPrevDiff,
    loaded,
    iframe_1_binding
  ];
}
class DiffHtmlView extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$42,
      create_fragment$46,
      safe_not_equal,
      {
        oldData: 6,
        newData: 7,
        diff: 0,
        uri: 14,
        selectedDiffContentMode: 8,
        showInserted: 15,
        showRemoved: 16,
        withStyle: 17,
        snipped: 18,
        iframeClass: 9,
        additions: 1,
        deletions: 2,
        scrollToFirstDiff: 19,
        diffNavigation: 20,
        showScrollBar: 10,
        dynamicHeight: 21,
        iframe: 3,
        iframeStyle: 11,
        goToNextDiff: 22,
        goToPrevDiff: 23,
        diffing: 4,
        diffError: 5,
        class: 12
      },
      null,
      [-1, -1]
    );
  }
  get goToNextDiff() {
    return this.$$.ctx[22];
  }
  get goToPrevDiff() {
    return this.$$.ctx[23];
  }
}
function create_if_block$2k(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$45(ctx) {
  let div1;
  let div0;
  let t0;
  let navigatediff;
  let t1;
  let diffhtmlview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let updating_withStyle;
  let current;
  let if_block = ctx[1] && create_if_block$2k();
  navigatediff = new NavigateDiff({
    props: {
      class: "ml-5 bg-transparent",
      nextFn: ctx[2],
      prevFn: ctx[3]
    }
  });
  function diffhtmlview_goToNextDiff_binding(value) {
    ctx[5](value);
  }
  function diffhtmlview_goToPrevDiff_binding(value) {
    ctx[6](value);
  }
  function diffhtmlview_withStyle_binding(value) {
    ctx[7](value);
  }
  let diffhtmlview_props = {
    diff: ctx[4].diff,
    uri: ctx[4].uri,
    diffError: ctx[4].diffError,
    diffing: ctx[4].diffing,
    scrollToFirstDiff: true,
    diffNavigation: true,
    selectedDiffContentMode: ctx[4].diffContentMode,
    iframeStyle: "min-height:100vh;",
    class: "flex-grow pt-6"
  };
  if (ctx[2] !== void 0) {
    diffhtmlview_props.goToNextDiff = ctx[2];
  }
  if (ctx[3] !== void 0) {
    diffhtmlview_props.goToPrevDiff = ctx[3];
  }
  if (ctx[0] !== void 0) {
    diffhtmlview_props.withStyle = ctx[0];
  }
  diffhtmlview = new DiffHtmlView({ props: diffhtmlview_props });
  binding_callbacks.push(() => bind$1(diffhtmlview, "goToNextDiff", diffhtmlview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(diffhtmlview, "goToPrevDiff", diffhtmlview_goToPrevDiff_binding));
  binding_callbacks.push(() => bind$1(diffhtmlview, "withStyle", diffhtmlview_withStyle_binding));
  diffhtmlview.$on("load", ctx[8]);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      create_component(navigatediff.$$.fragment);
      t1 = space();
      create_component(diffhtmlview.$$.fragment);
      attr(div0, "class", "flex flex-col align-items-start sticky top-0");
      attr(div1, "class", "flex flex-column self-stretch flex-grow");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div0, t0);
      mount_component(navigatediff, div0, null);
      append(div1, t1);
      mount_component(diffhtmlview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block) {
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2k();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const navigatediff_changes = {};
      if (dirty & 4)
        navigatediff_changes.nextFn = ctx2[2];
      if (dirty & 8)
        navigatediff_changes.prevFn = ctx2[3];
      navigatediff.$set(navigatediff_changes);
      const diffhtmlview_changes = {};
      if (dirty & 16)
        diffhtmlview_changes.diff = ctx2[4].diff;
      if (dirty & 16)
        diffhtmlview_changes.uri = ctx2[4].uri;
      if (dirty & 16)
        diffhtmlview_changes.diffError = ctx2[4].diffError;
      if (dirty & 16)
        diffhtmlview_changes.diffing = ctx2[4].diffing;
      if (dirty & 16)
        diffhtmlview_changes.selectedDiffContentMode = ctx2[4].diffContentMode;
      if (!updating_goToNextDiff && dirty & 4) {
        updating_goToNextDiff = true;
        diffhtmlview_changes.goToNextDiff = ctx2[2];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 8) {
        updating_goToPrevDiff = true;
        diffhtmlview_changes.goToPrevDiff = ctx2[3];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      if (!updating_withStyle && dirty & 1) {
        updating_withStyle = true;
        diffhtmlview_changes.withStyle = ctx2[0];
        add_flush_callback(() => updating_withStyle = false);
      }
      diffhtmlview.$set(diffhtmlview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(navigatediff.$$.fragment, local);
      transition_in(diffhtmlview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(navigatediff.$$.fragment, local);
      transition_out(diffhtmlview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      destroy_component(navigatediff);
      destroy_component(diffhtmlview);
    }
  };
}
function instance$41($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(4, $store = $$value));
  let { withStyle } = $$props;
  let showLoader = true;
  let goToNextDiff;
  let goToPrevDiff;
  function diffhtmlview_goToNextDiff_binding(value) {
    goToNextDiff = value;
    $$invalidate(2, goToNextDiff);
  }
  function diffhtmlview_goToPrevDiff_binding(value) {
    goToPrevDiff = value;
    $$invalidate(3, goToPrevDiff);
  }
  function diffhtmlview_withStyle_binding(value) {
    withStyle = value;
    $$invalidate(0, withStyle);
  }
  const load_handler = () => $$invalidate(1, showLoader = false);
  $$self.$$set = ($$props2) => {
    if ("withStyle" in $$props2)
      $$invalidate(0, withStyle = $$props2.withStyle);
  };
  return [
    withStyle,
    showLoader,
    goToNextDiff,
    goToPrevDiff,
    $store,
    diffhtmlview_goToNextDiff_binding,
    diffhtmlview_goToPrevDiff_binding,
    diffhtmlview_withStyle_binding,
    load_handler
  ];
}
class HTMLInlineDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$41, create_fragment$45, safe_not_equal, { withStyle: 0 });
  }
}
function create_if_block_1$1s(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_if_block$2j(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$44(ctx) {
  let div1;
  let div0;
  let t0;
  let navigatediff0;
  let t1;
  let diffhtmlview0;
  let updating_withStyle;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let t2;
  let div3;
  let div2;
  let t3;
  let navigatediff1;
  let t4;
  let diffhtmlview1;
  let updating_withStyle_1;
  let updating_goToNextDiff_1;
  let updating_goToPrevDiff_1;
  let current;
  let if_block0 = ctx[1] && create_if_block_1$1s();
  navigatediff0 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[3],
      prevFn: ctx[4]
    }
  });
  function diffhtmlview0_withStyle_binding(value) {
    ctx[8](value);
  }
  function diffhtmlview0_goToNextDiff_binding(value) {
    ctx[9](value);
  }
  function diffhtmlview0_goToPrevDiff_binding(value) {
    ctx[10](value);
  }
  let diffhtmlview0_props = {
    diff: ctx[7].diff,
    uri: ctx[7].uri,
    diffError: ctx[7].diffError,
    diffing: ctx[7].diffing,
    showInserted: false,
    diffNavigation: true,
    selectedDiffContentMode: ctx[7].diffContentMode,
    iframeStyle: "min-height:100vh;",
    class: "flex-grow pt-6"
  };
  if (ctx[0] !== void 0) {
    diffhtmlview0_props.withStyle = ctx[0];
  }
  if (ctx[3] !== void 0) {
    diffhtmlview0_props.goToNextDiff = ctx[3];
  }
  if (ctx[4] !== void 0) {
    diffhtmlview0_props.goToPrevDiff = ctx[4];
  }
  diffhtmlview0 = new DiffHtmlView({ props: diffhtmlview0_props });
  binding_callbacks.push(() => bind$1(diffhtmlview0, "withStyle", diffhtmlview0_withStyle_binding));
  binding_callbacks.push(() => bind$1(diffhtmlview0, "goToNextDiff", diffhtmlview0_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(diffhtmlview0, "goToPrevDiff", diffhtmlview0_goToPrevDiff_binding));
  diffhtmlview0.$on("load", ctx[11]);
  let if_block1 = ctx[2] && create_if_block$2j();
  navigatediff1 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[5],
      prevFn: ctx[6]
    }
  });
  function diffhtmlview1_withStyle_binding(value) {
    ctx[12](value);
  }
  function diffhtmlview1_goToNextDiff_binding(value) {
    ctx[13](value);
  }
  function diffhtmlview1_goToPrevDiff_binding(value) {
    ctx[14](value);
  }
  let diffhtmlview1_props = {
    diff: ctx[7].diff,
    uri: ctx[7].uri,
    diffError: ctx[7].diffError,
    diffing: ctx[7].diffing,
    showRemoved: false,
    diffNavigation: true,
    selectedDiffContentMode: ctx[7].diffContentMode,
    showLoader: true,
    iframeStyle: "min-height:100vh;",
    class: "flex-grow pt-6"
  };
  if (ctx[0] !== void 0) {
    diffhtmlview1_props.withStyle = ctx[0];
  }
  if (ctx[5] !== void 0) {
    diffhtmlview1_props.goToNextDiff = ctx[5];
  }
  if (ctx[6] !== void 0) {
    diffhtmlview1_props.goToPrevDiff = ctx[6];
  }
  diffhtmlview1 = new DiffHtmlView({ props: diffhtmlview1_props });
  binding_callbacks.push(() => bind$1(diffhtmlview1, "withStyle", diffhtmlview1_withStyle_binding));
  binding_callbacks.push(() => bind$1(diffhtmlview1, "goToNextDiff", diffhtmlview1_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(diffhtmlview1, "goToPrevDiff", diffhtmlview1_goToPrevDiff_binding));
  diffhtmlview1.$on("load", ctx[15]);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(navigatediff0.$$.fragment);
      t1 = space();
      create_component(diffhtmlview0.$$.fragment);
      t2 = space();
      div3 = element("div");
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      t3 = space();
      create_component(navigatediff1.$$.fragment);
      t4 = space();
      create_component(diffhtmlview1.$$.fragment);
      attr(div0, "class", "flex flex-col align-items-start sticky top-0");
      attr(div1, "class", "flex-grow flex flex-column items-stretch");
      attr(div2, "class", "flex flex-col align-items-start sticky top-0");
      attr(div3, "class", "flex-grow flex flex-column items-stretch");
      set_style(div3, "border-left", "2px solid black");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      mount_component(navigatediff0, div0, null);
      append(div1, t1);
      mount_component(diffhtmlview0, div1, null);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t3);
      mount_component(navigatediff1, div2, null);
      append(div3, t4);
      mount_component(diffhtmlview1, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block0) {
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$1s();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const navigatediff0_changes = {};
      if (dirty & 8)
        navigatediff0_changes.nextFn = ctx2[3];
      if (dirty & 16)
        navigatediff0_changes.prevFn = ctx2[4];
      navigatediff0.$set(navigatediff0_changes);
      const diffhtmlview0_changes = {};
      if (dirty & 128)
        diffhtmlview0_changes.diff = ctx2[7].diff;
      if (dirty & 128)
        diffhtmlview0_changes.uri = ctx2[7].uri;
      if (dirty & 128)
        diffhtmlview0_changes.diffError = ctx2[7].diffError;
      if (dirty & 128)
        diffhtmlview0_changes.diffing = ctx2[7].diffing;
      if (dirty & 128)
        diffhtmlview0_changes.selectedDiffContentMode = ctx2[7].diffContentMode;
      if (!updating_withStyle && dirty & 1) {
        updating_withStyle = true;
        diffhtmlview0_changes.withStyle = ctx2[0];
        add_flush_callback(() => updating_withStyle = false);
      }
      if (!updating_goToNextDiff && dirty & 8) {
        updating_goToNextDiff = true;
        diffhtmlview0_changes.goToNextDiff = ctx2[3];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 16) {
        updating_goToPrevDiff = true;
        diffhtmlview0_changes.goToPrevDiff = ctx2[4];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffhtmlview0.$set(diffhtmlview0_changes);
      if (ctx2[2]) {
        if (if_block1) {
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$2j();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const navigatediff1_changes = {};
      if (dirty & 32)
        navigatediff1_changes.nextFn = ctx2[5];
      if (dirty & 64)
        navigatediff1_changes.prevFn = ctx2[6];
      navigatediff1.$set(navigatediff1_changes);
      const diffhtmlview1_changes = {};
      if (dirty & 128)
        diffhtmlview1_changes.diff = ctx2[7].diff;
      if (dirty & 128)
        diffhtmlview1_changes.uri = ctx2[7].uri;
      if (dirty & 128)
        diffhtmlview1_changes.diffError = ctx2[7].diffError;
      if (dirty & 128)
        diffhtmlview1_changes.diffing = ctx2[7].diffing;
      if (dirty & 128)
        diffhtmlview1_changes.selectedDiffContentMode = ctx2[7].diffContentMode;
      if (!updating_withStyle_1 && dirty & 1) {
        updating_withStyle_1 = true;
        diffhtmlview1_changes.withStyle = ctx2[0];
        add_flush_callback(() => updating_withStyle_1 = false);
      }
      if (!updating_goToNextDiff_1 && dirty & 32) {
        updating_goToNextDiff_1 = true;
        diffhtmlview1_changes.goToNextDiff = ctx2[5];
        add_flush_callback(() => updating_goToNextDiff_1 = false);
      }
      if (!updating_goToPrevDiff_1 && dirty & 64) {
        updating_goToPrevDiff_1 = true;
        diffhtmlview1_changes.goToPrevDiff = ctx2[6];
        add_flush_callback(() => updating_goToPrevDiff_1 = false);
      }
      diffhtmlview1.$set(diffhtmlview1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(navigatediff0.$$.fragment, local);
      transition_in(diffhtmlview0.$$.fragment, local);
      transition_in(if_block1);
      transition_in(navigatediff1.$$.fragment, local);
      transition_in(diffhtmlview1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(navigatediff0.$$.fragment, local);
      transition_out(diffhtmlview0.$$.fragment, local);
      transition_out(if_block1);
      transition_out(navigatediff1.$$.fragment, local);
      transition_out(diffhtmlview1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      destroy_component(navigatediff0);
      destroy_component(diffhtmlview0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div3);
      if (if_block1)
        if_block1.d();
      destroy_component(navigatediff1);
      destroy_component(diffhtmlview1);
    }
  };
}
function instance$40($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(7, $store = $$value));
  let { withStyle } = $$props;
  let showLoader1 = true;
  let showLoader2 = true;
  let view1GoToNextDiff, view1GoToPrevDiff, view2GoToNextDiff, view2GoToPrevDiff;
  function diffhtmlview0_withStyle_binding(value) {
    withStyle = value;
    $$invalidate(0, withStyle);
  }
  function diffhtmlview0_goToNextDiff_binding(value) {
    view1GoToNextDiff = value;
    $$invalidate(3, view1GoToNextDiff);
  }
  function diffhtmlview0_goToPrevDiff_binding(value) {
    view1GoToPrevDiff = value;
    $$invalidate(4, view1GoToPrevDiff);
  }
  const load_handler = () => $$invalidate(1, showLoader1 = false);
  function diffhtmlview1_withStyle_binding(value) {
    withStyle = value;
    $$invalidate(0, withStyle);
  }
  function diffhtmlview1_goToNextDiff_binding(value) {
    view2GoToNextDiff = value;
    $$invalidate(5, view2GoToNextDiff);
  }
  function diffhtmlview1_goToPrevDiff_binding(value) {
    view2GoToPrevDiff = value;
    $$invalidate(6, view2GoToPrevDiff);
  }
  const load_handler_1 = () => $$invalidate(2, showLoader2 = false);
  $$self.$$set = ($$props2) => {
    if ("withStyle" in $$props2)
      $$invalidate(0, withStyle = $$props2.withStyle);
  };
  return [
    withStyle,
    showLoader1,
    showLoader2,
    view1GoToNextDiff,
    view1GoToPrevDiff,
    view2GoToNextDiff,
    view2GoToPrevDiff,
    $store,
    diffhtmlview0_withStyle_binding,
    diffhtmlview0_goToNextDiff_binding,
    diffhtmlview0_goToPrevDiff_binding,
    load_handler,
    diffhtmlview1_withStyle_binding,
    diffhtmlview1_goToNextDiff_binding,
    diffhtmlview1_goToPrevDiff_binding,
    load_handler_1
  ];
}
class HTMLSideBySideDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$40, create_fragment$44, safe_not_equal, { withStyle: 0 });
  }
}
function create_else_block$1g(ctx) {
  let htmlsidebysidediff;
  let current;
  htmlsidebysidediff = new HTMLSideBySideDiff({
    props: { withStyle: ctx[1] }
  });
  return {
    c() {
      create_component(htmlsidebysidediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(htmlsidebysidediff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const htmlsidebysidediff_changes = {};
      if (dirty & 2)
        htmlsidebysidediff_changes.withStyle = ctx2[1];
      htmlsidebysidediff.$set(htmlsidebysidediff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(htmlsidebysidediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(htmlsidebysidediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(htmlsidebysidediff, detaching);
    }
  };
}
function create_if_block$2i(ctx) {
  let htmlinlinediff;
  let current;
  htmlinlinediff = new HTMLInlineDiff({
    props: { withStyle: ctx[1] }
  });
  return {
    c() {
      create_component(htmlinlinediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(htmlinlinediff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const htmlinlinediff_changes = {};
      if (dirty & 2)
        htmlinlinediff_changes.withStyle = ctx2[1];
      htmlinlinediff.$set(htmlinlinediff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(htmlinlinediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(htmlinlinediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(htmlinlinediff, detaching);
    }
  };
}
function create_fragment$43(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$2i, create_else_block$1g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex-grow flex min-h-full w-full");
      set_style(div, "height", "fit-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3$($$self, $$props, $$invalidate) {
  let { inlined } = $$props;
  let { withStyle } = $$props;
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
    if ("withStyle" in $$props2)
      $$invalidate(1, withStyle = $$props2.withStyle);
  };
  return [inlined, withStyle];
}
class ExploreHTMLDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3$, create_fragment$43, safe_not_equal, { inlined: 0, withStyle: 1 });
  }
}
function create_fragment$42(ctx) {
  let div;
  let iframe_1;
  let iframe_1_class_value;
  let iframe_1_scrolling_value;
  let iframe_1_style_value;
  return {
    c() {
      div = element("div");
      iframe_1 = element("iframe");
      attr(iframe_1, "title", "xml-diff");
      attr(iframe_1, "class", iframe_1_class_value = "w-full border-none " + ctx[3]);
      attr(iframe_1, "scrolling", iframe_1_scrolling_value = ctx[2] ? "" : "no");
      attr(iframe_1, "srcdoc", ctx[0]);
      attr(iframe_1, "style", iframe_1_style_value = "min-height:100px;" + ctx[4]);
      set_style(iframe_1, "height", ctx[6]);
      attr(div, "class", ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, iframe_1);
      ctx[20](iframe_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8 && iframe_1_class_value !== (iframe_1_class_value = "w-full border-none " + ctx2[3])) {
        attr(iframe_1, "class", iframe_1_class_value);
      }
      if (dirty[0] & 4 && iframe_1_scrolling_value !== (iframe_1_scrolling_value = ctx2[2] ? "" : "no")) {
        attr(iframe_1, "scrolling", iframe_1_scrolling_value);
      }
      if (dirty[0] & 1) {
        attr(iframe_1, "srcdoc", ctx2[0]);
      }
      if (dirty[0] & 16 && iframe_1_style_value !== (iframe_1_style_value = "min-height:100px;" + ctx2[4])) {
        attr(iframe_1, "style", iframe_1_style_value);
      }
      const style_changed = dirty[0] & 16;
      if (style_changed || dirty[0] & 80) {
        set_style(iframe_1, "height", ctx2[6]);
      }
      if (dirty[0] & 32) {
        attr(div, "class", ctx2[5]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[20](null);
    }
  };
}
const highlightClass$2 = "highlighted";
function getDiffNodes$1(parentEl, diffs, options = {}) {
  let { selector } = options;
  diffs.nodes = [];
  diffs.curr = null;
  diffs.nodes = Array.from(parentEl.querySelectorAll(selector));
}
function instance$3_($$self, $$props, $$invalidate) {
  let { oldData } = $$props;
  let { newData } = $$props;
  let { diff: diff2 } = $$props;
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { showInserted = true } = $$props;
  let { showRemoved = true } = $$props;
  let { snipped = false } = $$props;
  let { scrollToFirstDiff = false } = $$props;
  let { diffNavigation = false } = $$props;
  let { showScrollBar } = $$props;
  let { iframe } = $$props;
  let { iframeClass = "" } = $$props;
  let { iframeStyle = "" } = $$props;
  const goToNextDiff = () => goToDiff(STEP.NEXT);
  const goToPrevDiff = () => goToDiff(STEP.PREV);
  let { selectedDiffContentMode } = $$props;
  const dispatch = createEventDispatcher();
  const STEP = { NEXT: 1, PREV: -1 };
  const selector = generateSelector();
  let { class: classes = "" } = $$props;
  let iframeDocEl;
  let loaded = false;
  let height;
  let diffs = { nodes: [], curr: null };
  onMount(() => {
    $$invalidate(1, iframe.onload = onLoad, iframe);
  });
  function setIframeHeight() {
    const doc = iframe.contentWindow.document;
    const html2 = doc.documentElement;
    const body = doc.body;
    if (selectedDiffContentMode === C$1.DIFF_MODE_TEXT) {
      $$invalidate(6, height = Math.min(body.scrollHeight, html2.scrollHeight) + "px");
    } else {
      $$invalidate(6, height = Math.max(body.scrollHeight, html2.scrollHeight) + "px");
    }
  }
  function onLoad() {
    iframeDocEl = iframe.contentDocument.documentElement;
    if (diffNavigation) {
      getDiffNodes$1(iframeDocEl, diffs, { selector });
      if (scrollToFirstDiff) {
        goToFirstDiff();
      }
    }
    $$invalidate(19, loaded = true);
    dispatch("load");
  }
  function setDiffStyles() {
    if (selectedDiffContentMode !== C$1.DIFF_MODE_VISUAL) {
      let snipElements = iframeDocEl.querySelectorAll(".snip");
      snipElements.forEach((s) => {
        let nonDiffHideElement = s.previousElementSibling;
        let nonDiffHideElementExists = nonDiffHideElement && nonDiffHideElement.classList.contains("nonDiffHide");
        if (nonDiffHideElementExists) {
          if (snipped) {
            let clickHandler = function(event) {
              event.preventDefault();
              nonDiffHideElement.style.display = "inline";
              s.style.display = "none";
              setIframeHeight();
              s.removeEventListener("click", clickHandler);
            };
            s.addEventListener("click", clickHandler);
          } else {
            nonDiffHideElement.removeAttribute("style");
            s.removeAttribute("style");
          }
        }
      });
    }
    let styleEl = iframeDocEl.querySelector("style.xdistill");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.classList.add("xdistill");
      iframeDocEl.querySelector("body").appendChild(styleEl);
    }
    let content = `
      ${diffStyles}
      body{
        padding: 20px;
      }
      ins,del {
        text-decoration: none;
      }
      .highlighted {
        outline: blue solid 2px;
      }
     ${!showRemoved ? "del, .removed {display:none;}" : ""}
     ${!showInserted ? "ins, .inserted {display:none;}" : ""}
     ${snipped ? ".nonDiffHide{display:none;}" : ".snip{display:none;}"}
    `;
    styleEl.innerHTML = content;
    setIframeHeight();
  }
  async function getDiff2() {
    try {
      $$invalidate(0, { diff: diff2, additions, deletions } = await diffHTMLAndRender(oldData, newData, selectedDiffContentMode), diff2, $$invalidate(7, additions), $$invalidate(8, deletions));
    } catch (e) {
      console.error(e);
      $$invalidate(0, diff2 = htmlEscape(newData.data));
    }
  }
  function generateSelector() {
    const selectors = [];
    if (showInserted) {
      selectors.push("ins");
    }
    if (showRemoved) {
      selectors.push("del");
    }
    return selectors.join(",");
  }
  function goToFirstDiff() {
    const firstDiffEl = diffs.nodes[0];
    if (firstDiffEl) {
      diffs.curr = 0;
      firstDiffEl.scrollIntoView({ behaviour: "smooth", block: "center" });
      firstDiffEl.classList.add(highlightClass$2);
    }
  }
  function goToDiff(step) {
    let { nodes, curr } = diffs;
    const length = nodes.length;
    if (length === 0) {
      return;
    }
    if (curr === null) {
      if (step === STEP.NEXT) {
        curr = -1;
      } else {
        curr = length;
      }
    }
    let next2 = curr + step;
    if (next2 < 0) {
      next2 = length - 1;
    } else if (next2 >= length) {
      next2 = 0;
    }
    const currDiff = nodes[curr];
    const nextDiff = nodes[next2];
    currDiff == null ? void 0 : currDiff.classList.remove(highlightClass$2);
    nextDiff.classList.add(highlightClass$2);
    nextDiff.scrollIntoView({ behaviour: "smooth", block: "center" });
    diffs.curr = next2;
  }
  function iframe_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iframe = $$value;
      $$invalidate(1, iframe);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("oldData" in $$props2)
      $$invalidate(9, oldData = $$props2.oldData);
    if ("newData" in $$props2)
      $$invalidate(10, newData = $$props2.newData);
    if ("diff" in $$props2)
      $$invalidate(0, diff2 = $$props2.diff);
    if ("additions" in $$props2)
      $$invalidate(7, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(8, deletions = $$props2.deletions);
    if ("showInserted" in $$props2)
      $$invalidate(11, showInserted = $$props2.showInserted);
    if ("showRemoved" in $$props2)
      $$invalidate(12, showRemoved = $$props2.showRemoved);
    if ("snipped" in $$props2)
      $$invalidate(13, snipped = $$props2.snipped);
    if ("scrollToFirstDiff" in $$props2)
      $$invalidate(14, scrollToFirstDiff = $$props2.scrollToFirstDiff);
    if ("diffNavigation" in $$props2)
      $$invalidate(15, diffNavigation = $$props2.diffNavigation);
    if ("showScrollBar" in $$props2)
      $$invalidate(2, showScrollBar = $$props2.showScrollBar);
    if ("iframe" in $$props2)
      $$invalidate(1, iframe = $$props2.iframe);
    if ("iframeClass" in $$props2)
      $$invalidate(3, iframeClass = $$props2.iframeClass);
    if ("iframeStyle" in $$props2)
      $$invalidate(4, iframeStyle = $$props2.iframeStyle);
    if ("selectedDiffContentMode" in $$props2)
      $$invalidate(18, selectedDiffContentMode = $$props2.selectedDiffContentMode);
    if ("class" in $$props2)
      $$invalidate(5, classes = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1) {
      $$invalidate(19, loaded = false);
    }
    if ($$self.$$.dirty[0] & 263680) {
      oldData && newData && selectedDiffContentMode && getDiff2();
    }
    if ($$self.$$.dirty[0] & 538625) {
      loaded && setDiffStyles();
    }
  };
  return [
    diff2,
    iframe,
    showScrollBar,
    iframeClass,
    iframeStyle,
    classes,
    height,
    additions,
    deletions,
    oldData,
    newData,
    showInserted,
    showRemoved,
    snipped,
    scrollToFirstDiff,
    diffNavigation,
    goToNextDiff,
    goToPrevDiff,
    selectedDiffContentMode,
    loaded,
    iframe_1_binding
  ];
}
class DiffXmlView extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$3_,
      create_fragment$42,
      safe_not_equal,
      {
        oldData: 9,
        newData: 10,
        diff: 0,
        additions: 7,
        deletions: 8,
        showInserted: 11,
        showRemoved: 12,
        snipped: 13,
        scrollToFirstDiff: 14,
        diffNavigation: 15,
        showScrollBar: 2,
        iframe: 1,
        iframeClass: 3,
        iframeStyle: 4,
        goToNextDiff: 16,
        goToPrevDiff: 17,
        selectedDiffContentMode: 18,
        class: 5
      },
      null,
      [-1, -1]
    );
  }
  get goToNextDiff() {
    return this.$$.ctx[16];
  }
  get goToPrevDiff() {
    return this.$$.ctx[17];
  }
}
function create_fragment$41(ctx) {
  let div1;
  let div0;
  let navigatediff;
  let t;
  let diffxmlview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  navigatediff = new NavigateDiff({
    props: {
      class: "ml-5 bg-transparent",
      nextFn: ctx[1],
      prevFn: ctx[2]
    }
  });
  function diffxmlview_goToNextDiff_binding(value) {
    ctx[4](value);
  }
  function diffxmlview_goToPrevDiff_binding(value) {
    ctx[5](value);
  }
  let diffxmlview_props = {
    diff: ctx[3].diff,
    selectedDiffContentMode: ctx[0],
    scrollToFirstDiff: true,
    diffNavigation: true,
    class: "flex-grow pt-6"
  };
  if (ctx[1] !== void 0) {
    diffxmlview_props.goToNextDiff = ctx[1];
  }
  if (ctx[2] !== void 0) {
    diffxmlview_props.goToPrevDiff = ctx[2];
  }
  diffxmlview = new DiffXmlView({ props: diffxmlview_props });
  binding_callbacks.push(() => bind$1(diffxmlview, "goToNextDiff", diffxmlview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(diffxmlview, "goToPrevDiff", diffxmlview_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff.$$.fragment);
      t = space();
      create_component(diffxmlview.$$.fragment);
      attr(div0, "class", "flex justify-start sticky top-0");
      attr(div1, "class", "flex flex-column self-stretch flex-grow");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff, div0, null);
      append(div1, t);
      mount_component(diffxmlview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff_changes = {};
      if (dirty & 2)
        navigatediff_changes.nextFn = ctx2[1];
      if (dirty & 4)
        navigatediff_changes.prevFn = ctx2[2];
      navigatediff.$set(navigatediff_changes);
      const diffxmlview_changes = {};
      if (dirty & 8)
        diffxmlview_changes.diff = ctx2[3].diff;
      if (dirty & 1)
        diffxmlview_changes.selectedDiffContentMode = ctx2[0];
      if (!updating_goToNextDiff && dirty & 2) {
        updating_goToNextDiff = true;
        diffxmlview_changes.goToNextDiff = ctx2[1];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 4) {
        updating_goToPrevDiff = true;
        diffxmlview_changes.goToPrevDiff = ctx2[2];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffxmlview.$set(diffxmlview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff.$$.fragment, local);
      transition_in(diffxmlview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff.$$.fragment, local);
      transition_out(diffxmlview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff);
      destroy_component(diffxmlview);
    }
  };
}
function instance$3Z($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(3, $store = $$value));
  let { selectedDiffContentMode } = $$props;
  let goToNextDiff;
  let goToPrevDiff;
  function diffxmlview_goToNextDiff_binding(value) {
    goToNextDiff = value;
    $$invalidate(1, goToNextDiff);
  }
  function diffxmlview_goToPrevDiff_binding(value) {
    goToPrevDiff = value;
    $$invalidate(2, goToPrevDiff);
  }
  $$self.$$set = ($$props2) => {
    if ("selectedDiffContentMode" in $$props2)
      $$invalidate(0, selectedDiffContentMode = $$props2.selectedDiffContentMode);
  };
  return [
    selectedDiffContentMode,
    goToNextDiff,
    goToPrevDiff,
    $store,
    diffxmlview_goToNextDiff_binding,
    diffxmlview_goToPrevDiff_binding
  ];
}
class XmlInlineDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3Z, create_fragment$41, safe_not_equal, { selectedDiffContentMode: 0 });
  }
}
function create_fragment$40(ctx) {
  let div1;
  let div0;
  let navigatediff0;
  let t0;
  let diffxmlview0;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let t1;
  let div3;
  let div2;
  let navigatediff1;
  let t2;
  let diffxmlview1;
  let updating_goToNextDiff_1;
  let updating_goToPrevDiff_1;
  let current;
  navigatediff0 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[1],
      prevFn: ctx[2]
    }
  });
  function diffxmlview0_goToNextDiff_binding(value) {
    ctx[6](value);
  }
  function diffxmlview0_goToPrevDiff_binding(value) {
    ctx[7](value);
  }
  let diffxmlview0_props = {
    diff: ctx[5].diff,
    selectedDiffContentMode: ctx[0],
    showInserted: false,
    diffNavigation: true,
    class: "flex-grow pt-6"
  };
  if (ctx[1] !== void 0) {
    diffxmlview0_props.goToNextDiff = ctx[1];
  }
  if (ctx[2] !== void 0) {
    diffxmlview0_props.goToPrevDiff = ctx[2];
  }
  diffxmlview0 = new DiffXmlView({ props: diffxmlview0_props });
  binding_callbacks.push(() => bind$1(diffxmlview0, "goToNextDiff", diffxmlview0_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(diffxmlview0, "goToPrevDiff", diffxmlview0_goToPrevDiff_binding));
  navigatediff1 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[3],
      prevFn: ctx[4]
    }
  });
  function diffxmlview1_goToNextDiff_binding(value) {
    ctx[8](value);
  }
  function diffxmlview1_goToPrevDiff_binding(value) {
    ctx[9](value);
  }
  let diffxmlview1_props = {
    diff: ctx[5].diff,
    selectedDiffContentMode: ctx[0],
    showRemoved: false,
    diffNavigation: true,
    class: "flex-grow pt-6"
  };
  if (ctx[3] !== void 0) {
    diffxmlview1_props.goToNextDiff = ctx[3];
  }
  if (ctx[4] !== void 0) {
    diffxmlview1_props.goToPrevDiff = ctx[4];
  }
  diffxmlview1 = new DiffXmlView({ props: diffxmlview1_props });
  binding_callbacks.push(() => bind$1(diffxmlview1, "goToNextDiff", diffxmlview1_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(diffxmlview1, "goToPrevDiff", diffxmlview1_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff0.$$.fragment);
      t0 = space();
      create_component(diffxmlview0.$$.fragment);
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(navigatediff1.$$.fragment);
      t2 = space();
      create_component(diffxmlview1.$$.fragment);
      attr(div0, "class", "flex justify-start sticky bg-white top-0");
      attr(div1, "class", "flex-grow flex flex-column items-stretch");
      attr(div2, "class", "flex justify-start sticky bg-white top-0");
      attr(div3, "class", "flex-grow flex flex-column items-stretch");
      set_style(div3, "border-left", "2px solid black");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff0, div0, null);
      append(div1, t0);
      mount_component(diffxmlview0, div1, null);
      insert(target, t1, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      mount_component(navigatediff1, div2, null);
      append(div3, t2);
      mount_component(diffxmlview1, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff0_changes = {};
      if (dirty & 2)
        navigatediff0_changes.nextFn = ctx2[1];
      if (dirty & 4)
        navigatediff0_changes.prevFn = ctx2[2];
      navigatediff0.$set(navigatediff0_changes);
      const diffxmlview0_changes = {};
      if (dirty & 32)
        diffxmlview0_changes.diff = ctx2[5].diff;
      if (dirty & 1)
        diffxmlview0_changes.selectedDiffContentMode = ctx2[0];
      if (!updating_goToNextDiff && dirty & 2) {
        updating_goToNextDiff = true;
        diffxmlview0_changes.goToNextDiff = ctx2[1];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 4) {
        updating_goToPrevDiff = true;
        diffxmlview0_changes.goToPrevDiff = ctx2[2];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffxmlview0.$set(diffxmlview0_changes);
      const navigatediff1_changes = {};
      if (dirty & 8)
        navigatediff1_changes.nextFn = ctx2[3];
      if (dirty & 16)
        navigatediff1_changes.prevFn = ctx2[4];
      navigatediff1.$set(navigatediff1_changes);
      const diffxmlview1_changes = {};
      if (dirty & 32)
        diffxmlview1_changes.diff = ctx2[5].diff;
      if (dirty & 1)
        diffxmlview1_changes.selectedDiffContentMode = ctx2[0];
      if (!updating_goToNextDiff_1 && dirty & 8) {
        updating_goToNextDiff_1 = true;
        diffxmlview1_changes.goToNextDiff = ctx2[3];
        add_flush_callback(() => updating_goToNextDiff_1 = false);
      }
      if (!updating_goToPrevDiff_1 && dirty & 16) {
        updating_goToPrevDiff_1 = true;
        diffxmlview1_changes.goToPrevDiff = ctx2[4];
        add_flush_callback(() => updating_goToPrevDiff_1 = false);
      }
      diffxmlview1.$set(diffxmlview1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff0.$$.fragment, local);
      transition_in(diffxmlview0.$$.fragment, local);
      transition_in(navigatediff1.$$.fragment, local);
      transition_in(diffxmlview1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff0.$$.fragment, local);
      transition_out(diffxmlview0.$$.fragment, local);
      transition_out(navigatediff1.$$.fragment, local);
      transition_out(diffxmlview1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff0);
      destroy_component(diffxmlview0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div3);
      destroy_component(navigatediff1);
      destroy_component(diffxmlview1);
    }
  };
}
function instance$3Y($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(5, $store = $$value));
  let { selectedDiffContentMode } = $$props;
  let view1GoToNextDiff, view1GoToPrevDiff, view2GoToNextDiff, view2GoToPrevDiff;
  function diffxmlview0_goToNextDiff_binding(value) {
    view1GoToNextDiff = value;
    $$invalidate(1, view1GoToNextDiff);
  }
  function diffxmlview0_goToPrevDiff_binding(value) {
    view1GoToPrevDiff = value;
    $$invalidate(2, view1GoToPrevDiff);
  }
  function diffxmlview1_goToNextDiff_binding(value) {
    view2GoToNextDiff = value;
    $$invalidate(3, view2GoToNextDiff);
  }
  function diffxmlview1_goToPrevDiff_binding(value) {
    view2GoToPrevDiff = value;
    $$invalidate(4, view2GoToPrevDiff);
  }
  $$self.$$set = ($$props2) => {
    if ("selectedDiffContentMode" in $$props2)
      $$invalidate(0, selectedDiffContentMode = $$props2.selectedDiffContentMode);
  };
  return [
    selectedDiffContentMode,
    view1GoToNextDiff,
    view1GoToPrevDiff,
    view2GoToNextDiff,
    view2GoToPrevDiff,
    $store,
    diffxmlview0_goToNextDiff_binding,
    diffxmlview0_goToPrevDiff_binding,
    diffxmlview1_goToNextDiff_binding,
    diffxmlview1_goToPrevDiff_binding
  ];
}
class XmlSideBySideDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3Y, create_fragment$40, safe_not_equal, { selectedDiffContentMode: 0 });
  }
}
function create_else_block$1f(ctx) {
  let xmlsidebysidediff;
  let current;
  xmlsidebysidediff = new XmlSideBySideDiff({
    props: {
      selectedDiffContentMode: ctx[1]
    }
  });
  return {
    c() {
      create_component(xmlsidebysidediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(xmlsidebysidediff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const xmlsidebysidediff_changes = {};
      if (dirty & 2)
        xmlsidebysidediff_changes.selectedDiffContentMode = ctx2[1];
      xmlsidebysidediff.$set(xmlsidebysidediff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(xmlsidebysidediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(xmlsidebysidediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(xmlsidebysidediff, detaching);
    }
  };
}
function create_if_block$2h(ctx) {
  let xmlinlinediff;
  let current;
  xmlinlinediff = new XmlInlineDiff({
    props: {
      selectedDiffContentMode: ctx[1]
    }
  });
  return {
    c() {
      create_component(xmlinlinediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(xmlinlinediff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const xmlinlinediff_changes = {};
      if (dirty & 2)
        xmlinlinediff_changes.selectedDiffContentMode = ctx2[1];
      xmlinlinediff.$set(xmlinlinediff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(xmlinlinediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(xmlinlinediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(xmlinlinediff, detaching);
    }
  };
}
function create_fragment$3$(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$2h, create_else_block$1f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex-grow flex w-full min-h-full");
      set_style(div, "height", "fit-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3X($$self, $$props, $$invalidate) {
  let { inlined } = $$props;
  let { selectedDiffContentMode } = $$props;
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
    if ("selectedDiffContentMode" in $$props2)
      $$invalidate(1, selectedDiffContentMode = $$props2.selectedDiffContentMode);
  };
  return [inlined, selectedDiffContentMode];
}
class ExploreXmlDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3X, create_fragment$3$, safe_not_equal, { inlined: 0, selectedDiffContentMode: 1 });
  }
}
function create_fragment$3_(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "text");
      attr(input, "class", "form-control xform-control-sm p-1");
      attr(input, "placeholder", "Search...");
      attr(div, "class", "form-group mb-0 mr-6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[2]),
          listen(input, "input", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3W($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let phrase = "";
  function onInput() {
    dispatch("search", { phrase: phrase.trim() });
  }
  function input_input_handler() {
    phrase = this.value;
    $$invalidate(0, phrase);
  }
  return [phrase, onInput, input_input_handler];
}
class SearchBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3W, create_fragment$3_, safe_not_equal, {});
  }
}
var diff = "";
function get_each_context$11(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[46] = list[i2];
  child_ctx[48] = i2;
  return child_ctx;
}
function create_catch_block$z(ctx) {
  return { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };
}
function create_then_block$z(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ctx[11];
  const get_key = (ctx2) => ctx2[46].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$11(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$11(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$1e(ctx);
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64760) {
        each_value = ctx2[11];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$11, each_1_anchor, get_each_context$11);
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$1e(ctx2);
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_else_block$1e(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[10])
      return create_if_block_1$1r;
    return create_else_block_1$g;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block_1$g(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No URLs found </td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_if_block_1$1r(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No URLs found for this search query </td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_if_block$2g(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[46].url + "";
  let t0;
  let td0_title_value;
  let td0_class_value;
  let t1;
  let td1;
  let t2_value = ctx[46].status_code + "";
  let t2;
  let t3;
  let td2;
  let a;
  let t4_value = new Date(ctx[46].first_seen_on).toLocaleString() + "";
  let t4;
  let a_href_value;
  let t5;
  let checkRender_action;
  let mounted;
  let dispose;
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      a = element("a");
      t4 = text(t4_value);
      t5 = space();
      attr(td0, "title", td0_title_value = ctx[46].url);
      attr(td0, "class", td0_class_value = "" + ctx[14][ctx[46].diff_type] + " " + ctx[7]);
      attr(a, "href", a_href_value = urlCfg.crawlerJobDetail(ctx[12].team, ctx[13], ctx[46].first_job_id));
      attr(a, "target", "_blank");
      toggle_class(tr, "opacity-0", ctx[5] && ctx[46].diff_type === ctx[15].addition || ctx[4] && ctx[46].diff_type === ctx[15].deletion);
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, a);
      append(a, t4);
      append(tr, t5);
      if (!mounted) {
        dispose = action_destroyer(checkRender_action = ctx[17].call(null, tr, ctx[48]));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 2048 && t0_value !== (t0_value = ctx[46].url + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 2048 && td0_title_value !== (td0_title_value = ctx[46].url)) {
        attr(td0, "title", td0_title_value);
      }
      if (dirty[0] & 2176 && td0_class_value !== (td0_class_value = "" + ctx[14][ctx[46].diff_type] + " " + ctx[7])) {
        attr(td0, "class", td0_class_value);
      }
      if (dirty[0] & 2048 && t2_value !== (t2_value = ctx[46].status_code + ""))
        set_data(t2, t2_value);
      if (dirty[0] & 2048 && t4_value !== (t4_value = new Date(ctx[46].first_seen_on).toLocaleString() + ""))
        set_data(t4, t4_value);
      if (dirty[0] & 6144 && a_href_value !== (a_href_value = urlCfg.crawlerJobDetail(ctx[12].team, ctx[13], ctx[46].first_job_id))) {
        attr(a, "href", a_href_value);
      }
      if (checkRender_action && is_function(checkRender_action.update) && dirty[0] & 2048)
        checkRender_action.update.call(null, ctx[48]);
      if (dirty[0] & 34864) {
        toggle_class(tr, "opacity-0", ctx[5] && ctx[46].diff_type === ctx[15].addition || ctx[4] && ctx[46].diff_type === ctx[15].deletion);
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$11(key_1, ctx) {
  let first2;
  let if_block_anchor;
  let if_block = !(ctx[3] && ctx[46].diff_type === ctx[15].deletion || ctx[6] && ctx[46].diff_type === ctx[15].unchanged) && create_if_block$2g(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!(ctx[3] && ctx[46].diff_type === ctx[15].deletion || ctx[6] && ctx[46].diff_type === ctx[15].unchanged)) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$2g(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_pending_block$z(ctx) {
  return { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };
}
function create_fragment$3Z(ctx) {
  let div2;
  let div0;
  let searchbar;
  let t0;
  let button;
  let t1;
  let a;
  let t2;
  let a_href_value;
  let t3;
  let div1;
  let table;
  let thead;
  let t9;
  let tbody_1;
  let promise;
  let current;
  let mounted;
  let dispose;
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[16]);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$z,
    then: create_then_block$z,
    catch: create_catch_block$z,
    value: 45
  };
  handle_promise(promise = ctx[2], info);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(searchbar.$$.fragment);
      t0 = space();
      button = element("button");
      button.innerHTML = `<i class="fa fa-download"></i>`;
      t1 = space();
      a = element("a");
      t2 = text("Import Monitors");
      t3 = space();
      div1 = element("div");
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="bg-gray-200"><th>URL</th> 
          <th>Status Code</th> 
          <th>First Seen On</th></tr>`;
      t9 = space();
      tbody_1 = element("tbody");
      info.block.c();
      attr(button, "class", "btn btn-default btn-sm -ml-5");
      attr(button, "title", "download csv");
      attr(a, "class", "btn btn-default btn-sm ms-1 text-nowrap");
      attr(a, "href", a_href_value = urlCfg.crawlerDiffImport(ctx[12].team, ctx[13], ctx[0].job_id, ctx[1].job_id));
      attr(div0, "class", "mt-6 mb-2 w-[300px] pl-2 flex");
      attr(thead, "class", "table-light");
      attr(table, "class", "table");
      attr(div1, "id", "myTable");
      attr(div2, "class", ctx[8]);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(searchbar, div0, null);
      append(div0, t0);
      append(div0, button);
      append(div0, t1);
      append(div0, a);
      append(a, t2);
      append(div2, t3);
      append(div2, div1);
      append(div1, table);
      append(table, thead);
      append(table, t9);
      append(table, tbody_1);
      info.block.m(tbody_1, info.anchor = null);
      info.mount = () => tbody_1;
      info.anchor = null;
      ctx[32](tbody_1);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[18]);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & 4099 && a_href_value !== (a_href_value = urlCfg.crawlerDiffImport(ctx[12].team, ctx[13], ctx[0].job_id, ctx[1].job_id))) {
        attr(a, "href", a_href_value);
      }
      info.ctx = ctx;
      if (dirty[0] & 4 && promise !== (promise = ctx[2]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
      if (!current || dirty[0] & 256) {
        attr(div2, "class", ctx[8]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(searchbar);
      info.block.d();
      info.token = null;
      info = null;
      ctx[32](null);
      mounted = false;
      dispose();
    }
  };
}
const highlightClass$1 = "xhighlighted";
function removeHighlighting(node) {
  const highlightedEl = node.querySelector(`.${highlightClass$1}`);
  if (highlightedEl) {
    highlightedEl.classList.remove(highlightClass$1);
  }
}
function instance$3V($$self, $$props, $$invalidate) {
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(12, $params = $$value));
  let { oldModel } = $$props;
  let { model } = $$props;
  let { newData } = $$props;
  let { oldData } = $$props;
  let { diff: diff2 } = $$props;
  let { sitemapDiffpromise } = $$props;
  let { pruneDeletions = false } = $$props;
  let { hideDeletions = false } = $$props;
  let { hideAdditions = false } = $$props;
  let { snipped = false } = $$props;
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { scrollToFirstDiff = false } = $$props;
  let { diffNavigation = false } = $$props;
  let { diffView } = $$props;
  let { urlClass = "" } = $$props;
  const goToNextDiff = () => goToDiff(STEP.NEXT);
  const goToPrevDiff = () => goToDiff(STEP.PREV);
  if (typeof oldData === "string") {
    oldData = JSON.parse(oldData);
  }
  if (typeof newData === "string") {
    newData = JSON.parse(newData);
  }
  const crawlerId = newData == null ? void 0 : newData.crawler_id;
  const dispatch = createEventDispatcher();
  const STEP = { NEXT: 1, PREV: -1 };
  const selector = getSelector();
  const diffClass = {
    addition: "inserted",
    deletion: "removed",
    unchanged: ""
  };
  const diffType = {
    addition: "addition",
    deletion: "deletion",
    unchanged: "unchanged"
  };
  let tbody;
  let summary;
  let diffs = { nodes: [], curr: null };
  let filteredDiff;
  let init2 = diff2 ? true : false;
  let diffRendered = false;
  let searchPhrase = "";
  let { class: classes = "" } = $$props;
  let fullDiff = [];
  async function getDiff2(jobId1, jobId2) {
    try {
      $$invalidate(30, init2 = false);
      let diffEndpoint = `/crawlers/data/${crawlerId}/diff/${jobId1}`;
      if (jobId2) {
        diffEndpoint += `?id2=${jobId2}`;
      }
      const diffData = await Api.api(diffEndpoint);
      $$invalidate(29, { summary, diff: diff2 } = diffData, summary, $$invalidate(19, diff2));
      fullDiff = diff2;
      $$invalidate(11, filteredDiff = diff2);
      $$invalidate(30, init2 = true);
      dispatch("load");
      $$invalidate(20, diffView = diffData.summary);
    } catch (err) {
      console.error(`Error while generating diff for crawler:${crawlerId} : id1:${jobId1} -> id2:${jobId2}`, err);
    }
  }
  function filterDiff() {
    if (!searchPhrase) {
      $$invalidate(11, filteredDiff = diff2);
      return;
    }
    $$invalidate(11, filteredDiff = diff2.filter((diffData) => {
      if (hideAdditions && diffData.diff_type === diffType.addition || hideDeletions && diffData.diff_type === diffType.deletion) {
        return false;
      }
      return diffData.url.includes(searchPhrase);
    }));
  }
  function getSelector() {
    const selArr = [];
    if (!hideAdditions) {
      selArr.push(".inserted");
    }
    if (!hideDeletions) {
      selArr.push(".removed");
    }
    return selArr.join(",");
  }
  function goToDiff(step) {
    let { nodes, curr } = diffs;
    const length = nodes.length;
    if (length === 0) {
      return;
    }
    if (curr === null) {
      if (step === STEP.NEXT) {
        curr = -1;
      } else {
        curr = length;
      }
    }
    let next2 = curr + step;
    if (next2 < 0) {
      next2 = length - 1;
    } else if (next2 >= length) {
      next2 = 0;
    }
    const currDiff = nodes[curr];
    const nextDiff = nodes[next2];
    currDiff == null ? void 0 : currDiff.classList.remove(highlightClass$1);
    nextDiff.classList.add(highlightClass$1);
    nextDiff.scrollIntoView({ behaviour: "smooth", block: "center" });
    diffs.curr = next2;
  }
  function goToFirstDiff() {
    const firstDiffEl = diffs.nodes[0];
    if (firstDiffEl) {
      diffs.curr = 0;
      firstDiffEl.scrollIntoView({ behaviour: "smooth", block: "center" });
      firstDiffEl.classList.add(highlightClass$1);
    }
  }
  function getDiffNodes2(node, selector2) {
    diffs.nodes = [];
    diffs.curr = null;
    diffs.nodes = Array.from(node.querySelectorAll(selector2));
  }
  function onSearch(e) {
    $$invalidate(10, searchPhrase = e.detail.phrase);
    filterDiff();
  }
  function diffNavigationActions(node) {
    removeHighlighting(node);
    getDiffNodes2(node, selector);
    if (scrollToFirstDiff) {
      goToFirstDiff();
    }
    $$invalidate(31, diffRendered = false);
  }
  function checkRender(_2, index2) {
    if (index2 === filteredDiff.length - 1)
      $$invalidate(31, diffRendered = true);
    return {
      update: (index3) => {
        if (index3 === filteredDiff.length - 1) {
          $$invalidate(31, diffRendered = true);
        }
      }
    };
  }
  async function downloadCSV() {
    await sitemapDiffpromise;
    const headers = ["URL", "Content Type", "Status Code", "Diff Type"];
    const rows = fullDiff.map((d) => {
      return [d.url, d.content_type, d.status_code, d.diff_type];
    });
    const content = Papa.unparse([headers, ...rows]);
    const filename = `${crawlerId} diff export - ${format(new Date(), "hh-mm_yyyy-MM-dd")}.csv`;
    downloadBlob(content, filename);
  }
  function tbody_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tbody = $$value;
      $$invalidate(9, tbody);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("oldModel" in $$props2)
      $$invalidate(23, oldModel = $$props2.oldModel);
    if ("model" in $$props2)
      $$invalidate(24, model = $$props2.model);
    if ("newData" in $$props2)
      $$invalidate(0, newData = $$props2.newData);
    if ("oldData" in $$props2)
      $$invalidate(1, oldData = $$props2.oldData);
    if ("diff" in $$props2)
      $$invalidate(19, diff2 = $$props2.diff);
    if ("sitemapDiffpromise" in $$props2)
      $$invalidate(2, sitemapDiffpromise = $$props2.sitemapDiffpromise);
    if ("pruneDeletions" in $$props2)
      $$invalidate(3, pruneDeletions = $$props2.pruneDeletions);
    if ("hideDeletions" in $$props2)
      $$invalidate(4, hideDeletions = $$props2.hideDeletions);
    if ("hideAdditions" in $$props2)
      $$invalidate(5, hideAdditions = $$props2.hideAdditions);
    if ("snipped" in $$props2)
      $$invalidate(6, snipped = $$props2.snipped);
    if ("additions" in $$props2)
      $$invalidate(21, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(22, deletions = $$props2.deletions);
    if ("scrollToFirstDiff" in $$props2)
      $$invalidate(25, scrollToFirstDiff = $$props2.scrollToFirstDiff);
    if ("diffNavigation" in $$props2)
      $$invalidate(26, diffNavigation = $$props2.diffNavigation);
    if ("diffView" in $$props2)
      $$invalidate(20, diffView = $$props2.diffView);
    if ("urlClass" in $$props2)
      $$invalidate(7, urlClass = $$props2.urlClass);
    if ("class" in $$props2)
      $$invalidate(8, classes = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 536870912) {
      if (summary) {
        $$invalidate(21, { additions, deletions } = summary, additions, ($$invalidate(22, deletions), $$invalidate(29, summary)));
      }
    }
    if ($$self.$$.dirty[0] & 1048579) {
      oldData && newData && !diffView && $$invalidate(2, sitemapDiffpromise = getDiff2(newData.job_id, oldData.job_id));
    }
    if ($$self.$$.dirty[0] & 1074267248) {
      init2 && filterDiff();
    }
    if ($$self.$$.dirty[0] & 67109376 | $$self.$$.dirty[1] & 1) {
      tbody && diffNavigation && diffRendered && diffNavigationActions(tbody);
    }
  };
  return [
    newData,
    oldData,
    sitemapDiffpromise,
    pruneDeletions,
    hideDeletions,
    hideAdditions,
    snipped,
    urlClass,
    classes,
    tbody,
    searchPhrase,
    filteredDiff,
    $params,
    crawlerId,
    diffClass,
    diffType,
    onSearch,
    checkRender,
    downloadCSV,
    diff2,
    diffView,
    additions,
    deletions,
    oldModel,
    model,
    scrollToFirstDiff,
    diffNavigation,
    goToNextDiff,
    goToPrevDiff,
    summary,
    init2,
    diffRendered,
    tbody_1_binding
  ];
}
class DiffSitemapView extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$3V,
      create_fragment$3Z,
      safe_not_equal,
      {
        oldModel: 23,
        model: 24,
        newData: 0,
        oldData: 1,
        diff: 19,
        sitemapDiffpromise: 2,
        pruneDeletions: 3,
        hideDeletions: 4,
        hideAdditions: 5,
        snipped: 6,
        additions: 21,
        deletions: 22,
        scrollToFirstDiff: 25,
        diffNavigation: 26,
        diffView: 20,
        urlClass: 7,
        goToNextDiff: 27,
        goToPrevDiff: 28,
        class: 8
      },
      null,
      [-1, -1]
    );
  }
  get oldModel() {
    return this.$$.ctx[23];
  }
  set oldModel(oldModel) {
    this.$$set({ oldModel });
    flush();
  }
  get model() {
    return this.$$.ctx[24];
  }
  set model(model) {
    this.$$set({ model });
    flush();
  }
  get newData() {
    return this.$$.ctx[0];
  }
  set newData(newData) {
    this.$$set({ newData });
    flush();
  }
  get oldData() {
    return this.$$.ctx[1];
  }
  set oldData(oldData) {
    this.$$set({ oldData });
    flush();
  }
  get diff() {
    return this.$$.ctx[19];
  }
  set diff(diff2) {
    this.$$set({ diff: diff2 });
    flush();
  }
  get sitemapDiffpromise() {
    return this.$$.ctx[2];
  }
  set sitemapDiffpromise(sitemapDiffpromise) {
    this.$$set({ sitemapDiffpromise });
    flush();
  }
  get pruneDeletions() {
    return this.$$.ctx[3];
  }
  set pruneDeletions(pruneDeletions) {
    this.$$set({ pruneDeletions });
    flush();
  }
  get hideDeletions() {
    return this.$$.ctx[4];
  }
  set hideDeletions(hideDeletions) {
    this.$$set({ hideDeletions });
    flush();
  }
  get hideAdditions() {
    return this.$$.ctx[5];
  }
  set hideAdditions(hideAdditions) {
    this.$$set({ hideAdditions });
    flush();
  }
  get snipped() {
    return this.$$.ctx[6];
  }
  set snipped(snipped) {
    this.$$set({ snipped });
    flush();
  }
  get additions() {
    return this.$$.ctx[21];
  }
  set additions(additions) {
    this.$$set({ additions });
    flush();
  }
  get deletions() {
    return this.$$.ctx[22];
  }
  set deletions(deletions) {
    this.$$set({ deletions });
    flush();
  }
  get scrollToFirstDiff() {
    return this.$$.ctx[25];
  }
  set scrollToFirstDiff(scrollToFirstDiff) {
    this.$$set({ scrollToFirstDiff });
    flush();
  }
  get diffNavigation() {
    return this.$$.ctx[26];
  }
  set diffNavigation(diffNavigation) {
    this.$$set({ diffNavigation });
    flush();
  }
  get diffView() {
    return this.$$.ctx[20];
  }
  set diffView(diffView) {
    this.$$set({ diffView });
    flush();
  }
  get urlClass() {
    return this.$$.ctx[7];
  }
  set urlClass(urlClass) {
    this.$$set({ urlClass });
    flush();
  }
  get goToNextDiff() {
    return this.$$.ctx[27];
  }
  get goToPrevDiff() {
    return this.$$.ctx[28];
  }
  get class() {
    return this.$$.ctx[8];
  }
  set class(classes) {
    this.$$set({ class: classes });
    flush();
  }
}
function create_fragment$3Y(ctx) {
  let div1;
  let div0;
  let navigatediff;
  let t;
  let diffsitemapview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  navigatediff = new NavigateDiff({
    props: {
      nextFn: ctx[0],
      prevFn: ctx[1]
    }
  });
  function diffsitemapview_goToNextDiff_binding(value) {
    ctx[3](value);
  }
  function diffsitemapview_goToPrevDiff_binding(value) {
    ctx[4](value);
  }
  let diffsitemapview_props = {
    newData: ctx[2].data1.data,
    oldData: ctx[2].data2.data,
    scrollToFirstDiff: true,
    class: "flex-grow",
    urlClass: "truncate max-w-[50vw]",
    diff: ctx[2].diff,
    diffNavigation: true
  };
  if (ctx[0] !== void 0) {
    diffsitemapview_props.goToNextDiff = ctx[0];
  }
  if (ctx[1] !== void 0) {
    diffsitemapview_props.goToPrevDiff = ctx[1];
  }
  diffsitemapview = new DiffSitemapView({ props: diffsitemapview_props });
  binding_callbacks.push(() => bind$1(diffsitemapview, "goToNextDiff", diffsitemapview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(diffsitemapview, "goToPrevDiff", diffsitemapview_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff.$$.fragment);
      t = space();
      create_component(diffsitemapview.$$.fragment);
      attr(div0, "class", "flex mb-3 sticky top-0 bg-transparent");
      attr(div1, "class", "flex-grow pl-5 pr-5 flex flex-column");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff, div0, null);
      append(div1, t);
      mount_component(diffsitemapview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff_changes = {};
      if (dirty & 1)
        navigatediff_changes.nextFn = ctx2[0];
      if (dirty & 2)
        navigatediff_changes.prevFn = ctx2[1];
      navigatediff.$set(navigatediff_changes);
      const diffsitemapview_changes = {};
      if (dirty & 4)
        diffsitemapview_changes.newData = ctx2[2].data1.data;
      if (dirty & 4)
        diffsitemapview_changes.oldData = ctx2[2].data2.data;
      if (dirty & 4)
        diffsitemapview_changes.diff = ctx2[2].diff;
      if (!updating_goToNextDiff && dirty & 1) {
        updating_goToNextDiff = true;
        diffsitemapview_changes.goToNextDiff = ctx2[0];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 2) {
        updating_goToPrevDiff = true;
        diffsitemapview_changes.goToPrevDiff = ctx2[1];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffsitemapview.$set(diffsitemapview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff.$$.fragment, local);
      transition_in(diffsitemapview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff.$$.fragment, local);
      transition_out(diffsitemapview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff);
      destroy_component(diffsitemapview);
    }
  };
}
function instance$3U($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(2, $store = $$value));
  let goToNextDiff;
  let goToPrevDiff;
  function diffsitemapview_goToNextDiff_binding(value) {
    goToNextDiff = value;
    $$invalidate(0, goToNextDiff);
  }
  function diffsitemapview_goToPrevDiff_binding(value) {
    goToPrevDiff = value;
    $$invalidate(1, goToPrevDiff);
  }
  return [
    goToNextDiff,
    goToPrevDiff,
    $store,
    diffsitemapview_goToNextDiff_binding,
    diffsitemapview_goToPrevDiff_binding
  ];
}
class SitemapInlineDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3U, create_fragment$3Y, safe_not_equal, {});
  }
}
function create_fragment$3X(ctx) {
  let div1;
  let div0;
  let navigatediff0;
  let t0;
  let diffsitemapview0;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let t1;
  let div3;
  let div2;
  let navigatediff1;
  let t2;
  let diffsitemapview1;
  let updating_goToNextDiff_1;
  let updating_goToPrevDiff_1;
  let current;
  navigatediff0 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[0],
      prevFn: ctx[1]
    }
  });
  function diffsitemapview0_goToNextDiff_binding(value) {
    ctx[5](value);
  }
  function diffsitemapview0_goToPrevDiff_binding(value) {
    ctx[6](value);
  }
  let diffsitemapview0_props = {
    newData: ctx[4].data2.data,
    oldData: ctx[4].data1.data,
    diff: ctx[4].diff,
    hideAdditions: true,
    class: "flex-grow  max-w-[48vw]",
    urlClass: "truncate max-w-[40vw]",
    diffNavigation: true
  };
  if (ctx[0] !== void 0) {
    diffsitemapview0_props.goToNextDiff = ctx[0];
  }
  if (ctx[1] !== void 0) {
    diffsitemapview0_props.goToPrevDiff = ctx[1];
  }
  diffsitemapview0 = new DiffSitemapView({ props: diffsitemapview0_props });
  binding_callbacks.push(() => bind$1(diffsitemapview0, "goToNextDiff", diffsitemapview0_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(diffsitemapview0, "goToPrevDiff", diffsitemapview0_goToPrevDiff_binding));
  navigatediff1 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[2],
      prevFn: ctx[3]
    }
  });
  function diffsitemapview1_goToNextDiff_binding(value) {
    ctx[7](value);
  }
  function diffsitemapview1_goToPrevDiff_binding(value) {
    ctx[8](value);
  }
  let diffsitemapview1_props = {
    newData: ctx[4].data2.data,
    oldData: ctx[4].data1.data,
    diff: ctx[4].diff,
    hideDeletions: true,
    class: "flex-grow  max-w-[48vw]",
    diffNavigation: true,
    urlClass: "truncate max-w-[40vw]"
  };
  if (ctx[2] !== void 0) {
    diffsitemapview1_props.goToNextDiff = ctx[2];
  }
  if (ctx[3] !== void 0) {
    diffsitemapview1_props.goToPrevDiff = ctx[3];
  }
  diffsitemapview1 = new DiffSitemapView({ props: diffsitemapview1_props });
  binding_callbacks.push(() => bind$1(diffsitemapview1, "goToNextDiff", diffsitemapview1_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(diffsitemapview1, "goToPrevDiff", diffsitemapview1_goToPrevDiff_binding));
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(navigatediff0.$$.fragment);
      t0 = space();
      create_component(diffsitemapview0.$$.fragment);
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(navigatediff1.$$.fragment);
      t2 = space();
      create_component(diffsitemapview1.$$.fragment);
      attr(div0, "class", "flex justify-start sticky top-0");
      attr(div1, "class", "flex flex-column flex-1");
      attr(div2, "class", "flex justify-start sticky top-0");
      attr(div3, "class", "flex flex-column flex-1");
      set_style(div3, "border-left", "2px solid black");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(navigatediff0, div0, null);
      append(div1, t0);
      mount_component(diffsitemapview0, div1, null);
      insert(target, t1, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      mount_component(navigatediff1, div2, null);
      append(div3, t2);
      mount_component(diffsitemapview1, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const navigatediff0_changes = {};
      if (dirty & 1)
        navigatediff0_changes.nextFn = ctx2[0];
      if (dirty & 2)
        navigatediff0_changes.prevFn = ctx2[1];
      navigatediff0.$set(navigatediff0_changes);
      const diffsitemapview0_changes = {};
      if (dirty & 16)
        diffsitemapview0_changes.newData = ctx2[4].data2.data;
      if (dirty & 16)
        diffsitemapview0_changes.oldData = ctx2[4].data1.data;
      if (dirty & 16)
        diffsitemapview0_changes.diff = ctx2[4].diff;
      if (!updating_goToNextDiff && dirty & 1) {
        updating_goToNextDiff = true;
        diffsitemapview0_changes.goToNextDiff = ctx2[0];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 2) {
        updating_goToPrevDiff = true;
        diffsitemapview0_changes.goToPrevDiff = ctx2[1];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      diffsitemapview0.$set(diffsitemapview0_changes);
      const navigatediff1_changes = {};
      if (dirty & 4)
        navigatediff1_changes.nextFn = ctx2[2];
      if (dirty & 8)
        navigatediff1_changes.prevFn = ctx2[3];
      navigatediff1.$set(navigatediff1_changes);
      const diffsitemapview1_changes = {};
      if (dirty & 16)
        diffsitemapview1_changes.newData = ctx2[4].data2.data;
      if (dirty & 16)
        diffsitemapview1_changes.oldData = ctx2[4].data1.data;
      if (dirty & 16)
        diffsitemapview1_changes.diff = ctx2[4].diff;
      if (!updating_goToNextDiff_1 && dirty & 4) {
        updating_goToNextDiff_1 = true;
        diffsitemapview1_changes.goToNextDiff = ctx2[2];
        add_flush_callback(() => updating_goToNextDiff_1 = false);
      }
      if (!updating_goToPrevDiff_1 && dirty & 8) {
        updating_goToPrevDiff_1 = true;
        diffsitemapview1_changes.goToPrevDiff = ctx2[3];
        add_flush_callback(() => updating_goToPrevDiff_1 = false);
      }
      diffsitemapview1.$set(diffsitemapview1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(navigatediff0.$$.fragment, local);
      transition_in(diffsitemapview0.$$.fragment, local);
      transition_in(navigatediff1.$$.fragment, local);
      transition_in(diffsitemapview1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(navigatediff0.$$.fragment, local);
      transition_out(diffsitemapview0.$$.fragment, local);
      transition_out(navigatediff1.$$.fragment, local);
      transition_out(diffsitemapview1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(navigatediff0);
      destroy_component(diffsitemapview0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div3);
      destroy_component(navigatediff1);
      destroy_component(diffsitemapview1);
    }
  };
}
function instance$3T($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(4, $store = $$value));
  let view1GoToNextDiff;
  let view1GoToPrevDiff;
  let view2GoToNextDiff;
  let view2GoToPrevDiff;
  function diffsitemapview0_goToNextDiff_binding(value) {
    view1GoToNextDiff = value;
    $$invalidate(0, view1GoToNextDiff);
  }
  function diffsitemapview0_goToPrevDiff_binding(value) {
    view1GoToPrevDiff = value;
    $$invalidate(1, view1GoToPrevDiff);
  }
  function diffsitemapview1_goToNextDiff_binding(value) {
    view2GoToNextDiff = value;
    $$invalidate(2, view2GoToNextDiff);
  }
  function diffsitemapview1_goToPrevDiff_binding(value) {
    view2GoToPrevDiff = value;
    $$invalidate(3, view2GoToPrevDiff);
  }
  return [
    view1GoToNextDiff,
    view1GoToPrevDiff,
    view2GoToNextDiff,
    view2GoToPrevDiff,
    $store,
    diffsitemapview0_goToNextDiff_binding,
    diffsitemapview0_goToPrevDiff_binding,
    diffsitemapview1_goToNextDiff_binding,
    diffsitemapview1_goToPrevDiff_binding
  ];
}
class SitemapSideBySideDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3T, create_fragment$3X, safe_not_equal, {});
  }
}
function create_else_block$1d(ctx) {
  let sitemapsidebysidediff;
  let current;
  sitemapsidebysidediff = new SitemapSideBySideDiff({});
  return {
    c() {
      create_component(sitemapsidebysidediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sitemapsidebysidediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(sitemapsidebysidediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sitemapsidebysidediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sitemapsidebysidediff, detaching);
    }
  };
}
function create_if_block$2f(ctx) {
  let sitemapinlinediff;
  let current;
  sitemapinlinediff = new SitemapInlineDiff({});
  return {
    c() {
      create_component(sitemapinlinediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sitemapinlinediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(sitemapinlinediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sitemapinlinediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sitemapinlinediff, detaching);
    }
  };
}
function create_fragment$3W(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$2f, create_else_block$1d];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex items-stretch max-w-[100vw]");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3S($$self, $$props, $$invalidate) {
  let { inlined = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
  };
  return [inlined];
}
class ExploreSitemapDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3S, create_fragment$3W, safe_not_equal, { inlined: 0 });
  }
}
function get_each_context$10(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2];
  return child_ctx;
}
function create_else_block$1c(ctx) {
  let div;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$10(get_each_context$10(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      ctx[8](div);
    },
    p(ctx2, dirty) {
      if (dirty & 23) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$10(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$10(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      ctx[8](null);
    }
  };
}
function create_if_block$2e(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(ctx[0], target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        html_tag.p(ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_if_block_4$t(ctx) {
  var _a;
  let div1;
  let h6;
  let a;
  let raw0_value = ctx[10].title + "";
  let a_href_value;
  let t0;
  let t1;
  let t2;
  let div0;
  let raw1_value = (ctx[10].description || ctx[10].summary || "") + "";
  let t3;
  let div1_class_value;
  let if_block0 = ((_a = ctx[10]) == null ? void 0 : _a.label) && ctx[10].label !== "unchanged" && create_if_block_6$g(ctx);
  let if_block1 = (ctx[10].pubdate || ctx[10].date || ctx[10].published) && create_if_block_5$m(ctx);
  return {
    c() {
      div1 = element("div");
      h6 = element("h6");
      a = element("a");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div0 = element("div");
      t3 = space();
      attr(a, "class", "text-black");
      attr(a, "href", a_href_value = ctx[10].link);
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener noreferrer");
      attr(h6, "class", "mb-2");
      attr(div0, "class", "pt-3 mb-3 fs-6");
      attr(div1, "class", div1_class_value = "mb-3 border-bottom border-dark " + ctx[10].label);
      toggle_class(div1, "invisible", !ctx[4](ctx[10].label));
      toggle_class(div1, "visible", ctx[4](ctx[10].label));
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, h6);
      append(h6, a);
      a.innerHTML = raw0_value;
      append(h6, t0);
      if (if_block0)
        if_block0.m(h6, null);
      append(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      div0.innerHTML = raw1_value;
      append(div1, t3);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 1 && raw0_value !== (raw0_value = ctx2[10].title + ""))
        a.innerHTML = raw0_value;
      if (dirty & 1 && a_href_value !== (a_href_value = ctx2[10].link)) {
        attr(a, "href", a_href_value);
      }
      if (((_a2 = ctx2[10]) == null ? void 0 : _a2.label) && ctx2[10].label !== "unchanged") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$g(ctx2);
          if_block0.c();
          if_block0.m(h6, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[10].pubdate || ctx2[10].date || ctx2[10].published) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5$m(ctx2);
          if_block1.c();
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 1 && raw1_value !== (raw1_value = (ctx2[10].description || ctx2[10].summary || "") + ""))
        div0.innerHTML = raw1_value;
      if (dirty & 1 && div1_class_value !== (div1_class_value = "mb-3 border-bottom border-dark " + ctx2[10].label)) {
        attr(div1, "class", div1_class_value);
      }
      if (dirty & 17) {
        toggle_class(div1, "invisible", !ctx2[4](ctx2[10].label));
      }
      if (dirty & 17) {
        toggle_class(div1, "visible", ctx2[4](ctx2[10].label));
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_1$1q(ctx) {
  var _a;
  let div1;
  let h6;
  let a;
  let raw0_value = ctx[10].title + "";
  let a_href_value;
  let t0;
  let t1;
  let t2;
  let div0;
  let raw1_value = (ctx[10].description || ctx[10].summary || "") + "";
  let t3;
  let div1_class_value;
  let if_block0 = ((_a = ctx[10]) == null ? void 0 : _a.label) && ctx[10].label !== "unchanged" && create_if_block_3$J(ctx);
  let if_block1 = (ctx[10].pubdate || ctx[10].date || ctx[10].published) && create_if_block_2$V(ctx);
  return {
    c() {
      div1 = element("div");
      h6 = element("h6");
      a = element("a");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div0 = element("div");
      t3 = space();
      attr(a, "class", "text-black");
      attr(a, "href", a_href_value = ctx[10].link);
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener noreferrer");
      attr(h6, "class", "mb-2");
      attr(div0, "class", "pt-3 mb-3 fs-6");
      attr(div1, "class", div1_class_value = "mb-3 border-bottom border-dark " + ctx[10].label);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, h6);
      append(h6, a);
      a.innerHTML = raw0_value;
      append(h6, t0);
      if (if_block0)
        if_block0.m(h6, null);
      append(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t2);
      append(div1, div0);
      div0.innerHTML = raw1_value;
      append(div1, t3);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 1 && raw0_value !== (raw0_value = ctx2[10].title + ""))
        a.innerHTML = raw0_value;
      if (dirty & 1 && a_href_value !== (a_href_value = ctx2[10].link)) {
        attr(a, "href", a_href_value);
      }
      if (((_a2 = ctx2[10]) == null ? void 0 : _a2.label) && ctx2[10].label !== "unchanged") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$J(ctx2);
          if_block0.c();
          if_block0.m(h6, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[10].pubdate || ctx2[10].date || ctx2[10].published) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$V(ctx2);
          if_block1.c();
          if_block1.m(div1, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 1 && raw1_value !== (raw1_value = (ctx2[10].description || ctx2[10].summary || "") + ""))
        div0.innerHTML = raw1_value;
      if (dirty & 1 && div1_class_value !== (div1_class_value = "mb-3 border-bottom border-dark " + ctx2[10].label)) {
        attr(div1, "class", div1_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_6$g(ctx) {
  let span;
  let t_value = ctx[10].label + "";
  let t;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", span_class_value = "text-capitalize float-end badge text-" + getColor(ctx[10].label));
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[10].label + ""))
        set_data(t, t_value);
      if (dirty & 1 && span_class_value !== (span_class_value = "text-capitalize float-end badge text-" + getColor(ctx2[10].label))) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_5$m(ctx) {
  let div;
  let t_value = moment(ctx[10].pubdate || ctx[10].date || ctx[10].published).format("LLL") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "mb-1 text-body-tertiary");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = moment(ctx2[10].pubdate || ctx2[10].date || ctx2[10].published).format("LLL") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3$J(ctx) {
  let span;
  let t_value = ctx[10].label + "";
  let t;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", span_class_value = "text-capitalize float-end badge text-" + getColor(ctx[10].label));
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[10].label + ""))
        set_data(t, t_value);
      if (dirty & 1 && span_class_value !== (span_class_value = "text-capitalize float-end badge text-" + getColor(ctx2[10].label))) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2$V(ctx) {
  let div;
  let t_value = moment(ctx[10].pubdate || ctx[10].date || ctx[10].published).format("LLL") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "mb-1 text-body-tertiary");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = moment(ctx2[10].pubdate || ctx2[10].date || ctx2[10].published).format("LLL") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$10(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[2] && ctx2[10].label !== "deleted")
      return create_if_block_1$1q;
    if (ctx2[1])
      return create_if_block_4$t;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$3V(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (typeof ctx2[0] === "string")
      return create_if_block$2e;
    return create_else_block$1c;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function getColor(label) {
  const classes = {
    added: "success",
    updated: "secondary",
    deleted: "danger"
  };
  return `bg-${classes[label] || "dark"}`;
}
function instance$3R($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { feedItems } = $$props;
  let { showRemoved = false } = $$props;
  let { showDeletedEntries = false } = $$props;
  let { showInserted = true } = $$props;
  let imgLoadCount = 0;
  let imgs = [];
  let feedEl;
  onMount(() => {
    $$invalidate(7, imgs = feedEl == null ? void 0 : feedEl.querySelectorAll("img"));
    imgs == null ? void 0 : imgs.forEach((img) => ["load", "error"].forEach((evt) => img.addEventListener(evt, () => {
      $$invalidate(6, imgLoadCount++, imgLoadCount);
    })));
  });
  function showFeed(label) {
    return showRemoved && label !== "added" || showInserted && label === "added" || showDeletedEntries && label === "deleted";
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      feedEl = $$value;
      $$invalidate(3, feedEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("feedItems" in $$props2)
      $$invalidate(0, feedItems = $$props2.feedItems);
    if ("showRemoved" in $$props2)
      $$invalidate(5, showRemoved = $$props2.showRemoved);
    if ("showDeletedEntries" in $$props2)
      $$invalidate(1, showDeletedEntries = $$props2.showDeletedEntries);
    if ("showInserted" in $$props2)
      $$invalidate(2, showInserted = $$props2.showInserted);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 192) {
      if (imgLoadCount === (imgs == null ? void 0 : imgs.length)) {
        dispatch("load");
      }
    }
  };
  return [
    feedItems,
    showDeletedEntries,
    showInserted,
    feedEl,
    showFeed,
    showRemoved,
    imgLoadCount,
    imgs,
    div_binding
  ];
}
class FeedList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3R, create_fragment$3V, safe_not_equal, {
      feedItems: 0,
      showRemoved: 5,
      showDeletedEntries: 1,
      showInserted: 2
    });
  }
}
function create_fragment$3U(ctx) {
  let div;
  let iframe_1;
  let iframe_1_class_value;
  let iframe_1_scrolling_value;
  return {
    c() {
      div = element("div");
      iframe_1 = element("iframe");
      attr(iframe_1, "title", "Feed Diff");
      attr(iframe_1, "class", iframe_1_class_value = "w-full border-none " + ctx[1]);
      attr(iframe_1, "style", ctx[3]);
      attr(iframe_1, "scrolling", iframe_1_scrolling_value = ctx[2] ? "" : "no");
      attr(iframe_1, "srcdoc", `<html>
              <head>
                <link rel="stylesheet" href="lib/feeddiff.css">
                <style class="xdistill"></style>
              </head>
              <body></body>
              </html>`);
      set_style(iframe_1, "height", ctx[5]);
      attr(div, "class", ctx[4]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, iframe_1);
      ctx[22](iframe_1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && iframe_1_class_value !== (iframe_1_class_value = "w-full border-none " + ctx2[1])) {
        attr(iframe_1, "class", iframe_1_class_value);
      }
      if (dirty[0] & 8) {
        attr(iframe_1, "style", ctx2[3]);
      }
      if (dirty[0] & 4 && iframe_1_scrolling_value !== (iframe_1_scrolling_value = ctx2[2] ? "" : "no")) {
        attr(iframe_1, "scrolling", iframe_1_scrolling_value);
      }
      const style_changed = dirty[0] & 8;
      if (style_changed || dirty[0] & 40) {
        set_style(iframe_1, "height", ctx2[5]);
      }
      if (dirty[0] & 16) {
        attr(div, "class", ctx2[4]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[22](null);
    }
  };
}
const highlightClass = "xhighlighted";
function getDiffNodes(parentEl, diffs, options = {}) {
  let { selector } = options;
  diffs.nodes = [];
  diffs.curr = null;
  let allElements = parentEl.querySelectorAll(selector);
  diffs.nodes = Array.from(allElements).filter((element2) => {
    if (element2.classList.contains("added")) {
      return !element2.parentElement.classList.contains("added");
    }
    return true;
  });
}
function instance$3Q($$self, $$props, $$invalidate) {
  let { oldData } = $$props;
  let { newData } = $$props;
  let { diff: diff2 } = $$props;
  let { showInserted = true } = $$props;
  let { newFeedCount = 0 } = $$props;
  let { updatedFeedCount = 0 } = $$props;
  let { deletedFeedCount = 0 } = $$props;
  let { iframe } = $$props;
  let { iframeClass = "" } = $$props;
  let { showScrollBar } = $$props;
  let { iframeStyle = "" } = $$props;
  let { diffNavigation = false } = $$props;
  let { showRemoved = true } = $$props;
  let { showDeletedEntries = false } = $$props;
  let { snipped = false } = $$props;
  let { selectedDiffContentMode } = $$props;
  let { scrollToFirstDiff = false } = $$props;
  const goToNextDiff = () => goToDiff(STEP.NEXT);
  const goToPrevDiff = () => goToDiff(STEP.PREV);
  let diffs = { nodes: [], curr: null };
  const STEP = { NEXT: 1, PREV: -1 };
  let selector = "";
  if (showInserted) {
    selector = ".inserted, .added";
  } else if (showRemoved) {
    selector = ".removed";
  }
  const dispatch = createEventDispatcher();
  let iframeDocEl;
  let loaded = false;
  let feedView;
  let height;
  let loadOff;
  let { class: classes = "" } = $$props;
  onMount(() => {
    $$invalidate(0, iframe.onload = onLoad, iframe);
    iframe.addEventListener("load", onLoad);
    return () => {
      loadOff && loadOff();
      feedView && feedView.$destroy();
      iframe.removeEventListener("load", onLoad);
    };
  });
  function setIframeHeight() {
    const doc = iframe.contentWindow.document;
    const html2 = doc.documentElement;
    const body = doc.body;
    $$invalidate(5, height = Math.max(body.scrollHeight, body.offsetHeight, html2.clientHeight, html2.scrollHeight, html2.offsetHeight) + "px");
  }
  function showDiff() {
    feedView && feedView.$destroy();
    const feedViewProps = {
      target: iframeDocEl.querySelector("body"),
      props: { feedItems: diff2 }
    };
    feedViewProps.props.showRemoved = showRemoved;
    feedViewProps.props.showInserted = showInserted;
    feedViewProps.props.showDeletedEntries = showDeletedEntries;
    feedView = new FeedList(feedViewProps);
    getDiffNodes(iframeDocEl, diffs, { selector });
    setIframeHeight();
    loadOff = feedView.$on("load", setIframeHeight);
  }
  async function getDiff2(oldData2, newData2) {
    try {
      $$invalidate(6, { diff: diff2, newFeedCount, updatedFeedCount, deletedFeedCount } = await diffFeed(oldData2, newData2, selectedDiffContentMode), diff2, $$invalidate(7, newFeedCount), $$invalidate(8, updatedFeedCount), $$invalidate(9, deletedFeedCount));
    } catch (e) {
      console.error("Error in update feed: ", e);
      Msg.error("Error finding changes in feed");
    }
  }
  function setDiffStyles() {
    if (selectedDiffContentMode !== C$1.DIFF_MODE_VISUAL) {
      let snipElements = iframeDocEl.querySelectorAll(".snip");
      snipElements.forEach((s) => {
        let nonDiffHideElement = s.previousElementSibling;
        let nonDiffHideElementExists = nonDiffHideElement && nonDiffHideElement.classList.contains("nonDiffHide");
        if (nonDiffHideElementExists) {
          if (snipped) {
            let clickHandler = function(event) {
              event.preventDefault();
              nonDiffHideElement.style.display = "inline";
              s.style.display = "none";
              setIframeHeight();
              s.removeEventListener("click", clickHandler);
            };
            s.addEventListener("click", clickHandler);
          } else {
            nonDiffHideElement.removeAttribute("style");
            s.removeAttribute("style");
          }
        }
      });
    }
    const style = iframeDocEl.querySelector("style.xdistill");
    const styles = `
      ${diffStyles}
      img{
        margin-top:2px;
        margin-bottom:5px;
        max-width:100%;
        height:auto;
      }
      body{
        width:700px;
        margin:0 auto;
        padding:10px 10px;
      }
      ${!showRemoved ? "del, .removed, div.deleted{display:none;}" : ""}
      ${!showInserted ? "ins, .inserted{ display:none;}" : ""}
      ${snipped ? "body > div > div.unchanged,.nonDiffHide{display:none;}" : ".snip{display:none;}"}
      `;
    style.innerHTML = styles;
    setIframeHeight();
  }
  function goToDiff(step) {
    let { nodes, curr } = diffs;
    const length = nodes.length;
    if (length === 0) {
      return;
    }
    if (curr === null) {
      if (step === STEP.NEXT) {
        curr = -1;
      } else {
        curr = length;
      }
    }
    let next2 = curr + step;
    if (next2 < 0) {
      next2 = length - 1;
    } else if (next2 >= length) {
      next2 = 0;
    }
    const currDiff = nodes[curr];
    const nextDiff = nodes[next2];
    currDiff == null ? void 0 : currDiff.classList.remove(highlightClass);
    nextDiff.classList.add(highlightClass);
    nextDiff.scrollIntoView({ behaviour: "smooth", block: "center" });
    diffs.curr = next2;
  }
  async function onLoad() {
    iframeDocEl = iframe.contentDocument.documentElement;
    if (diffNavigation) {
      getDiffNodes(iframeDocEl, diffs, { selector });
      if (scrollToFirstDiff) {
        goToFirstDiff();
      }
    }
    $$invalidate(21, loaded = true);
    dispatch("load");
  }
  function goToFirstDiff() {
    const firstDiffEl = diffs.nodes[0];
    if (firstDiffEl) {
      diffs.curr = 0;
      firstDiffEl.scrollIntoView({ behaviour: "smooth", block: "center" });
      firstDiffEl.classList.add(highlightClass);
    }
  }
  function iframe_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iframe = $$value;
      $$invalidate(0, iframe);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("oldData" in $$props2)
      $$invalidate(10, oldData = $$props2.oldData);
    if ("newData" in $$props2)
      $$invalidate(11, newData = $$props2.newData);
    if ("diff" in $$props2)
      $$invalidate(6, diff2 = $$props2.diff);
    if ("showInserted" in $$props2)
      $$invalidate(12, showInserted = $$props2.showInserted);
    if ("newFeedCount" in $$props2)
      $$invalidate(7, newFeedCount = $$props2.newFeedCount);
    if ("updatedFeedCount" in $$props2)
      $$invalidate(8, updatedFeedCount = $$props2.updatedFeedCount);
    if ("deletedFeedCount" in $$props2)
      $$invalidate(9, deletedFeedCount = $$props2.deletedFeedCount);
    if ("iframe" in $$props2)
      $$invalidate(0, iframe = $$props2.iframe);
    if ("iframeClass" in $$props2)
      $$invalidate(1, iframeClass = $$props2.iframeClass);
    if ("showScrollBar" in $$props2)
      $$invalidate(2, showScrollBar = $$props2.showScrollBar);
    if ("iframeStyle" in $$props2)
      $$invalidate(3, iframeStyle = $$props2.iframeStyle);
    if ("diffNavigation" in $$props2)
      $$invalidate(13, diffNavigation = $$props2.diffNavigation);
    if ("showRemoved" in $$props2)
      $$invalidate(14, showRemoved = $$props2.showRemoved);
    if ("showDeletedEntries" in $$props2)
      $$invalidate(15, showDeletedEntries = $$props2.showDeletedEntries);
    if ("snipped" in $$props2)
      $$invalidate(16, snipped = $$props2.snipped);
    if ("selectedDiffContentMode" in $$props2)
      $$invalidate(17, selectedDiffContentMode = $$props2.selectedDiffContentMode);
    if ("scrollToFirstDiff" in $$props2)
      $$invalidate(18, scrollToFirstDiff = $$props2.scrollToFirstDiff);
    if ("class" in $$props2)
      $$invalidate(4, classes = $$props2.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 134144) {
      oldData && newData && selectedDiffContentMode && getDiff2(oldData, newData);
    }
    if ($$self.$$.dirty[0] & 2129984) {
      diff2 && loaded && showDiff();
    }
    if ($$self.$$.dirty[0] & 2183232) {
      loaded && setDiffStyles();
    }
  };
  return [
    iframe,
    iframeClass,
    showScrollBar,
    iframeStyle,
    classes,
    height,
    diff2,
    newFeedCount,
    updatedFeedCount,
    deletedFeedCount,
    oldData,
    newData,
    showInserted,
    diffNavigation,
    showRemoved,
    showDeletedEntries,
    snipped,
    selectedDiffContentMode,
    scrollToFirstDiff,
    goToNextDiff,
    goToPrevDiff,
    loaded,
    iframe_1_binding
  ];
}
class DiffFeedView extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$3Q,
      create_fragment$3U,
      safe_not_equal,
      {
        oldData: 10,
        newData: 11,
        diff: 6,
        showInserted: 12,
        newFeedCount: 7,
        updatedFeedCount: 8,
        deletedFeedCount: 9,
        iframe: 0,
        iframeClass: 1,
        showScrollBar: 2,
        iframeStyle: 3,
        diffNavigation: 13,
        showRemoved: 14,
        showDeletedEntries: 15,
        snipped: 16,
        selectedDiffContentMode: 17,
        scrollToFirstDiff: 18,
        goToNextDiff: 19,
        goToPrevDiff: 20,
        class: 4
      },
      null,
      [-1, -1]
    );
  }
  get goToNextDiff() {
    return this.$$.ctx[19];
  }
  get goToPrevDiff() {
    return this.$$.ctx[20];
  }
}
function create_if_block$2d(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3T(ctx) {
  let div1;
  let div0;
  let t0;
  let navigatediff;
  let t1;
  let difffeedview;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let current;
  let if_block = ctx[0] && create_if_block$2d();
  navigatediff = new NavigateDiff({
    props: {
      class: "ml-5 bg-transparent",
      nextFn: ctx[1],
      prevFn: ctx[2]
    }
  });
  function difffeedview_goToNextDiff_binding(value) {
    ctx[4](value);
  }
  function difffeedview_goToPrevDiff_binding(value) {
    ctx[5](value);
  }
  let difffeedview_props = {
    diff: ctx[3].diff,
    scrollToFirstDiff: true,
    diffNavigation: true,
    showDeletedEntries: true,
    class: "flex-grow pt-6"
  };
  if (ctx[1] !== void 0) {
    difffeedview_props.goToNextDiff = ctx[1];
  }
  if (ctx[2] !== void 0) {
    difffeedview_props.goToPrevDiff = ctx[2];
  }
  difffeedview = new DiffFeedView({ props: difffeedview_props });
  binding_callbacks.push(() => bind$1(difffeedview, "goToNextDiff", difffeedview_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(difffeedview, "goToPrevDiff", difffeedview_goToPrevDiff_binding));
  difffeedview.$on("load", ctx[6]);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      create_component(navigatediff.$$.fragment);
      t1 = space();
      create_component(difffeedview.$$.fragment);
      attr(div0, "class", "flex justify-start sticky top-0");
      attr(div1, "class", "flex flex-column self-stretch flex-grow");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div0, t0);
      mount_component(navigatediff, div0, null);
      append(div1, t1);
      mount_component(difffeedview, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2d();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const navigatediff_changes = {};
      if (dirty & 2)
        navigatediff_changes.nextFn = ctx2[1];
      if (dirty & 4)
        navigatediff_changes.prevFn = ctx2[2];
      navigatediff.$set(navigatediff_changes);
      const difffeedview_changes = {};
      if (dirty & 8)
        difffeedview_changes.diff = ctx2[3].diff;
      if (!updating_goToNextDiff && dirty & 2) {
        updating_goToNextDiff = true;
        difffeedview_changes.goToNextDiff = ctx2[1];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 4) {
        updating_goToPrevDiff = true;
        difffeedview_changes.goToPrevDiff = ctx2[2];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      difffeedview.$set(difffeedview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(navigatediff.$$.fragment, local);
      transition_in(difffeedview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(navigatediff.$$.fragment, local);
      transition_out(difffeedview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      destroy_component(navigatediff);
      destroy_component(difffeedview);
    }
  };
}
function instance$3P($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(3, $store = $$value));
  let showLoader = true;
  let goToNextDiff;
  let goToPrevDiff;
  function difffeedview_goToNextDiff_binding(value) {
    goToNextDiff = value;
    $$invalidate(1, goToNextDiff);
  }
  function difffeedview_goToPrevDiff_binding(value) {
    goToPrevDiff = value;
    $$invalidate(2, goToPrevDiff);
  }
  const load_handler = () => $$invalidate(0, showLoader = false);
  return [
    showLoader,
    goToNextDiff,
    goToPrevDiff,
    $store,
    difffeedview_goToNextDiff_binding,
    difffeedview_goToPrevDiff_binding,
    load_handler
  ];
}
class FeedInlineDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3P, create_fragment$3T, safe_not_equal, {});
  }
}
function create_if_block$2c(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3S(ctx) {
  let div1;
  let div0;
  let t0;
  let navigatediff0;
  let t1;
  let difffeedview0;
  let updating_goToNextDiff;
  let updating_goToPrevDiff;
  let t2;
  let div3;
  let div2;
  let navigatediff1;
  let t3;
  let difffeedview1;
  let updating_goToNextDiff_1;
  let updating_goToPrevDiff_1;
  let current;
  let if_block = ctx[4] && create_if_block$2c();
  navigatediff0 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[0],
      prevFn: ctx[1]
    }
  });
  function difffeedview0_goToNextDiff_binding(value) {
    ctx[6](value);
  }
  function difffeedview0_goToPrevDiff_binding(value) {
    ctx[7](value);
  }
  let difffeedview0_props = {
    diff: ctx[5].diff,
    showInserted: false,
    showDeletedEntries: true,
    diffNavigation: true,
    class: "flex-grow pt-6"
  };
  if (ctx[0] !== void 0) {
    difffeedview0_props.goToNextDiff = ctx[0];
  }
  if (ctx[1] !== void 0) {
    difffeedview0_props.goToPrevDiff = ctx[1];
  }
  difffeedview0 = new DiffFeedView({ props: difffeedview0_props });
  binding_callbacks.push(() => bind$1(difffeedview0, "goToNextDiff", difffeedview0_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(difffeedview0, "goToPrevDiff", difffeedview0_goToPrevDiff_binding));
  difffeedview0.$on("load", ctx[8]);
  navigatediff1 = new NavigateDiff({
    props: {
      class: "ml-5",
      nextFn: ctx[2],
      prevFn: ctx[3]
    }
  });
  function difffeedview1_goToNextDiff_binding(value) {
    ctx[9](value);
  }
  function difffeedview1_goToPrevDiff_binding(value) {
    ctx[10](value);
  }
  let difffeedview1_props = {
    diff: ctx[5].diff,
    showRemoved: false,
    diffNavigation: true,
    class: "flex-grow pt-6"
  };
  if (ctx[2] !== void 0) {
    difffeedview1_props.goToNextDiff = ctx[2];
  }
  if (ctx[3] !== void 0) {
    difffeedview1_props.goToPrevDiff = ctx[3];
  }
  difffeedview1 = new DiffFeedView({ props: difffeedview1_props });
  binding_callbacks.push(() => bind$1(difffeedview1, "goToNextDiff", difffeedview1_goToNextDiff_binding));
  binding_callbacks.push(() => bind$1(difffeedview1, "goToPrevDiff", difffeedview1_goToPrevDiff_binding));
  difffeedview1.$on("load", ctx[11]);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      create_component(navigatediff0.$$.fragment);
      t1 = space();
      create_component(difffeedview0.$$.fragment);
      t2 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(navigatediff1.$$.fragment);
      t3 = space();
      create_component(difffeedview1.$$.fragment);
      attr(div0, "class", "flex justify-start sticky bg-white top-0");
      attr(div1, "class", "flex-grow flex flex-column items-stretch");
      attr(div2, "class", "flex justify-start sticky bg-white top-0");
      attr(div3, "class", "flex-grow flex flex-column items-stretch border-2 border-start border-black");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div0, t0);
      mount_component(navigatediff0, div0, null);
      append(div1, t1);
      mount_component(difffeedview0, div1, null);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      mount_component(navigatediff1, div2, null);
      append(div3, t3);
      mount_component(difffeedview1, div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[4]) {
        if (if_block) {
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2c();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const navigatediff0_changes = {};
      if (dirty & 1)
        navigatediff0_changes.nextFn = ctx2[0];
      if (dirty & 2)
        navigatediff0_changes.prevFn = ctx2[1];
      navigatediff0.$set(navigatediff0_changes);
      const difffeedview0_changes = {};
      if (dirty & 32)
        difffeedview0_changes.diff = ctx2[5].diff;
      if (!updating_goToNextDiff && dirty & 1) {
        updating_goToNextDiff = true;
        difffeedview0_changes.goToNextDiff = ctx2[0];
        add_flush_callback(() => updating_goToNextDiff = false);
      }
      if (!updating_goToPrevDiff && dirty & 2) {
        updating_goToPrevDiff = true;
        difffeedview0_changes.goToPrevDiff = ctx2[1];
        add_flush_callback(() => updating_goToPrevDiff = false);
      }
      difffeedview0.$set(difffeedview0_changes);
      const navigatediff1_changes = {};
      if (dirty & 4)
        navigatediff1_changes.nextFn = ctx2[2];
      if (dirty & 8)
        navigatediff1_changes.prevFn = ctx2[3];
      navigatediff1.$set(navigatediff1_changes);
      const difffeedview1_changes = {};
      if (dirty & 32)
        difffeedview1_changes.diff = ctx2[5].diff;
      if (!updating_goToNextDiff_1 && dirty & 4) {
        updating_goToNextDiff_1 = true;
        difffeedview1_changes.goToNextDiff = ctx2[2];
        add_flush_callback(() => updating_goToNextDiff_1 = false);
      }
      if (!updating_goToPrevDiff_1 && dirty & 8) {
        updating_goToPrevDiff_1 = true;
        difffeedview1_changes.goToPrevDiff = ctx2[3];
        add_flush_callback(() => updating_goToPrevDiff_1 = false);
      }
      difffeedview1.$set(difffeedview1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(navigatediff0.$$.fragment, local);
      transition_in(difffeedview0.$$.fragment, local);
      transition_in(navigatediff1.$$.fragment, local);
      transition_in(difffeedview1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(navigatediff0.$$.fragment, local);
      transition_out(difffeedview0.$$.fragment, local);
      transition_out(navigatediff1.$$.fragment, local);
      transition_out(difffeedview1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      destroy_component(navigatediff0);
      destroy_component(difffeedview0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div3);
      destroy_component(navigatediff1);
      destroy_component(difffeedview1);
    }
  };
}
function instance$3O($$self, $$props, $$invalidate) {
  let $store;
  component_subscribe($$self, store, ($$value) => $$invalidate(5, $store = $$value));
  let view1GoToNextDiff, view1GoToPrevDiff, view2GoToNextDiff, view2GoToPrevDiff;
  let showLoader = true;
  function difffeedview0_goToNextDiff_binding(value) {
    view1GoToNextDiff = value;
    $$invalidate(0, view1GoToNextDiff);
  }
  function difffeedview0_goToPrevDiff_binding(value) {
    view1GoToPrevDiff = value;
    $$invalidate(1, view1GoToPrevDiff);
  }
  const load_handler = () => $$invalidate(4, showLoader = false);
  function difffeedview1_goToNextDiff_binding(value) {
    view2GoToNextDiff = value;
    $$invalidate(2, view2GoToNextDiff);
  }
  function difffeedview1_goToPrevDiff_binding(value) {
    view2GoToPrevDiff = value;
    $$invalidate(3, view2GoToPrevDiff);
  }
  const load_handler_1 = () => $$invalidate(4, showLoader = false);
  return [
    view1GoToNextDiff,
    view1GoToPrevDiff,
    view2GoToNextDiff,
    view2GoToPrevDiff,
    showLoader,
    $store,
    difffeedview0_goToNextDiff_binding,
    difffeedview0_goToPrevDiff_binding,
    load_handler,
    difffeedview1_goToNextDiff_binding,
    difffeedview1_goToPrevDiff_binding,
    load_handler_1
  ];
}
class FeedSideBySideDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3O, create_fragment$3S, safe_not_equal, {});
  }
}
function create_else_block$1b(ctx) {
  let feedsidebysidediff;
  let current;
  feedsidebysidediff = new FeedSideBySideDiff({});
  return {
    c() {
      create_component(feedsidebysidediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(feedsidebysidediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(feedsidebysidediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(feedsidebysidediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(feedsidebysidediff, detaching);
    }
  };
}
function create_if_block$2b(ctx) {
  let feedinlinediff;
  let current;
  feedinlinediff = new FeedInlineDiff({});
  return {
    c() {
      create_component(feedinlinediff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(feedinlinediff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(feedinlinediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(feedinlinediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(feedinlinediff, detaching);
    }
  };
}
function create_fragment$3R(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$2b, create_else_block$1b];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex-grow flex w-full min-h-full");
      set_style(div, "height", "fit-content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3N($$self, $$props, $$invalidate) {
  let { inlined } = $$props;
  $$self.$$set = ($$props2) => {
    if ("inlined" in $$props2)
      $$invalidate(0, inlined = $$props2.inlined);
  };
  return [inlined];
}
class ExploreFeedDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3N, create_fragment$3R, safe_not_equal, { inlined: 0 });
  }
}
function create_catch_block$y(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$y(ctx) {
  let explorediffheader;
  let updating_inlined;
  let updating_withStyle;
  let t;
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  function explorediffheader_inlined_binding(value) {
    ctx[13](value);
  }
  function explorediffheader_withStyle_binding(value) {
    ctx[14](value);
  }
  let explorediffheader_props = {
    class: "bb b--light-gray",
    promise: ctx[7],
    showStyleMode: ctx[6].type === C$1.TYPE_HTML,
    dataType: ctx[0],
    datasourceId: ctx[1],
    sieve: ctx[3]
  };
  if (ctx[4] !== void 0) {
    explorediffheader_props.inlined = ctx[4];
  }
  if (ctx[5] !== void 0) {
    explorediffheader_props.withStyle = ctx[5];
  }
  explorediffheader = new ExploreDiffHeader({ props: explorediffheader_props });
  binding_callbacks.push(() => bind$1(explorediffheader, "inlined", explorediffheader_inlined_binding));
  binding_callbacks.push(() => bind$1(explorediffheader, "withStyle", explorediffheader_withStyle_binding));
  explorediffheader.$on("close", ctx[8]);
  const if_block_creators = [create_if_block$2a, create_if_block_7$a];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6].diff)
      return 0;
    if (ctx2[6].errorMessage)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      create_component(explorediffheader.$$.fragment);
      t = space();
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "flex-grow bg-white pt2");
    },
    m(target, anchor) {
      mount_component(explorediffheader, target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      const explorediffheader_changes = {};
      if (dirty & 64)
        explorediffheader_changes.showStyleMode = ctx2[6].type === C$1.TYPE_HTML;
      if (dirty & 1)
        explorediffheader_changes.dataType = ctx2[0];
      if (dirty & 2)
        explorediffheader_changes.datasourceId = ctx2[1];
      if (dirty & 8)
        explorediffheader_changes.sieve = ctx2[3];
      if (!updating_inlined && dirty & 16) {
        updating_inlined = true;
        explorediffheader_changes.inlined = ctx2[4];
        add_flush_callback(() => updating_inlined = false);
      }
      if (!updating_withStyle && dirty & 32) {
        updating_withStyle = true;
        explorediffheader_changes.withStyle = ctx2[5];
        add_flush_callback(() => updating_withStyle = false);
      }
      explorediffheader.$set(explorediffheader_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(explorediffheader.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(explorediffheader.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(explorediffheader, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_7$a(ctx) {
  let div;
  let t0_value = ctx[6].errorMessage + "";
  let t0;
  let t1;
  let p;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      p = element("p");
      p.textContent = `${TXT("m_sieve_count_per_plan")}`;
      attr(p, "class", "help");
      attr(div, "class", "alert alert-danger ma3 ");
      attr(div, "role", "alert");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, p);
    },
    p(ctx2, dirty) {
      if (dirty & 64 && t0_value !== (t0_value = ctx2[6].errorMessage + ""))
        set_data(t0, t0_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$2a(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block_1$1p,
    create_if_block_2$U,
    create_if_block_4$s,
    create_if_block_5$l,
    create_if_block_6$f
  ];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (show_if == null)
      show_if = !!ctx2[9]();
    if (show_if)
      return 0;
    if (ctx2[6].type === C$1.TYPE_JSON)
      return 1;
    if (ctx2[6].type === C$1.TYPE_XML)
      return 2;
    if (ctx2[6].type === C$1.TYPE_SITEMAP)
      return 3;
    if (ctx2[6].type === C$1.TYPE_FEED)
      return 4;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_6$f(ctx) {
  let explorefeeddiff;
  let current;
  explorefeeddiff = new ExploreFeedDiff({ props: { inlined: ctx[4] } });
  return {
    c() {
      create_component(explorefeeddiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorefeeddiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorefeeddiff_changes = {};
      if (dirty & 16)
        explorefeeddiff_changes.inlined = ctx2[4];
      explorefeeddiff.$set(explorefeeddiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorefeeddiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorefeeddiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorefeeddiff, detaching);
    }
  };
}
function create_if_block_5$l(ctx) {
  let exploresitemapdiff;
  let current;
  exploresitemapdiff = new ExploreSitemapDiff({ props: { inlined: ctx[4] } });
  return {
    c() {
      create_component(exploresitemapdiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exploresitemapdiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exploresitemapdiff_changes = {};
      if (dirty & 16)
        exploresitemapdiff_changes.inlined = ctx2[4];
      exploresitemapdiff.$set(exploresitemapdiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(exploresitemapdiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exploresitemapdiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exploresitemapdiff, detaching);
    }
  };
}
function create_if_block_4$s(ctx) {
  let explorexmldiff;
  let current;
  explorexmldiff = new ExploreXmlDiff({
    props: {
      inlined: ctx[4],
      selectedDiffContentMode: ctx[6].diffContentMode
    }
  });
  return {
    c() {
      create_component(explorexmldiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorexmldiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorexmldiff_changes = {};
      if (dirty & 16)
        explorexmldiff_changes.inlined = ctx2[4];
      if (dirty & 64)
        explorexmldiff_changes.selectedDiffContentMode = ctx2[6].diffContentMode;
      explorexmldiff.$set(explorexmldiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorexmldiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorexmldiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorexmldiff, detaching);
    }
  };
}
function create_if_block_2$U(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$I, create_else_block$1a];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[6].diffContentMode === C$1.DIFF_MODE_DATA)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$1p(ctx) {
  let explorehtmldiff;
  let updating_withStyle;
  let current;
  function explorehtmldiff_withStyle_binding(value) {
    ctx[15](value);
  }
  let explorehtmldiff_props = { inlined: ctx[4] };
  if (ctx[5] !== void 0) {
    explorehtmldiff_props.withStyle = ctx[5];
  }
  explorehtmldiff = new ExploreHTMLDiff({ props: explorehtmldiff_props });
  binding_callbacks.push(() => bind$1(explorehtmldiff, "withStyle", explorehtmldiff_withStyle_binding));
  return {
    c() {
      create_component(explorehtmldiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorehtmldiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorehtmldiff_changes = {};
      if (dirty & 16)
        explorehtmldiff_changes.inlined = ctx2[4];
      if (!updating_withStyle && dirty & 32) {
        updating_withStyle = true;
        explorehtmldiff_changes.withStyle = ctx2[5];
        add_flush_callback(() => updating_withStyle = false);
      }
      explorehtmldiff.$set(explorehtmldiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorehtmldiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorehtmldiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorehtmldiff, detaching);
    }
  };
}
function create_else_block$1a(ctx) {
  let explorehtmldiff;
  let updating_withStyle;
  let current;
  function explorehtmldiff_withStyle_binding_1(value) {
    ctx[16](value);
  }
  let explorehtmldiff_props = { inlined: ctx[4] };
  if (ctx[5] !== void 0) {
    explorehtmldiff_props.withStyle = ctx[5];
  }
  explorehtmldiff = new ExploreHTMLDiff({ props: explorehtmldiff_props });
  binding_callbacks.push(() => bind$1(explorehtmldiff, "withStyle", explorehtmldiff_withStyle_binding_1));
  return {
    c() {
      create_component(explorehtmldiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorehtmldiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorehtmldiff_changes = {};
      if (dirty & 16)
        explorehtmldiff_changes.inlined = ctx2[4];
      if (!updating_withStyle && dirty & 32) {
        updating_withStyle = true;
        explorehtmldiff_changes.withStyle = ctx2[5];
        add_flush_callback(() => updating_withStyle = false);
      }
      explorehtmldiff.$set(explorehtmldiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorehtmldiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorehtmldiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorehtmldiff, detaching);
    }
  };
}
function create_if_block_3$I(ctx) {
  let explorejsondiff;
  let current;
  explorejsondiff = new ExploreJSONDiff({ props: { inlined: ctx[4] } });
  return {
    c() {
      create_component(explorejsondiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorejsondiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorejsondiff_changes = {};
      if (dirty & 16)
        explorejsondiff_changes.inlined = ctx2[4];
      explorejsondiff.$set(explorejsondiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorejsondiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorejsondiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorejsondiff, detaching);
    }
  };
}
function create_pending_block$y(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3Q(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$y,
    then: create_then_block$y,
    catch: create_catch_block$y,
    value: 20,
    blocks: [, , ,]
  };
  handle_promise(ctx[7], info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "flex flex-column h-screen");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$3M($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop$1, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store2, ($$value) => $$invalidate(6, $store = $$value)), store2);
  let $sieve, $$unsubscribe_sieve = noop$1, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(17, $sieve = $$value)), sieve);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  const dispatch = createEventDispatcher();
  let { sieveId } = $$props;
  let { sieveDataId1 } = $$props;
  let { sieveDataId2 } = $$props;
  let dataType;
  let datasourceId;
  let store2;
  let sieve;
  let inlined = false;
  let withStyle = true;
  let initPromise = init2();
  async function init2() {
    $$subscribe_store($$invalidate(2, store2 = initStore()));
    $$subscribe_sieve($$invalidate(3, sieve = new Model$2.Sieve({ id: sieveId })));
    await sieve.fetch();
    $$invalidate(0, dataType = $sieve.content_type);
    $$invalidate(1, datasourceId = $sieve.datasource_id);
    store2.updateStore({ type: dataType, uri: $sieve.uri, sieve });
    await store2.fetchSieveData(sieveDataId1, sieveDataId2);
    dispatch("sieve", sieve);
  }
  function onClose() {
    dispatch("close");
  }
  function isHTML() {
    return [C$1.TYPE_DOC, C$1.TYPE_HTML, C$1.TYPE_PDF_HTML].includes($store.type);
  }
  onDestroy(() => {
    destroyStore();
  });
  function explorediffheader_inlined_binding(value) {
    inlined = value;
    $$invalidate(4, inlined);
  }
  function explorediffheader_withStyle_binding(value) {
    withStyle = value;
    $$invalidate(5, withStyle);
  }
  function explorehtmldiff_withStyle_binding(value) {
    withStyle = value;
    $$invalidate(5, withStyle);
  }
  function explorehtmldiff_withStyle_binding_1(value) {
    withStyle = value;
    $$invalidate(5, withStyle);
  }
  $$self.$$set = ($$props2) => {
    if ("sieveId" in $$props2)
      $$invalidate(10, sieveId = $$props2.sieveId);
    if ("sieveDataId1" in $$props2)
      $$invalidate(11, sieveDataId1 = $$props2.sieveDataId1);
    if ("sieveDataId2" in $$props2)
      $$invalidate(12, sieveDataId2 = $$props2.sieveDataId2);
  };
  return [
    dataType,
    datasourceId,
    store2,
    sieve,
    inlined,
    withStyle,
    $store,
    initPromise,
    onClose,
    isHTML,
    sieveId,
    sieveDataId1,
    sieveDataId2,
    explorediffheader_inlined_binding,
    explorediffheader_withStyle_binding,
    explorehtmldiff_withStyle_binding,
    explorehtmldiff_withStyle_binding_1
  ];
}
class ExploreDiff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3M, create_fragment$3Q, safe_not_equal, {
      sieveId: 10,
      sieveDataId1: 11,
      sieveDataId2: 12
    });
  }
}
function create_default_slot$1f(ctx) {
  let a;
  let h3;
  let t0_value = (ctx[2] && ctx[3].name) + "";
  let t0;
  let a_href_value;
  let t1;
  let explorediff;
  let current;
  explorediff = new ExploreDiff({
    props: {
      sieveId: ctx[0],
      sieveDataId1: ctx[4],
      sieveDataId2: ctx[1]
    }
  });
  explorediff.$on("sieve", ctx[6]);
  return {
    c() {
      a = element("a");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = space();
      create_component(explorediff.$$.fragment);
      attr(h3, "class", "ph3 mt-3 mb-2");
      attr(a, "href", a_href_value = urlCfg.sievePage(ctx[2] && ctx[3].id));
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, h3);
      append(h3, t0);
      insert(target, t1, anchor);
      mount_component(explorediff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 12) && t0_value !== (t0_value = (ctx2[2] && ctx2[3].name) + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 12 && a_href_value !== (a_href_value = urlCfg.sievePage(ctx2[2] && ctx2[3].id))) {
        attr(a, "href", a_href_value);
      }
      const explorediff_changes = {};
      if (dirty & 1)
        explorediff_changes.sieveId = ctx2[0];
      if (dirty & 2)
        explorediff_changes.sieveDataId2 = ctx2[1];
      explorediff.$set(explorediff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorediff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorediff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (detaching)
        detach(t1);
      destroy_component(explorediff, detaching);
    }
  };
}
function create_topbar_slot$7(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Changes" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$3P(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$7],
        default: [create_default_slot$1f]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 271) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$3L($$self, $$props, $$invalidate) {
  let $querystring;
  let $sieveStore, $$unsubscribe_sieveStore = noop$1, $$subscribe_sieveStore = () => ($$unsubscribe_sieveStore(), $$unsubscribe_sieveStore = subscribe(sieveStore, ($$value) => $$invalidate(3, $sieveStore = $$value)), sieveStore);
  component_subscribe($$self, querystring, ($$value) => $$invalidate(7, $querystring = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieveStore());
  let { params: params2 = {} } = $$props;
  let { sieveId = params2.sieveId } = $$props;
  Api.setIdentityId(params2.team == 0 ? null : params2.team);
  let sieveDataId1 = params2.dataId, sieveDataId2 = null;
  if ($querystring) {
    const searchParams = new URLSearchParams($querystring);
    sieveDataId2 = searchParams.has("d2") && searchParams.get("d2");
  }
  let sieveStore;
  const sieve_handler = (e) => $$subscribe_sieveStore($$invalidate(2, sieveStore = e.detail));
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(5, params2 = $$props2.params);
    if ("sieveId" in $$props2)
      $$invalidate(0, sieveId = $$props2.sieveId);
  };
  return [
    sieveId,
    sieveDataId2,
    sieveStore,
    $sieveStore,
    sieveDataId1,
    params2,
    sieve_handler
  ];
}
class Explore_diff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3L, create_fragment$3P, safe_not_equal, { params: 5, sieveId: 0 });
  }
}
function create_if_block$29(ctx) {
  let div7;
  let div0;
  let t1;
  let div6;
  let div5;
  let div1;
  let t2_value = (ctx[0].get("err").code || "NA") + "";
  let t2;
  let t3;
  let pre;
  let t5;
  let div4;
  let strong0;
  let t7;
  let show_if;
  let show_if_1;
  let show_if_2;
  let show_if_3;
  let show_if_4;
  let t8;
  let div3;
  function select_block_type(ctx2, dirty) {
    if (dirty & 1)
      show_if = null;
    if (dirty & 1)
      show_if_1 = null;
    if (dirty & 1)
      show_if_2 = null;
    if (dirty & 1)
      show_if_3 = null;
    if (dirty & 1)
      show_if_4 = null;
    if (show_if == null)
      show_if = !!(ctx2[0].get("err").code === "SELECTION_EMPTY");
    if (show_if)
      return create_if_block_1$1o;
    if (show_if_1 == null)
      show_if_1 = !!(ctx2[0].get("err").code === "EPROXY");
    if (show_if_1)
      return create_if_block_2$T;
    if (show_if_2 == null)
      show_if_2 = !!(ctx2[0].get("err").code === "EMACRO");
    if (show_if_2)
      return create_if_block_3$H;
    if (show_if_3 == null)
      show_if_3 = !!(ctx2[0].get("err").code === "TIMEOUT" || ctx2[0].get("err").code === "ENOTFOUND" || ctx2[0].get("err").code === "EREQUEST" || ctx2[0].get("err").code === "ETIMEDOUT" || ctx2[0].get("err").code === "ECONNREFUSED");
    if (show_if_3)
      return create_if_block_4$r;
    if (show_if_4 == null)
      show_if_4 = !!(ctx2[0].get("err").code === "JAVASCRIPT");
    if (show_if_4)
      return create_if_block_5$k;
    return create_else_block$19;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div7 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3 class="card-title">Error Details</h3>`;
      t1 = space();
      div6 = element("div");
      div5 = element("div");
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      pre = element("pre");
      pre.textContent = `${ctx[1]()}`;
      t5 = space();
      div4 = element("div");
      strong0 = element("strong");
      strong0.textContent = "Recommended Actions";
      t7 = space();
      if_block.c();
      t8 = space();
      div3 = element("div");
      div3.innerHTML = `<strong>Need Help?</strong> 
            <div>Contact us at support@distill.io</div>`;
      attr(div0, "class", "card-header text-danger");
      attr(div1, "class", "mb-1");
      attr(pre, "class", "card-footer");
      attr(div3, "class", "pt1");
      attr(div4, "class", "pt1");
      attr(div5, "data-id", "error");
      attr(div6, "class", "card-body overflow-scroll");
      attr(div7, "class", "card");
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div0);
      append(div7, t1);
      append(div7, div6);
      append(div6, div5);
      append(div5, div1);
      append(div1, t2);
      append(div5, t3);
      append(div5, pre);
      append(div5, t5);
      append(div5, div4);
      append(div4, strong0);
      append(div4, t7);
      if_block.m(div4, null);
      append(div4, t8);
      append(div4, div3);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t2_value !== (t2_value = (ctx2[0].get("err").code || "NA") + ""))
        set_data(t2, t2_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div4, t8);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div7);
      if_block.d();
    }
  };
}
function create_else_block$19(ctx) {
  let show_if = ctx[0].get("err").status === 0;
  let t0;
  let div;
  let if_block = show_if && create_if_block_6$e();
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      div = element("div");
      div.textContent = "There is no information about this error.";
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = ctx2[0].get("err").status === 0;
      if (show_if) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_6$e();
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_5$k(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Ensure that JavaScript is working in the page.";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4$r(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Please ensure that the webpage is accessible.";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3$H(ctx) {
  let div;
  let t0_value = (prepareEMacroErrorMessage(ctx[0]) || "") + "";
  let t0;
  let t1;
  let a;
  let t3;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      a = element("a");
      a.textContent = "Macro: Record and Replay Automated Actions";
      t3 = text(".");
      attr(a, "href", "https://distill.io/docs/web-monitor/macro-to-record-replay-actions/");
      attr(div, "class", "");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, a);
      append(div, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = (prepareEMacroErrorMessage(ctx2[0]) || "") + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$T(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `Please consider using a different proxy:

                <a href="https://distill.io/docs/web-monitor/monitor-webpage-using-proxy-servers/">Using proxy servers for checks</a>.`;
      attr(div, "class", "");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$1o(ctx) {
  let ul;
  return {
    c() {
      ul = element("ul");
      ul.innerHTML = `<li>Ensure that selected elements has text content.</li> 
              <li>If website needs login, make sure that you are logged in.</li>`;
      attr(ul, "class", "pl3");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(ul);
    }
  };
}
function create_if_block_6$e(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Ensure that internet connection is working.";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$3O(ctx) {
  let show_if = ctx[0].get("err");
  let if_block_anchor;
  let if_block = show_if && create_if_block$29(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        show_if = ctx2[0].get("err");
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$29(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function prepareEMacroErrorMessage(workStore) {
  if (workStore.get("err").code !== "EMACRO") {
    return;
  }
  if (!workStore.get("err").step) {
    return;
  }
  const stepType = workStore.get("err").step;
  switch (stepType.type) {
    case "KEYPRESS": {
      return "KEYPRESS is not supported in this device type. Please use a supported device for this monitor and retry";
    }
  }
}
function instance$3K($$self, $$props, $$invalidate) {
  let $workStore, $$unsubscribe_workStore = noop$1, $$subscribe_workStore = () => ($$unsubscribe_workStore(), $$unsubscribe_workStore = subscribe(workStore, ($$value) => $$invalidate(2, $workStore = $$value)), workStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_workStore());
  let { workStore } = $$props;
  $$subscribe_workStore();
  function getErrorDescription() {
    var _a, _b;
    const error2 = $workStore.err;
    let description = (_b = (_a = error2.msg) != null ? _a : error2.message) != null ? _b : JSON.stringify(error2);
    if (error2.stackLineNames) {
      for (const stackLine of error2.stackEx.slice().reverse()) {
        let lineStr = stackLine.__name__;
        if (stackLine.type) {
          lineStr = `${lineStr} - ${stackLine.type}`;
        }
        if (stackLine.name) {
          lineStr = `${stackLine.name}(${lineStr})`;
        }
        description = `${description}
  ${lineStr}`;
      }
    }
    return description;
  }
  $$self.$$set = ($$props2) => {
    if ("workStore" in $$props2)
      $$subscribe_workStore($$invalidate(0, workStore = $$props2.workStore));
  };
  return [workStore, getErrorDescription];
}
class Error$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3K, create_fragment$3O, safe_not_equal, { workStore: 0 });
  }
}
var replay = "";
function id(prefix = "", seed = 0) {
  return () => `${prefix}${seed++}`;
}
const CLIENT_VERSION = "2.6.22";
const isHttps = (host) => {
  if (typeof window !== "undefined") {
    return !(window.location.protocol == "http:" && host.startsWith("localhost:"));
  }
  return !host.startsWith("localhost:");
};
const idFn = id("_");
class APIError extends Error {
  constructor(e) {
    var _a;
    super((_a = e.message) != null ? _a : e.msg);
    this.code = e.code;
  }
}
class APIClient extends EventEmitter {
  constructor(options) {
    super();
    this.messageListeners = [];
    this.messageQueue = [];
    this._responseListeners = /* @__PURE__ */ new Map();
    if (!options.basePath) {
      options.basePath = "";
    }
    this.options = options;
    this.onMessage = this.onMessage.bind(this);
    this.onSocketClose = this.onSocketClose.bind(this);
    this.onSocketError = this.onSocketError.bind(this);
    this.onSocketOpen = this.onSocketOpen.bind(this);
    this._isS = isHttps(options.host);
  }
  addMessageListener(messageListener) {
    this.messageListeners.push(messageListener);
  }
  removeMessageListener(messageListener) {
    let index2 = this.messageListeners.indexOf(messageListener);
    if (index2 >= 0) {
      this.messageListeners.splice(index2, 1);
    }
  }
  close() {
    if (this.socket) {
      this.removeSocketListeners();
      if (this.socket.readyState != WebSocket.CLOSED) {
        this.socket.close(1e3);
      }
    }
  }
  async startRecording() {
    await this.api("recording/start", "POST", {
      recordMode: true
    });
  }
  async stopRecording() {
    await this.api("recording/stop", "POST", {
      recordMode: true
    });
  }
  async mark(data) {
    await this.api("recording/mark", "POST", data);
  }
  async setAdditionalContentScript(contentScript) {
    await this.api("set-additional-content-script", "POST", { contentScript });
  }
  async connect() {
    if (this.socket) {
      this.removeSocketListeners();
    }
    let url;
    if (this.options.host) {
      url = `ws${this._isS ? "s" : ""}://${this.options.host + this.options.basePath}`;
      let checkReady = this.options.checkReady == void 0 ? true : this.options.checkReady;
      if (checkReady) {
        await this.waitForInstanceToBeReady();
      }
    } else {
      if (this.options.url) {
        console.warn(`Browser-box has deprecated Url as connect option, host can be given as option
 Eg: {host:abc.bbx.net}  `);
      } else {
        console.error(`Host was not given as option, host can be given as option
  Eg: {host:abc.bbx.net}  `);
      }
    }
    this.socket = new WebSocket(url);
    this.addSocketListeners();
  }
  async waitForInstanceToBeReady() {
    let retryCount = 22, ready = false;
    while (retryCount > 0 && !ready) {
      try {
        await this.api("about");
        ready = true;
      } catch (e) {
        console.error("bbx runner not ready?", e);
        await wait$1(2400);
      }
      retryCount--;
    }
    if (!ready) {
      this.emit("socket:error", { message: "Browser server not ready" });
      throw new Error("Browser server not ready");
    }
  }
  addSocketListeners() {
    this.socket.addEventListener("open", this.onSocketOpen);
    this.socket.addEventListener("error", this.onSocketError);
    this.socket.addEventListener("close", this.onSocketClose);
    this.socket.addEventListener("message", this.onMessage);
  }
  removeSocketListeners() {
    this.socket.removeEventListener("open", this.onSocketOpen);
    this.socket.removeEventListener("error", this.onSocketError);
    this.socket.removeEventListener("close", this.onSocketClose);
    this.socket.removeEventListener("message", this.onMessage);
  }
  getBaseURL() {
    return `http${this._isS ? "s" : ""}://${this.options.host}${this.options.basePath}`;
  }
  async api(path, method = "GET", data = void 0) {
    const res = await this.request(path, method, data);
    return res.json();
  }
  async request(path, method = "GET", data = void 0) {
    let { host, key, basePath } = this.options;
    let hasData = !!data;
    let url = `http${this._isS ? "s" : ""}://${host}${basePath}/${path}`;
    let headers = {
      "content-type": "application/json",
      "x-auth": key,
      "x-client-id": this.clientId
    };
    let res = await fetch(url, {
      method,
      mode: "cors",
      headers,
      body: hasData ? JSON.stringify(data) : void 0
    });
    switch (res.status) {
      case 200:
        return res;
      case 401:
        throw new Error("Invalid authentication credentials");
      default:
        console.error("invalid response", res);
        throw new Error("Error response received.");
    }
  }
  async call(name, ...args) {
    let id2 = idFn();
    try {
      this.send(JSON.stringify({
        type: EventNames.MSG_REQUEST,
        id: id2,
        name,
        args
      }));
      return this._waitForResponse(id2);
    } catch (e) {
      this.emit("api:error", e);
      throw e;
    }
  }
  async callPup(path, method, ...args) {
    return this.call("pup", path, method, ...args);
  }
  async _waitForResponse(id2) {
    return new Promise((resolve, reject2) => {
      this._responseListeners.set(id2, (res) => {
        let err = res.err;
        if (err) {
          reject2(new APIError(err));
        } else {
          resolve(res.data);
        }
      });
    });
  }
  onMessage(msg) {
    let data = JSON.parse(msg.data);
    if (data.type == EventNames.MSG_RESPONSE) {
      this.onResponse(data);
      return;
    }
    this.messageListeners.forEach((l) => l.onMessage(data));
  }
  onResponse(response) {
    let { id: id2 } = response;
    let handler = this._responseListeners.get(id2);
    if (handler) {
      this._responseListeners.delete(id2);
      handler(response);
    } else {
      console.error("Unhandled response", response);
      throw new Error("Unhandled response: " + id2);
    }
  }
  onSocketClose(e) {
    this.emit("socket:close", { code: e.code });
  }
  onSocketError(e) {
    this.emit("socket:error", e);
  }
  async onSocketOpen(_e) {
    let resp = await this.register();
    this.clientId = resp.clientId;
    this.messageQueue.forEach((msg) => this.send(msg));
    this.messageQueue = [];
  }
  async register() {
    let data = {
      features: this.options.features,
      key: this.options.key,
      clientVersion: CLIENT_VERSION,
      allowJSON: true
    };
    return await this.call("register", data);
  }
  send(msg) {
    let socket = this.socket;
    if (socket && socket.readyState == WebSocket.OPEN) {
      this.socket.send(msg);
    } else {
      this.messageQueue.push(msg);
    }
  }
  async sendError(e) {
    await this.api("errors", "POST", e);
  }
}
async function wait$1(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function connect(options) {
  let apiClient = new APIClient(options);
  apiClient.connect().catch((e) => {
    apiClient.sendError(new BBXErrorEvent(e, "connect"));
  });
  return apiClient;
}
const TOPIC_ORIGIN = "t";
class BaseItem extends EventEmitter {
  constructor(data, collection) {
    super();
    this.collection = collection;
    this.id = data.id;
    this.set(data);
  }
  set(data) {
    this.data = { ...this.data, ...data };
    this.collection.emit(EventNames.ALL, {
      name: OPS.UPDATE,
      event: { data }
    });
    this.collection.emit(OPS.UPDATE, { data });
  }
}
class BaseCollection extends EventEmitter {
  constructor(name, store2, options = {}) {
    super();
    this.items = [];
    this.onTopicEvent = async (event) => {
      let resp, item;
      let id2 = event.result.id;
      switch (event.operation) {
        case OPS.CREATE:
        case OPS.UPDATE:
          resp = await this._api(`/${id2}`);
          item = this.get(resp.id);
          item ? item.set(resp) : this._add(resp);
          break;
        case OPS.DELETE:
          item = this.get(id2);
          if (item) {
            this._remove(item);
          } else {
            console.error("the item is already deleted", event.result);
          }
          break;
      }
    };
    this.name = name;
    this.store = store2;
    this.options = options;
    if (this.options.autoSync) {
      this.enableSync();
    }
  }
  async getCurrentItems() {
    let resp = await this.fetch();
    (resp.data || []).forEach((it) => {
      let item = this.get(it.id);
      item ? item.set(it) : this._add(it);
    });
  }
  enableSync() {
    if (!this._unSubscribe) {
      this._unSubscribe = this.store.subscribe(this.name, this.onTopicEvent);
    }
  }
  disableSync() {
    this._unSubscribe();
  }
  _api(path, method = "GET", data = null) {
    const url = `${TOPIC_ORIGIN}/${this.name}` + path;
    return this.store.apiClient.api(url, method, data);
  }
  get(id2) {
    return this.items.find((item) => item.id === id2);
  }
  setQuery(query) {
    this.query = new URLSearchParams(query).toString();
  }
  async fetch() {
    let path = this.query ? "?" + this.query : "";
    let resp = await this._api(path);
    return resp;
  }
  async _add(data) {
    let item = this.newItem(data);
    this.emit(OPS.CREATE, { data });
    this.emit(EventNames.ALL, {
      name: OPS.CREATE,
      event: { data }
    });
    this.items.push(item);
    return item;
  }
  async _remove(item) {
    let index2 = this.items.indexOf(item);
    this.items.splice(index2, 1);
    this.emit(OPS.DELETE, { data: item.id });
    this.emit(EventNames.ALL, {
      name: OPS.DELETE,
      event: { data: item.id }
    });
  }
}
class Clients extends BaseCollection {
  constructor(store2, options = {}) {
    super("client", store2, options);
    this.name = "client";
  }
  newItem(data) {
    return new BaseItem(data, this);
  }
}
class Base$1 extends EventEmitter {
  constructor(caller, id2) {
    super();
    this.caller = caller;
    this.id = id2;
  }
  async call(method, ...args) {
    this.emit("call", this, { method, args });
    return this.caller.call(this.getPath(), method, ...args);
  }
  getPath() {
    let parent2 = this.getParent();
    let path = parent2 ? parent2.getPath() : [];
    path.push(this.getNodeId());
    return path;
  }
}
class Frame extends Base$1 {
  constructor(page, state) {
    super(page.caller, state.id);
    this.page = page;
    Object.assign(this, state);
  }
  getIndex() {
    return this.page.frames.indexOf(this);
  }
  getNodeId() {
    return { name: "frame", id: this.id };
  }
  getParent() {
    return this.page;
  }
  isMain() {
    return this.page.mainFrame == this;
  }
  update(state) {
    const oldState = { ...this };
    for (let key in state) {
      if (this[key] != state[key]) {
        const oldVal = this[key];
        this[key] = state[key];
        this.emit(`change:${key}`, oldVal);
      }
    }
    this.emit("change", oldState);
  }
}
class Page extends Base$1 {
  constructor(browser2, state) {
    super(browser2.caller, state.id);
    this.frames = [];
    this.browser = browser2;
    for (let i2 = 0; i2 < state.frames.length; i2 += 1) {
      let frame = new Frame(this, state.frames[i2]);
      this.frames.push(frame);
    }
    this.mainFrame = this.frames[0];
    this.jsEnabled = state.jsEnabled;
    this.mainFrame.on("change", (e) => this.emit("change", e));
  }
  addFrame(state) {
    let frame = new Frame(this, state);
    this.frames.push(frame);
    this.emit("frameadded", frame);
    return frame;
  }
  delFrame(frameId) {
    let frame = this.getFrame(frameId);
    if (frame) {
      let index2 = this.frames.indexOf(frame);
      this.frames.splice(index2, 1);
      this.emit("framedetached", frame);
    } else {
      console.warn("warn: failed to delete frame");
    }
    return frame;
  }
  async close() {
    return this.call("close");
  }
  async goto(url, options) {
    return this.call("goto", url, options);
  }
  async goBack() {
    return this.call("goBack", ...arguments);
  }
  async goForward() {
    return this.call("goForward", ...arguments);
  }
  async reload() {
    return this.goto(this.mainFrame.url);
  }
  async trigger(name, params2) {
    this.emit("trigger", name, params2);
    return this.browser.call("trigger", this.id, name, params2);
  }
  getFrame(frameId) {
    let frames = this.frames;
    let len = frames.length;
    for (let i2 = 0; i2 < len; i2 += 1) {
      let frame = frames[i2];
      if (frame.id == frameId) {
        return frame;
      }
    }
  }
  getNodeId() {
    return { name: "page", id: this.id };
  }
  getParent() {
    return this.browser;
  }
  update(state) {
    this.jsEnabled = state.jsEnabled;
  }
}
class Browser$2 extends Base$1 {
  constructor(caller, state) {
    super(caller, "0");
    this.pages = [];
    for (let i2 = 0; i2 < state.pages.length; i2 += 1) {
      this.pages.push(new Page(this, state.pages[i2]));
    }
    this.viewport = state.viewport;
    this.replay = state.replay;
    this.extensions = state.extensions;
  }
  isReplay() {
    return this.replay;
  }
  async newPage() {
    let res = await this.call("newPage");
    let pageState = res;
    let page = this.getPage(pageState.id);
    if (page) {
      return page;
    }
    return await this.waitForEvent("pageadded");
  }
  onNewPage(state) {
    let page = new Page(this, state);
    this.pages.push(page);
    this.emit("pageadded", page);
    return page;
  }
  onDelPage(pageId) {
    let page = this.getPage(pageId);
    if (page) {
      let index2 = this.pages.indexOf(page);
      this.pages.splice(index2, 1);
      this.emit("pagedeleted", page);
    } else {
      console.warn("warn: failed to delete page");
    }
    return page;
  }
  onViewport(viewport) {
    this.viewport = viewport;
    this.emit("viewport", viewport);
  }
  getNodeId() {
    return { name: "browser", id: this.id };
  }
  getActivePage() {
    return this.pages[this.pages.length - 1];
  }
  async setActivePage(_id) {
    throw new Error("Not implemented");
  }
  getPage(id2) {
    let pages = this.pages;
    let len = pages.length;
    for (let i2 = 0; i2 < len; i2 += 1) {
      let page = pages[i2];
      if (page.id == id2) {
        return page;
      }
    }
  }
  getParent() {
    return null;
  }
  clearAllSiteData() {
    return this.call("clearAllSiteData");
  }
}
class StoreManager extends EventEmitter {
  constructor(apiClient) {
    super();
    this.connectedClients = [];
    this._domStreamListeners = [];
    this._webrtcStreamListeners = [];
    this.apiClient = apiClient;
    this.apiClient.addMessageListener(this);
    this.clients = new Clients(this, { autoSync: true });
  }
  subscribe(name, callback = (_event) => {
  }) {
    if (!this.hasListener(`broadcast:${name}`)) {
      this.apiClient.call(EventNames.TOPIC_SUBSCRIBE, {
        name
      });
    }
    this.on(`broadcast:${name}`, callback);
    return () => {
      this.off(`broadcast:${name}`, callback);
      if (!this.hasListener(`broadcast:${name}`)) {
        this.apiClient.call(EventNames.TOPIC_UNSUBSCRIBE, {
          name
        });
      }
    };
  }
  addDOMStreamListener(listener) {
    this._domStreamListeners.push(listener);
  }
  removeDOMStreamListener(listener) {
    let index2 = this._domStreamListeners.indexOf(listener);
    while (index2 >= 0) {
      this._domStreamListeners.splice(index2, 1);
      index2 = this._domStreamListeners.indexOf(listener);
    }
  }
  addWEBRTCStreamListener(listener) {
    this._webrtcStreamListeners.push(listener);
  }
  removeWEBRTCStreamListener(listener) {
    let index2 = this._webrtcStreamListeners.indexOf(listener);
    while (index2 >= 0) {
      this._webrtcStreamListeners.splice(index2, 1);
      index2 = this._webrtcStreamListeners.indexOf(listener);
    }
  }
  onMessage(data) {
    let { type } = data;
    switch (type) {
      case EventNames.MSG_EVENT:
        this.onEvent(data);
        break;
      case EventNames.MSG_STATE:
        this.onState(data.data);
        break;
      case EventNames.BROADCAST:
        this.onBroadcast(data);
        break;
    }
  }
  onBroadcast(event) {
    let { name, data } = event;
    this.emit(`broadcast:${name}`, data);
  }
  onEvent(event) {
    let { name, data } = event;
    let obj;
    switch (name) {
      case EventNames.WEBRTC_STREAM: {
        let [pageId2, frameId2, peerId, webrtcEvent] = data;
        const event2 = webrtcEvent;
        this._webrtcStreamListeners.forEach((l) => l.onWEBRTCEvent(pageId2, frameId2, peerId, event2));
        let frame2 = this.browser.getPage(pageId2).getFrame(frameId2);
        frame2.emit(EventNames.WEBRTC_STREAM, event2);
        break;
      }
      case EventNames.DOM_STREAM:
        let [pageId, frameId, domEvent] = data;
        this._domStreamListeners.forEach((l) => l.onDOMEvent(pageId, frameId, domEvent));
        let page = this.browser.getPage(pageId);
        let frame = obj = page.getFrame(frameId);
        frame.emit(EventNames.DOM_STREAM, domEvent);
        break;
      case EventNames.FRAME_DEL: {
        let [pageId2, frameId2] = data;
        let page2 = obj = this.browser.getPage(pageId2);
        page2.delFrame(frameId2);
        break;
      }
      case EventNames.FRAME_NEW: {
        let [pageId2, frameState] = data;
        let page2 = this.browser.getPage(pageId2);
        obj = page2.addFrame(frameState);
        break;
      }
      case EventNames.FRAME_UPDATE: {
        let [pageId2, frameState] = data;
        let page2 = this.browser.getPage(pageId2);
        let frame2 = obj = page2.getFrame(frameState.id);
        frame2.update(frameState);
        break;
      }
      case EventNames.PAGE_DEL: {
        let [pageId2] = data;
        obj = this.browser.onDelPage(pageId2);
        break;
      }
      case EventNames.PAGE_NEW: {
        let [pageState] = data;
        obj = this.browser.onNewPage(pageState);
        break;
      }
      case EventNames.PAGE_UPDATE: {
        let { id: pageId2, ...pageState } = data[0];
        let page2 = this.browser.getPage(pageId2);
        page2.update(pageState);
        break;
      }
      case EventNames.VIEWPORT: {
        let [viewport] = data;
        this.browser.onViewport(viewport);
        obj = this.browser;
        break;
      }
      case EventNames.EXTENSIONS: {
        this.browser.extensions = data[0];
        break;
      }
      default:
        console.warn("Unhandled event:", name, data);
    }
    this.emit("bbx", name, obj, data);
  }
  onState(state) {
    this.browser = new Browser$2(this, state);
    this.emit("ready");
  }
  async call(path, method, ...args) {
    this.emit("api", path, method, ...args);
    return await this.apiClient.callPup(getNodePath(path), method, ...args);
  }
}
function getNodePath(nodes) {
  return nodes.map((node) => node.id).join("/");
}
async function createView({ key, host, basePath, container }) {
  let apiClient = connect({
    key,
    host,
    basePath,
    features: [
      Feature.command,
      Feature.state,
      Feature.stream_dom,
      Feature.stream_video
    ]
  });
  let manager = new StoreManager(apiClient);
  await manager.waitForEvent("ready");
  await manager.browser.call("setContentConfig", "stream_dom", true);
  let view = new BrowserView({
    manager,
    container
  });
  view.syncSize();
  return view;
}
const EventApplied = "event_applied";
class SavedMessage {
  constructor(obj) {
    this.id = obj["id"];
    this.ts = obj["ts"];
    this.message = obj["message"];
  }
  getMessage() {
    return this.message;
  }
  parse() {
    if (typeof this.message !== "string") {
      throw new Error("message is not a string");
    }
    return new SavedMessage({
      id: this.id,
      ts: this.ts,
      message: JSON.parse(this.message)
    });
  }
}
class EventsIterator {
  constructor(dbClient) {
    this.db = dbClient;
    this.limit = 50;
    this.offset = 0;
    this.cache = [];
  }
  async _fetchNextBatch() {
    const rows = await this.db.query("SELECT * FROM events ORDER BY id ASC LIMIT ? OFFSET ?", [this.limit, this.offset]);
    if (rows.length === 0) {
      return [];
    }
    return rows.map((row) => {
      return new SavedMessage({
        id: row.id,
        ts: row.ts,
        message: row.message
      });
    });
  }
  async seekToNearest(eventId, lastPlayedEventId) {
    const nearestFrameNavEvent = await this.db.query(`
      WITH MAIN_FRAME_IDS AS (
          SELECT MIN(id) AS id, json_extract(message, "$.data[1]") AS main_frame_id 
          FROM events 
          WHERE json_extract(message, "$.data[2].name") = 'navigated'
          GROUP BY json_extract(message, "$.data[0]")
      )
      SELECT id 
      FROM events
      WHERE json_extract(message, "$.data[1]") IN (SELECT main_frame_id FROM MAIN_FRAME_IDS)
        AND json_extract(message, "$.data[2].name") = 'navigated'
        AND id < ?
      ORDER BY id DESC 
      LIMIT 1;
    `, [eventId]);
    this.offset = 0;
    if (nearestFrameNavEvent.length) {
      this.offset = nearestFrameNavEvent[0].id - 1;
    }
    if (lastPlayedEventId > this.offset && lastPlayedEventId < eventId) {
      this.offset = lastPlayedEventId;
    }
    this.cache = [];
  }
  async next() {
    if (this.cache.length === 0) {
      this.cache = await this._fetchNextBatch();
      this.offset += this.limit;
      if (this.cache.length === 0) {
        return { value: void 0, done: true };
      }
    }
    return { value: this.cache.shift(), done: false };
  }
  [Symbol.asyncIterator]() {
    return this;
  }
}
class KV {
  constructor(obj) {
    this.key = obj["key"];
    this.value = obj["value"] && JSON.parse(obj["value"]);
  }
}
class MockAPIClient extends APIClient {
  addMessageListener(messageListener) {
    console.log("Mock API Client -> addMessageListener(messageListener: MessageListener) called");
  }
  removeMessageListener(messageListener) {
    console.log("Mock API Client -> removeMessageListener(messageListener: MessageListener) called");
  }
  close() {
    console.log("Mock API Client -> close() called");
  }
  async connect() {
    console.log("Mock API Client -> async connect() called");
  }
  async waitForInstanceToBeReady() {
    console.log("Mock API Client -> async waitForInstanceToBeReady() called");
  }
  addSocketListeners() {
    console.log("Mock API Client -> addSocketListeners() called");
  }
  removeSocketListeners() {
    console.log("Mock API Client -> removeSocketListeners() called");
  }
  async _waitForResponse(id2) {
    return new Promise((resolve, reject2) => {
      this._responseListeners.set(id2, (res) => {
        let err = res.err;
        if (err) {
          reject2(res.err);
        } else {
          resolve(res.data);
        }
      });
    });
  }
  onMessage(msg) {
    console.log("Mock API Client -> onMessage(msg: MessageEvent) called");
  }
  onResponse(response) {
    console.log("Mock API Client -> onResponse(response: APIResponse) called");
  }
  onSocketClose(e) {
    console.log("Mock API Client -> onSocketClose(e: CloseEvent) called");
  }
  onSocketError(e) {
    console.log("Mock API Client -> onSocketError(e: ErrorEvent) called");
  }
  async onSocketOpen(e) {
    console.log("Mock API Client -> async onSocketOpen(e) called");
  }
  async register() {
    let resp;
    console.log("Mock API Client -> async register() called");
    return resp.data;
  }
  send(msg) {
    console.log("Mock API Client -> send(msg: string) called");
  }
  async sendError(e) {
    console.log("Mock API Client -> async sendError(e: BBXErrorEvent) called");
  }
}
var TickEvents;
(function(TickEvents2) {
  TickEvents2[TickEvents2["frameNavigated"] = 0] = "frameNavigated";
  TickEvents2[TickEvents2["click"] = 1] = "click";
  TickEvents2[TickEvents2["mousedown"] = 2] = "mousedown";
  TickEvents2[TickEvents2["keydown"] = 3] = "keydown";
  TickEvents2[TickEvents2["keyup"] = 4] = "keyup";
  TickEvents2[TickEvents2["input"] = 5] = "input";
  TickEvents2[TickEvents2["type"] = 6] = "type";
  TickEvents2[TickEvents2["select"] = 7] = "select";
  TickEvents2[TickEvents2["mark"] = 8] = "mark";
  TickEvents2[TickEvents2["error"] = 9] = "error";
})(TickEvents || (TickEvents = {}));
async function getEventsForTicks(db, eventNames) {
  const events = [];
  for (let i2 = 0; i2 < eventNames.length; i2++) {
    switch (eventNames[i2]) {
      case TickEvents.frameNavigated:
        events.push(...await getFrameNavigatedEvents(db));
        break;
      case TickEvents.mousedown:
        events.push(...await getMousedownEvents(db));
        break;
      case TickEvents.error:
        events.push(...await getErrorEvents(db));
        break;
      case TickEvents.mark:
        events.push(...await getMarkEvents(db));
        break;
      case TickEvents.click:
      case TickEvents.type:
      case TickEvents.select:
        events.push(...await getCallEvents(db, TickEvents[eventNames[i2]]));
        break;
      default:
        events.push(...await getTriggerEvents(db, TickEvents[eventNames[i2]]));
        break;
    }
  }
  return events;
}
async function getFrameNavigatedEvents(db) {
  const stateEvent = await db.stateEvent();
  stateEvent.message = JSON.parse(stateEvent.message);
  const newPageEventQuery = `SELECT * FROM events WHERE message->>'name' = 'page:new' ORDER BY id ASC`;
  let rows = await db.query(newPageEventQuery, []);
  const pageEvents = rows.map((r) => {
    r.message = JSON.parse(r.message);
    return r;
  });
  const pageStates = stateEvent.message["data"]["pages"];
  pageEvents.forEach((pageEvent) => {
    const _pageStates = pageEvent.message["data"];
    pageStates.push(..._pageStates);
  });
  const mainFrameIds = pageStates.filter((p) => {
    var _a;
    return (_a = p.frames) == null ? void 0 : _a[0];
  }).map((p) => {
    return p.frames[0].id;
  });
  const frameNavigatedEventsQuery = `select * from events where message->'data'->>1 IN ('${mainFrameIds.join("','")}') and  message->'data'->2->>'name' = 'navigated'`;
  rows = await db.query(frameNavigatedEventsQuery, []);
  return rows.map((r) => {
    r.message = JSON.parse(r.message);
    r["callName"] = "frameNavigated";
    return r;
  });
}
async function getMousedownEvents(db) {
  const clickCallQuery = `select c1.* from calls c1 inner join calls c2 on c1.id = c2.id - 1 where c1.args->>'args'->>1 = 'mousedown' and c2.args->>'args'->>1 = 'mouseup'`;
  const calls = await db.query(clickCallQuery, []);
  const eventIDs = calls.map((c) => c.last_event_id);
  const frameNavigatedEventsQuery = `select * from events where id IN ('${eventIDs.join("','")}')`;
  const rows = await db.query(frameNavigatedEventsQuery, []);
  return rows.map((r) => {
    r.message = JSON.parse(r.message);
    r["callName"] = "mousedown";
    return r;
  });
}
async function getMarkEvents(db) {
  const marksQuery = "SELECT * FROM marks;";
  const marks = await db.query(marksQuery, []);
  const eventIDs = marks.map((m) => m.event_id);
  const marksEventQuery = `SELECT * FROM events WHERE id IN ('${eventIDs.join("','")}')`;
  const rows = await db.query(marksEventQuery, []);
  return rows.map((r, i2) => {
    r.message = JSON.parse(r.message);
    r["callName"] = `S${i2 + 1}`;
    return r;
  });
}
async function getErrorEvents(db) {
  const marksQuery = "SELECT * FROM marks;";
  let marks = await db.query(marksQuery, []);
  marks = marks.filter((m) => {
    var _a;
    return ((_a = JSON.parse(m.step_info)) == null ? void 0 : _a.type) === "error";
  });
  const eventIDs = marks.map((m) => m.event_id);
  const marksEventQuery = `SELECT * FROM events WHERE id IN ('${eventIDs.join("','")}')`;
  const rows = await db.query(marksEventQuery, []);
  return rows.map((r, i2) => {
    r.message = JSON.parse(r.message);
    r["callName"] = `error`;
    return r;
  });
}
async function getCallEvents(db, callName) {
  const clickCallQuery = `select c1.* from calls c1 where c1.args->>'method' = ?`;
  const calls = await db.query(clickCallQuery, [callName]);
  const eventIDs = calls.map((c) => c.last_event_id);
  const frameNavigatedEventsQuery = `select * from events where id IN ('${eventIDs.join("','")}')`;
  const rows = await db.query(frameNavigatedEventsQuery, []);
  return rows.map((r) => {
    r.message = JSON.parse(r.message);
    r["callName"] = callName;
    return r;
  });
}
async function getTriggerEvents(db, callName) {
  const clickCallQuery = `select c1.* from calls c1 where c1.args->>'args'->>1 = ?`;
  const calls = await db.query(clickCallQuery, [callName]);
  const eventIDs = calls.map((c) => c.last_event_id);
  const frameNavigatedEventsQuery = `select * from events where id IN ('${eventIDs.join("','")}')`;
  const rows = await db.query(frameNavigatedEventsQuery, []);
  return rows.map((r) => {
    r.message = JSON.parse(r.message);
    r["callName"] = callName;
    return r;
  });
}
function prepareMappers() {
  return [
    (message, manager) => {
      var _a;
      const actualProxyPath = (_a = manager.getConfig().kvs.find((kv) => kv.key === "PROXY_ORIGIN")) == null ? void 0 : _a.value;
      return message.replaceAll(actualProxyPath, manager.proxyPath);
    },
    (message, manager) => {
      return JSON.parse(message);
    },
    (message, manager) => {
      var _a;
      if (message.type === EventNames.MSG_EVENT && message.name === EventNames.DOM_STREAM) {
        if (((_a = message.data) == null ? void 0 : _a.length) === 3) {
          const data = message.data[2];
          if (data["name"] === "document") {
            const value = data["value"];
            if (typeof value === "string") {
              const dmp = new DOMParser();
              const doc = dmp.parseFromString(value, "text/html");
              doc.querySelectorAll("base").forEach((base2) => {
                base2.href = manager.proxyPath + base2.href;
              });
              message.data[2]["value"] = doc.documentElement.outerHTML;
            } else {
              let node = toDOM(value.content, null);
              if (node.nodeType === Node.DOCUMENT_NODE) {
                const documentNode = node;
                documentNode.querySelectorAll("base").forEach((base2) => {
                  base2.href = manager.proxyPath + base2.href;
                });
                message.data[2]["value"] = documentNode.outerHTML;
              }
            }
          }
        }
      }
      return message;
    },
    (message, manager) => {
      if (message.type === EventNames.MSG_STATE) {
        if (message.data) {
          message.data.replay = true;
        }
      }
      return message;
    }
  ];
}
class ReplayManager extends StoreManager {
  constructor(apiClient, db, config) {
    super(apiClient);
    this.ready = false;
    this.replayedMessageListeners = [];
    this.apiClient.close();
    this.db = db;
    this.config = config;
    this.proxyPath = config.proxyPath;
    this.mappers = prepareMappers();
    this.playerContext = new PlayerContext(this);
    this.readStateMessage();
  }
  applyMappers(message) {
    let value = message.getMessage();
    for (let i2 = 0; i2 < this.mappers.length; i2++) {
      value = this.mappers[i2](value, this);
    }
    const rrMessage = value;
    rrMessage.owner = message;
    return rrMessage;
  }
  getConfig() {
    return this.config;
  }
  getDB() {
    return this.db;
  }
  async getEventIDs() {
    const rows = await this.db.query(`SELECT id FROM events ORDER BY id ASC`);
    return rows.map((row) => row.id);
  }
  async reset() {
    this.stateMessage = null;
    this.resetBrowser();
    await this.readStateMessage();
    await this.browser.call("setContentConfig", "stream_dom", true);
    await this.browserView.addListeners();
  }
  resetBrowser() {
    let pages = this.browser.pages;
    for (let i2 = 0; i2 < this.browser.pages.length; i2 += 1) {
      let page = pages[i2];
      if (!!page.frames && page.frames.length > 0) {
        for (let j = 0; j < page.frames.length; j++) {
          page.delFrame(page.frames[j].id);
        }
      }
      this.browser.onDelPage(page.id);
    }
  }
  addMessageListener(messageListener) {
    this.replayedMessageListeners.push(messageListener);
  }
  async wait(ms) {
    if (ms === 0)
      return;
    return new Promise((resolve) => setTimeout(resolve, 0));
  }
  async readStateMessage() {
    const savedMessage = await this.db.stateEvent();
    this.stateMessage = this.applyMappers(savedMessage);
    this.onMessage(this.stateMessage);
  }
  async startReplay() {
    await this.playerContext.play();
  }
  pause() {
    this.playerContext.pause();
  }
  updateWaitTime(newWaitTime) {
    this.playerContext.updateWaitTime(newWaitTime);
  }
  onMessage(msg) {
    this.replayedMessageListeners.forEach((l) => l.onMessage(msg));
    try {
      super.onMessage(msg);
    } catch (e) {
      msg.err = e.message;
    } finally {
      this.emit(EventApplied, msg);
    }
  }
  async call(path, method, ...args) {
    await this.wait(this.getWaitTimeBetweenEvents());
    return new Promise((resolve) => {
      resolve({
        id: idFn(),
        type: EventNames.MSG_RESPONSE
      });
    });
  }
  pauseOnEvent(clickedEventId) {
    this.playerContext.pauseOnEvent(clickedEventId);
  }
  getWaitTimeBetweenEvents() {
    return this.playerContext.getWaitTimeBetweenEvents();
  }
  getEventsForTicks(eventNames) {
    return getEventsForTicks(this.db, eventNames);
  }
}
ReplayManager.EventNames = {
  PLAY_BEGIN: "playBegin",
  PLAY_END: "playEnd",
  PLAY_PAUSED: "playPaused",
  UPDATE_WAIT_TIME_BW_EVENTS: "updateWaitTimeBetweenEvents"
};
class PlayerContext {
  constructor(manager) {
    this.playInProgress = false;
    this.resetRequired = false;
    this.paused = false;
    this.pauseOnEventId = -1;
    this.waitTimeBetweenEvents = 10;
    this.cancelled = false;
    this.manager = manager;
  }
  getWaitTimeBetweenEvents() {
    return this.waitTimeBetweenEvents;
  }
  updateWaitTime(newWaitTime) {
    if (newWaitTime < 1) {
      newWaitTime = 1;
    }
    this.waitTimeBetweenEvents = newWaitTime;
    this.manager.emit(ReplayManager.EventNames.UPDATE_WAIT_TIME_BW_EVENTS, newWaitTime);
  }
  async reset() {
    this.playInProgress = false;
    this.events = null;
    this.lastPlayedEventId = null;
    this.resetRequired = false;
    this.cancelled = false;
    await this.manager.reset();
  }
  async play() {
    if (!this.playInProgress) {
      this.manager.emit(ReplayManager.EventNames.PLAY_BEGIN, { resume: false });
      if (this.manager.stateMessage) {
        this.manager.replayedMessageListeners.forEach((l) => l.onMessage(this.manager.stateMessage));
        await this.manager.wait(this.waitTimeBetweenEvents);
      }
      this.events = this.manager.db.events();
    }
    this.paused = false;
    this.playInProgress = true;
    return this.resume();
  }
  async resume() {
    if (!this.playInProgress) {
      throw new Error("Cannot resume, replay not started");
    }
    this.paused = false;
    this.manager.emit(ReplayManager.EventNames.PLAY_BEGIN, { resume: true });
    try {
      for await (const m of this.events) {
        const rrMessage = this.manager.applyMappers(m);
        this.manager.onMessage(rrMessage);
        this.lastPlayedEventId = m.id;
        await this.manager.wait(this.waitTimeBetweenEvents);
        if (this.cancelled) {
          break;
        }
        if (this.pauseOnEventId === m.id) {
          this.pause();
          break;
        }
        if (this.paused) {
          break;
        }
      }
    } finally {
      if (!this.paused) {
        this.resetRequired = true;
        this.playInProgress = false;
        this.manager.emit(ReplayManager.EventNames.PLAY_END);
      }
    }
  }
  pause() {
    if (!this.playInProgress) {
      throw new Error("Cannot pause, replay not started");
    }
    this.paused = true;
    this.manager.emit(ReplayManager.EventNames.PLAY_PAUSED, this.pauseOnEventId);
    this.pauseOnEventId = -1;
  }
  pauseOnEvent(eventId) {
    this.pauseOnEventId = eventId;
    if (!this.events)
      this.events = this.manager.db.events();
    this.events.seekToNearest(eventId, this.lastPlayedEventId).then(() => {
      this.waitTimeBetweenEvents = 0;
      this.manager.once(ReplayManager.EventNames.PLAY_PAUSED, () => {
        this.waitTimeBetweenEvents = 10;
      });
      this.play();
    });
  }
}
class WSDBWrapper {
  constructor(wsConn) {
    this.wsConn = wsConn;
    this.wsConn.onmessage = this.onMessage.bind(this);
    this.promises = {};
    this.lastId = 0;
  }
  onMessage(event) {
    const { id: id2, result: result2, error: error2 } = JSON.parse(event.data);
    if (this.promises[id2]) {
      if (error2) {
        this.promises[id2].reject(error2);
      } else {
        this.promises[id2].resolve(result2);
      }
      delete this.promises[id2];
    }
  }
  sendMessage(method, ...args) {
    return new Promise((resolve, reject2) => {
      const id2 = this.lastId++;
      this.promises[id2] = { resolve, reject: reject2 };
      this.wsConn.send(JSON.stringify({ method, args, id: id2 }));
    });
  }
  async query(statement, args = []) {
    return await this.sendMessage("query", statement, args);
  }
  async close() {
    this.wsConn.close();
  }
  async connect(dbUrl) {
    const res = await this.sendMessage("connect", dbUrl);
    return res;
  }
  events() {
    return new EventsIterator(this);
  }
  async getMarks() {
    return await this.query("SELECT * FROM marks;");
  }
  async stateEvent() {
    const rows = await this.query(`SELECT * FROM events WHERE message->>'type' = 'ST' ORDER BY id ASC LIMIT 1`);
    return new SavedMessage(rows[0]);
  }
}
function create_fragment$3N(ctx) {
  let div1;
  let div0;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "bbx-replay-slider-tickmark ");
      set_style(div0, "background", ctx[3]());
      attr(div1, "data-componenttype", "TickView");
      attr(div1, "data-bs-title", ctx[1]);
      attr(div1, "data-bs-toggle", "tooltip");
      attr(div1, "class", "bbx-replay-slider-tick d-flex flex-column");
      set_style(div1, "left", ctx[2] + "%");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      ctx[7](div1);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        attr(div1, "data-bs-title", ctx2[1]);
      }
      if (dirty & 4) {
        set_style(div1, "left", ctx2[2] + "%");
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[7](null);
    }
  };
}
function instance$3J($$self, $$props, $$invalidate) {
  let leftPosition;
  let label;
  let { event } = $$props;
  let { minId } = $$props;
  let { maxId } = $$props;
  let tooltip2;
  onMount(() => {
    new window.bootstrap.Tooltip(tooltip2);
  });
  const getTickColor = () => {
    if (event.callName === "error") {
      return "#dc3545";
    }
    return "#0275ff";
  };
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tooltip2 = $$value;
      $$invalidate(0, tooltip2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("event" in $$props2)
      $$invalidate(4, event = $$props2.event);
    if ("minId" in $$props2)
      $$invalidate(5, minId = $$props2.minId);
    if ("maxId" in $$props2)
      $$invalidate(6, maxId = $$props2.maxId);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 112) {
      $$invalidate(2, leftPosition = (event.id - minId) / (maxId - minId) * 100);
    }
    if ($$self.$$.dirty & 16) {
      $$invalidate(1, label = event.callName);
    }
  };
  return [tooltip2, label, leftPosition, getTickColor, event, minId, maxId, div1_binding];
}
class TickView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3J, create_fragment$3N, safe_not_equal, { event: 4, minId: 5, maxId: 6 });
  }
}
function get_each_context$$(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2];
  return child_ctx;
}
function create_each_block$$(ctx) {
  let tickview;
  let current;
  tickview = new TickView({
    props: {
      minId: ctx[3],
      maxId: ctx[4],
      event: ctx[23]
    }
  });
  return {
    c() {
      create_component(tickview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tickview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tickview_changes = {};
      if (dirty & 8)
        tickview_changes.minId = ctx2[3];
      if (dirty & 16)
        tickview_changes.maxId = ctx2[4];
      if (dirty & 32)
        tickview_changes.event = ctx2[23];
      tickview.$set(tickview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tickview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tickview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tickview, detaching);
    }
  };
}
function create_fragment$3M(ctx) {
  let div2;
  let div1;
  let div0;
  let t;
  let input;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[5];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$$(get_each_context$$(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      input = element("input");
      attr(div0, "class", "bbx-replay-slider-ticks position-relative bbx-rounded");
      attr(div0, "role", "slider");
      attr(div0, "aria-valuenow", ctx[2]);
      attr(div0, "tabindex", "0");
      attr(input, "type", "range");
      attr(input, "name", "eventId");
      attr(input, "class", "w-100 bbx-pointer bbx-outline-none");
      attr(input, "min", ctx[3]);
      attr(input, "max", ctx[4]);
      input.value = ctx[2];
      attr(input, "data-value", ctx[4]);
      attr(div1, "class", "position-relative");
      attr(div2, "data-componenttype", "RangeValue");
      attr(div2, "class", "seeker");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      ctx[14](div0);
      append(div1, t);
      append(div1, input);
      ctx[15](input);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "mouseenter", ctx[7]),
          listen(div0, "mouseleave", ctx[8]),
          listen(div0, "mousemove", ctx[9]),
          listen(input, "change", ctx[16])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 56) {
        each_value = ctx2[5];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$$(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$$(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & 4) {
        attr(div0, "aria-valuenow", ctx2[2]);
      }
      if (!current || dirty & 8) {
        attr(input, "min", ctx2[3]);
      }
      if (!current || dirty & 16) {
        attr(input, "max", ctx2[4]);
      }
      if (!current || dirty & 4) {
        input.value = ctx2[2];
      }
      if (!current || dirty & 16) {
        attr(input, "data-value", ctx2[4]);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      ctx[14](null);
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3I($$self, $$props, $$invalidate) {
  let $highlightNodes;
  let { manager } = $$props;
  let { marks } = $$props;
  let { expressionTree } = $$props;
  let rangeInputRef;
  let tickContainer;
  let currentEventId = 0;
  let minId = 0;
  let maxId = 0;
  let tickEvents = [];
  const tickableEvents = [
    "click",
    "wait_doc",
    "select",
    "keypress",
    "mousemove",
    "drag",
    "focus",
    "type",
    "scroll",
    "wait_for_duration",
    "wait_for_element",
    "open",
    "fill",
    "assert"
  ];
  let highlightNodes = getContext("highlightNodes");
  component_subscribe($$self, highlightNodes, (value) => $$invalidate(18, $highlightNodes = value));
  let setHighlightNodePaths = getContext("setHighlightNodePaths");
  const init2 = async () => {
    const eventIds = await manager.getEventIDs();
    $$invalidate(3, minId = eventIds[0]);
    $$invalidate(4, maxId = eventIds[eventIds.length - 1]);
    $$invalidate(2, currentEventId = minId);
    const onMessage = (message) => {
      if (message.type === EventNames.MSG_STATE) {
        $$invalidate(2, currentEventId = minId);
      } else {
        $$invalidate(2, currentEventId = message.owner.id);
      }
    };
    const messageListener = { onMessage };
    const getNode = (path, root2) => {
      let node = root2;
      for (let i2 of path) {
        node = node.children[i2];
      }
      return node;
    };
    manager.addMessageListener(messageListener);
    const tEvents = [];
    marks.forEach((mark) => {
      if (mark.step_info.type === "error") {
        tEvents.push({ id: mark.event_id, callName: "error" });
      }
      if (mark.step_info.state !== 0)
        return;
      const node = getNode(mark.step_info.path, expressionTree.expression);
      if (node.type === "FUNCTION_CALL" && tickableEvents.includes(node.name)) {
        tEvents.push({ id: mark.event_id, callName: node.name });
      }
    });
    $$invalidate(5, tickEvents = tEvents);
  };
  init2();
  let prevHighlightNodes = null;
  const onMouseEnter = (e) => {
    prevHighlightNodes = $highlightNodes;
  };
  const onMouseLeave = (e) => {
    set_store_value(highlightNodes, $highlightNodes = prevHighlightNodes, $highlightNodes);
  };
  const getNodePaths = (event_id) => {
    const nodePaths = /* @__PURE__ */ new Set();
    for (let mark of marks) {
      if (mark.event_id > event_id) {
        break;
      }
      if (mark.step_info.state === 0 && mark.event_id <= event_id) {
        nodePaths.add(JSON.stringify(mark.step_info.path));
      } else if (mark.step_info.state === 1 && mark.event_id <= event_id) {
        nodePaths.delete(JSON.stringify(mark.step_info.path));
      }
    }
    return Array.from(nodePaths).map((path) => JSON.parse(path));
  };
  const onMouseMove = (e) => {
    const id2 = minId + Math.round(e.offsetX / e.target.getBoundingClientRect().width * (maxId - minId));
    const paths = getNodePaths(id2);
    setHighlightNodePaths(paths);
  };
  const onSeekToEvent = (e) => {
    let clickedEventId = parseInt(e.target.value);
    $$invalidate(0, rangeInputRef.value = currentEventId, rangeInputRef);
    manager.pauseOnEvent(clickedEventId);
  };
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tickContainer = $$value;
      $$invalidate(1, tickContainer);
    });
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rangeInputRef = $$value;
      $$invalidate(0, rangeInputRef);
    });
  }
  const change_handler = (e) => onSeekToEvent(e);
  $$self.$$set = ($$props2) => {
    if ("manager" in $$props2)
      $$invalidate(11, manager = $$props2.manager);
    if ("marks" in $$props2)
      $$invalidate(12, marks = $$props2.marks);
    if ("expressionTree" in $$props2)
      $$invalidate(13, expressionTree = $$props2.expressionTree);
  };
  return [
    rangeInputRef,
    tickContainer,
    currentEventId,
    minId,
    maxId,
    tickEvents,
    highlightNodes,
    onMouseEnter,
    onMouseLeave,
    onMouseMove,
    onSeekToEvent,
    manager,
    marks,
    expressionTree,
    div0_binding,
    input_binding,
    change_handler
  ];
}
class RangeValue extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3I, create_fragment$3M, safe_not_equal, {
      manager: 11,
      marks: 12,
      expressionTree: 13
    });
  }
}
function create_fragment$3L(ctx) {
  let div;
  let span;
  let t0;
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text(ctx[1]);
      t1 = text(" / ");
      t2 = text(ctx[0]);
      attr(span, "class", "bbx-pad");
      attr(span, "title", "Events replayed");
      attr(div, "class", "d-flex justify-content-center align-items-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t0, ctx2[1]);
      if (dirty & 1)
        set_data(t2, ctx2[0]);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$3H($$self, $$props, $$invalidate) {
  let { manager } = $$props;
  let minId = 0;
  let maxId = 0;
  let lastEventId;
  const init2 = async () => {
    const eventIds = await manager.getEventIDs();
    minId = eventIds[0];
    $$invalidate(0, maxId = eventIds[eventIds.length - 1]);
    $$invalidate(1, lastEventId = minId);
    const messageListener = {
      onMessage: (m) => {
        var _a, _b;
        $$invalidate(1, lastEventId = m.owner.id);
        `${m.type}-${m.name}-${(_b = (_a = m.data) == null ? void 0 : _a[2]) == null ? void 0 : _b.name}`;
      }
    };
    manager.addMessageListener(messageListener);
  };
  init2();
  $$self.$$set = ($$props2) => {
    if ("manager" in $$props2)
      $$invalidate(2, manager = $$props2.manager);
  };
  return [maxId, lastEventId, manager];
}
class EventSummary extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3H, create_fragment$3L, safe_not_equal, { manager: 2 });
  }
}
function create_else_block$18(ctx) {
  let svg;
  let title;
  let t;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      title = svg_element("title");
      t = text("Play");
      path = svg_element("path");
      attr(path, "d", "M5.92 24.096q0 1.088 0.928 1.728 0.512 0.288 1.088 0.288 0.448 0 0.896-0.224l16.16-8.064q0.48-0.256 0.8-0.736t0.288-1.088-0.288-1.056-0.8-0.736l-16.16-8.064q-0.448-0.224-0.896-0.224-0.544 0-1.088 0.288-0.928 0.608-0.928 1.728v16.16z");
      attr(svg, "fill", "#000000");
      attr(svg, "width", "40px");
      attr(svg, "height", "40px");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "version", "1.1");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, title);
      append(title, t);
      append(svg, path);
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_if_block$28(ctx) {
  let svg;
  let title;
  let t;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      title = svg_element("title");
      t = text("Pause");
      path = svg_element("path");
      attr(path, "d", "M8 5V19M16 5V19");
      attr(path, "stroke", "#000000");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(svg, "width", "40px");
      attr(svg, "height", "40px");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, title);
      append(title, t);
      append(svg, path);
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_fragment$3K(ctx) {
  let div3;
  let div0;
  let a;
  let t0;
  let div1;
  let label;
  let input;
  let t1;
  let t2_value = ctx[2] ? ctx[2] + "ms" : "";
  let t2;
  let t3;
  let div2;
  let eventsummary;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block$28;
    return create_else_block$18;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  eventsummary = new EventSummary({ props: { manager: ctx[0] } });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      a = element("a");
      if_block.c();
      t0 = space();
      div1 = element("div");
      label = element("label");
      input = element("input");
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      create_component(eventsummary.$$.fragment);
      attr(a, "class", "link");
      attr(div0, "class", "bbx-margin-r-1/2");
      attr(input, "type", "range");
      attr(input, "id", "waitTimeBetweenEvents");
      attr(input, "name", "waitTimeBetweenEvents");
      attr(input, "title", "Wait Time Between Events (In Milliseconds)");
      attr(input, "min", "1");
      attr(input, "max", "60");
      input.value = ctx[2];
      attr(label, "for", "waitTimeBetweenEvents");
      attr(div2, "class", "bbx-pad");
      attr(div3, "data-view-name", "PlayControls");
      attr(div3, "class", "d-flex align-items-center");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, a);
      if_block.m(a, null);
      append(div3, t0);
      append(div3, div1);
      append(div1, label);
      append(label, input);
      append(label, t1);
      append(label, t2);
      append(div3, t3);
      append(div3, div2);
      mount_component(eventsummary, div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a, "click", ctx[5]),
          listen(input, "input", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(a, null);
        }
      }
      if (!current || dirty & 4) {
        input.value = ctx2[2];
      }
      if ((!current || dirty & 4) && t2_value !== (t2_value = ctx2[2] ? ctx2[2] + "ms" : ""))
        set_data(t2, t2_value);
      const eventsummary_changes = {};
      if (dirty & 1)
        eventsummary_changes.manager = ctx2[0];
      eventsummary.$set(eventsummary_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(eventsummary.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(eventsummary.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if_block.d();
      destroy_component(eventsummary);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3G($$self, $$props, $$invalidate) {
  let playing = false;
  let waitTimeBetweenEvents = 10;
  let { manager } = $$props;
  manager.on(ReplayManager.EventNames.PLAY_BEGIN, (event) => {
    $$invalidate(1, playing = true);
    event.resume;
  });
  manager.on(ReplayManager.EventNames.PLAY_PAUSED, () => {
    $$invalidate(1, playing = false);
  });
  manager.on(ReplayManager.EventNames.PLAY_END, () => {
    $$invalidate(1, playing = false);
  });
  manager.on(ReplayManager.EventNames.UPDATE_WAIT_TIME_BW_EVENTS, (newWaitTime) => {
    $$invalidate(2, waitTimeBetweenEvents = newWaitTime);
  });
  const toggleClick = () => {
    if (playing) {
      manager.pause();
    } else {
      manager.startReplay();
    }
  };
  const updateWaitTime = (e) => {
    const waitTime = parseInt(e.target.value);
    manager.updateWaitTime(waitTime);
  };
  const click_handler = () => toggleClick();
  const input_handler = (e) => updateWaitTime(e);
  $$self.$$set = ($$props2) => {
    if ("manager" in $$props2)
      $$invalidate(0, manager = $$props2.manager);
  };
  return [
    manager,
    playing,
    waitTimeBetweenEvents,
    toggleClick,
    updateWaitTime,
    click_handler,
    input_handler
  ];
}
class PlayControls extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3G, create_fragment$3K, safe_not_equal, { manager: 0 });
  }
}
function create_fragment$3J(ctx) {
  let div4;
  let div3;
  let div2;
  let div0;
  let rangevalue;
  let t;
  let div1;
  let playcontrols;
  let current;
  rangevalue = new RangeValue({
    props: {
      marks: ctx[1],
      manager: ctx[0],
      expressionTree: ctx[2]
    }
  });
  playcontrols = new PlayControls({ props: { manager: ctx[0] } });
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      create_component(rangevalue.$$.fragment);
      t = space();
      div1 = element("div");
      create_component(playcontrols.$$.fragment);
      attr(div0, "class", "bbx-pad w-full");
      attr(div1, "class", "bbx-pad w-full ");
      attr(div2, "class", "d-flex flex-column w-full");
      attr(div3, "class", "container bbx-replay-controls");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div2);
      append(div2, div0);
      mount_component(rangevalue, div0, null);
      append(div2, t);
      append(div2, div1);
      mount_component(playcontrols, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const rangevalue_changes = {};
      if (dirty & 2)
        rangevalue_changes.marks = ctx2[1];
      if (dirty & 1)
        rangevalue_changes.manager = ctx2[0];
      if (dirty & 4)
        rangevalue_changes.expressionTree = ctx2[2];
      rangevalue.$set(rangevalue_changes);
      const playcontrols_changes = {};
      if (dirty & 1)
        playcontrols_changes.manager = ctx2[0];
      playcontrols.$set(playcontrols_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(rangevalue.$$.fragment, local);
      transition_in(playcontrols.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rangevalue.$$.fragment, local);
      transition_out(playcontrols.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(rangevalue);
      destroy_component(playcontrols);
    }
  };
}
function instance$3F($$self, $$props, $$invalidate) {
  let { manager } = $$props;
  let { marks } = $$props;
  let { expressionTree } = $$props;
  $$self.$$set = ($$props2) => {
    if ("manager" in $$props2)
      $$invalidate(0, manager = $$props2.manager);
    if ("marks" in $$props2)
      $$invalidate(1, marks = $$props2.marks);
    if ("expressionTree" in $$props2)
      $$invalidate(2, expressionTree = $$props2.expressionTree);
  };
  return [manager, marks, expressionTree];
}
class Replay extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3F, create_fragment$3J, safe_not_equal, { manager: 0, marks: 1, expressionTree: 2 });
  }
}
function create_if_block$27(ctx) {
  let replay2;
  let current;
  replay2 = new Replay({
    props: {
      expressionTree: ctx[1],
      marks: ctx[0],
      manager: ctx[4]
    }
  });
  return {
    c() {
      create_component(replay2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(replay2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const replay_changes = {};
      if (dirty & 2)
        replay_changes.expressionTree = ctx2[1];
      if (dirty & 1)
        replay_changes.marks = ctx2[0];
      if (dirty & 16)
        replay_changes.manager = ctx2[4];
      replay2.$set(replay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(replay2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(replay2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(replay2, detaching);
    }
  };
}
function create_fragment$3I(ctx) {
  let div1;
  let div0;
  let t;
  let current;
  let if_block = ctx[4] && create_if_block$27(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "d-flex flex-grow-1 position-relative");
      attr(div1, "class", "d-flex flex-column flex-grow-1 justify-content-between");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      ctx[6](div0);
      append(div1, t);
      if (if_block)
        if_block.m(div1, null);
      ctx[7](div1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$27(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[6](null);
      if (if_block)
        if_block.d();
      ctx[7](null);
    }
  };
}
function instance$3E($$self, $$props, $$invalidate) {
  let { options } = $$props;
  let { marks } = $$props;
  let { expressionTree } = $$props;
  let container;
  let browserViewContainer;
  let manager;
  const dispatch = createEventDispatcher();
  const connectToWSDB = async (wsPath) => {
    return new Promise((resolve) => {
      const wsConn = new WebSocket(wsPath);
      wsConn.onopen = () => {
        resolve(new WSDBWrapper(wsConn));
      };
    });
  };
  const createView2 = async () => {
    const db = await connectToWSDB(options.replayWSPath);
    await db.connect(options.dbRemoteURI);
    const kvsRows = await db.query("SELECT key, value FROM kv", []);
    const kvs = kvsRows.map((doc) => new KV(doc));
    let apiClient = new MockAPIClient({
      key: options.key,
      host: options.host,
      basePath: options.basePath,
      features: [Feature.command, Feature.state, Feature.stream_dom, Feature.stream_video],
      record: options.record
    });
    $$invalidate(4, manager = new ReplayManager(
      apiClient,
      db,
      {
        replay: true,
        proxyPath: apiClient.getBaseURL(),
        dbRemoteURI: options.dbRemoteURI,
        kvs
      }
    ));
    manager.readStateMessage();
    let view = new BrowserView({ manager, container: browserViewContainer });
    $$invalidate(4, manager.browserView = view, manager);
    dispatch("managerReady", manager);
  };
  createView2();
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      browserViewContainer = $$value;
      $$invalidate(3, browserViewContainer);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(2, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(5, options = $$props2.options);
    if ("marks" in $$props2)
      $$invalidate(0, marks = $$props2.marks);
    if ("expressionTree" in $$props2)
      $$invalidate(1, expressionTree = $$props2.expressionTree);
  };
  return [
    marks,
    expressionTree,
    container,
    browserViewContainer,
    manager,
    options,
    div0_binding,
    div1_binding
  ];
}
class MainReplay extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3E, create_fragment$3I, safe_not_equal, { options: 5, marks: 0, expressionTree: 1 });
  }
}
class RuntimeScope {
  constructor() {
    __publicField(this, "stack");
    this.stack = [{}];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  set(name, value) {
    if (RESERVED.includes(name)) {
      throw new Error(`Cannot use reserved word ${name} as variable name`);
    }
    if (name in this.top) {
      throw new Error(`Variable ${name} already exists`);
    }
    if (!isValidType(value) && !(typeof value === "function")) {
      throw new Error(`Error setting variable: "${name}". Value: "${JSON.stringify(value)}" doesn't match any valid type.`);
    }
    this.top[name] = value;
  }
  get(name) {
    for (let i2 = this.stack.length - 1; i2 >= 0; i2--) {
      if (name in this.stack[i2]) {
        return this.stack[i2][name];
      }
    }
    throw new Error(`Variable ${name} does not exist`);
  }
  update(name, value) {
    if (!isValidType(value)) {
      throw new Error(`Error updating variable: "${name}". Value: "${JSON.stringify(value)}" doesn't match any valid type.`);
    }
    for (let i2 = this.stack.length - 1; i2 >= 0; i2--) {
      if (name in this.stack[i2]) {
        this.stack[i2][name] = value;
        return;
      }
    }
    throw new Error(`Variable ${name} does not exist`);
  }
  has(name) {
    for (let i2 = this.stack.length - 1; i2 >= 0; i2--) {
      if (name in this.stack[i2]) {
        return true;
      }
    }
    return false;
  }
  push() {
    this.stack.push({});
  }
  pop() {
    this.stack.pop();
  }
  isFromRegistry(name) {
    return name in this.stack[0];
  }
}
class VM extends EventEmitter$1 {
  constructor(registry2, context, source, opts) {
    var _a;
    super();
    __publicField(this, "observer", { expressionStack: [] });
    __publicField(this, "interruptPromises", []);
    __publicField(this, "scopeStack");
    __publicField(this, "context");
    __publicField(this, "registry");
    __publicField(this, "tree");
    __publicField(this, "hooks", []);
    __publicField(this, "_running", false);
    __publicField(this, "getExpression", () => {
      return this.observer.expressionStack[this.observer.expressionStack.length - 1];
    });
    __publicField(this, "_hookForObserver", async (step, args) => {
      if (step === HOOK_EVENT.BEFORE_EVAL) {
        this.observer.expressionStack.push(args.node);
      } else if (step === HOOK_EVENT.AFTER_EVAL && !args.error) {
        this.observer.expressionStack.pop();
      }
    });
    __publicField(this, "_hookToEmit", async (step, args) => {
      switch (step) {
        case HOOK_EVENT.BEFORE_EVAL:
        case HOOK_EVENT.AFTER_EVAL:
          this.emit("replay:change", step, args.node, args.error);
          break;
      }
    });
    __publicField(this, "runHooks", async (eventName, args) => {
      try {
        for (const hook of this.hooks) {
          const hookInterruptPromise = this.appendNewInterruptPromise();
          try {
            await Promise.race([
              hookInterruptPromise,
              hook(eventName, { scope: this.scopeStack, context: this.context, ...args })
            ]);
          } finally {
            this.interruptPromises.pop();
          }
        }
      } catch (err) {
        if ((args == null ? void 0 : args.error) && [HOOK_EVENT.AFTER_EVAL, HOOK_EVENT.AFTER_RUN].includes(eventName)) {
          err.cause = args == null ? void 0 : args.error;
        }
        throw StackedError.handle(err, "hook", { type: eventName });
      }
    });
    this.registry = registry2;
    this.context = context;
    this.context.getExpression = this.getExpression;
    this.scopeStack = new RuntimeScope();
    for (let func2 in registry2.funcs) {
      this.scopeStack.set(func2, registry2.getFunc(func2).fn);
    }
    this.tree = source instanceof Root ? source : new Root(this.registry, source, { declarations: opts == null ? void 0 : opts.vars });
    try {
      this.setVars((_a = opts == null ? void 0 : opts.vars) != null ? _a : []);
      this.validate();
    } catch (err) {
      if (!err.code) {
        err.code = ErrorCodes.E_PARSE;
      }
      throw StackedError.handle(err, "parse");
    }
    this.addHook(this._hookForObserver);
    this.addHook(this._hookToEmit);
  }
  setVars(vars) {
    const declarations = this.tree.declarations;
    for (let v of vars) {
      if (!declarations.has(v.name)) {
        throw new Error(`No declaration with name ${v.name} found`);
      }
      if (this.scopeStack.has(v.name)) {
        throw new Error(`Error setting value. Value already set for name ${v.name}`);
      }
      let declaration = declarations.get(v.name);
      if (!matchesDataType(this.tree.scope, declaration.dataType, v.dataType)) {
        throw new Error(`Error type ${v.dataType} is not compatible with ${declaration.dataType}`);
      }
      if (!isOfType(this.tree.scope, v.value, declaration.dataType)) {
        throw new Error(`Error setting value. Provided value is not of type ${v.dataType}`);
      }
      this.scopeStack.set(v.name, v.value);
    }
  }
  validate() {
    if (this.tree.hasErrors()) {
      const errorNodes = this.tree.getErrorNodes();
      let errorNode = errorNodes[0].error;
      if (errorNodes[0] instanceof ErrorExp) {
        errorNode = errorNodes[0];
      }
      throw StackedError.handle({
        message: errorNode.description,
        code: errorNode.code
      }, "node", { path: errorNode.path(), node: errorNode.title });
    }
    for (let declaration of this.tree.declarations.list) {
      if (!this.scopeStack.has(declaration.name)) {
        throw new Error(`Value not set for declaration: ${declaration.name}`);
      }
    }
  }
  interrupt(err) {
    if (!this._running) {
      return;
    }
    if (!this.interruptPromises.length) {
      throw new Error("Cannot interrupt: VM is not running");
    }
    if (!err) {
      err = new Error("Interrupted");
    }
    if (!err.code) {
      err.code = ErrorCodes.E_INTERRUPT;
    }
    err = StackedError.handle(err, "interrupt");
    const interruptRejectPromise = this.interruptPromises[this.interruptPromises.length - 1];
    interruptRejectPromise.reject(err);
  }
  addHook(hook) {
    this.hooks.unshift(hook);
  }
  removeHook(hook) {
    const hookIdx = this.hooks.indexOf(hook);
    this.hooks.splice(hookIdx, 1);
  }
  appendNewInterruptPromise() {
    this.interruptPromises.push(new RejectablePromise());
    return this.interruptPromises[this.interruptPromises.length - 1];
  }
  isRunning() {
    return this._running;
  }
  async run() {
    if (!this.tree) {
      console.error("source not set");
      return;
    }
    if (this._running) {
      throw new Error("VM is already running");
    }
    this._running = true;
    try {
      return await this.tree.evaluate(this);
    } catch (error2) {
      throw StackedError.handle(error2, "run");
    } finally {
      this._running = false;
    }
  }
}
const VERSION$1 = 2;
class Player$3 extends EventEmitter$1 {
  constructor(source, opts) {
    var _a, _b;
    super();
    this.emitChange = (type, node) => {
      let parent2 = node.parent;
      if (type === "beforeEval" && (parent2 instanceof Block || parent2 instanceof Clause || parent2 instanceof Conditional)) {
        this.emit("statusChange", { step: node });
      }
    };
    let registry2;
    if (source instanceof Root) {
      registry2 = source.registry;
    } else {
      registry2 = (_a = opts === null || opts === void 0 ? void 0 : opts.registry) !== null && _a !== void 0 ? _a : this.getNewRegistry();
    }
    this.context = (_b = opts === null || opts === void 0 ? void 0 : opts.context) !== null && _b !== void 0 ? _b : {};
    this.vm = new VM(registry2, this.context, source, { vars: opts === null || opts === void 0 ? void 0 : opts.vars });
  }
  getNewRegistry() {
    return new Registry();
  }
  interrupt(err) {
    this.vm.interrupt(err);
  }
  async play() {
    this.vm.on("replay:change", this.emitChange);
    let res = await this.vm.run();
    this.vm.off("replay:change", this.emitChange);
    return res;
  }
}
class Store extends EventEmitter$1 {
  constructor() {
    super();
    this._listeners = [];
  }
  _notify() {
    this._listeners.forEach((listener) => {
      listener(this.getStoreValue());
    });
  }
  emit(name, ...args) {
    super.emit(name, ...args);
    this._notify();
  }
  subscribe(listener) {
    this._listeners.push(listener);
    listener(this.getStoreValue());
    return () => {
      this._listeners.splice(this._listeners.indexOf(listener), 1);
    };
  }
}
const TagTypeLeafNode = "leaf";
const TagTypeListOfObject = "list";
const TagTypeSchema = "schema";
class ExtractionContext {
  constructor(opts) {
    __publicField(this, "document");
    __publicField(this, "currentNode");
    __publicField(this, "parentContext");
    __publicField(this, "scoped", true);
    __publicField(this, "hook");
    if (!document) {
      throw new Error("cannot create ExtractionContext without a document or document fragment");
    }
    this.document = opts.document;
    this.currentNode = opts.currentNode;
    this.parentContext = opts.parentContext;
    this.hook = opts.hook;
  }
  setNoScope() {
    this.scoped = false;
  }
  setScoped() {
    this.scoped = true;
  }
  newContext(element2, document2) {
    return new ExtractionContext({
      document: document2 || element2.ownerDocument,
      currentNode: element2,
      parentContext: this,
      hook: this.hook
    });
  }
  getDocument() {
    return this.document;
  }
  querySelector(selector, opts = { scoped: true }) {
    let scoped = this.scoped;
    if (opts.scoped !== void 0) {
      scoped = opts.scoped;
    }
    if (!this.currentNode || !scoped) {
      return this.document.querySelector(selector);
    }
    return this.currentNode.querySelector(selector);
  }
  querySelectorAll(selector, opts = { scoped: true }) {
    let scoped = this.scoped;
    if (opts.scoped !== void 0) {
      scoped = opts.scoped;
    }
    if (!this.currentNode || !scoped) {
      return this.document.querySelectorAll(selector);
    }
    return this.currentNode.querySelectorAll(selector);
  }
  evaluateXPath(xpath, opts = { scoped: true }) {
    let contextNode = this.currentNode || this.document;
    if (!this.scoped || !opts.scoped) {
      contextNode = this.document;
    }
    const resultSet = this.document.evaluate(xpath, contextNode, null, XPathResult.ANY_TYPE, null);
    let temp = resultSet.iterateNext();
    const elements = [];
    while (temp && temp.nodeType == document.ELEMENT_NODE) {
      elements.push(temp);
      temp = resultSet.iterateNext();
    }
    return elements;
  }
}
const get_steps_menu_l_slot_changes = (dirty) => ({});
const get_steps_menu_l_slot_context = (ctx) => ({});
function create_steps_menu_l_slot$1(ctx) {
  let div;
  let current;
  const steps_menu_l_slot_template = ctx[2]["steps-menu-l"];
  const steps_menu_l_slot = create_slot(steps_menu_l_slot_template, ctx, ctx[3], get_steps_menu_l_slot_context);
  return {
    c() {
      div = element("div");
      if (steps_menu_l_slot)
        steps_menu_l_slot.c();
      attr(div, "slot", "steps-menu-l");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (steps_menu_l_slot) {
        steps_menu_l_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (steps_menu_l_slot) {
        if (steps_menu_l_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            steps_menu_l_slot,
            steps_menu_l_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(steps_menu_l_slot_template, ctx2[3], dirty, get_steps_menu_l_slot_changes),
            get_steps_menu_l_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(steps_menu_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(steps_menu_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (steps_menu_l_slot)
        steps_menu_l_slot.d(detaching);
    }
  };
}
function create_fragment$3H(ctx) {
  let div;
  let switch_instance;
  let current;
  var switch_value = getComponent(ctx[1].expression);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[1].expression,
        level: 0,
        highlight: false,
        $$slots: {
          "steps-menu-l": [create_steps_menu_l_slot$1]
        },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", "bbx-steps bbx-flex bbx-flex-col bbx-gap bbx-pad bbx-w-full bbx-h-full");
      set_style(div, "overflow", "auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & 2)
        switch_instance_changes.node = ctx2[1].expression;
      if (dirty & 8) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & 2 && switch_value !== (switch_value = getComponent(ctx2[1].expression))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function instance$3D($$self, $$props, $$invalidate) {
  let $tree, $$unsubscribe_tree = noop$1, $$subscribe_tree = () => ($$unsubscribe_tree(), $$unsubscribe_tree = subscribe(tree, ($$value) => $$invalidate(1, $tree = $$value)), tree);
  $$self.$$.on_destroy.push(() => $$unsubscribe_tree());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { tree } = $$props;
  $$subscribe_tree();
  $$self.$$set = ($$props2) => {
    if ("tree" in $$props2)
      $$subscribe_tree($$invalidate(0, tree = $$props2.tree));
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [tree, $tree, slots, $$scope];
}
class TreeView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3D, create_fragment$3H, safe_not_equal, { tree: 0 });
  }
}
var index = "";
function create_else_block$17(ctx) {
  let t;
  return {
    c() {
      t = text("No Steps Found");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$26(ctx) {
  let bbxtreeview;
  let current;
  bbxtreeview = new TreeView({
    props: { tree: ctx[0] }
  });
  return {
    c() {
      create_component(bbxtreeview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(bbxtreeview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const bbxtreeview_changes = {};
      if (dirty & 1)
        bbxtreeview_changes.tree = ctx2[0];
      bbxtreeview.$set(bbxtreeview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(bbxtreeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bbxtreeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(bbxtreeview, detaching);
    }
  };
}
function create_fragment$3G(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block$26, create_else_block$17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "style", ctx[1]);
      attr(div, "class", div_class_value = "bbx-disable " + ctx[2]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & 2) {
        attr(div, "style", ctx2[1]);
      }
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "bbx-disable " + ctx2[2])) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$3C($$self, $$props, $$invalidate) {
  let { steps } = $$props;
  let { tags } = $$props;
  let { params: params2 = [] } = $$props;
  let { expressionTree } = $$props;
  let { style = "" } = $$props;
  let { class: classes = "" } = $$props;
  if (!expressionTree && steps && tags) {
    expressionTree = parseSteps$4(steps, tags.models.map((tag) => tag.get("name")), { declarations: params2 });
  }
  setContext("statusStore", writable("ready"));
  setContext("errorStore", writable({ message: "", nodeStack: [] }));
  setContext("expressionCtx", { replace: { stepNames: [] } });
  $$self.$$set = ($$props2) => {
    if ("steps" in $$props2)
      $$invalidate(3, steps = $$props2.steps);
    if ("tags" in $$props2)
      $$invalidate(4, tags = $$props2.tags);
    if ("params" in $$props2)
      $$invalidate(5, params2 = $$props2.params);
    if ("expressionTree" in $$props2)
      $$invalidate(0, expressionTree = $$props2.expressionTree);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("class" in $$props2)
      $$invalidate(2, classes = $$props2.class);
  };
  return [expressionTree, style, classes, steps, tags, params2];
}
class ViewSteps extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3C, create_fragment$3G, safe_not_equal, {
      steps: 3,
      tags: 4,
      params: 5,
      expressionTree: 0,
      style: 1,
      class: 2
    });
  }
}
var WorkflowReplay_svelte_svelte_type_style_lang = "";
function create_if_block$25(ctx) {
  let div2;
  let replay2;
  let t0;
  let div1;
  let div0;
  let t1;
  let current;
  replay2 = new MainReplay({
    props: {
      expressionTree: ctx[6],
      marks: ctx[3],
      options: ctx[7]
    }
  });
  replay2.$on("managerReady", ctx[8]);
  let if_block0 = ctx[6] && create_if_block_2$S(ctx);
  let if_block1 = ctx[4].length > 0 && create_if_block_1$1n(ctx);
  return {
    c() {
      div2 = element("div");
      create_component(replay2.$$.fragment);
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr(div1, "class", "h-100 border border-0 border-start border-secondary border-opacity-75 d-flex flex-column");
      set_style(div1, "flex-basis", "30%");
      set_style(div1, "max-width", "500px");
      attr(div2, "class", "d-flex h-100 card m-2 flex-row overflow-hidden");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(replay2, div2, null);
      append(div2, t0);
      append(div2, div1);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const replay_changes = {};
      if (dirty & 8)
        replay_changes.marks = ctx2[3];
      replay2.$set(replay_changes);
      if (ctx2[6])
        if_block0.p(ctx2, dirty);
      if (ctx2[4].length > 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$1n(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(replay2.$$.fragment, local);
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(replay2.$$.fragment, local);
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(replay2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_2$S(ctx) {
  let t;
  let viewsteps;
  let current;
  let if_block = ctx[2] && create_if_block_3$G(ctx);
  viewsteps = new ViewSteps({
    props: {
      expressionTree: ctx[6]
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(viewsteps.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(viewsteps, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$G(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(viewsteps.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(viewsteps.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      destroy_component(viewsteps, detaching);
    }
  };
}
function create_if_block_3$G(ctx) {
  let div;
  let strong;
  let t1;
  let a;
  let br;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      strong = element("strong");
      strong.textContent = "This macro is outdated.";
      t1 = text(" The steps shown here were current when the\n              monitor was last run.\n              ");
      a = element("a");
      br = element("br");
      t2 = text("\n                View latest macro here.");
      attr(a, "href", ctx[2]);
      attr(div, "class", "m-2 alert alert-warning");
      attr(div, "role", "alert");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, strong);
      append(div, t1);
      append(div, a);
      append(a, br);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[11]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        attr(a, "href", ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$1n(ctx) {
  let div;
  let t_value = (ctx[1].err.msg || ctx[1].err.message || JSON.stringify(ctx[1].err)) + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "error-msg alert alert-danger svelte-1wf2u6r");
      attr(div, "role", "alert");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = (ctx2[1].err.msg || ctx2[1].err.message || JSON.stringify(ctx2[1].err)) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$3F(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block$25(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$25(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function findNode(path, root2) {
  let node = root2;
  for (let i2 of path)
    node = node.children[i2];
  return node;
}
function instance$3B($$self, $$props, $$invalidate) {
  let $higlightNodes;
  let { macroSteps } = $$props;
  let { recordingUrl } = $$props;
  let { setLoading } = $$props;
  let { workStore } = $$props;
  let { updatedMacroUrl } = $$props;
  let marks;
  let higlightNodes = writable([]);
  component_subscribe($$self, higlightNodes, (value) => $$invalidate(12, $higlightNodes = value));
  let expressionTree = parseSteps$4(macroSteps, [].map((tag) => tag.get("name")), { declarations: [] });
  let errorNodes = [];
  setContext("highlightNodes", higlightNodes);
  setContext("highlightStyle", (node) => {
    if (errorNodes.includes(node)) {
      return "border: 2px solid red; border-radius: var(--bbx-border-radius);";
    }
    if ($higlightNodes.includes(node)) {
      return "border: 2px solid black; border-radius: var(--bbx-border-radius); ";
    }
    return "";
  });
  const sessionId = self.crypto.randomUUID();
  const setHighlightNodePaths = (paths) => {
    set_store_value(higlightNodes, $higlightNodes = paths.map((n) => findNode(n, expressionTree.expression)), $higlightNodes);
  };
  setContext("setHighlightNodePaths", setHighlightNodePaths);
  const options = {
    key: sessionId,
    host: URL_RR + "/",
    basePath: `proxy/${sessionId}/`,
    dbRemoteURI: recordingUrl,
    replayWSPath: `wss://${URL_RR}/ws/${sessionId}`
  };
  const highlightErrorNodes = (marks2) => {
    const errorMarks = marks2.filter((mark) => mark.step_info.type === "error" && !!mark.step_info.path);
    errorMarks.forEach((mark) => {
      const { path } = mark.step_info;
      const node = findNode(path, expressionTree.expression);
      $$invalidate(4, errorNodes = errorNodes.concat([node]));
      set_store_value(higlightNodes, $higlightNodes = $higlightNodes.concat([node]), $higlightNodes);
    });
  };
  async function setup(event) {
    const manager = event.detail;
    $$invalidate(3, marks = await manager.db.getMarks());
    marks.forEach((m) => m.step_info = JSON.parse(m.step_info));
    highlightErrorNodes(marks);
    manager.on("event_applied", async (msg) => {
      const matchedMarks = [];
      for (let mark of marks) {
        if (mark.event_id === msg.owner.id) {
          matchedMarks.push(mark);
        }
      }
      for (const mark of matchedMarks) {
        const { path, state } = mark.step_info;
        if (state === 0) {
          set_store_value(higlightNodes, $higlightNodes = $higlightNodes.concat(findNode(path, expressionTree.expression)), $higlightNodes);
        }
        if (state === 1) {
          const node = findNode(path, expressionTree.expression);
          set_store_value(higlightNodes, $higlightNodes = $higlightNodes.filter((n) => n !== node), $higlightNodes);
        }
      }
    });
    manager.on("playBegin", () => {
    });
    manager.on("playEnd", () => {
      setTimeout(() => set_store_value(higlightNodes, $higlightNodes = [], $higlightNodes), 300);
    });
    setLoading(false);
  }
  const click_handler = () => {
    push$1(updatedMacroUrl);
  };
  $$self.$$set = ($$props2) => {
    if ("macroSteps" in $$props2)
      $$invalidate(0, macroSteps = $$props2.macroSteps);
    if ("recordingUrl" in $$props2)
      $$invalidate(9, recordingUrl = $$props2.recordingUrl);
    if ("setLoading" in $$props2)
      $$invalidate(10, setLoading = $$props2.setLoading);
    if ("workStore" in $$props2)
      $$invalidate(1, workStore = $$props2.workStore);
    if ("updatedMacroUrl" in $$props2)
      $$invalidate(2, updatedMacroUrl = $$props2.updatedMacroUrl);
  };
  return [
    macroSteps,
    workStore,
    updatedMacroUrl,
    marks,
    errorNodes,
    higlightNodes,
    expressionTree,
    options,
    setup,
    recordingUrl,
    setLoading,
    click_handler
  ];
}
class WorkflowReplay extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3B, create_fragment$3F, safe_not_equal, {
      macroSteps: 0,
      recordingUrl: 9,
      setLoading: 10,
      workStore: 1,
      updatedMacroUrl: 2
    });
  }
}
function create_fragment$3E(ctx) {
  let iframe;
  let iframe_src_value;
  let iframe_title_value;
  return {
    c() {
      iframe = element("iframe");
      if (!src_url_equal(iframe.src, iframe_src_value = "about:blank"))
        attr(iframe, "src", iframe_src_value);
      attr(iframe, "frameborder", "none");
      attr(iframe, "class", "flex-grow-1");
      set_style(iframe, "height", "calc(100vh - " + ctx[2] + "px)");
      set_style(iframe, "width", "100%");
      attr(iframe, "title", iframe_title_value = "Iframe for " + ctx[0]);
    },
    m(target, anchor) {
      insert(target, iframe, anchor);
      ctx[4](iframe);
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        set_style(iframe, "height", "calc(100vh - " + ctx2[2] + "px)");
      }
      if (dirty & 1 && iframe_title_value !== (iframe_title_value = "Iframe for " + ctx2[0])) {
        attr(iframe, "title", iframe_title_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(iframe);
      ctx[4](null);
    }
  };
}
function instance$3A($$self, $$props, $$invalidate) {
  let { snapshot } = $$props;
  let { sieveName } = $$props;
  const dispatch = createEventDispatcher();
  let iframeElement;
  let iframeTop = 0;
  async function loadSrcDoc() {
    dispatch("setLoading", true);
    const snapShotContent = snapshot.content;
    if (snapShotContent) {
      $$invalidate(1, iframeElement.srcdoc = snapShotContent, iframeElement);
      $$invalidate(2, iframeTop = iframeElement.getBoundingClientRect().y);
    }
    const win = iframeElement.contentWindow;
    const doc = win.document;
    const el2 = doc.documentElement;
    async.map(
      el2.querySelectorAll("link[rel=stylesheet]"),
      function(link, callback) {
        const img = doc.createElement("img");
        img.onerror = function() {
          callback();
        };
        img.src = link.href;
      },
      (err, res) => {
        dispatch("setLoading", false);
      }
    );
  }
  onMount(() => {
    loadSrcDoc();
  });
  function iframe_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iframeElement = $$value;
      $$invalidate(1, iframeElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("snapshot" in $$props2)
      $$invalidate(3, snapshot = $$props2.snapshot);
    if ("sieveName" in $$props2)
      $$invalidate(0, sieveName = $$props2.sieveName);
  };
  return [sieveName, iframeElement, iframeTop, snapshot, iframe_binding];
}
class SnapShot extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3A, create_fragment$3E, safe_not_equal, { snapshot: 3, sieveName: 0 });
  }
}
class SessionSelector extends Base$2 {
  constructor({ model }) {
    super();
    this.model = model;
    this.setId(model.get("session_id"));
    this.state.names = {};
    if (App.user.isLoggedIn()) {
      this.loadSessions();
    }
  }
  async loadSessions(query = {}) {
    let res = await Api.api("/sessions", query);
    this.state.sessions = res.data;
    let names = res.data.reduce((m, s) => {
      m[s.id] = s.name;
      return m;
    }, {});
    let id2 = this.state.id;
    if (id2 && !names[id2]) {
      let res2 = await Api.api(`/sessions/${id2}`);
      names[id2] = res2.name;
    }
    this.state.names = names;
  }
  onSearch(e) {
    this.loadSessions({
      "name.ilike": `%${e.target.value}%`
    });
  }
  setId(id2, e) {
    e && e.preventDefault();
    this.state.id = id2;
    this.model.set("session_id", id2);
  }
  createTpl({ id: id2, sessions, names }) {
    let loadedSessions = !!sessions;
    let team = get_store_value(params).team;
    return html`<div class='dropdown'>
      <a class='btn btn-default dropdown-toggle' data-bs-toggle='dropdown'
        href='#'>
        Profile - ${!id2 ? "Empty" : names[id2] || "Deleted"}
        <span class='caret'></span>
      </a>
      <ul class='dropdown-menu'>
        ${loadedSessions ? [
      html`
        <li>
          <div class='ma2 dropdown-item' @click=${(e) => (e.preventDefault(), e.stopPropagation())}>
            <input type='text' class='ba0' placeholder='Search' @input=${(e) => this.onSearch(e)}></input>
          </div>
        </li>
          <li><a href='#' class='dropdown-item' @click=${(e) => this.setId(null, e)}>
              <i class='mr2 fa ${!id2 ? "fa-check" : "mr4"}'></i>
              Empty (Default)</a></li>`,
      ...sessions.map((s) => html`<li>
            <a data-id=${s.id} class='dropdown-item' href='#' @click=${(e) => this.setId(s.id, e)}>
              <i class='mr2 fa ${id2 == s.id ? "fa-check" : "mr4"}'></i>
              ${s.name}
            </a>
          </li>`),
      html`
          <li class='dropdown-divider'></li>

          <li><a class='dropdown-item' href='#/w/${team}/profiles/' target='_blank'>
              <span class='pl4'> Manage Profiles<span></a></li>

          <li><a class='dropdown-item' href='${URL_WEBSITE}/kb/help/profiles-for-cloud-monitors' target='_blank'>
              <span class='pl4'> Learn More<span></a></li>
              `
    ] : html`<li><a class='dropdown-item'>Loading...</a></li>`}
      </ul>
    </div>`;
  }
}
const async$2 = window.async;
if (!async$2) {
  throw new Error("ADD async");
}
class ClientSelector$1 extends Base$2 {
  constructor({ model }) {
    super();
    this.model = model;
    this.state.showOptions = false;
    this.setClientId(this.getDefaultClientID());
    this.sessionSelector = new SessionSelector({ model });
    this.setProxyID(model.get("proxy_id"));
    this.state.proxyNames = {};
    if (App.user.isLoggedIn()) {
      this.loadProxies();
    }
  }
  getDefaultClientID() {
    let id2 = this.model.get("client_id") || App.clients.defaultId;
    let ids = this.model.getAccessibleClients(App.clients).map((c) => c.id);
    return ids.includes(id2) ? id2 : ids[0];
  }
  setClientId(client_id) {
    this.state.client_id = client_id;
    this.model.set("client_id", client_id);
  }
  setProxyID(proxy_id, e) {
    e && e.preventDefault();
    this.state.proxy_id = proxy_id;
    this.model.set("proxy_id", proxy_id);
  }
  async loadProxies() {
    const res = await Api.api("/proxies", {
      only: ["id", "name", "cost"]
    });
    let globalData = (await Api.api("/proxies/global")).data;
    globalData = globalData.filter((p) => p.available);
    this.state.proxies = [...res.data, ...globalData];
    res.data.reduce((m, s) => (m[s.id] = s.name, m), this.state.proxyNames);
    globalData.reduce((m, s) => (m[s.id] = s.name, m), this.state.proxyNames);
  }
  createTpl({
    client_id,
    proxyNames,
    proxies,
    proxy_id,
    showOptions
  }) {
    let $params = get_store_value(params);
    let team = $params.team;
    let client = App.clients.get(client_id);
    let loadedProxies = !!proxies;
    let availableClients = this.model.getAccessibleClients(App.clients);
    return html`<div class='flex align-items'>
      <select @change=${(e) => this.setClientId(e.target.value)} class='mr3'>
        ${repeat(availableClients, (c) => c.id, (c) => html`<option value=${c.id} ?selected=${c.id == client_id}>${c.getInfo()}</option>`)}
      </select>
      ${client && client.isWeb() && !showOptions ? html`<a
        @click=${(e) => this.state.showOptions = true}
        href='javascript:void 0'>Options</a>` : ""}
      ${client && client.isWeb() && showOptions ? this.sessionSelector.el : ""}
      ${showOptions && client && client.isWeb() ? html`<div class='ml3 dropdown relative'>
        <a class='dropdown-toggle btn btn-default' data-bs-toggle='dropdown'
          href=#
          >
          Proxy - ${!proxy_id ? "Shared Pool" : proxyNames[proxy_id] || "Deleted"} <span class='caret'></span>
        </a>
        <ul class='dropdown-menu'>
        ${loadedProxies ? [
      html`<li><a class='dropdown-item' href='#' @click=${(e) => this.setProxyID(null, e)}>
            <i class='mr2 fa ${!proxy_id ? "fa-check" : "mr4"}'></i>
            Shared Pool (Default)</a></li>`,
      ...proxies.map((s) => html`<li>
            <a data-id=${s.id} class='dropdown-item' href='#' @click=${(e) => this.setProxyID(s.id, e)}>
              <i class='mr2 fa ${proxy_id == s.id ? "fa-check" : "mr4"}'></i>
              ${s.name}
            </a>
          </li>`),
      html`
          <li class='dropdown-divider'></li>

          <li><a class='dropdown-item' href='#/w/${team}/proxies/' target='_blank'>
              <span class='pl4'> Manage Proxies<span></a></li>

          <li><a class='dropdown-item' href='${URL_WEBSITE}/kb/help/monitor-webpage-using-proxy-servers/' target='_blank'>
              <span class='pl4'> Learn More<span></a></li>
          `
    ] : html`<li><a class='dropdown-item'>Loading...</a></li>`}
        </ul>
      
      </div>` : ""}
    </div>`;
  }
}
const ClientManager$1 = View.Collection.extend({
  name: "ClientManager",
  actions: {
    "client edit name": {
      fn: "action_edit_name"
    },
    "client remove": {
      fn: "action_remove"
    }
  },
  action_edit_name: function(id2) {
    const view = Editor.create("text");
    const model = this.collection.get(id2);
    const modal = new View.PromptModal({
      title: "l_name",
      parent: this.getRoot(),
      view,
      width: 500
    });
    modal.show();
    view.setValue(model.get("info"));
    $(view.field).focus();
    modal.on("save", () => {
      const value = view.getValue();
      model.save({ "info": value }, { patch: true });
      modal.remove();
      this.onReset(this.collection, {
        previousModels: this.collection.models
      });
    });
  },
  action_remove: function(id2) {
    const model = this.collection.get(id2);
    if (id2 == this.collection.defaultId) {
      return alert(TXT("Can't remove self"));
    } else if (model.isWeb()) {
      return alert(TXT("Can't remove web app"));
    } else if (confirm(TXT("Remove " + model.get("info") + "?"))) {
      model.save({ state: 90 }, {
        wait: true,
        success: () => {
          this.collection.remove(model);
        }
      });
    }
  },
  addOne: function(model) {
    if (model.get("type") < 3) {
      return new View.Base();
    }
    const info = model.get("info");
    const isThisClient = model.id == this.collection.defaultId;
    const view = new View.Base({
      el: P(
        SPAN(
          BUTTON({
            "class": "btn btn-default btn-sm",
            "data-action": "client edit name",
            "data-action-param": model.id
          }, I({ "class": "fa fa-edit" })),
          " ",
          BUTTON({
            "class": "btn btn-danger btn-sm",
            "data-action": "client remove",
            "data-action-param": model.id
          }, I({ "class": "fa fa-trash-o" }))
        ),
        " ",
        SPAN({ style: isThisClient ? "font-weight: bold;" : "" }, info, isThisClient ? " (" + TXT("l_device_this") + ")" : ""),
        SMALL({}, moment(model.get("ts")).format(" (YYYY-MM-DD)"))
      ),
      parent: this
    }).render();
    this.$el.append(view.el);
    return view;
  },
  onSave: function() {
    Msg.info("l_loading");
    async$2.eachSeries(this.collection.models, function(model, callback) {
      if (model.hasChanged("info")) {
        model.save(null, {
          error: function() {
            callback(new Error("Failed to save changes"));
          },
          success: function() {
            callback();
          }
        });
      } else {
        callback();
      }
    }, function(err) {
      Msg.reset();
    });
  },
  renderBase: function() {
  }
});
var ViewClients = {
  ClientManager: ClientManager$1,
  ClientSelector: ClientSelector$1
};
const SieveActionEditor = View.Base.extend({
  name: "SieveActionEditor",
  postInit: function() {
    this.listenTo(this.model, "remove", this.remove);
    this.paramsModel = new Backbone.Model(this.model.get("config"));
    this.listenTo(this.paramsModel, "change", this.onEditParams);
  },
  onDelete: function() {
    this.model.collection.remove(this.model);
  },
  onEditParams: function() {
    this.model.set("config", this.paramsModel.toJSON());
  },
  render: function() {
    const desc = this.model.desc;
    let paramsEl;
    let editors;
    if (!desc.single) {
      let del;
      this.$el.append(
        del = A({
          "class": "btn fa fa-trash-o xbtn-light",
          "style": "vertical-align: top;margin-top: 5px;",
          "href": "javascript:void 0",
          "title": TXT("h_del_action")
        })
      );
      del.onclick = this.onDelete;
    } else {
      this.$el.css({
        "margin-left": 30,
        "line-height": 0
      });
    }
    this.$el.append(
      paramsEl = DIV({ style: "display:inline-block;width:80%; margin-bottom: 5px;white-space:nowrap;" })
    ).css({ position: "relative", overflow: "visible" });
    editors = this.paramEditors = _.map(desc.params, function(param) {
      const paramEditor = Editor.create(param.type, {
        param,
        parent: this,
        model: this.paramsModel
      });
      paramsEl.appendChild(paramEditor.render().el);
      if (!param.must) {
        paramEditor.$el.hide();
      }
      return paramEditor;
    }, this);
    if (_.any(desc.params, function(param) {
      return !param.must;
    })) {
      let elToggle;
      paramsEl.appendChild(
        elToggle = BUTTON(
          { "class": "btn btn-default btn-sm xbtn-light" },
          TXT("l_options")
        )
      );
      elToggle.onclick = function() {
        _.each(editors, function(editor) {
          editor.$el.show();
        });
        $(elToggle).remove();
      };
    }
    if (desc.plugin) {
      desc.plugin(this);
    }
    return this;
  }
});
const SieveActionGroup = View.Base.extend({
  name: "SieveActionGroup",
  className: "xtype-group",
  postInit: function(options) {
    this.desc = options.desc;
    this.models = options.models;
    this.views = {};
    this.listenTo(this.models, "add", this.addOne);
    this.listenTo(this.models, "remove", this.onActionRemove);
  },
  addOne: function(action) {
    if (this.views[action.cid] == null && action.desc.type == this.desc.type) {
      const view = new SieveActionEditor({
        model: action,
        parent: this
      }).render();
      this.$list.append(view.el);
      this.views[action.cid] = view;
    }
  },
  isVoid: function(view) {
    return this.desc.single || this.desc.params.length == 0;
  },
  onActionAdd: function() {
    this.models.add(new Model$2.SieveAction[this.desc.type]());
  },
  onActionRemove: function(action, actionGroup) {
    if (this.models.where({ type: this.desc.type }).length == 0) {
      this.remove();
    }
  },
  onDelete: function() {
    const actions = this.models.where({ type: this.desc.type });
    _.each(actions, function(action) {
      this.models.remove(action);
    }, this);
  },
  render: function() {
    const desc = this.desc;
    let btnAdd;
    let btnDel;
    this.$list = $(DIV());
    if (desc.single) {
      this.$el.append(
        btnDel = BUTTON({
          "class": "btn fa fa-trash-o xbtn-light",
          "title": TXT("h_del_action")
        })
      );
      btnDel.onclick = this.onDelete;
    }
    if (!desc.single) {
      this.$el.append(
        btnAdd = BUTTON({ "class": "btn fa fa-plus xbtn-light pull-right" })
      );
      btnAdd.onclick = this.onActionAdd;
    }
    this.$el.append(
      SPAN(
        { style: "" },
        SPAN(TXT(desc.label)),
        this.$list[0]
      )
    );
    if (desc.groupPlugin) {
      desc.groupPlugin(this);
    }
    this.models.each(this.addOne);
    return this;
  }
});
function getGlobalActions() {
  var _a, _b;
  return (_b = (_a = USER.prefs) == null ? void 0 : _a.actions) != null ? _b : [{ type: C.ACTION_PUSH, config: null }];
}
const SieveActionsEditor = View.ActionProvider.extend({
  name: "SieveActionsEditor",
  actions: {
    action_global_actions: { fn: "action_global_actions" }
  },
  action_global_actions: function() {
    showGlobalActionEditor();
  },
  postInit: function(options) {
    this.actionGroups = {};
    this.dels = [];
    this.sieve = options.sieve;
    this.models = options.actions;
    this.listenTo(this.models, "add", this.addOne);
    this.listenTo(this.models, "remove", this.onActionRemove);
    this.listenTo(this.models, "reset", this.render);
    this.listenTo(App.user, "change", this.renderGlobalCount);
  },
  addOne: function(action) {
    const desc = action.desc;
    const type = desc.type;
    this.$emptyEl.remove();
    if (!this.actionGroups[type]) {
      const view = this.actionGroups[type] = new SieveActionGroup({
        models: this.models,
        desc,
        parent: this
      }).render();
      this.listenTo(view, "remove", function() {
        delete this.actionGroups[type];
      }, this);
      this.$list.append(view.el);
    }
  },
  getChanges: function() {
    return {
      dels: this.dels,
      posts: this.getPosts(),
      puts: this.getPuts()
    };
  },
  getPosts: function() {
    return this.models.filter(function(action) {
      return action.isNew();
    });
  },
  getPuts: function() {
    return this.models.filter(function(action) {
      return !action.isNew() && action.hasChanged();
    });
  },
  onAddActionMenuClick: function(e) {
    const type = $(e.currentTarget).attr("tag");
    const Type2 = Model$2.SieveAction[type];
    if (Type2.desc.single && this.models.where({ type: Type2.desc.type }).length > 0) {
      Msg.info("m_action_can_add_only_one");
      return;
    }
    this.models.add(new Type2(null, {
      parent: this.sieve
    }));
    e.preventDefault();
  },
  onActionRemove: function(action) {
    if (!action.isNew()) {
      this.dels.push(action);
    }
  },
  render: function() {
    let menu;
    this.reset();
    this.$emptyEl = $(DIV(
      { "class": "alert alert-warning hide" },
      "No action added - add one to get alerted on changes"
    ));
    this.$list = $(DIV());
    this.$el.empty().append(
      DIV(
        { style: "position: relative;" },
        DIV(
          { "class": "space-x-4" },
          A({
            "id": "menu_add_action",
            "class": "dropdown-toggle",
            "data-bs-toggle": "dropdown",
            "href": "javascript:void 0"
          }, TXT("a_add_action"), " ", B({ "class": "caret" })),
          " ",
          menu = UL({
            "class": "dropdown-menu",
            "role": "menu",
            "aria-labelledby": "menu_add_action",
            "style": "z-index: 2000"
          }),
          " ",
          this.options.global ? "" : A({
            "href": "#",
            "class": "",
            "data-action": "action_global_actions"
          }, "Global Actions: ", this.elGlobalCount = SPAN(0))
        ),
        DIV({
          "class": "right",
          "style": "margin-left:10px;"
        })
      ),
      this.$emptyEl,
      DIV({ style: "max-height: 360px;overflow-y:auto;overflow-x-hidden;" }, this.$list[0])
    );
    _.each(Model$2.SieveActionDescList, function(desc) {
      menu.appendChild(LI(
        A(
          { tag: desc.type, tabindex: -1, href: "javascript:void 0", class: "dropdown-item" },
          I({ "class": "fa " + desc.icon }),
          SPAN({ style: "margin-left: 10px;" }, TXT(desc.label), desc.paid ? " *" : "")
        )
      ));
    });
    this.renderGlobalCount();
    menu.appendChild(LI(
      { "class": "disabled" },
      A({ href: "#", class: "dropdown-item" }, "* " + TXT("m_premium_only"))
    ));
    $(menu).find("a").click(this.onAddActionMenuClick);
    this.models.each(this.addOne);
    this.$emptyEl[this.models.length == 0 ? "removeClass" : "addClass"]("hide");
    return this;
  },
  async renderGlobalCount() {
    if (App.user.isLoggedIn()) {
      $(this.elGlobalCount).text(getGlobalActions().length);
    }
  },
  reset: function() {
    _.each(this.actionGroups, function(view) {
      view.remove();
    });
    this.actionGroups = {};
    this.dels = [];
  }
});
async function showGlobalActionEditor() {
  if (!USER.id) {
    return alert("Please sign in to save global actions");
  }
  let sieve = new Model$2.Sieve();
  let actions = new Model$2.SieveActions(null, { parent: sieve });
  actions.set({
    data: getGlobalActions()
  }, { parse: true });
  let view = new SieveActionsEditor({
    actions,
    sieve,
    parent: App.root,
    global: true
  });
  const modal = new View.SaveDiscardModal({
    name: "GlobalActionEditor$SaveDiscardModal",
    title: "Global Actions",
    titleEx: `taken on changes for all monitors, merged with monitor's actions`,
    view,
    parent: App.root
  });
  modal.on("save", async () => {
    modal.remove();
    let data = actions.toJSON();
    try {
      await Api.api("/prefs/actions", "PUT", data);
      USER.prefs.actions = data;
    } catch (e) {
      console.error(e);
      Msg.error("Failed to save data, please try again later");
    }
  });
  modal.on("discard", () => {
    modal.remove();
  });
  modal.show();
}
const DescList = [
  {
    type: C$1.RULE_NOT_EMPTY,
    label: "l_not_is_empty",
    params: []
  },
  {
    type: C$1.RULE_HAS_TEXT,
    label: "l_has",
    params: [{
      label: "l_text",
      must: true,
      name: "input",
      type: "text"
    }]
  },
  {
    type: C$1.RULE_HAS_TEXT_NOT,
    label: "l_has_not",
    params: [{
      label: "l_text",
      must: true,
      name: "input",
      type: "text"
    }]
  },
  {
    type: C$1.RULE_HAS_NUMBER_LT,
    label: "l_has_num_lt",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$1.RULE_HAS_NUMBER_GT,
    label: "l_has_num_gt",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$1.RULE_HAS_NUMBER_DECR_MIN,
    label: "l_has_num_decr_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$1.RULE_HAS_NUMBER_INCR_MIN,
    label: "l_has_num_incr_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$1.RULE_HAS_NUMBER_DECR_PERCENT_MIN,
    label: "l_has_num_decr_pct_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$1.RULE_HAS_NUMBER_INCR_PERCENT_MIN,
    label: "l_has_num_incr_pct_min",
    params: [{
      label: "l_num",
      must: true,
      name: "input",
      type: "number"
    }]
  },
  {
    type: C$1.RULE_MATCH_REGEX,
    label: "l_match_regex",
    params: [{
      label: "l_regex",
      must: true,
      name: "input",
      type: "regexp"
    }]
  }
];
const ContentList = [{
  type: C$1.CONTENT_TYPE_TEXT,
  label: "l_text"
}, {
  type: C$1.CONTENT_TYPE_CHANGED_TEXT,
  label: "l_added_text"
}, {
  type: C$1.CONTENT_TYPE_OLD_TEXT,
  label: "l_text_old"
}];
const NumericConditions = [
  C$1.RULE_HAS_NUMBER_LT,
  C$1.RULE_HAS_NUMBER_GT,
  C$1.RULE_HAS_NUMBER_DECR_MIN,
  C$1.RULE_HAS_NUMBER_INCR_MIN,
  C$1.RULE_HAS_NUMBER_DECR_PERCENT_MIN,
  C$1.RULE_HAS_NUMBER_INCR_PERCENT_MIN
];
var Rules = {
  ContentList,
  DescList,
  NumericConditions
};
function get_each_context$_(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  return child_ctx;
}
function create_each_block$_(key_1, ctx) {
  let option;
  let t_value = TXT(ctx[7].label) + "";
  let t;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[7].value;
      option.value = option.__value;
      attr(option, "title", TXT(ctx[7].title));
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$3D(ctx) {
  let div;
  let span;
  let t2;
  let select2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let mounted;
  let dispose;
  let each_value = ctx[3];
  const get_key = (ctx2) => ctx2[7].value;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$_(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$_(key, child_ctx));
  }
  let div_levels = [
    {
      class: div_class_value = "flex " + ctx[2]
    },
    ctx[4]
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign(div_data, div_levels[i2]);
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = `${TXT("l_num_format")}:`;
      t2 = space();
      select2 = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(span, "class", "pr-2");
      attr(select2, "title", TXT("title_num_format"));
      select2.disabled = ctx[1];
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[5].call(select2));
      set_attributes(div, div_data);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t2);
      append(div, select2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      select_option(select2, ctx[0], true);
      if (!mounted) {
        dispose = listen(select2, "change", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 8) {
        each_value = ctx2[3];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select2, destroy_block, create_each_block$_, null, get_each_context$_);
      }
      if (dirty & 2) {
        select2.disabled = ctx2[1];
      }
      if (dirty & 9) {
        select_option(select2, ctx2[0]);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 4 && div_class_value !== (div_class_value = "flex " + ctx2[2]) && { class: div_class_value },
        dirty & 16 && ctx2[4]
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$3z($$self, $$props, $$invalidate) {
  const omit_props_names = ["format", "disabled", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { format: format2 } = $$props;
  let { disabled } = $$props;
  const OPTIONS = [
    {
      label: "rule_comma_dot",
      title: "title_format_option_comma_dot",
      value: C$1.NUM_FORMAT_COMMA_DOT
    },
    {
      label: "rule_dot_comma",
      title: "title_format_option_dot_comma",
      value: C$1.NUM_FORMAT_DOT_COMMA
    },
    {
      label: "rule_space_comma",
      title: "title_format_option_space_comma",
      value: C$1.NUM_FORMAT_SPACE_COMMA
    }
  ];
  format2 || (format2 = C$1.NUM_FORMAT_COMMA_DOT);
  let dispatch = createEventDispatcher();
  let { class: clazz } = $$props;
  function select_change_handler() {
    format2 = select_value(this);
    $$invalidate(0, format2);
    $$invalidate(3, OPTIONS);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("format" in $$new_props)
      $$invalidate(0, format2 = $$new_props.format);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("class" in $$new_props)
      $$invalidate(2, clazz = $$new_props.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      dispatch("change", format2);
    }
  };
  return [format2, disabled, clazz, OPTIONS, $$restProps, select_change_handler];
}
class NumberFormat extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3z, create_fragment$3D, safe_not_equal, { format: 0, disabled: 1, class: 2 });
  }
}
const SieveRuleEditor = View.Base.extend({
  name: "SieveRuleEditor",
  className: "flex space-x-2",
  postInit: function() {
    this.paramsModel = new Backbone.Model(this.model.rule.params);
  },
  getConfig: function() {
    return {
      type: C$1.TYPE_RULE,
      contentType: this.getContentType(),
      rule: {
        type: this.getRuleType(),
        params: this.getParams()
      }
    };
  },
  getContentType: function() {
    return parseInt(this.selContentType.value);
  },
  getParams: function() {
    const keys2 = _.pluck(this.getRuleDesc().params, "name");
    const json = this.paramsModel.toJSON();
    return _.pick(...[json].concat(keys2));
  },
  getRuleDesc: function() {
    return _.findWhere(Rules.DescList, { type: this.getRuleType() }) || {
      type: 0,
      lable: "l_rule_unknown",
      params: []
    };
  },
  getRuleType: function() {
    return parseInt(this.selRuleType.value);
  },
  onTypeChange: function() {
    this.renderParams();
    this.bubbleEvent("onTypeChange");
  },
  render: function() {
    let elParams;
    this.$el.append(
      this.selContentType = SELECT.apply(
        window,
        _.map(Rules.ContentList, function(item) {
          return OPTION({ value: item.type }, TXT(item.label));
        })
      ),
      this.selRuleType = SELECT.apply(
        window,
        _.map(Rules.DescList, function(item) {
          return OPTION({ value: item.type }, TXT(item.label));
        })
      ),
      elParams = DIV({
        style: "flex: 1"
      })
    );
    this.selContentType.value = this.model.contentType;
    this.selRuleType.value = this.model.rule.type;
    this.$elParams = $(elParams);
    this.renderParams();
    $(this.selRuleType).change(this.onTypeChange);
    return this;
  },
  renderParams: function() {
    const elParams = this.$elParams;
    const model = this.paramsModel;
    const desc = this.getRuleDesc();
    if (!desc)
      throw new Error("Unknown rule desc:" + this.getRuleType());
    elParams.empty();
    const els = _.map(desc.params, function(param) {
      return Editor.create(param.type, {
        param,
        parent: this,
        model
      }).render().el;
    }, this);
    elParams.append(els);
  }
});
var SieveRuleGroupEditor$1 = View.Base.extend({
  name: "SieveRuleGroupEditor",
  tagName: "fieldset",
  className: "xrulegroup flex-1",
  postInit: function() {
    this.editors = [];
  },
  addOne: function(config) {
    if (config.type == C$1.TYPE_RULE) {
      this.addRule(config);
    } else if (config.type == C$1.TYPE_RULE_GROUP) {
      this.addRuleGroup(config);
    }
  },
  addEditor: function(editor, isGroup) {
    let btn;
    let wrapper;
    editor.el.style.flex = 1;
    this.$list.append(
      wrapper = DIV(
        {
          "class": `flex items-start ${isGroup ? "py-4 px-4 bl border-gray-400" : ""}`
        },
        editor.el,
        btn = BUTTON(
          { "class": "btn btn-default btn-sm ml-2", title: TXT("a_del") },
          I({ "class": "fa fa-trash-o" })
        )
      )
    );
    $(btn).click(() => {
      editor.remove();
      wrapper.remove();
      this.editors.splice(_.indexOf(this.editors, editor), 1);
    });
    this.editors.push(editor);
  },
  addRule: function(ruleConfig) {
    ruleConfig || (ruleConfig = this.defaultRule());
    const editor = new SieveRuleEditor({
      model: ruleConfig,
      parent: this
    }).render();
    this.addEditor(editor, false);
  },
  addRuleGroup: function(ruleGroupConfig) {
    ruleGroupConfig || (ruleGroupConfig = this.defaultRuleGroup());
    const editor = new SieveRuleGroupEditor$1({
      model: ruleGroupConfig,
      parent: this
    }).render();
    editor.setConfig(ruleGroupConfig);
    this.addEditor(editor, true);
  },
  defaultRule: function() {
    return {
      type: C$1.TYPE_RULE,
      contentType: C$1.CONTENT_TYPE_CHANGED_TEXT,
      rule: {
        type: C$1.RULE_HAS_TEXT,
        params: { input: "" }
      }
    };
  },
  defaultRuleGroup: function() {
    return {
      type: C$1.TYPE_RULE_GROUP,
      op: C$1.OP_AND,
      rules: [this.defaultRule()]
    };
  },
  getConfig: function() {
    return {
      type: C$1.TYPE_RULE_GROUP,
      op: parseInt(this.selOp.value),
      rules: _.map(this.editors, function(editor) {
        return editor.getConfig();
      })
    };
  },
  isEmpty: function() {
    return this.editors.length == 0;
  },
  onAddClick: function(e) {
    const tag = e.target.getAttribute("tag");
    if (!tag)
      return;
    if (tag == C$1.TYPE_RULE) {
      this.addRule();
    } else if (tag == C$1.TYPE_RULE_GROUP) {
      this.addRuleGroup();
    } else
      ;
  },
  render: function() {
    let list;
    let actions;
    this.$el.append(
      LEGEND(
        TXT("l_rule_true_if_matches_x") + " ",
        this.selOp = SELECT(
          OPTION({ value: C$1.OP_AND }, TXT("l_all")),
          OPTION({ value: C$1.OP_OR }, TXT("l_any"))
        ),
        " " + TXT("l_x_of_following_rules") + ":",
        actions = DIV(
          { "class": "btn-group xadd-rule right" },
          BUTTON(
            { "class": "btn btn-default btn-sm w-28", "tag": C$1.TYPE_RULE },
            I({ "class": "fa fa-plus" }),
            " ",
            TXT("a_add")
          ),
          BUTTON({
            "class": "btn btn-default btn-sm dropdown-toggle",
            "data-toggle": "dropdown"
          }, SPAN({ "class": "caret" })),
          UL(
            { "class": "dropdown-menu dropdown-menu-right", "role": "menu" },
            LI(
              A({
                tag: C$1.TYPE_RULE_GROUP,
                tabindex: -1,
                href: "javascript:void 0"
              }, SPRINTF("a_action_object", "a_add", "l_rule_group"))
            )
          )
        )
      ),
      list = DIV({ "class": "space-y-2" })
    );
    $(actions).click(this.onAddClick);
    this.$list = $(list);
    return this;
  },
  setConfig: function(model) {
    this.selOp.value = model.op;
    _.each(this.editors, function(editor) {
      editor.remove();
    });
    this.editors = [];
    _.each(model.rules, this.addOne);
  }
});
const SieveRulesEditorV1$1 = View.ActionProvider.extend({
  name: "SieveRulesEditorV1",
  numberFormat: C$1.NUM_FORMAT_COMMA_DOT,
  actions: {
    add_condition: { fn: "action_add" }
  },
  action_add: function() {
    this.ruleView.addRule();
    this.renderRules();
    this.trigger("onTypeChange");
  },
  postInit: function(options) {
    this.ruleView = new SieveRuleGroupEditor$1({
      parent: this
    }).render();
    if (!this.model.isEmpty()) {
      _.delay(this.onLoad);
    } else {
      this.ruleView.setConfig(this.model.get("config"));
    }
    this.on("onTypeChange", function() {
      let config = this.ruleView.getConfig();
      if (config) {
        let cl = this.elNumFormat.classList;
        if (containsRuleWithNumber(config)) {
          cl.remove("hide");
        } else {
          cl.add("hide");
        }
      }
    });
  },
  onLoad: function() {
    let config = this.model.get("config");
    this.numberFormat = config.numberFormat || C$1.NUM_FORMAT_COMMA_DOT;
    this.ruleView.setConfig(config);
    this.renderRules();
    this.renderNumberFormat();
    this.trigger("onTypeChange");
  },
  render: function() {
    let body;
    this.$el.append(
      body = DIV({ style: "max-height: 600px; overflow-y: auto; overflow-x:hidden;" })
    );
    this.$body = $(body);
    this.renderRules();
    this.renderNumberFormat();
    return this;
  },
  renderRules: function() {
    const $el = this.$body;
    $el.empty();
    if (this.ruleView.isEmpty()) {
      $el.append(
        A({
          href: "#",
          "data-action": "add_condition"
        }, SPRINTF("a_action_object", "a_add", "l_rule"))
      );
    } else {
      $el.append(this.ruleView.el);
    }
  },
  renderNumberFormat: function() {
    this.$el.append(this.elNumFormat = DIV({ "class": "mt-4 hide" }));
    this.viewNumFormat = new NumberFormat({
      target: this.elNumFormat,
      props: {
        format: this.numberFormat
      }
    });
    this.viewNumFormat.$on("change", (e) => this.numberFormat = e.detail);
  },
  remove() {
    SieveRulesEditorV1$1.__super__.remove.call(this);
    this.viewNumFormat.$destroy();
  },
  updateModel: function() {
    const config = this.ruleView.getConfig();
    config.numberFormat = this.numberFormat;
    this.model.set("config", config);
  }
});
function containsRuleWithNumber(config) {
  if (config.type === 1 && !!config.rule) {
    return Rules.NumericConditions.includes(config.rule.type);
  } else if (config.type === 2 && config.rules.length > 0) {
    return _.any(config.rules, function(config2) {
      return containsRuleWithNumber(config2);
    });
  }
  return false;
}
function create_fragment$3C(ctx) {
  let span;
  let span_data_bs_content_value;
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      attr(span, "tabindex", "0");
      attr(span, "class", "d-block");
      attr(span, "role", "button");
      attr(span, "data-bs-toggle", "popover");
      attr(span, "data-bs-custom-class", "scrollable-popover");
      attr(span, "data-bs-title", ctx[0]);
      attr(span, "data-bs-placement", "right");
      attr(span, "data-bs-content", span_data_bs_content_value = ctx[1] + INVISIBLE_CHAR);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[6](span);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1) {
        attr(span, "data-bs-title", ctx2[0]);
      }
      if (!current || dirty & 2 && span_data_bs_content_value !== (span_data_bs_content_value = ctx2[1] + INVISIBLE_CHAR)) {
        attr(span, "data-bs-content", span_data_bs_content_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
    }
  };
}
const INVISIBLE_CHAR = "\u200E ";
function instance$3y($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { header } = $$props;
  let { content } = $$props;
  let popoverEl;
  let popoverInstance;
  function clickEvent(event) {
    const target = event.target;
    if (popoverInstance._isShown() && !popoverInstance.tip.contains(target)) {
      popoverInstance.hide();
    }
  }
  const createPopover = () => {
    $$invalidate(3, popoverInstance = new bootstrap.Popover(popoverEl, { container: "body" }));
    document.addEventListener("click", clickEvent);
  };
  const disposePopover = () => {
    popoverInstance.dispose();
  };
  const recreatePopover = () => {
    disposePopover();
    popoverEl.setAttribute("data-bs-content", content + INVISIBLE_CHAR);
    createPopover();
  };
  onMount(createPopover);
  onDestroy(disposePopover);
  onDestroy(() => {
    document.removeEventListener("click", clickEvent);
  });
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popoverEl = $$value;
      $$invalidate(2, popoverEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("header" in $$props2)
      $$invalidate(0, header = $$props2.header);
    if ("content" in $$props2)
      $$invalidate(1, content = $$props2.content);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 10) {
      content && popoverInstance && recreatePopover();
    }
  };
  return [header, content, popoverEl, popoverInstance, $$scope, slots, span_binding];
}
class Popover extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3y, create_fragment$3C, safe_not_equal, { header: 0, content: 1 });
  }
}
var Autocomplete_svelte_svelte_type_style_lang = "";
function create_if_block$24(ctx) {
  let menulist;
  let current;
  menulist = new MenuList({
    props: {
      show: true,
      id: ctx[0],
      focusedId: ctx[3],
      hasMainSlot: false,
      allowNull: false,
      dropDownClass: "overflow-auto max-h-80",
      items: ctx[7].map(func$2),
      $$slots: {
        "item-right": [
          create_item_right_slot$1,
          ({ item }) => ({ 23: item }),
          ({ item }) => item ? 8388608 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  menulist.$on("select", ctx[16]);
  return {
    c() {
      create_component(menulist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menulist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menulist_changes = {};
      if (dirty & 1)
        menulist_changes.id = ctx2[0];
      if (dirty & 8)
        menulist_changes.focusedId = ctx2[3];
      if (dirty & 128)
        menulist_changes.items = ctx2[7].map(func$2);
      if (dirty & 25165824) {
        menulist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menulist.$set(menulist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menulist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menulist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menulist, detaching);
    }
  };
}
function create_item_right_slot$1(ctx) {
  let small;
  let t_value = ctx[23].type + "";
  let t;
  return {
    c() {
      small = element("small");
      t = text(t_value);
      attr(small, "slot", "item-right");
      attr(small, "class", "pl-1");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8388608 && t_value !== (t_value = ctx2[23].type + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment$3B(ctx) {
  let div1;
  let input_1;
  let t;
  let div0;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[2] && create_if_block$24(ctx);
  return {
    c() {
      div1 = element("div");
      input_1 = element("input");
      t = space();
      div0 = element("div");
      if (if_block)
        if_block.c();
      attr(input_1, "type", "text");
      attr(input_1, "class", "form-control input z-2 position-relative svelte-1e2dako");
      input_1.value = ctx[0];
      input_1.disabled = ctx[1];
      attr(input_1, "placeholder", "(all data)");
      attr(div0, "class", "z-1000000 fixed svelte-1e2dako");
      attr(div1, "class", "flex-grow");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, input_1);
      ctx[14](input_1);
      append(div1, t);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      ctx[17](div0);
      ctx[18](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input_1, "input", ctx[8]),
          listen(input_1, "keydown", ctx[10]),
          listen(input_1, "focus", ctx[15]),
          action_destroyer(clickOutside.call(null, div1)),
          listen(div1, "outclick", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1 && input_1.value !== ctx2[0]) {
        input_1.value = ctx2[0];
      }
      if (!current || dirty & 2) {
        input_1.disabled = ctx2[1];
      }
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[14](null);
      if (if_block)
        if_block.d();
      ctx[17](null);
      ctx[18](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function selectAllText(event) {
  event.target.select();
}
const func$2 = (item) => ({
  name: item.name,
  id: item.path,
  type: item.type
});
function instance$3x($$self, $$props, $$invalidate) {
  let filteredSuggestions;
  let { suggestions = [] } = $$props;
  let { input = "" } = $$props;
  let { onChange } = $$props;
  let { disabled = false } = $$props;
  let showSuggestions = false;
  let focusedId = void 0;
  let contEl;
  function onInput(event) {
    $$invalidate(0, input = event.target.value);
    $$invalidate(7, filteredSuggestions = suggestions.filter((suggestion) => suggestion.name.toLowerCase().includes(input.toLowerCase())));
    $$invalidate(2, showSuggestions = true);
    onChange(input);
  }
  function onClickSuggestion(path) {
    $$invalidate(0, input = path);
    $$invalidate(2, showSuggestions = false);
    onChange(input);
  }
  const updateFocusedId = (index2) => {
    var _a;
    if (index2 >= 0 && index2 < filteredSuggestions.length) {
      $$invalidate(3, focusedId = (_a = filteredSuggestions[index2]) == null ? void 0 : _a.path);
    }
  };
  const focusNext = () => {
    let index2 = filteredSuggestions.findIndex((sugg) => sugg.path === focusedId);
    index2 = (index2 + 1) % filteredSuggestions.length;
    updateFocusedId(index2);
  };
  const focusPrevious = () => {
    let index2 = filteredSuggestions.findIndex((sugg) => sugg.path === focusedId);
    index2 = (index2 - 1 + filteredSuggestions.length) % filteredSuggestions.length;
    updateFocusedId(index2);
  };
  function onKeyDown(event) {
    var _a;
    if (event.key === "ArrowDown") {
      $$invalidate(2, showSuggestions = true);
    }
    if (!showSuggestions)
      return;
    if (["Enter", "ArrowUp", "ArrowDown", "Escape"].includes(event.key)) {
      event.preventDefault();
    }
    if (event.key === "Enter") {
      const newPath = (_a = filteredSuggestions.find((sugg) => sugg.path === focusedId)) == null ? void 0 : _a.path;
      if (newPath !== void 0) {
        $$invalidate(0, input = newPath);
        $$invalidate(2, showSuggestions = false);
        onChange(input);
        $$invalidate(7, filteredSuggestions = suggestions);
      }
    } else if (event.key === "ArrowUp") {
      focusPrevious();
    } else if (event.key === "ArrowDown") {
      focusNext();
    } else if (event.key === "Escape") {
      $$invalidate(2, showSuggestions = false);
    }
    setTimeout(() => {
      var _a2;
      return (_a2 = contEl.querySelector(".focused")) == null ? void 0 : _a2.scrollIntoView({ block: "nearest" });
    }, 1);
  }
  let inputEl;
  let dropdownEl;
  let popperInstance;
  onMount(() => {
    $$invalidate(13, popperInstance = window.Popper.createPopper(inputEl, dropdownEl, {
      placement: "bottom-start",
      strategy: "fixed"
    }));
    return () => {
      popperInstance.destroy();
    };
  });
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(5, inputEl);
    });
  }
  const focus_handler = (event) => {
    $$invalidate(2, showSuggestions = true);
    selectAllText(event);
  };
  const select_handler = (e) => onClickSuggestion(e.detail);
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dropdownEl = $$value;
      $$invalidate(6, dropdownEl);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contEl = $$value;
      $$invalidate(4, contEl);
    });
  }
  const outclick_handler = () => $$invalidate(2, showSuggestions = false);
  $$self.$$set = ($$props2) => {
    if ("suggestions" in $$props2)
      $$invalidate(11, suggestions = $$props2.suggestions);
    if ("input" in $$props2)
      $$invalidate(0, input = $$props2.input);
    if ("onChange" in $$props2)
      $$invalidate(12, onChange = $$props2.onChange);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2048) {
      $$invalidate(7, filteredSuggestions = suggestions);
    }
    if ($$self.$$.dirty & 1) {
      input && $$invalidate(3, focusedId = input);
    }
    if ($$self.$$.dirty & 8196) {
      showSuggestions && popperInstance.forceUpdate();
    }
  };
  return [
    input,
    disabled,
    showSuggestions,
    focusedId,
    contEl,
    inputEl,
    dropdownEl,
    filteredSuggestions,
    onInput,
    onClickSuggestion,
    onKeyDown,
    suggestions,
    onChange,
    popperInstance,
    input_1_binding,
    focus_handler,
    select_handler,
    div0_binding,
    div1_binding,
    outclick_handler
  ];
}
class Autocomplete extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3x, create_fragment$3B, safe_not_equal, {
      suggestions: 11,
      input: 0,
      onChange: 12,
      disabled: 1
    });
  }
}
const getSieveConditionInputs = (sieve) => {
  var _a, _b, _c;
  const contentType = sieve.content_type;
  let inputs = getGlobalConditionInputs();
  const isSummaryEnabled = (_a = USER.prefs.summary) == null ? void 0 : _a.enabled;
  if (contentType === C$1.TYPE_HTML) {
    const params2 = (_c = (_b = USER.prefs.summary) == null ? void 0 : _b.params) != null ? _c : [];
    inputs = inputs.concat([
      {
        id: "$summary.new",
        name: "Summary",
        type: "json",
        schema: {
          type: "object",
          properties: params2.reduce((acc, cur) => {
            acc[cur.name] = { type: cur.type };
            return acc;
          }, {})
        },
        inactive: !isSummaryEnabled
      }
    ]);
  }
  if (contentType === C$1.TYPE_JSON) {
    const dataLabels = {
      "$new": "Data",
      "$old": "Previous Data"
    };
    inputs = inputs.map((input) => {
      if (["$new", "$old"].includes(input.id)) {
        return {
          ...input,
          name: dataLabels[input.id],
          type: "json"
        };
      }
      return input;
    });
  }
  return inputs;
};
const getGlobalConditionInputs = () => [
  {
    id: "$new",
    name: TXT("l_text")
  },
  {
    id: "$diff.new",
    name: TXT("l_added_text")
  },
  {
    id: "$diff.old",
    name: TXT("l_text_del")
  },
  {
    id: "$old",
    name: TXT("l_text_old")
  },
  {
    id: "$diff.net_add",
    name: TXT("l_net_added_text")
  },
  {
    id: "$diff.net_del",
    name: TXT("l_net_deleted_text")
  }
];
const getDefaultInputs = (contentType) => {
  const inputs = getGlobalConditionInputs();
  if (contentType === C$1.TYPE_JSON) {
    return inputs.map((input) => {
      if (["$new", "$old"].includes(input.id)) {
        return {
          ...input,
          type: "json"
        };
      }
      return input;
    });
  }
  inputs.push({
    id: "$summary.new",
    name: "Summary",
    type: "json"
  });
  return inputs;
};
const convertSchemaToList = (schema) => {
  const schemaItems = [];
  const schemaToList = (path, schema2, label) => {
    let { type, properties, items } = schema2;
    if (type === "array") {
      schemaItems.push({ path, type });
      if (items) {
        schemaToList(path + ".0", items);
      }
    } else if (type === "object") {
      schemaItems.push({ path, type });
      if (properties) {
        Object.keys(properties).map((key) => schemaToList(`${path}.${key}`, properties[key]));
      }
    } else {
      schemaItems.push({ path, type });
    }
  };
  schemaToList("", schema);
  schemaItems.forEach((item) => {
    item.path = item.path.slice(1);
    item.name = item.path;
  });
  schemaItems[0].name = "(all data)";
  return schemaItems;
};
const UPTIME_JSON_SCHEMA = {
  type: "object",
  properties: {
    status: {
      type: "object",
      properties: {
        code: { type: "number" },
        message: { type: "string" }
      }
    },
    headers: {
      type: "object",
      properties: {}
    }
  }
};
function create_if_block$23(ctx) {
  let popover;
  let current;
  popover = new Popover({
    props: {
      header: "current value",
      content: ctx[4],
      $$slots: { default: [create_default_slot$1e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(popover.$$.fragment);
    },
    m(target, anchor) {
      mount_component(popover, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const popover_changes = {};
      if (dirty & 16)
        popover_changes.content = ctx2[4];
      if (dirty & 4096) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(popover, detaching);
    }
  };
}
function create_default_slot$1e(ctx) {
  let button;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-bug text-secondary"></i>`;
      attr(button, "class", "btn btn-link");
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
    }
  };
}
function create_fragment$3A(ctx) {
  let autocomplete;
  let t;
  let if_block_anchor;
  let current;
  autocomplete = new Autocomplete({
    props: {
      suggestions: ctx[5],
      disabled: ctx[2],
      input: ctx[0],
      onChange: ctx[11]
    }
  });
  let if_block = ctx[3] && create_if_block$23(ctx);
  return {
    c() {
      create_component(autocomplete.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(autocomplete, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const autocomplete_changes = {};
      if (dirty & 32)
        autocomplete_changes.suggestions = ctx2[5];
      if (dirty & 4)
        autocomplete_changes.disabled = ctx2[2];
      if (dirty & 1)
        autocomplete_changes.input = ctx2[0];
      if (dirty & 2)
        autocomplete_changes.onChange = ctx2[11];
      autocomplete.$set(autocomplete_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$23(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(autocomplete.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(autocomplete.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(autocomplete, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$3w($$self, $$props, $$invalidate) {
  let showVariable;
  let $ctxEditorSieveDataInputs;
  const ctxEditorSieveDataInputs = getContext("editorSieveDataInputs");
  component_subscribe($$self, ctxEditorSieveDataInputs, (value2) => $$invalidate(10, $ctxEditorSieveDataInputs = value2));
  let { schema } = $$props;
  let { value } = $$props;
  let { operand } = $$props;
  let { onChange } = $$props;
  let { disabled } = $$props;
  let data = "";
  let previousSchema;
  let suggestions = [];
  const func2 = (val) => onChange(val);
  $$self.$$set = ($$props2) => {
    if ("schema" in $$props2)
      $$invalidate(7, schema = $$props2.schema);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("operand" in $$props2)
      $$invalidate(8, operand = $$props2.operand);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      $$invalidate(3, showVariable = !!$ctxEditorSieveDataInputs);
    }
    if ($$self.$$.dirty & 1288) {
      {
        if (showVariable) {
          let newData = getVar(operand, { vars: $ctxEditorSieveDataInputs });
          $$invalidate(4, data = newData === void 0 ? "<undefined>" : JSON.stringify(newData));
        }
      }
    }
    if ($$self.$$.dirty & 640) {
      {
        if (schema !== previousSchema) {
          $$invalidate(5, suggestions = convertSchemaToList(schema != null ? schema : { type: "string" }));
          $$invalidate(9, previousSchema = schema);
        }
      }
    }
  };
  return [
    value,
    onChange,
    disabled,
    showVariable,
    data,
    suggestions,
    ctxEditorSieveDataInputs,
    schema,
    operand,
    previousSchema,
    $ctxEditorSieveDataInputs,
    func2
  ];
}
class SchemaPathSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3w, create_fragment$3A, safe_not_equal, {
      schema: 7,
      value: 0,
      operand: 8,
      onChange: 1,
      disabled: 2
    });
  }
}
var Left_svelte_svelte_type_style_lang = "";
function create_label_slot$2(ctx) {
  let span1;
  let span0;
  let t_value = ctx[3].name + "";
  let t;
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      t = text(t_value);
      attr(span0, "class", "flex-1");
      attr(span1, "slot", "label");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, span0);
      append(span0, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span1);
    }
  };
}
function create_default_slot$1d(ctx) {
  let t;
  return {
    c() {
      t = text("Learn More");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_bottom_slot$5(ctx) {
  let li;
  let t;
  let menuitemlink;
  let current;
  menuitemlink = new MenuItemLink({
    props: {
      class: "dropdown-item",
      href: URL_WEBSITE + "/docs/web-monitor/using-conditions-to-get-alert-on-important-changes/",
      target: "_blank",
      $$slots: { default: [create_default_slot$1d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      li = element("li");
      t = space();
      create_component(menuitemlink.$$.fragment);
      attr(li, "class", "dropdown-divider");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      insert(target, t, anchor);
      mount_component(menuitemlink, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemlink_changes = {};
      if (dirty & 256) {
        menuitemlink_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemlink.$set(menuitemlink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemlink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemlink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t);
      destroy_component(menuitemlink, detaching);
    }
  };
}
function create_if_block$22(ctx) {
  let schemapathselector;
  let current;
  schemapathselector = new SchemaPathSelector({
    props: {
      disabled: ctx[1],
      operand: ctx[0],
      onChange: ctx[7],
      value: ctx[0].slice(ctx[3].id.length + 1),
      schema: ctx[3].schema
    }
  });
  return {
    c() {
      create_component(schemapathselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(schemapathselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const schemapathselector_changes = {};
      if (dirty & 2)
        schemapathselector_changes.disabled = ctx2[1];
      if (dirty & 1)
        schemapathselector_changes.operand = ctx2[0];
      if (dirty & 9)
        schemapathselector_changes.onChange = ctx2[7];
      if (dirty & 9)
        schemapathselector_changes.value = ctx2[0].slice(ctx2[3].id.length + 1);
      if (dirty & 8)
        schemapathselector_changes.schema = ctx2[3].schema;
      schemapathselector.$set(schemapathselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(schemapathselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(schemapathselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(schemapathselector, detaching);
    }
  };
}
function create_fragment$3z(ctx) {
  let div;
  let menu;
  let t;
  let current;
  menu = new Menu({
    props: {
      id: ctx[4],
      items: ctx[2].filter(func$1),
      allowNull: false,
      actionClass: "btn btn-default w-40 text-start",
      style: "text-align: start;",
      disabled: ctx[1],
      strategy: "fixed",
      $$slots: {
        bottom: [create_bottom_slot$5],
        label: [create_label_slot$2]
      },
      $$scope: { ctx }
    }
  });
  menu.$on("select", ctx[6]);
  menu.$on("search", ctx[5]);
  let if_block = ctx[3].type === "json" && create_if_block$22(ctx);
  return {
    c() {
      var _a;
      div = element("div");
      create_component(menu.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "svelte-xfsr8a");
      toggle_class(div, "input-group", ((_a = ctx[3]) == null ? void 0 : _a.type) === "json");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(menu, div, null);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a;
      const menu_changes = {};
      if (dirty & 16)
        menu_changes.id = ctx2[4];
      if (dirty & 4)
        menu_changes.items = ctx2[2].filter(func$1);
      if (dirty & 2)
        menu_changes.disabled = ctx2[1];
      if (dirty & 264) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (ctx2[3].type === "json") {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 8) {
        toggle_class(div, "input-group", ((_a = ctx2[3]) == null ? void 0 : _a.type) === "json");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(menu);
      if (if_block)
        if_block.d();
    }
  };
}
const func$1 = (i2) => !i2.inactive;
function instance$3v($$self, $$props, $$invalidate) {
  let id2;
  let { operand } = $$props;
  let { disabled } = $$props;
  let { items } = $$props;
  let { selectedItem } = $$props;
  const onSearch = (e) => {
    e.detail;
  };
  const select_handler = (e) => {
    $$invalidate(0, operand = e.detail);
  };
  const func_12 = (val) => {
    $$invalidate(0, operand = selectedItem.id + "." + val);
  };
  $$self.$$set = ($$props2) => {
    if ("operand" in $$props2)
      $$invalidate(0, operand = $$props2.operand);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("items" in $$props2)
      $$invalidate(2, items = $$props2.items);
    if ("selectedItem" in $$props2)
      $$invalidate(3, selectedItem = $$props2.selectedItem);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $$invalidate(4, id2 = selectedItem == null ? void 0 : selectedItem.id);
    }
  };
  return [operand, disabled, items, selectedItem, id2, onSearch, select_handler, func_12];
}
class Left extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3v, create_fragment$3z, safe_not_equal, {
      operand: 0,
      disabled: 1,
      items: 2,
      selectedItem: 3
    });
  }
}
function create_if_block$21(ctx) {
  let div;
  let t_value = ctx[5].operandTypeHint + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "text-muted");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[5].operandTypeHint + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_item_right_slot(ctx) {
  let div;
  let if_block = ctx[5].operandTypeHint && create_if_block$21(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "slot", "item-right");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (ctx2[5].operandTypeHint) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$21(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_fragment$3y(ctx) {
  let searchablemenu;
  let updating_id;
  let current;
  function searchablemenu_id_binding(value) {
    ctx[3](value);
  }
  let searchablemenu_props = {
    items: ctx[1],
    allowNull: false,
    actionClass: "btn btn-default",
    strategy: "fixed",
    disabled: ctx[2],
    useLocalSearch: true,
    $$slots: {
      "item-right": [
        create_item_right_slot,
        ({ item }) => ({ 5: item }),
        ({ item }) => item ? 32 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    searchablemenu_props.id = ctx[0];
  }
  searchablemenu = new SearchableMenu({ props: searchablemenu_props });
  binding_callbacks.push(() => bind$1(searchablemenu, "id", searchablemenu_id_binding));
  searchablemenu.$on("select", ctx[4]);
  return {
    c() {
      create_component(searchablemenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchablemenu_changes = {};
      if (dirty & 2)
        searchablemenu_changes.items = ctx2[1];
      if (dirty & 4)
        searchablemenu_changes.disabled = ctx2[2];
      if (dirty & 96) {
        searchablemenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        searchablemenu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      searchablemenu.$set(searchablemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemenu, detaching);
    }
  };
}
function instance$3u($$self, $$props, $$invalidate) {
  let { id: id2 } = $$props;
  let { items = [] } = $$props;
  let { disabled } = $$props;
  function searchablemenu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  function select_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("items" in $$props2)
      $$invalidate(1, items = $$props2.items);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  return [id2, items, disabled, searchablemenu_id_binding, select_handler];
}
class Operator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3u, create_fragment$3y, safe_not_equal, { id: 0, items: 1, disabled: 2 });
  }
}
function create_if_block$20(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Invalid regular expression";
      attr(div, "class", "invalid-tooltip");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$3x(ctx) {
  let div;
  let input0;
  let t0;
  let t1;
  let input1;
  let mounted;
  let dispose;
  let if_block = ctx[4] && create_if_block$20();
  return {
    c() {
      div = element("div");
      input0 = element("input");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      input1 = element("input");
      attr(input0, "class", "flex form-control xform-control-sm");
      attr(input0, "type", "text");
      attr(input0, "autocomplete", "off");
      attr(input0, "placeholder", "Expression");
      input0.disabled = ctx[1];
      toggle_class(input0, "is-invalid", ctx[4]);
      attr(input1, "class", "flex form-control xform-control-sm w-20");
      attr(input1, "type", "text");
      attr(input1, "autocomplete", "off");
      attr(input1, "placeholder", "Flags");
      input1.disabled = ctx[1];
      toggle_class(input1, "is-invalid", ctx[4]);
      attr(div, "class", "form-control pa0 border-0 input-group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input0);
      set_input_value(input0, ctx[2]);
      append(div, t0);
      if (if_block)
        if_block.m(div, null);
      append(div, t1);
      append(div, input1);
      set_input_value(input1, ctx[3]);
      if (!mounted) {
        dispose = [
          listen(input0, "beforeinput", ctx[7], { once: true }),
          listen(input0, "input", ctx[8]),
          listen(input0, "input", ctx[9]),
          listen(input1, "beforeinput", ctx[10], { once: true }),
          listen(input1, "input", ctx[11]),
          listen(input1, "input", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        input0.disabled = ctx2[1];
      }
      if (dirty & 4 && input0.value !== ctx2[2]) {
        set_input_value(input0, ctx2[2]);
      }
      if (dirty & 16) {
        toggle_class(input0, "is-invalid", ctx2[4]);
      }
      if (ctx2[4]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$20();
          if_block.c();
          if_block.m(div, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 2) {
        input1.disabled = ctx2[1];
      }
      if (dirty & 8 && input1.value !== ctx2[3]) {
        set_input_value(input1, ctx2[3]);
      }
      if (dirty & 16) {
        toggle_class(input1, "is-invalid", ctx2[4]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3t($$self, $$props, $$invalidate) {
  let $regex, $$unsubscribe_regex = noop$1, $$subscribe_regex = () => ($$unsubscribe_regex(), $$unsubscribe_regex = subscribe(regex, ($$value) => $$invalidate(13, $regex = $$value)), regex);
  let $showError;
  $$self.$$.on_destroy.push(() => $$unsubscribe_regex());
  let { regex } = $$props;
  $$subscribe_regex();
  let { disabled } = $$props;
  regex.dirty;
  let expr = $regex.expr;
  let flags = $regex.flags;
  const { showError } = regex;
  component_subscribe($$self, showError, (value) => $$invalidate(4, $showError = value));
  function set(key, value) {
    regex.update(($old) => ({ ...$old, [key]: value }));
  }
  const beforeinput_handler = () => {
    regex.setTouched(true);
  };
  function input0_input_handler() {
    expr = this.value;
    $$invalidate(2, expr);
  }
  const input_handler = (e) => set("expr", e.target.value);
  const beforeinput_handler_1 = () => {
    regex.setTouched(true);
  };
  function input1_input_handler() {
    flags = this.value;
    $$invalidate(3, flags);
  }
  const input_handler_1 = (e) => set("flags", e.target.value);
  $$self.$$set = ($$props2) => {
    if ("regex" in $$props2)
      $$subscribe_regex($$invalidate(0, regex = $$props2.regex));
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  return [
    regex,
    disabled,
    expr,
    flags,
    $showError,
    showError,
    set,
    beforeinput_handler,
    input0_input_handler,
    input_handler,
    beforeinput_handler_1,
    input1_input_handler,
    input_handler_1
  ];
}
class Regex extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3t, create_fragment$3x, safe_not_equal, { regex: 0, disabled: 1 });
  }
}
function create_if_block_3$F(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "class", "form-control xform-control-sm");
      attr(input, "type", ctx[3]);
      input.value = ctx[0];
      attr(input, "autocomplete", "off");
      attr(input, "placeholder", ctx[3]);
      input.disabled = ctx[2];
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8) {
        attr(input, "type", ctx2[3]);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
      if (dirty & 8) {
        attr(input, "placeholder", ctx2[3]);
      }
      if (dirty & 4) {
        input.disabled = ctx2[2];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$R(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "class", "form-control xform-control-sm");
      attr(input, "type", ctx[3]);
      input.value = ctx[0];
      attr(input, "autocomplete", "off");
      attr(input, "placeholder", ctx[3]);
      input.disabled = ctx[2];
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8) {
        attr(input, "type", ctx2[3]);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
      if (dirty & 8) {
        attr(input, "placeholder", ctx2[3]);
      }
      if (dirty & 4) {
        input.disabled = ctx2[2];
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$1m(ctx) {
  let regex;
  let current;
  regex = new Regex({
    props: {
      regex: ctx[4],
      disabled: ctx[2]
    }
  });
  return {
    c() {
      create_component(regex.$$.fragment);
    },
    m(target, anchor) {
      mount_component(regex, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const regex_changes = {};
      if (dirty & 16)
        regex_changes.regex = ctx2[4];
      if (dirty & 4)
        regex_changes.disabled = ctx2[2];
      regex.$set(regex_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(regex.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(regex.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(regex, detaching);
    }
  };
}
function create_if_block$1$(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Unknown operator - upgrading app maybe needed";
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$3w(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1$, create_if_block_1$1m, create_if_block_2$R, create_if_block_3$F];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!defs[ctx2[1]])
      return 0;
    if (ctx2[3] === "regex")
      return 1;
    if (ctx2[3] == "number")
      return 2;
    if (ctx2[3] != null)
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$3s($$self, $$props, $$invalidate) {
  let { operator } = $$props;
  let { value } = $$props;
  let { disabled } = $$props;
  let type = "text";
  let regexStore = null;
  updateType(operator);
  function createRegexStore() {
    $$invalidate(4, regexStore = createFieldStore({ type: "regex" }, value ? value : void 0));
    regexStore.subscribe((fsVal) => {
      $$invalidate(0, value = fsVal);
    });
  }
  function updateType(operator2) {
    const def = getDef(operator2);
    $$invalidate(3, type = def == null ? void 0 : def.fieldType);
    if (type === "regex" && !regexStore) {
      createRegexStore();
    }
  }
  const input_handler = (e) => $$invalidate(0, value = e.target.valueAsNumber);
  const input_handler_1 = (e) => $$invalidate(0, value = e.target.value);
  $$self.$$set = ($$props2) => {
    if ("operator" in $$props2)
      $$invalidate(1, operator = $$props2.operator);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      updateType(operator);
    }
  };
  return [value, operator, disabled, type, regexStore, input_handler, input_handler_1];
}
class Right extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3s, create_fragment$3w, safe_not_equal, { operator: 1, value: 0, disabled: 2 });
  }
}
function create_fragment$3v(ctx) {
  let span;
  let t;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t = text(ctx[0]);
      attr(span, "class", span_class_value = "text-capitalize badge " + ctx[1]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
      if (dirty & 2 && span_class_value !== (span_class_value = "text-capitalize badge " + ctx2[1])) {
        attr(span, "class", span_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function instance$3r($$self, $$props, $$invalidate) {
  let finalClass;
  let { result: result2 } = $$props;
  let { classes = {
    true: "text-bg-light text-success",
    false: "text-bg-light text-danger"
  } } = $$props;
  $$self.$$set = ($$props2) => {
    if ("result" in $$props2)
      $$invalidate(0, result2 = $$props2.result);
    if ("classes" in $$props2)
      $$invalidate(2, classes = $$props2.classes);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 5) {
      $$invalidate(1, finalClass = classes[result2]);
    }
  };
  return [result2, finalClass, classes];
}
class RuleResult extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3r, create_fragment$3v, safe_not_equal, { result: 0, classes: 2 });
  }
}
function create_if_block_1$1l(ctx) {
  let div1;
  let div0;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      result: ctx[2].get(ctx[0])
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      create_component(ruleresult.$$.fragment);
      attr(div0, "class", "d-flex");
      attr(div1, "class", "py-2");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(ruleresult, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 5)
        ruleresult_changes.result = ctx2[2].get(ctx2[0]);
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(ruleresult);
    }
  };
}
function create_if_block$1_(ctx) {
  let button;
  let cross;
  let current;
  let mounted;
  let dispose;
  cross = new Cross({ props: { class: "h-5 w-5" } });
  return {
    c() {
      button = element("button");
      create_component(cross.$$.fragment);
      attr(button, "class", "btn btn-default btn-sm flex items-center px-2");
      attr(button, "title", TXT("a_del"));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(cross, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[6]);
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      destroy_component(cross);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$3u(ctx) {
  let div;
  let left;
  let updating_operand;
  let t0;
  let operator;
  let updating_id;
  let t1;
  let right;
  let updating_value;
  let t2;
  let t3;
  let current;
  function left_operand_binding(value) {
    ctx[8](value);
  }
  let left_props = {
    selectedItem: ctx[5],
    items: ctx[3],
    disabled: ctx[1]
  };
  if (ctx[0].expr[1] !== void 0) {
    left_props.operand = ctx[0].expr[1];
  }
  left = new Left({ props: left_props });
  binding_callbacks.push(() => bind$1(left, "operand", left_operand_binding));
  function operator_id_binding(value) {
    ctx[9](value);
  }
  let operator_props = {
    disabled: ctx[1],
    items: ctx[4]
  };
  if (ctx[0].expr[0] !== void 0) {
    operator_props.id = ctx[0].expr[0];
  }
  operator = new Operator({ props: operator_props });
  binding_callbacks.push(() => bind$1(operator, "id", operator_id_binding));
  operator.$on("select", ctx[7]);
  function right_value_binding(value) {
    ctx[10](value);
  }
  let right_props = {
    disabled: ctx[1],
    operator: ctx[0].expr[0]
  };
  if (ctx[0].expr[2] !== void 0) {
    right_props.value = ctx[0].expr[2];
  }
  right = new Right({ props: right_props });
  binding_callbacks.push(() => bind$1(right, "value", right_value_binding));
  let if_block0 = ctx[0].result !== void 0 && create_if_block_1$1l(ctx);
  let if_block1 = !ctx[1] && create_if_block$1_(ctx);
  return {
    c() {
      div = element("div");
      create_component(left.$$.fragment);
      t0 = space();
      create_component(operator.$$.fragment);
      t1 = space();
      create_component(right.$$.fragment);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "flex flex-row mb-2 space-x-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(left, div, null);
      append(div, t0);
      mount_component(operator, div, null);
      append(div, t1);
      mount_component(right, div, null);
      append(div, t2);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const left_changes = {};
      if (dirty & 32)
        left_changes.selectedItem = ctx2[5];
      if (dirty & 8)
        left_changes.items = ctx2[3];
      if (dirty & 2)
        left_changes.disabled = ctx2[1];
      if (!updating_operand && dirty & 1) {
        updating_operand = true;
        left_changes.operand = ctx2[0].expr[1];
        add_flush_callback(() => updating_operand = false);
      }
      left.$set(left_changes);
      const operator_changes = {};
      if (dirty & 2)
        operator_changes.disabled = ctx2[1];
      if (dirty & 16)
        operator_changes.items = ctx2[4];
      if (!updating_id && dirty & 1) {
        updating_id = true;
        operator_changes.id = ctx2[0].expr[0];
        add_flush_callback(() => updating_id = false);
      }
      operator.$set(operator_changes);
      const right_changes = {};
      if (dirty & 2)
        right_changes.disabled = ctx2[1];
      if (dirty & 1)
        right_changes.operator = ctx2[0].expr[0];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        right_changes.value = ctx2[0].expr[2];
        add_flush_callback(() => updating_value = false);
      }
      right.$set(right_changes);
      if (ctx2[0].result !== void 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$1l(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1_(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(left.$$.fragment, local);
      transition_in(operator.$$.fragment, local);
      transition_in(right.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(left.$$.fragment, local);
      transition_out(operator.$$.fragment, local);
      transition_out(right.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(left);
      destroy_component(operator);
      destroy_component(right);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$3q($$self, $$props, $$invalidate) {
  var _a;
  let selectedInput;
  let { disabled } = $$props;
  let { results = /* @__PURE__ */ new Map() } = $$props;
  let { inputs } = $$props;
  const dispatch = createEventDispatcher();
  let operators;
  let { rule } = $$props;
  function onDel(event) {
    dispatch("delete");
  }
  const conditionsRevisionFF = parseInt((_a = USER.features.conditions_revision) != null ? _a : "0");
  function updateOperators() {
    $$invalidate(4, operators = Object.values(defs).filter((def) => {
      var _a2;
      const revision = (_a2 = def.featureFlagRevision) != null ? _a2 : 0;
      return revision <= conditionsRevisionFF;
    }).map((def) => ({ ...def, name: TXT("l_" + def.id) })));
    const textNotPresentOperatorId = "not_match_any_previous_text";
    const deltaConditions = [
      "has_num_decr_min",
      "has_num_incr_min",
      "has_num_decr_pct_min",
      "has_num_incr_pct_min"
    ];
    const fallbackRuleExpr = () => {
      $$invalidate(0, rule.expr[0] = defs.contains.id, rule);
      $$invalidate(0, rule.expr[2] = defs.contains.fieldType, rule);
    };
    if (selectedInput.id !== "$new") {
      $$invalidate(4, operators = operators.filter((op) => op.id !== textNotPresentOperatorId));
    }
    if (!["$diff.new", "$new", "$summary.new"].includes(selectedInput.id)) {
      $$invalidate(4, operators = operators.filter((op) => !deltaConditions.includes(op.id)));
    }
    if (selectedInput.type !== "json") {
      $$invalidate(4, operators = operators.filter((op) => op.operandType !== "json"));
    }
    if (operators.map((op) => op.id).indexOf(rule.expr[0]) === -1) {
      fallbackRuleExpr();
    }
  }
  const findMatchingInput = (inputs2, operand) => {
    const operandItems = operand.split(".");
    let s = operandItems.shift();
    while (true) {
      let input = inputs2.find((i2) => i2.id === s);
      if (input) {
        return input;
      }
      if (operandItems.length == 0) {
        return void 0;
      }
      s += "." + operandItems.shift();
    }
  };
  function onOperatorChange(e) {
    let op = e.detail;
    let currentValue = rule.expr[2];
    let defaultValue;
    let def = getDef(op);
    if (!def || def.fieldType == "text") {
      if (typeof currentValue == "string") {
        defaultValue = rule.expr[2];
      } else {
        defaultValue = "";
      }
    } else if (def.fieldType == "number") {
      if (typeof currentValue == "number") {
        defaultValue = currentValue;
      } else {
        defaultValue = 0;
      }
    } else {
      if (def.defaultValue) {
        defaultValue = def.defaultValue();
      } else if (def.fieldType != null) {
        throw new Error("cant set default value for rule def:" + def.id);
      }
    }
    $$invalidate(0, rule.expr[2] = defaultValue, rule);
    dispatch("operatorChange", op);
  }
  function left_operand_binding(value) {
    if ($$self.$$.not_equal(rule.expr[1], value)) {
      rule.expr[1] = value;
      $$invalidate(0, rule);
    }
  }
  function operator_id_binding(value) {
    if ($$self.$$.not_equal(rule.expr[0], value)) {
      rule.expr[0] = value;
      $$invalidate(0, rule);
    }
  }
  function right_value_binding(value) {
    if ($$self.$$.not_equal(rule.expr[2], value)) {
      rule.expr[2] = value;
      $$invalidate(0, rule);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("results" in $$props2)
      $$invalidate(2, results = $$props2.results);
    if ("inputs" in $$props2)
      $$invalidate(3, inputs = $$props2.inputs);
    if ("rule" in $$props2)
      $$invalidate(0, rule = $$props2.rule);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 9) {
      $$invalidate(5, selectedInput = findMatchingInput(inputs, rule.expr[1]));
    }
    if ($$self.$$.dirty & 1) {
      rule.expr[1], rule.expr[0] && updateOperators();
    }
  };
  return [
    rule,
    disabled,
    results,
    inputs,
    operators,
    selectedInput,
    onDel,
    onOperatorChange,
    left_operand_binding,
    operator_id_binding,
    right_value_binding
  ];
}
class Condition extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3q, create_fragment$3u, safe_not_equal, {
      disabled: 1,
      results: 2,
      inputs: 3,
      rule: 0
    });
  }
}
function defaultRule() {
  return new SingleRule("contains", "$new", "");
}
function createStore(rules) {
  const { subscribe: subscribe2, set, update } = writable(["or"]);
  set(rules);
  return {
    subscribe: subscribe2,
    set,
    update,
    onAddRuleGrp: function(idxRuleGrp) {
      update((value) => {
        const existingExpr = value.expr[idxRuleGrp + 1];
        existingExpr.expr.push(defaultRule());
        return value;
      });
    },
    addOrCondition: function() {
      update((value) => {
        value.expr.push(new And(defaultRule()));
        return value;
      });
    },
    onRemoveRule: function(idxRuleGrp, idxRule) {
      update((value) => {
        const existingExpr = value.expr[idxRuleGrp + 1];
        existingExpr.expr.splice(idxRule + 1, 1);
        if (existingExpr.expr.length === 1) {
          value.expr.splice(idxRuleGrp + 1, 1);
        }
        return value;
      });
    },
    addRule: function() {
      update((value) => {
        if (value.expr.length === 0) {
          value.expr.push(new Or());
        }
        value.expr.push(new And(defaultRule()));
        return value;
      });
    }
  };
}
function create_fragment$3t(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { fill: "none" },
    { viewBox: "0 0 24 24" },
    { stroke: "currentColor" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "2");
      attr(path, "d", "M12 6v6m0 0v6m0-6h6m-6 0H6");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        { viewBox: "0 0 24 24" },
        { stroke: "currentColor" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$3p($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Plus extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3p, create_fragment$3t, safe_not_equal, {});
  }
}
function get_each_context$Z(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  child_ctx[16] = i2;
  return child_ctx;
}
function get_each_context_1$a(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  child_ctx[18] = list;
  child_ctx[19] = i2;
  return child_ctx;
}
function create_else_block$16(ctx) {
  let div1;
  let div0;
  let t0_value = TXT("l_continue_only") + "";
  let t0;
  let t1;
  let show_if = ctx[2].get(ctx[4].expr[1]) !== void 0;
  let t2;
  let t3;
  let current;
  let if_block0 = show_if && create_if_block_6$d(ctx);
  let each_value = ctx[4].expr.slice(1);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$Z(get_each_context$Z(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block1 = ctx[5] && create_if_block_1$1k(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "mb-1");
      attr(div1, "class", "flex flex-col m-2");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append(div1, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div1, t3);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 20)
        show_if = ctx2[2].get(ctx2[4].expr[1]) !== void 0;
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 20) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6$d(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & 126) {
        each_value = ctx2[4].expr.slice(1);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$Z(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$Z(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, t3);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (ctx2[5]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$1k(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block$1Z(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = `${SPRINTF("a_action_object", "a_add", "l_rule")}`;
      attr(a, "class", "inline-block py-2 px-1");
      attr(a, "href", "#");
      toggle_class(a, "d-none", ctx[1]);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[6].addRule));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        toggle_class(a, "d-none", ctx2[1]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_6$d(ctx) {
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      result: ctx[2].get(ctx[4].expr[1])
    }
  });
  return {
    c() {
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 20)
        ruleresult_changes.result = ctx2[2].get(ctx2[4].expr[1]);
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_each_block_1$a(ctx) {
  let condition;
  let updating_rule;
  let current;
  function condition_rule_binding(value) {
    ctx[7](value, ctx[17], ctx[18], ctx[19]);
  }
  function delete_handler() {
    return ctx[8](ctx[16], ctx[19]);
  }
  let condition_props = {
    disabled: ctx[1],
    results: ctx[2],
    inputs: ctx[3]
  };
  if (ctx[17] !== void 0) {
    condition_props.rule = ctx[17];
  }
  condition = new Condition({ props: condition_props });
  binding_callbacks.push(() => bind$1(condition, "rule", condition_rule_binding));
  condition.$on("delete", delete_handler);
  condition.$on("operatorChange", ctx[9]);
  return {
    c() {
      create_component(condition.$$.fragment);
    },
    m(target, anchor) {
      mount_component(condition, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const condition_changes = {};
      if (dirty & 2)
        condition_changes.disabled = ctx[1];
      if (dirty & 4)
        condition_changes.results = ctx[2];
      if (dirty & 8)
        condition_changes.inputs = ctx[3];
      if (!updating_rule && dirty & 16) {
        updating_rule = true;
        condition_changes.rule = ctx[17];
        add_flush_callback(() => updating_rule = false);
      }
      condition.$set(condition_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(condition.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(condition.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(condition, detaching);
    }
  };
}
function create_if_block_4$q(ctx) {
  let div;
  let button;
  let plus;
  let t0;
  let t1_value = TXT("l_and") + "";
  let t1;
  let t2;
  let current;
  let mounted;
  let dispose;
  plus = new Plus({ props: { class: "h-5 w-5" } });
  function click_handler() {
    return ctx[10](ctx[16]);
  }
  let if_block = ctx[16] + 2 === ctx[4].expr.length && create_if_block_5$j(ctx);
  return {
    c() {
      div = element("div");
      button = element("button");
      create_component(plus.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      attr(button, "class", "btn btn-default btn-sm w-24 flex items-center");
      attr(div, "class", "flex flex-row space-x-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      mount_component(plus, button, null);
      append(button, t0);
      append(button, t1);
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[16] + 2 === ctx[4].expr.length) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$j(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(plus.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(plus.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(plus);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$j(ctx) {
  let button;
  let plus;
  let t0;
  let t1_value = TXT("l_or") + "";
  let t1;
  let current;
  let mounted;
  let dispose;
  plus = new Plus({ props: { class: "h-5 w-5" } });
  return {
    c() {
      button = element("button");
      create_component(plus.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      attr(button, "class", "btn btn-default btn-sm w-24 flex items-center");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(plus, button, null);
      append(button, t0);
      append(button, t1);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[6].addOrCondition);
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(plus.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(plus.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      destroy_component(plus);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$Q(ctx) {
  let div;
  let t0_value = TXT("l_continue_or") + "";
  let t0;
  let t1;
  let show_if = ctx[2].get(ctx[4].expr[ctx[16] + 2]) !== void 0;
  let current;
  let if_block = show_if && create_if_block_3$E(ctx);
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "mt-4 mb-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 20)
        show_if = ctx2[2].get(ctx2[4].expr[ctx2[16] + 2]) !== void 0;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 20) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$E(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_3$E(ctx) {
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      result: ctx[2].get(ctx[4].expr[ctx[16] + 2])
    }
  });
  return {
    c() {
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 20)
        ruleresult_changes.result = ctx2[2].get(ctx2[4].expr[ctx2[16] + 2]);
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_each_block$Z(ctx) {
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let each_value_1 = ctx[14].expr.slice(1);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$a(get_each_context_1$a(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block0 = !ctx[1] && create_if_block_4$q(ctx);
  let if_block1 = ctx[16] + 2 !== ctx[4].expr.length && create_if_block_2$Q(ctx);
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 126) {
        each_value_1 = ctx2[14].expr.slice(1);
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$a(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$a(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t0.parentNode, t0);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$q(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[16] + 2 !== ctx2[4].expr.length) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$Q(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_if_block_1$1k(ctx) {
  let numberformat;
  let updating_format;
  let current;
  function numberformat_format_binding(value) {
    ctx[11](value);
  }
  let numberformat_props = {
    class: "mt-4",
    disabled: ctx[1]
  };
  if (ctx[0].numberFormat !== void 0) {
    numberformat_props.format = ctx[0].numberFormat;
  }
  numberformat = new NumberFormat({ props: numberformat_props });
  binding_callbacks.push(() => bind$1(numberformat, "format", numberformat_format_binding));
  return {
    c() {
      create_component(numberformat.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberformat, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberformat_changes = {};
      if (dirty & 2)
        numberformat_changes.disabled = ctx2[1];
      if (!updating_format && dirty & 1) {
        updating_format = true;
        numberformat_changes.format = ctx2[0].numberFormat;
        add_flush_callback(() => updating_format = false);
      }
      numberformat.$set(numberformat_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberformat.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberformat.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberformat, detaching);
    }
  };
}
function create_fragment$3s(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1Z, create_else_block$16];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[4] || ctx2[4].expr.length <= 1)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$3o($$self, $$props, $$invalidate) {
  let $store;
  let { config } = $$props;
  let { disabled = false } = $$props;
  let { results = /* @__PURE__ */ new Map() } = $$props;
  let { inputs } = $$props;
  let dispatch = createEventDispatcher();
  let numberFormat = config.numberFormat;
  let store2 = createStore(config.rule);
  component_subscribe($$self, store2, (value) => $$invalidate(4, $store = value));
  let showNumFormat = false;
  function condition_rule_binding(value, rule, each_value_1, idxRule) {
    each_value_1[idxRule] = value;
    store2.set($store);
  }
  const delete_handler = (idxRuleGrp, idxRule) => store2.onRemoveRule(idxRuleGrp, idxRule);
  const operatorChange_handler = (e) => $$invalidate(5, showNumFormat = hasNumeric($store));
  const click_handler = (idxRuleGrp) => store2.onAddRuleGrp(idxRuleGrp);
  function numberformat_format_binding(value) {
    if ($$self.$$.not_equal(config.numberFormat, value)) {
      config.numberFormat = value;
      $$invalidate(0, config);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("results" in $$props2)
      $$invalidate(2, results = $$props2.results);
    if ("inputs" in $$props2)
      $$invalidate(3, inputs = $$props2.inputs);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      store2.update((previousRules) => {
        if (config.rule !== previousRules) {
          return config.rule;
        }
        return previousRules;
      });
    }
    if ($$self.$$.dirty & 16) {
      dispatch("change", { rules: $store, numberFormat });
    }
    if ($$self.$$.dirty & 16) {
      $$invalidate(5, showNumFormat = hasNumeric($store));
    }
  };
  return [
    config,
    disabled,
    results,
    inputs,
    $store,
    showNumFormat,
    store2,
    condition_rule_binding,
    delete_handler,
    operatorChange_handler,
    click_handler,
    numberformat_format_binding
  ];
}
class SieveRulesEditorV2$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3o, create_fragment$3s, safe_not_equal, {
      config: 0,
      disabled: 1,
      results: 2,
      inputs: 3
    });
  }
}
const SieveRulesEditorV2 = View.ActionProvider.extend({
  name: "SieveRulesEditorV2",
  render: function() {
    let body;
    this.$el.append(
      body = DIV({ style: "max-height: 600px;" })
    );
    this.$body = $(body);
    this.renderRules();
    return this;
  },
  renderRules: function() {
    this.config = this.model.get("config");
    this.$body.empty();
    this.view = new SieveRulesEditorV2$1({
      target: this.el,
      props: {
        config: this.config
      }
    });
    this.view.$on("change", (e) => this.config = e.detail);
  },
  remove() {
    SieveRulesEditorV2.__super__.remove.call(this);
    this.view.$destroy();
  },
  updateModel: function() {
    this.model.set("config", this.config);
  }
});
function get_each_context$Y(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  return child_ctx;
}
function create_each_block$Y(ctx) {
  let option;
  let t_value = TXT(ctx[11].label) + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[11].type;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_else_block$15(ctx) {
  let inputedit;
  let current;
  inputedit = new InputEdit({
    props: {
      field: ctx[3],
      disabled: ctx[1]
    }
  });
  return {
    c() {
      create_component(inputedit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputedit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inputedit_changes = {};
      if (dirty & 8)
        inputedit_changes.field = ctx2[3];
      if (dirty & 2)
        inputedit_changes.disabled = ctx2[1];
      inputedit.$set(inputedit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputedit, detaching);
    }
  };
}
function create_if_block_1$1j(ctx) {
  let regex;
  let current;
  regex = new Regex({
    props: {
      regex: ctx[3],
      disabled: ctx[1]
    }
  });
  return {
    c() {
      create_component(regex.$$.fragment);
    },
    m(target, anchor) {
      mount_component(regex, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const regex_changes = {};
      if (dirty & 8)
        regex_changes.regex = ctx2[3];
      if (dirty & 2)
        regex_changes.disabled = ctx2[1];
      regex.$set(regex_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(regex.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(regex.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(regex, detaching);
    }
  };
}
function create_if_block$1Y(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "d-flex flex-grow");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_key_block$7(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1Y, create_if_block_1$1j, create_else_block$15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2] === C$1.RULE_NOT_EMPTY)
      return 0;
    if (ctx2[2] === C$1.RULE_MATCH_REGEX)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$3r(ctx) {
  let select2;
  let select_value_value;
  let t;
  let previous_key = ctx[3];
  let key_block_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value = Rules.DescList;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$Y(get_each_context$Y(ctx, each_value, i2));
  }
  let key_block = create_key_block$7(ctx);
  return {
    c() {
      select2 = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      key_block.c();
      key_block_anchor = empty();
      attr(select2, "class", "input-group-text form-select flex-grow-0 w-auto pr-8");
      select2.disabled = ctx[1];
    },
    m(target, anchor) {
      insert(target, select2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      select_option(select2, ctx[4].type);
      insert(target, t, anchor);
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(select2, "change", prevent_default(ctx[6]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 0) {
        each_value = Rules.DescList;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$Y(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$Y(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & 2) {
        select2.disabled = ctx2[1];
      }
      if (!current || dirty & 16 && select_value_value !== (select_value_value = ctx2[4].type)) {
        select_option(select2, ctx2[4].type);
      }
      if (dirty & 8 && safe_not_equal(previous_key, previous_key = ctx2[3])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$7(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(select2);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$3n($$self, $$props, $$invalidate) {
  let $rule, $$unsubscribe_rule = noop$1, $$subscribe_rule = () => ($$unsubscribe_rule(), $$unsubscribe_rule = subscribe(rule, ($$value) => $$invalidate(4, $rule = $$value)), rule);
  $$self.$$.on_destroy.push(() => $$unsubscribe_rule());
  let { rule } = $$props;
  $$subscribe_rule();
  let { disabled } = $$props;
  const dispatch = createEventDispatcher();
  let ruleType = $rule.type;
  let input = rule.fields.params.input;
  let originalRule = rule.toJSON();
  function setInputFieldDef() {
    let value = getOriginalValue(rule.fields.type.get());
    rule.replaceField(input, value);
    $$invalidate(3, input = rule.fields.params.input);
  }
  function getOriginalValue(ruleType2) {
    let type = RuleToTypeMap[ruleType2];
    switch (type) {
      case "regex":
        return originalRule.type === C$1.RULE_MATCH_REGEX ? originalRule.params.input : { expr: "", flags: "" };
      case "text":
        return [C$1.RULE_HAS_TEXT, C$1.RULE_HAS_TEXT_NOT].includes(originalRule.type) ? originalRule.params.input : "";
      case "int":
        return ![C$1.RULE_MATCH_REGEX, C$1.RULE_HAS_TEXT, C$1.RULE_HAS_TEXT_NOT].includes(originalRule.type) ? originalRule.params.input : 0;
    }
  }
  const onRuleTypeChange = (newType) => {
    rule.fields.type.set(newType);
    $$invalidate(2, ruleType = newType);
    setInputFieldDef();
    dispatch("update");
  };
  const change_handler = (e) => onRuleTypeChange(parseInt(e.target.value));
  $$self.$$set = ($$props2) => {
    if ("rule" in $$props2)
      $$subscribe_rule($$invalidate(0, rule = $$props2.rule));
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
  };
  return [rule, disabled, ruleType, input, $rule, onRuleTypeChange, change_handler];
}
class RuleInput extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3n, create_fragment$3r, safe_not_equal, { rule: 0, disabled: 1 });
  }
}
function get_each_context$X(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2];
  return child_ctx;
}
function create_else_block$14(ctx) {
  let div2;
  let div0;
  let select2;
  let select_value_value;
  let t0;
  let ruleinput;
  let t1;
  let t2;
  let t3;
  let div1;
  let current;
  let mounted;
  let dispose;
  let each_value = Rules.ContentList;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$X(get_each_context$X(ctx, each_value, i2));
  }
  ruleinput = new RuleInput({
    props: {
      rule: ctx[0].fields.rule,
      disabled: ctx[1]
    }
  });
  ruleinput.$on("update", ctx[8]);
  let if_block0 = !ctx[1] && create_if_block_2$P(ctx);
  let if_block1 = ctx[3].result !== void 0 && create_if_block_1$1i(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      select2 = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      create_component(ruleinput.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      div1 = element("div");
      attr(select2, "class", "input-group-text form-select flex-grow-0 w-auto pr-8");
      select2.disabled = ctx[1];
      attr(div0, "class", "input-group my-2 items-center");
      attr(div2, "class", "d-flex align-items-center");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, select2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      select_option(select2, ctx[3].contentType);
      append(div0, t0);
      mount_component(ruleinput, div0, null);
      append(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      append(div2, t3);
      append(div2, div1);
      current = true;
      if (!mounted) {
        dispose = listen(select2, "change", prevent_default(ctx[5]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 0) {
        each_value = Rules.ContentList;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$X(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$X(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & 8 && select_value_value !== (select_value_value = ctx2[3].contentType)) {
        select_option(select2, ctx2[3].contentType);
      }
      if (!current || dirty & 2) {
        select2.disabled = ctx2[1];
      }
      const ruleinput_changes = {};
      if (dirty & 1)
        ruleinput_changes.rule = ctx2[0].fields.rule;
      if (dirty & 2)
        ruleinput_changes.disabled = ctx2[1];
      ruleinput.$set(ruleinput_changes);
      if (!ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$P(ctx2);
          if_block0.c();
          if_block0.m(div0, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[3].result !== void 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$1i(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleinput.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(ruleinput.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      destroy_component(ruleinput);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1X(ctx) {
  let div;
  let sieverulegroupeditor;
  let current;
  sieverulegroupeditor = new SieveRuleGroupEditor({
    props: {
      results: ctx[2],
      config: ctx[0],
      disabled: ctx[1]
    }
  });
  sieverulegroupeditor.$on("remove", ctx[6]);
  sieverulegroupeditor.$on("update", ctx[7]);
  return {
    c() {
      div = element("div");
      create_component(sieverulegroupeditor.$$.fragment);
      attr(div, "class", "border-start pl-10 my-4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(sieverulegroupeditor, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const sieverulegroupeditor_changes = {};
      if (dirty & 4)
        sieverulegroupeditor_changes.results = ctx2[2];
      if (dirty & 1)
        sieverulegroupeditor_changes.config = ctx2[0];
      if (dirty & 2)
        sieverulegroupeditor_changes.disabled = ctx2[1];
      sieverulegroupeditor.$set(sieverulegroupeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieverulegroupeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieverulegroupeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(sieverulegroupeditor);
    }
  };
}
function create_each_block$X(ctx) {
  let option;
  let t_value = TXT(ctx[10].label) + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[10].type;
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_2$P(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-trash-o"></i>`;
      attr(button, "class", "btn input-group-text btn-default");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$1i(ctx) {
  let div;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      result: ctx[2].get(ctx[3])
    }
  });
  return {
    c() {
      div = element("div");
      create_component(ruleresult.$$.fragment);
      attr(div, "class", "px-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(ruleresult, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 12)
        ruleresult_changes.result = ctx2[2].get(ctx2[3]);
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(ruleresult);
    }
  };
}
function create_fragment$3q(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1X, create_else_block$14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3].type === 2)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$3m($$self, $$props, $$invalidate) {
  let $rule, $$unsubscribe_rule = noop$1, $$subscribe_rule = () => ($$unsubscribe_rule(), $$unsubscribe_rule = subscribe(rule, ($$value) => $$invalidate(3, $rule = $$value)), rule);
  $$self.$$.on_destroy.push(() => $$unsubscribe_rule());
  let { rule } = $$props;
  $$subscribe_rule();
  let { disabled } = $$props;
  let { results } = $$props;
  const dispatch = createEventDispatcher();
  function removeRule() {
    dispatch("remove");
  }
  function changeRuleType(e) {
    let newType = e.target.value;
    rule.fields.contentType.set(newType);
  }
  function remove_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("rule" in $$props2)
      $$subscribe_rule($$invalidate(0, rule = $$props2.rule));
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("results" in $$props2)
      $$invalidate(2, results = $$props2.results);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      console.log(" RUle changed ", rule);
    }
  };
  return [
    rule,
    disabled,
    results,
    $rule,
    removeRule,
    changeRuleType,
    remove_handler,
    update_handler,
    update_handler_1
  ];
}
class RuleTypeEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3m, create_fragment$3q, safe_not_equal, { rule: 0, disabled: 1, results: 2 });
  }
}
function get_each_context$W(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  child_ctx[10] = i2;
  return child_ctx;
}
function create_each_block$W(key_1, ctx) {
  let first2;
  let ruletypeeditor;
  let current;
  function remove_handler() {
    return ctx[6](ctx[10]);
  }
  ruletypeeditor = new RuleTypeEditor({
    props: {
      results: ctx[2],
      rule: ctx[8],
      disabled: ctx[1]
    }
  });
  ruletypeeditor.$on("update", ctx[5]);
  ruletypeeditor.$on("remove", remove_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(ruletypeeditor.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(ruletypeeditor, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const ruletypeeditor_changes = {};
      if (dirty & 4)
        ruletypeeditor_changes.results = ctx[2];
      if (dirty & 8)
        ruletypeeditor_changes.rule = ctx[8];
      if (dirty & 2)
        ruletypeeditor_changes.disabled = ctx[1];
      ruletypeeditor.$set(ruletypeeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruletypeeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruletypeeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(ruletypeeditor, detaching);
    }
  };
}
function create_fragment$3p(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ctx[3];
  const get_key = (ctx2) => ctx2[8]._iid;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$W(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$W(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 30) {
        each_value = ctx2[3];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$W, null, get_each_context$W);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function instance$3l($$self, $$props, $$invalidate) {
  let $rules, $$unsubscribe_rules = noop$1, $$subscribe_rules = () => ($$unsubscribe_rules(), $$unsubscribe_rules = subscribe(rules, ($$value) => $$invalidate(3, $rules = $$value)), rules);
  $$self.$$.on_destroy.push(() => $$unsubscribe_rules());
  const dispatch = createEventDispatcher();
  let { rules } = $$props;
  $$subscribe_rules();
  let { disabled } = $$props;
  let { results } = $$props;
  function removeRule(i2) {
    rules.remove(i2);
    dispatch("update");
  }
  console.log(" RULE LIST ", rules, $rules);
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  const remove_handler = (i2) => removeRule(i2);
  $$self.$$set = ($$props2) => {
    if ("rules" in $$props2)
      $$subscribe_rules($$invalidate(0, rules = $$props2.rules));
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("results" in $$props2)
      $$invalidate(2, results = $$props2.results);
  };
  return [rules, disabled, results, $rules, removeRule, update_handler, remove_handler];
}
class RuleList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3l, create_fragment$3p, safe_not_equal, { rules: 0, disabled: 1, results: 2 });
  }
}
function create_if_block_1$1h(ctx) {
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      result: ctx[2].get(ctx[0])
    }
  });
  return {
    c() {
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty & 5)
        ruleresult_changes.result = ctx2[2].get(ctx2[0]);
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_if_block$1W(ctx) {
  let div1;
  let div0;
  let button0;
  let t1;
  let button1;
  let t3;
  let ul;
  let li;
  let a;
  let t5;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.innerHTML = `<i class="fa fa-plus mr-2"></i>
        Add Rule`;
      t1 = space();
      button1 = element("button");
      button1.innerHTML = `<span class="visually-hidden">Toggle Dropdown</span>`;
      t3 = space();
      ul = element("ul");
      li = element("li");
      a = element("a");
      a.textContent = "Add Compound Rule";
      t5 = space();
      button2 = element("button");
      button2.innerHTML = `<i class="fa fa-trash-o"></i>`;
      attr(button0, "type", "button");
      attr(button0, "class", "btn btn-outline-dark");
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-outline-dark dropdown-toggle dropdown-toggle-split");
      attr(button1, "data-bs-toggle", "dropdown");
      attr(button1, "aria-expanded", "false");
      attr(a, "class", "dropdown-item");
      attr(ul, "class", "dropdown-menu");
      attr(button2, "class", "btn btn-outline-dark");
      attr(div0, "class", "input-group input-group-sm bg-white");
      attr(div1, "class", "mx-2 ");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, button1);
      append(div0, t3);
      append(div0, ul);
      append(ul, li);
      append(li, a);
      append(div0, t5);
      append(div0, button2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", prevent_default(ctx[8])),
          listen(a, "click", prevent_default(ctx[9])),
          listen(button2, "click", ctx[10])
        ];
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$3o(ctx) {
  let div4;
  let div3;
  let div0;
  let t1;
  let div1;
  let select2;
  let option0;
  let t2;
  let option1;
  let t3;
  let select_value_value;
  let t4;
  let div2;
  let t5_value = TXT("l_x_of_following_rules") + "";
  let t5;
  let t6;
  let t7;
  let t8;
  let rulelist;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[4].result !== void 0 && create_if_block_1$1h(ctx);
  let if_block1 = !ctx[1] && create_if_block$1W(ctx);
  rulelist = new RuleList({
    props: {
      rules: ctx[3],
      disabled: ctx[1],
      results: ctx[2]
    }
  });
  rulelist.$on("update", ctx[11]);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      div0.textContent = `${TXT("l_rule_true_if_matches_x")}`;
      t1 = space();
      div1 = element("div");
      select2 = element("select");
      option0 = element("option");
      t2 = text("Any");
      option1 = element("option");
      t3 = text("All");
      t4 = space();
      div2 = element("div");
      t5 = text(t5_value);
      t6 = text(":\n      ");
      if (if_block0)
        if_block0.c();
      t7 = space();
      if (if_block1)
        if_block1.c();
      t8 = space();
      create_component(rulelist.$$.fragment);
      attr(div0, "class", "pt-2");
      option0.__value = C$1.OP_OR;
      option0.value = option0.__value;
      option1.__value = C$1.OP_AND;
      option1.value = option1.__value;
      attr(select2, "class", "form-select form-select-sm");
      select2.disabled = ctx[1];
      attr(div1, "class", "mx-2");
      attr(div2, "class", "pt-2");
      attr(div3, "class", "d-flex align-items-center");
      attr(div4, "class", "d-flex justify-content-between mt-4");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div0);
      append(div3, t1);
      append(div3, div1);
      append(div1, select2);
      append(select2, option0);
      append(option0, t2);
      append(select2, option1);
      append(option1, t3);
      select_option(select2, ctx[4].op);
      append(div3, t4);
      append(div3, div2);
      append(div2, t5);
      append(div2, t6);
      if (if_block0)
        if_block0.m(div2, null);
      append(div4, t7);
      if (if_block1)
        if_block1.m(div4, null);
      insert(target, t8, anchor);
      mount_component(rulelist, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(select2, "change", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 16 && select_value_value !== (select_value_value = ctx2[4].op)) {
        select_option(select2, ctx2[4].op);
      }
      if (!current || dirty & 2) {
        select2.disabled = ctx2[1];
      }
      if (ctx2[4].result !== void 0) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$1h(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$1W(ctx2);
          if_block1.c();
          if_block1.m(div4, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      const rulelist_changes = {};
      if (dirty & 8)
        rulelist_changes.rules = ctx2[3];
      if (dirty & 2)
        rulelist_changes.disabled = ctx2[1];
      if (dirty & 4)
        rulelist_changes.results = ctx2[2];
      rulelist.$set(rulelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(rulelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(rulelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach(t8);
      destroy_component(rulelist, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$3k($$self, $$props, $$invalidate) {
  let ruleFields;
  let $config, $$unsubscribe_config = noop$1, $$subscribe_config = () => ($$unsubscribe_config(), $$unsubscribe_config = subscribe(config, ($$value) => $$invalidate(4, $config = $$value)), config);
  $$self.$$.on_destroy.push(() => $$unsubscribe_config());
  let { config } = $$props;
  $$subscribe_config();
  let { disabled } = $$props;
  let { results } = $$props;
  const dispatch = createEventDispatcher();
  console.log("SOME CONFIGS ", config, $config);
  function addRule(compound) {
    let newRule;
    newRule = ruleFields.getDefaultValue(compound);
    ruleFields.add(newRule);
  }
  function changeOp(e) {
    let newOp = e.target.value;
    config.fields.op.set(newOp);
    dispatch("update");
  }
  const click_handler = () => addRule(false);
  const click_handler_1 = () => addRule(true);
  const click_handler_2 = () => dispatch("remove");
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$subscribe_config($$invalidate(0, config = $$props2.config));
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("results" in $$props2)
      $$invalidate(2, results = $$props2.results);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(3, ruleFields = config.fields.rules);
    }
  };
  return [
    config,
    disabled,
    results,
    ruleFields,
    $config,
    dispatch,
    addRule,
    changeOp,
    click_handler,
    click_handler_1,
    click_handler_2,
    update_handler
  ];
}
class SieveRuleGroupEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3k, create_fragment$3o, safe_not_equal, { config: 0, disabled: 1, results: 2 });
  }
}
function get_each_context$V(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  return child_ctx;
}
function create_else_block$13(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = "Add Condition";
      attr(a, "class", "inline-block py-2 px-1");
      attr(a, "href", "#");
      toggle_class(a, "d-none", ctx[2]);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[10]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        toggle_class(a, "d-none", ctx2[2]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1V(ctx) {
  let div;
  let sieverulegroupeditor;
  let t;
  let current;
  sieverulegroupeditor = new SieveRuleGroupEditor({
    props: {
      results: ctx[1],
      config: ctx[0],
      disabled: ctx[2]
    }
  });
  sieverulegroupeditor.$on("remove", ctx[9]);
  sieverulegroupeditor.$on("update", ctx[7]);
  let if_block = ctx[5] && create_if_block_1$1g(ctx);
  return {
    c() {
      div = element("div");
      create_component(sieverulegroupeditor.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(sieverulegroupeditor, div, null);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const sieverulegroupeditor_changes = {};
      if (dirty & 2)
        sieverulegroupeditor_changes.results = ctx2[1];
      if (dirty & 1)
        sieverulegroupeditor_changes.config = ctx2[0];
      if (dirty & 4)
        sieverulegroupeditor_changes.disabled = ctx2[2];
      sieverulegroupeditor.$set(sieverulegroupeditor_changes);
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1g(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sieverulegroupeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieverulegroupeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(sieverulegroupeditor);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$1g(ctx) {
  let div;
  let span;
  let t1;
  let select2;
  let select_value_value;
  let mounted;
  let dispose;
  let each_value = ctx[6];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$V(get_each_context$V(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = "Number Format:";
      t1 = space();
      select2 = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(span, "class", "pr-2");
      attr(select2, "class", "form-select w-56");
      select2.disabled = ctx[2];
      attr(div, "class", "d-flex align-items-center mt-4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t1);
      append(div, select2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      select_option(select2, ctx[3].numberFormat);
      if (!mounted) {
        dispose = listen(select2, "change", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 64) {
        each_value = ctx2[6];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$V(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$V(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 72 && select_value_value !== (select_value_value = ctx2[3].numberFormat)) {
        select_option(select2, ctx2[3].numberFormat);
      }
      if (dirty & 4) {
        select2.disabled = ctx2[2];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$V(ctx) {
  let option;
  let t0_value = TXT(ctx[13].label) + "";
  let t0;
  let t1;
  return {
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = ctx[13].value;
      option.value = option.__value;
      attr(option, "title", TXT(ctx[13].title));
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment$3n(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1V, create_else_block$13];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$3j($$self, $$props, $$invalidate) {
  let $config, $$unsubscribe_config = noop$1, $$subscribe_config = () => ($$unsubscribe_config(), $$unsubscribe_config = subscribe(config, ($$value) => $$invalidate(3, $config = $$value)), config);
  $$self.$$.on_destroy.push(() => $$unsubscribe_config());
  const dispatch = createEventDispatcher();
  let { config } = $$props;
  $$subscribe_config();
  let { results = /* @__PURE__ */ new Map() } = $$props;
  let { disabled = false } = $$props;
  let showConditions = false;
  const OPTIONS = [
    {
      label: "rule_comma_dot",
      title: "title_format_option_comma_dot",
      value: C$1.NUM_FORMAT_COMMA_DOT
    },
    {
      label: "rule_dot_comma",
      title: "title_format_option_dot_comma",
      value: C$1.NUM_FORMAT_DOT_COMMA
    },
    {
      label: "rule_space_comma",
      title: "title_format_option_space_comma",
      value: C$1.NUM_FORMAT_SPACE_COMMA
    }
  ];
  let hasNumeric2 = config.hasNumeric();
  let numberFormat = config.fields.numberFormat;
  function updateNumeric() {
    $$invalidate(5, hasNumeric2 = config.hasNumeric());
  }
  function changeNumberFormat(e) {
    let newFormat = e.target.value;
    numberFormat.set(newFormat);
  }
  function removeRules() {
    config.fields.rules.set([]);
    $$invalidate(4, showConditions = false);
  }
  const click_handler = () => {
    $$invalidate(4, showConditions = true);
  };
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$subscribe_config($$invalidate(0, config = $$props2.config));
    if ("results" in $$props2)
      $$invalidate(1, results = $$props2.results);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $config && dispatch("change", $config);
    }
    if ($$self.$$.dirty & 8) {
      if ($config.rules.length > 0) {
        $$invalidate(4, showConditions = true);
      }
    }
  };
  return [
    config,
    results,
    disabled,
    $config,
    showConditions,
    hasNumeric2,
    OPTIONS,
    updateNumeric,
    changeNumberFormat,
    removeRules,
    click_handler
  ];
}
class SieveRulesEditorV1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3j, create_fragment$3n, safe_not_equal, { config: 0, results: 1, disabled: 2 });
  }
}
function create_fragment$3m(ctx) {
  let div;
  let p0;
  let t1;
  let p1;
  return {
    c() {
      div = element("div");
      p0 = element("p");
      p0.textContent = "Please upgrade to the latest version of app/extension.";
      t1 = space();
      p1 = element("p");
      p1.textContent = `This condition was created using a newer version of the app which is not supported by this version. Current version is ${ctx[0]}`;
      attr(div, "class", "p-2 text-base");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p0);
      append(div, t1);
      append(div, p1);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$3i($$self) {
  let currentVersion = Supports.agents && Supports.agents.local ? serviceProxy.CFG.VERSION : "1.0.0";
  return [currentVersion];
}
class VersionUpdateMsg extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3i, create_fragment$3m, safe_not_equal, {});
  }
}
const { V1, V2 } = Model$2.SieveRule;
const SieveRuleWrapper = View.ActionProvider.extend({
  name: "SieveRuleWrapper",
  actions: {
    action_global_rules: { fn: "action_global_rules" }
  },
  action_global_rules() {
    showGlobalRuleEditor();
  },
  postInit(options) {
    if (!this.model.isNew()) {
      this.loading = true;
      this.model.fetch({
        success: this.onLoad,
        error: this.onError
      });
    }
    this.listenTo(this.model, "change:version", this.renderEditor);
    this.listenTo(App.user, "change:prefs", this.renderGlobalCount);
  },
  onError() {
    this.loading = false;
    this.$body.empty();
    this.$body.append(TXT("e_req"), " ", TXT("h_try_later"));
  },
  onLoad() {
    this.loading = false;
    this.renderEditor();
  },
  getGlobalRuleModel() {
    var _a;
    let config = (_a = App.user.get("prefs")) == null ? void 0 : _a.rule;
    let version = (config == null ? void 0 : config.version) || V1;
    return new Model$2.SieveRule({ config, version });
  },
  render() {
    let elVersion;
    this.$el.append(
      DIV(
        { class: "flex gap-4" },
        elVersion = DIV({ class: "dropdown relative" }),
        this.options.global ? "" : A(
          {
            href: "#",
            "data-action": "action_global_rules"
          },
          "Global Conditions: ",
          this.elGlobalCount = SPAN()
        )
      ),
      this.$body = $(DIV())
    );
    this.$elVersion = $(elVersion);
    this.$elVersion.on("click", "li", this.onVersionSelection);
    this.renderGlobalCount();
    if (this.loading) {
      this.$body.text(TXT("l_loading"));
    } else {
      this.renderEditor();
    }
    return this;
  },
  renderGlobalCount() {
    let globalRule = this.getGlobalRuleModel();
    $(this.elGlobalCount).text(globalRule.getCount());
  },
  onVersionSelection(e) {
    this.model.setVersion(e.target.id);
    e.preventDefault();
  },
  renderEditor() {
    let version = this.model.get("version");
    if (USER.features.rule_default) {
      this.renderVersion(version);
    } else {
      this.$elVersion.remove();
    }
    const $el = this.$body;
    $el.empty();
    if (version && version !== V1 && version !== V2) {
      new VersionUpdateMsg({ target: this.$el[0] });
    } else if (version === V1) {
      this.editor = new SieveRulesEditorV1({ target: this.$el[0], props: { model: this.model } });
      $el.append(this.editor.el);
    } else {
      this.editor = new SieveRulesEditorV2({ ..._.omit(this.options, "el"), parent: this }).render();
      $el.append(this.editor.el);
    }
  },
  renderVersion(version) {
    const href2 = "javascript: void 0";
    this.$elVersion.empty().append(
      A({ href: href2, class: "dropdown-toggle", "data-bs-toggle": "dropdown" }, `Version: v${version[0]}`, " ", B({ class: "caret" })),
      UL(
        { class: "dropdown-menu" },
        LI({ class: "dropdown-header" }, "Change condition version"),
        LI({ class: version == V1 ? "active" : "" }, A({ href: href2, id: V1 }, `v${V1[0]} (classic)`)),
        LI({ class: version == V2 ? "active" : "" }, A({ href: href2, id: V2 }, `v${V2[0]} (modern)`))
      )
    );
  },
  async duplicate(fromId) {
    const model = new Model$2.SieveRule({ id: fromId });
    await model.fetch({
      success: () => {
        this.model.set(_.omit(model.attributes, "id", "ts", "ts_mod"));
        this.onLoad();
      }
    });
  },
  updateModel() {
    if (this.editor) {
      this.editor.updateModel();
    }
  }
});
async function showGlobalRuleEditor() {
  if (!USER.id) {
    return alert("Please sign in to save global conditions");
  }
  let prefs = App.user.get("prefs") || {};
  let config = prefs.rule;
  let version = (config == null ? void 0 : config.version) || V1;
  let model = new Model$2.SieveRule({ config, version });
  let view = new SieveRuleWrapper({ model, global: true, parent: App.root });
  const modal = new View.SaveDiscardModal({
    name: "GlobalRuleEditor$SaveDiscardModal",
    title: "Global Conditions",
    titleEx: `used for all monitors and combined with each monitor's conditions`,
    view,
    parent: App.root
  });
  modal.on("save", async () => {
    modal.remove();
    view.updateModel();
    let config2 = model.get("config");
    let version2 = model.get("version");
    try {
      await Api.api("/prefs/rule", "PUT", { ...config2, version: version2 });
      USER.prefs.rule = config2;
    } catch (e) {
      console.error(e);
      Msg.error("Failed to save data, please try again later");
    }
  });
  modal.on("discard", () => {
    modal.remove();
  });
  modal.show();
}
const Backbone$2 = window.Backbone;
function getInterval($el, defaultUnit = "m", defaultValue = 120) {
  const units = { "s": 1, "m": 60, "h": 3600, "d": 86400, "w": 604800 };
  const parts = $el.val().trim().replace(/\s+/g, "").split(/(\d*\.*\d*)/);
  const num = parseInt(parts[1]) || defaultValue;
  const unit = (parts[2] || "").toLowerCase()[0] || defaultUnit;
  const value = num * units[unit];
  return value;
}
const WEEK_DAY_INDEX = ["Sunday", "Monday", "Tuesday", "Thursday", "Friday", "Saturday", "Sunday"];
const MONTH_INDEX = ["", "Jan", "Feb", "March", "April", "May", "June", "July", "August", "Sep", "Oct", "Nov", "Dec"];
class SieveCronScheduleEditor extends Base$2 {
  constructor(options) {
    super({
      ...options.model.toJSON(),
      params: options.model.get("schedule").toJSON().params
    });
    this.model = options.model;
    this.schedule = this.model.get("schedule");
    this.el.classList.add("xtype-group");
    this.el.classList.add("inline-block");
    this.el.style.minWidth = "480px";
  }
  onChange(name, value) {
    const index2 = ["m", "h", "dm", "mon", "dw"].indexOf(name);
    const params2 = { ...this.state.params };
    const { expr } = params2;
    const parts = expr.split(/\s/g);
    parts[index2] = value;
    params2.expr = parts.join(" ");
    this.state.params = params2;
    if (parts.length == 5 && _.all(parts, (p) => p.length > 0)) {
      this.setModelParams(params2);
    }
  }
  onPresetClick(e) {
    e.preventDefault();
    const params2 = { ...this.state.params };
    params2.expr = e.target.dataset.expr;
    this.state.params = params2;
    this.setModelParams(params2);
  }
  setModelParams(params2) {
    this.schedule.set("params", new Backbone$2.Model(params2));
    this.model.trigger("change:schedule", this.model);
  }
  getDesc({ m, h, dm, mon, dw }) {
    function unit(name, val) {
      if (val.includes(",")) {
        const parts = val.split(",").map((expr) => unit(name, expr));
        const last2 = parts.pop();
        return `${parts.join(", ")} and ${last2}`;
      }
      if ("*" == val) {
        return `every ${name}`;
      }
      if (val.includes("-")) {
        let [start, end] = val.split("-");
        if (name == "month") {
          start = MONTH_INDEX[start];
          end = MONTH_INDEX[end];
        }
        if (name == "day-of-week") {
          start = WEEK_DAY_INDEX[start];
          end = WEEK_DAY_INDEX[end - 1];
        }
        return `every ${name} from ${start} through ${end}`;
      }
      if (val.includes("/")) {
        let [start, step] = val.split("/");
        const end = "";
        let startText = "every";
        if (step > 1) {
          const suffixes = ["", "st", "nd", "rd"];
          startText = step + (suffixes[step] || "th");
        }
        if ("*" == start) {
          start = null;
        } else if (name == "month") {
          start = MONTH_INDEX[start];
        } else if (name == "day-of-week") {
          start = WEEK_DAY_INDEX[start];
        }
        return `every  ${startText} ${name} ${start ? `from ${start} through ${end}` : ""}`;
      }
      if (name == "month") {
        val = MONTH_INDEX[val];
        name = "";
      }
      if (name == "day-of-week") {
        val = WEEK_DAY_INDEX[val];
        name = "";
      }
      return `${name} ${val}`;
    }
    try {
      return `At ${unit("minute", m)} past ${unit("hour", h)} on ${unit("day-of-week", dw)} in ${unit("month", mon)}`;
    } catch (e) {
      console.error(e, arguments[0]);
      return "Invalid expression";
    }
  }
  createTpl({ params: params2 }) {
    const expr = params2.expr;
    params2.tz || new Date().getTimezoneOffset();
    const [m, h, dm, mon, dw] = expr.split(/\s/g);
    const attrMap = { m, h, dm, mon, dw };
    const desc = this.getDesc(attrMap);
    const names = {
      m: "Minute",
      h: "Hour",
      dm: "Day",
      mon: "Month",
      dw: "Weekday"
    };
    return html`
      <table>
        <thead>
          ${_.map(names, (name, key) => {
      return html`<th class='col-md-2'>${name}</th>`;
    })}
          <th></th>
        </thead>
        <tbody>
          <tr>
            ${_.map(names, (name, key) => {
      return html`
                <td class='col-md-2'>
                  <input
                    style='width: 60px; padding: 0 10px;'
                    .value=${attrMap[key]}
                    placeholder=${name}
                    @keyup=${(e) => this.onChange(key, e.target.value)}>
                  </input>
                </td>
                `;
    })}
            <td>
              <div class='dropdown'>
                <a href='#' data-toggle='dropdown'>Use Preset <i class='fa fa-caret-down'></i></a>
                <ul class='dropdown-menu' @click=${(e) => this.onPresetClick(e)}>
                  <li><a href='#' data-expr='0 9 * * 1-5'>Weekdays at 9am</a></li>
                  <li><a href='#' data-expr='0 9-17 * * 1-5'>Weekdays between 9am to 5pm</a></li>
                  <li><a href='#' data-expr='0 9 * * *'>All days at 9am</a></li>
                  <li><a href='#' data-expr='0 9-17 * * *'>All days between 9am to 5pm</a></li>
                </ul>
              </div>
            </td>
          </tr>
          <tr>
            <td
              style='width: 60px; padding: 0 12px;'
              colspan=6><div class='help'>
                ${desc}
              </div>
            </td>
          </tr>
        </tbody>
      </table>
    `;
  }
  remove() {
  }
  render() {
    return this;
  }
}
var SieveIntervalScheduleEditor = View.ActionProvider.extend({
  name: "SieveIntervalScheduleEditor",
  convertToSlider: function(v) {
    return Math.log(v);
  },
  convertToModel: function(v) {
    return Math.round(Math.pow(Math.E, v));
  },
  focus: function() {
    this.textInput.focus();
  },
  getSliderValue: function() {
    return this.convertToModel(this.$slider.val());
  },
  setSliderValue: function(value) {
    this.$slider.slider("setValue", this.convertToSlider(value));
  },
  remove: function() {
    if (this.$slider.data("slider")) {
      this.$slider.slider("destroy");
    }
    SieveIntervalScheduleEditor.__super__.remove.call(this);
  },
  render: function() {
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    const interval = params2.get("interval");
    const value = this.convertToSlider(interval);
    this.$el.empty().append(
      DIV(
        { style: "display:flex;min-width:420px;margin-bottom:25px;" },
        this.slider = INPUT({
          style: "width:100%;",
          value
        }),
        this.textInput = INPUT({ "class": "xschdlr-input" })
      ),
      SPAN(
        { "class": "help" },
        this.constraint = SPAN(
          { style: "color: red; display: none;" },
          TXT("h_schedule_constraint_1"),
          TXT(formatInterval(USER.constraint.interval, false) + "."),
          BR(),
          TXT("h_schedule_constraint_2"),
          A({ "href": "https://distill.io/pricing", "target": "_blank" }, "Upgrade Account")
        )
      ),
      P(
        { "class": "help" },
        TXT("h_schedule_interval")
      )
    );
    this.$constraint = $(this.constraint);
    this.$slider = $(this.slider).slider({
      min: 1.6,
      max: 14.78,
      step: 0.05,
      tooltip: "hide",
      value,
      "ticks": [1.6, 3.4, 5.7, 8.3, 11.55, 14.78],
      "ticks_positions": [0, 13.657, 31.107, 50.834, 75.493, 100],
      "ticks_labels": ["5s", "30s", "5m", "1h", "1d", "Never"],
      "ticks_snap_bounds": 0
    }).on("slide", this.updateValue).on("slideStop", this.updateModel);
    this.$textInput = $(this.textInput).on("change", this.textInputChanged).on("focus", function() {
      this.select();
    });
    this.updateValue();
    return this;
  },
  textInputChanged: function() {
    const value = getInterval(this.$textInput, "m", 3600);
    this.setSliderValue(value);
    this.updateValue();
    this.updateModel();
  },
  updateModel: function() {
    this.updateValue();
    this.model.get("schedule");
    this.model.trigger("change");
    this.model.trigger("change:schedule", this.model);
  },
  updateValue: function() {
    const seconds = this.getSliderValue();
    const client_id = this.model.get("client_id");
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    const constraint = USER && USER.constraint;
    const minInt = constraint && constraint.interval || 5;
    if (client_id == ModelClient.Clients.webAppId && seconds < minInt) {
      params2.set("interval", USER.constraint.interval);
      this.$constraint.css("display", "block");
    } else {
      params2.set("interval", seconds);
      this.$constraint.css("display", "none");
    }
    this.$textInput.val(getShortDisplayText(schedule.attributes));
  }
});
const SieveLiveScheduleEditor = View.ActionProvider.extend({
  name: "SieveLiveScheduleEditor",
  render: function() {
    this.$el.append(
      DIV("Use it only if page auto-updates content using JavaScript."),
      DIV({ "class": "help" }, TXT("l_schedule_live_desc"))
    );
    return this;
  }
});
const SieveRandomScheduleEditor = View.ActionProvider.extend({
  name: "SieveRandomScheduleEditor",
  render: function() {
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    this.$el.empty().append(
      DIV(
        SPAN("Min: "),
        this.minInput = INPUT({ "class": "xschdlr-input" }),
        SPAN({ style: "margin-left: 20px;" }, "Max: "),
        this.maxInput = INPUT({ "class": "xschdlr-input" })
      ),
      SPAN(
        { "class": "help" },
        this.constraint = SPAN(
          { style: "color: black; display: none;" },
          TXT("h_schedule_constraint_1"),
          TXT(USER.constraint.interval + " seconds. "),
          BR(),
          TXT("h_schedule_constraint_2"),
          A({ "href": "https://distill.io/pricing", "target": "_blank" }, "Upgrade Account")
        )
      ),
      P(
        { "class": "help" },
        TXT("h_schedule_random")
      )
    );
    this.$constraint = $(this.constraint);
    (this.$minInput = $(this.minInput)).val(params2.get("min"));
    (this.$maxInput = $(this.maxInput)).val(params2.get("max"));
    $([this.minInput, this.maxInput]).on("change", this.updateModel);
    this.updateValue();
    return this;
  },
  updateModel: function() {
    this.updateValue();
    this.model.get("schedule");
    this.model.trigger("change");
    this.model.trigger("change:schedule", this.model);
  },
  updateValue: function() {
    if (getInterval(this.$minInput, "s") > getInterval(this.$maxInput, "s")) {
      var maxSecs = Math.max(this.model.get("client_id") == ModelClient.Clients.webAppId ? USER.constraint.interval : 5, getInterval(this.$minInput, "s") + 1);
    } else {
      var maxSecs = Math.max(this.model.get("client_id") == ModelClient.Clients.webAppId ? USER.constraint.interval : 5, getInterval(this.$maxInput, "s"));
    }
    const minSecs = Math.max(this.model.get("client_id") == ModelClient.Clients.webAppId ? USER.constraint.interval : 5, getInterval(this.$minInput, "s"));
    const schedule = this.model.get("schedule");
    const params2 = schedule.get("params");
    const client_id = this.model.get("client_id");
    const constraint = USER && USER.constraint;
    constraint && constraint.interval || 5;
    params2.set("min", minSecs);
    params2.set("max", maxSecs);
    this.$minInput.val(minSecs);
    this.$maxInput.val(maxSecs);
    if (client_id == ModelClient.Clients.webAppId) {
      this.$constraint.css("display", "block");
    } else {
      this.$constraint.css("display", "none");
    }
  }
});
var SieveScheduleEditor = View.ActionProvider.extend({
  name: "SieveScheduleEditor",
  EDITORS: {
    "INTERVAL": SieveIntervalScheduleEditor,
    "LIVE": SieveLiveScheduleEditor,
    "RANDOM": SieveRandomScheduleEditor,
    "CRON": SieveCronScheduleEditor
  },
  focus: function() {
  },
  render: function() {
    let elSelect;
    let elEditor;
    var schedule = this.model.get("schedule");
    const type = schedule.get("type");
    Supports.agents.local;
    let editor = new this.EDITORS[type](_.extend({ parent: this }, _.omit(this.options, "el")));
    this.$el.css({
      "display": "flex",
      "flex-direction": "row"
    }).empty().append(
      DIV(
        elSelect = SELECT(
          { style: "margin-right: 20px;" },
          OPTION({ value: "INTERVAL" }, "Interval"),
          OPTION({ value: "RANDOM" }, "Random"),
          OPTION({ value: "LIVE" }, "Live (beta)"),
          USER.account_id ? OPTION({ value: "CRON" }, "Crontab *") : OPTION({ value: "CRON", disabled: "" }, "Crontab *"),
          OPTION({ value: "", disabled: "" }, "*For Enterprise")
        )
      ),
      elEditor = DIV({ style: "flex:1" }, editor.render().el)
    );
    $(elSelect).val(type).on("change", () => {
      const type2 = elSelect.value;
      const schedule2 = new Model$2.Schedule({ type: type2 });
      if (type2 == "RANDOM") {
        schedule2.get("params").set({ min: 60, max: 120 });
      }
      if (type2 == "CRON") {
        schedule2.get("params").set({
          expr: "* * * * *",
          tz: new Date().getTimezoneOffset()
        });
      }
      editor.remove();
      this.model.set("schedule", schedule2);
      editor = new this.EDITORS[type2](_.extend({ parent: this }, _.omit(this.options, "el")));
      $(elEditor).empty().append(editor.render().el);
    });
    return this;
  }
});
var TagsEditor$1 = View.Base.extend({
  name: "TagsEditor",
  className: "flex flex-wrap",
  events: {
    "click :checkbox": "event_check"
  },
  event_check: function(e) {
    const el2 = e.target;
    const id2 = el2.dataset.id;
    const checked = el2.checked;
    const tag = App.labels.get(id2);
    if (checked) {
      this.tags.push(tag);
    } else {
      this.tags = _.without(this.tags, tag);
    }
    this.model.set("tags", _.pluck(this.tags, "id").join(","));
  },
  postInit: function() {
    this.tags = this.model.getTags(App.labels);
    this.listenTo(App.labels, "sync", this.render);
  },
  render: function() {
    this.$el.empty();
    if (App.labels.length > 0) {
      this.$el.append(_.map(App.labels.models, (tag) => {
        const input = INPUT({
          "type": "checkbox",
          "style": "vertical-align: top; margin: 0 4px;",
          "data-id": tag.id
        });
        const el2 = LABEL({
          "class": "flex font-normal mr-2"
        }, input, tag.get("name"));
        if (this.tags.indexOf(tag) >= 0) {
          input.checked = true;
        }
        return el2;
      }));
    } else {
      this.$el.append("No label found.");
    }
    return this;
  }
});
const domo$1 = window.domo;
if (!domo$1) {
  throw new Error("ADD domo");
}
function SieveConstraints(constraint) {
  return DIV(
    { "class": "xmonitor-limit" },
    DIV(
      { "class": "alert alert-danger" },
      SPRINTF("m_monitor_constraint_1", constraint.count, constraint.limit),
      " ",
      SPRINTF("m_monitor_constraint_2"),
      UL(
        LI(
          A({ href: urlCfg.watchlist }, I({ "class": "fa fa-link" }), " ", SPRINTF("a_go_to_watchlist")),
          ": ",
          SPRINTF("m_monitor_constraint_3")
        ),
        LI(
          A({ href: urlCfg.billing }, I({ "class": "fa fa-link" }), " ", SPRINTF("a_go_to_billing")),
          ": ",
          SPRINTF("m_monitor_constraint_4")
        )
      )
    )
  );
}
class MacroSelector extends Base$2 {
  constructor({ model, classes }) {
    super();
    this.model = model;
    this.state.classes = classes || [];
    this.setId(model.get("macro_id"));
    this.state.names = {};
    this.state.macros = new Macros$1([], {});
    if (App.user.isLoggedIn()) {
      this.loadMacros();
    }
  }
  getTrimmedURI() {
    if (!this.model.get("uri")) {
      return "";
    }
    return new URL(this.model.get("uri")).host;
  }
  async loadMacros({ name = "" } = {}) {
    const query = {
      "_opt": {
        only: ["id", "name"]
      }
    };
    if (name) {
      query["name.ilike"] = `%${name}%`;
      query["meta:->>'url'.like"] = `%${this.getTrimmedURI()}%`;
    } else if (this.state.id) {
      query["$or"] = {
        "meta:->>'url'.like": `%${this.getTrimmedURI()}%`,
        id: this.state.id
      };
    } else {
      query["meta:->>'url'.like"] = `%${this.getTrimmedURI()}%`;
    }
    this.state.macros.setQuery(query);
    await this.state.macros.fetch();
    this.state.names = this.state.macros.models.reduce((names, m) => {
      names[m.id] = m.get("name");
      return names;
    }, {});
  }
  onSearch(e) {
    this.loadMacros({
      name: e.target.value
    });
  }
  setId(id2, e) {
    e && e.preventDefault();
    this.state.id = id2;
    this.model.set("macro_id", id2);
  }
  createTpl({ id: id2, macros, names, classes }) {
    let loadedMacros = !!macros.models;
    let team = get_store_value(params).team;
    return html`<div class='drowdown relative ${classes.join(" ")}'>
      <a class='btn btn-default dropdown-toggle' data-toggle='dropdown'
        href='#'>
        Macro - ${!macros.get(id2) ? "None" : macros.get(id2).get("name") || "Deleted"}
        <span class='caret'></span>
      </a>
      <ul class='dropdown-menu'>
        ${loadedMacros ? [
      html`
        <li>
          <div class='ma2' @click=${(e) => (e.preventDefault(), e.stopPropagation())}>
            <input type='text' class='ba0' placeholder='Search' @input=${(e) => this.onSearch(e)}></input>
          </div>
        </li>
          <li><a href='#' @click=${(e) => this.setId(null, e)}>
              <i class='mr2 fa ${!id2 ? "fa-check" : "mr4"}'></i>
              Empty (Default)</a></li>`,
      macros.models.map((s) => html`<li>
            <a data-id=${s.id} href='#' @click=${(e) => this.setId(s.id, e)}>
              <i class='mr2 fa ${id2 === s.id ? "fa-check" : "mr4"}'></i>
              ${s.get("name")}
            </a>
          </li>`),
      html`
          <li class='divider'></li>

          <li><a href='#/w/${team}/macros/' target='_blank'>
              <span class='pl4'> Manage Macros<span></a></li>

          <li><a href='${URL_WEBSITE}/docs/web-monitor/macro-to-record-replay-actions/' target='_blank'>
              <span class='pl4'> Learn More<span></a></li>
              `
    ] : html`<li><a>Loading...</a></li>`}
      </ul>
    </div>`;
  }
}
View.ActionProvider.extend({
  name: "HTMLSelector",
  render: function() {
    this.selectorModal = new Selector.Modal({
      model: this.model.clone(),
      parent: this,
      onDiscard: this.onSelectorDiscard,
      onSave: this.onSelectorSave
    });
    this.selectorModal.show();
    return this;
  },
  onSelectorDiscard: function() {
    this.trigger("discard");
    this.selectorModal.remove();
  },
  onSelectorSave: function(err, model) {
    if (err) {
      Msg.error("Error running visual selector: " + err);
      this.trigger("error", err);
    } else {
      this.trigger(
        "save",
        _.pick(
          model.toJSON(),
          "uri",
          "name",
          "config",
          "content_type",
          "macro_id",
          "session_id",
          "datasource_id"
        )
      );
    }
    this.selectorModal.remove();
  }
});
View.ActionProvider.extend({
  name: "PDFSelector",
  postInit: function() {
    if (USER.constraint && USER.constraint.flexi) {
      this.editor = Editor.create("url", {
        param: {
          label: "m_enter_pdf_url",
          must: true,
          name: "uri"
        },
        parent: this
      }).render();
      this.listenTo(this.editor, "change", this.save);
    } else {
      this.editor = new View.Base({
        el: DIV(
          { class: "alert alert-info" },
          "PDF monitoring is available to Flexi and Enterprise customers only. Please upgrade your account or contact support for more information."
        )
      });
    }
  },
  save: function() {
    const uri = this.editor.getValue();
    const parts = uri.split("/");
    const name = parts[parts.length - 1];
    const attrs = {
      name: name + (name.match(/\.pdf$/) ? "" : " pdf"),
      uri,
      content_type: C$1.TYPE_PDF_HTML,
      config: {}
    };
    this.trigger("save", attrs);
  },
  render: function() {
    this.$el.empty().append(this.editor.el);
    return this;
  }
});
View.ActionProvider.extend({
  name: "DOCSelector",
  postInit: function() {
    this.editor = Editor.create("url", {
      param: {
        label: "m_enter_doc_url",
        must: true,
        name: "uri"
      },
      parent: this
    }).render();
    this.listenTo(this.editor, "change", this.save);
  },
  save: function() {
    const uri = this.editor.getValue();
    const parts = uri.split("/");
    const name = parts[parts.length - 1];
    const attrs = {
      name: name + (name.match(/\.docx?$/) ? "" : " doc"),
      uri,
      content_type: C$1.TYPE_DOC,
      config: {}
    };
    this.trigger("save", attrs);
  },
  render: function() {
    this.$el.empty().append(this.editor.el);
    return this;
  }
});
const SieveSourceEditor = View.ActionProvider.extend({
  name: "SieveSourceEditor",
  actions: {
    edit_url: {
      fn: "action_edit_url"
    },
    force_static: {
      fn: "action_force_static"
    },
    selector_config_show: {
      fn: "action_config_show"
    },
    selector_edit: {
      fn: "action_selector_edit"
    }
  },
  action_config_show: function() {
    openConfigEditor(this.model, TXT("l_selection_config"), (modal) => {
      modal.remove();
    });
  },
  action_edit_url: function() {
    const model = this.model;
    const view = Editor.create("url", {
      param: {
        label: "l_url",
        must: true,
        name: "uri"
      },
      model: model.clone(),
      parent: this
    });
    const modal = new View.SaveDiscardModal({
      name: "SieveSourceEditor$URLModal",
      parent: this,
      title: TXT("l_url"),
      view
    });
    modal.show();
    modal.on("save", function() {
      model.set({ uri: view.getValue() });
      modal.remove();
    });
    modal.on("discard", function() {
      modal.remove();
    });
  },
  action_force_static: function() {
    const model = this.model;
    const config = model.get("config");
    const pages = config.get("selections");
    const page = pages && pages.at(0);
    page.set("dynamic", false);
    this.checkURI(model);
    model.trigger("change");
  },
  action_selector_edit: function() {
    if (this.sourceSelector) {
      this.onEditSourceSelectorDiscard();
    } else {
      this.openSelector();
    }
  },
  checkURI: async function(model) {
    if (model.get("content_type") != C$1.TYPE_HTML) {
      return;
    }
    const url = model.get("uri");
    const config = model.get("config");
    const pages = config.get("selections");
    const page = pages.at(0);
    const tabXF = Supports.tabForXFrame;
    const tabDn = Supports.tabForDynamic;
    const elMsg = this.elXFrameNotice;
    if (!url || page.get("dynamic") === false || !Supports.agents.local || !(tabXF || tabDn)) {
      return $(elMsg).addClass("hide");
    }
    if (tabDn) {
      $(elMsg).removeClass("hide");
    } else if (tabXF) {
      try {
        let res = await serviceProxy.HTTP.get({ url });
        if (res.headers["x-frame-options"] || /x-frame-options/i.test(res.response)) {
          $(elMsg).removeClass("hide");
        }
      } catch (err) {
        return Msg.error("Failed to fetch URL.", err);
      }
    }
  },
  onSourceSelectorSave: function(attrs) {
    attrs.config = this.parseConfig(typeof attrs.config == "string" ? JSON.parse(attrs.config) : attrs.config);
    if (this.model.get("name")) {
      delete attrs.name;
    }
    this.model.set(attrs);
    this.sourceSelector.remove();
    this.sourceSelector = null;
  },
  onEditSourceSelectorDiscard: function() {
    this.sourceSelector.remove();
    this.sourceSelector = null;
    if (this.model.isNew()) {
      App.navBack();
    }
  },
  openSelector: function() {
    this.sourceSelector = new SieveSourceSelector({
      parent: this,
      model: this.model
    });
    this.listenTo(this.sourceSelector, "save", this.onSourceSelectorSave);
    this.listenTo(this.sourceSelector, "discard", this.onEditSourceSelectorDiscard);
    this.sourceSelector.render();
    this.elSelector.appendChild(this.sourceSelector.el);
    this.sourceSelector.$el.css({ padding: 10 });
  },
  parseConfig: function(config) {
    const ctor2 = this.model.get("config").constructor;
    return new ctor2(config, { parse: true });
  },
  postInit: function() {
    const model = this.model;
    this.listenTo(model, "change:config change:uri", this.render);
    if (model.isEmpty()) {
      _.defer(this.openSelector);
    }
    this.elXFrameNotice = DIV(
      {
        "class": "alert alert-info hide",
        "style": "margin: 5px 0; padding: 5px;"
      },
      TXT("m_xframe_notice"),
      " ",
      BUTTON({
        "class": "btn btn-default btn-sm",
        "data-action": "force_static"
      }, TXT("a_static_load")),
      " ",
      A({ href: "https://distill.io/help/new-tab-chrome-extension" }, TXT("Learn More"))
    );
    this.listenTo(model, "change:uri", this.checkURI);
    this.checkURI(model);
  },
  getContentTypeDescription: function() {
    switch (this.model.get("content_type")) {
      case C$1.TYPE_HTML:
        return SPRINTF("a_open_x_selector", "l_webpage");
      case C$1.TYPE_FEED:
        return SPRINTF("a_open_x_selector", "l_feed");
      case C$1.TYPE_XML:
        return SPRINTF("a_open_x_selector", "l_xml");
      case C$1.TYPE_PDF_HTML:
        return SPRINTF("a_open_x_selector", "l_pdf");
      case C$1.TYPE_DOC:
        return SPRINTF("a_open_x_selector", "l_doc");
      case C$1.TYPE_JSON:
        let name = "l_datasource";
        switch (this.model.get("datasource_id")) {
          case C$1.DS_ID_UPTIME:
            name = "l_uptime";
            break;
          case C$1.DS_ID_JSON:
          case null:
            name = "l_json";
        }
        return SPRINTF("a_open_x_selector", name);
      default:
        console.warn("getContentTypeDescription", "unknown content type", this.model.get("content_type"));
        return TXT("a_open_selector");
    }
  },
  render: function() {
    this.macroSelector = new MacroSelector({ model: this.model, classes: [] });
    this.$el.empty().append(
      DIV(
        {
          "class": "flex"
        },
        DIV(
          {
            "class": "btn-group flex mr2",
            "role": "group"
          },
          BUTTON({
            "type": "button",
            "class": "btn btn-default",
            "data-action": "selector_edit",
            "title": TXT("h_selector_edit")
          }, this.getContentTypeDescription()),
          BUTTON({
            "class": "btn btn-default dropdown-toggle",
            "data-toggle": "dropdown"
          }, SPAN({ "class": "caret" })),
          UL(
            { "class": "dropdown-menu" },
            LI(
              A({
                "data-action": "selector_config_show",
                "href": "javascript:void 0"
              }, TXT("h_config_show"))
            )
          )
        ),
        this.model.get("content_type") == C$1.TYPE_HTML ? DIV(
          {
            "class": "mr2"
          },
          this.macroSelector.el
        ) : "",
        BUTTON({
          "class": "btn btn-default truncate mw6",
          "data-action": "edit_url"
        }, TXT("a_edit"), " ", this.model.get("uri"))
      ),
      this.elXFrameNotice,
      this.elSelector = DIV()
    );
    return this;
  }
});
View.ActionProvider.extend({
  name: "SieveOptions",
  actions: {
    sieve_save: { fn: "action_save" }
  },
  action_save: function(x, el2) {
    const model = this.model;
    Msg.start("sieve:save", { info: "saving" });
    $(el2).button("loading");
    async.series([
      (callback) => {
        const rule = this.rulesEditor.model;
        this.rulesEditor.updateModel();
        if (rule.isNew() && rule.isEmpty()) {
          return callback();
        }
        Msg.start("sieve:rule:save", { info: "l_loading" });
        rule.save(null, {
          error: function(rule2, res) {
            Msg.stop("sieve:rule:save", { error: "e_req" });
            callback({ msg: "Failed to save conditions", err: res });
          },
          success: function() {
            if (model.get("rule_id") != rule.id) {
              model.set({ rule_id: rule.id }, { silent: true });
            }
            Msg.stop("sieve:rule:save");
            callback();
          }
        });
      },
      (callback) => {
        const attrs = _.omit(
          model.toJSON(),
          "err",
          "text",
          "ts",
          "ts_data",
          "ts_mod",
          "ts_view",
          "user_id"
        );
        if (attrs.state == C$1.STATE_INIT) {
          attrs.state = C$1.STATE_READY;
        }
        model.save(null, {
          data: attrs,
          patch: true,
          silent: true,
          wait: true,
          error: function(model2, res) {
            Msg.stop("sieve:save", { error: "Failed to save changes to server" });
            callback({ msg: "Failed to save changes", err: res });
          },
          success: function(model2) {
            Msg.stop("sieve:save");
            callback(null);
          }
        });
      },
      (callback) => {
        const changes = this.actionEditor.getChanges();
        if (!base.syncBatch(changes, callback)) {
          callback();
        }
      }
    ], (err, results) => {
      $(el2).button("reset");
      if (err) {
        Msg.error("Failed to save data. Please check console for more info.");
      } else {
        this.trigger("save");
        App.navBack();
      }
    });
  },
  duplicate: async function(id2) {
    const model = await this.fetch(id2);
    const json = _.pick(
      model.toJSON(),
      "name",
      "uri",
      "config",
      "client_id",
      "content_type",
      "schedule",
      "tags",
      "datasource_id"
    );
    json.name = "Copy of " + json.name;
    this.setModel(new this.collection.model(json, { parse: true }), {
      defaultsModel: model,
      editURL: false
    });
  },
  edit: async function(id2) {
    let model = await this.fetch(id2);
    this.setModel(model);
  },
  editNew: function(type, options) {
    let content_type = 0;
    let attrs = {};
    switch (type) {
      case "page":
        content_type = C$1.TYPE_HTML;
        break;
      case "feed":
        content_type = C$1.TYPE_FEED;
        break;
      case "xml":
        content_type = C$1.TYPE_XML;
        break;
      case "pdf":
        content_type = C$1.TYPE_PDF_HTML;
        break;
      case "doc":
        content_type = C$1.TYPE_DOC;
        break;
      case "json":
        content_type = C$1.TYPE_JSON;
        switch (options.type) {
          case C$1.DS_TYPE_UPTIME:
            attrs.datasource_id = C$1.DS_ID_UPTIME;
            break;
          case C$1.DS_TYPE_JSON:
          default:
            attrs.datasource_id = C$1.DS_ID_JSON;
        }
        break;
      default:
        Msg.error("Unknown monitor type: " + type);
        throw new Error("Unknown monitor type: " + type);
    }
    this.setModel(new Model$2.Sieve({
      ...attrs,
      content_type
    }, { parse: true }));
  },
  fetch: async function(id2) {
    let model = new Model$2.Sieve({ id: id2 });
    await model.fetch();
    return model;
  },
  initEditors: async function(model, defaultsModel) {
    const actions = new Model$2.SieveActions(null, { parent: model });
    const rule = new Model$2.SieveRule({
      id: model.get("rule_id") || void 0
    });
    this.sourceEditor = new SieveSourceEditor({
      model,
      parent: this,
      className: "controls"
    }).render();
    this.clientSelector = new ViewClients.ClientSelector({ model });
    this.nameEditor = Editor.create("text", {
      model,
      param: {
        label: "l_name",
        must: true,
        name: "name",
        type: "text"
      },
      parent: this
    }).render();
    this.scheduleEditor = new SieveScheduleEditor({
      model,
      parent: this
    }).render();
    this.actionEditor = new SieveActionsEditor({
      actions,
      sieve: model,
      parent: this
    }).render();
    this.rulesEditor = new SieveRuleWrapper({
      model: rule,
      parent: this
    }).render();
    this.tagsEditor = new TagsEditor$1({
      model,
      parent: this
    }).render();
    this.loadDefaults(model, actions, defaultsModel);
  },
  async createDefaults(sieve, actions, defaultsModel) {
    const uri = sieve.get("uri");
    const hostn = uri && new URL(uri).hostname;
    const colln = new Model$2.Sieves();
    if (_.isEmpty(sieve.get("name")) && uri) {
      sieve.set("name", TXT("l_loading"));
      $.get(URL_UTILS + "/v1/http/get?html_css_filter=title&url=" + encodeURIComponent(uri), function(res) {
        if (res) {
          sieve.set("name", $(res).text().trim() || "Untitled");
        }
      });
    }
    let copyRef = (ref, defaultRules) => {
      const refActions = new Model$2.SieveActions(null, { parent: ref });
      refActions.fetch({
        data: { state: 0 },
        success: () => {
          refActions.each((action) => {
            const attrs = action.omit("id", "sieve_id", "ts", "ts_mod");
            actions.add(new Model$2.SieveAction[attrs.type](attrs, { parse: true }));
          });
          this.onChanges();
        }
      });
      let refSchedule = ref.get("schedule");
      if (refSchedule.get("type") == "LIVE") {
        refSchedule = new Model$2.Schedule({ type: "INTERVAL" });
      }
      sieve.set("schedule", refSchedule);
      this.scheduleEditor.render();
      const rule_id = ref.get("rule_id");
      if (defaultRules && rule_id) {
        this.rulesEditor.duplicate(rule_id);
      }
    };
    if (defaultsModel) {
      return copyRef(defaultsModel, true);
    }
    await colln.fetch({
      data: {
        "uri.like": "%" + hostn + "%",
        "state.in": [C$1.STATE_READY, C$1.STATE_PAUSED],
        "_opt": {
          limit: 1,
          order: ["-ts"],
          only: ["id", "schedule", "tags"]
        }
      }
    });
    if (colln.length > 0) {
      return copyRef(colln.at(0), false);
    }
    await colln.fetch({
      data: {
        "state.in": [C$1.STATE_READY, C$1.STATE_PAUSED],
        "_opt": {
          limit: 1,
          order: ["-ts"],
          only: ["id", "schedule", "tags"]
        }
      }
    });
    if (colln.length > 0) {
      return copyRef(colln.at(0), false);
    }
    _.each(Model$2.SieveActionDescList, (desc) => {
      if (desc.addByDefault(Supports)) {
        actions.add(new Model$2.SieveAction[desc.type]());
      }
    });
    this.onChanges();
  },
  loadDefaults: function(sieve, actions, defaultsModel) {
    if (sieve.isNew() || sieve.get("state") == C$1.STATE_INIT) {
      this.createDefaults(sieve, actions, defaultsModel);
    } else {
      actions.fetch({ data: { state: 0 } });
    }
  },
  postInit: function(options) {
    this.clients = options.clients;
  },
  showProgress: function() {
    this.$el.children(".xprogress").show();
  },
  removeProgress: function() {
    this.$el.children(".xprogress").hide();
  },
  render: function() {
    this.$el.empty().append(
      DIV(
        { "class": "xtbar xvbar-margin mb-4 ml-2" },
        BUTTON(
          {
            "class": "btn btn-default",
            "data-action": "go_back"
          },
          I({ "class": "fa fa-chevron-left" }),
          " ",
          TXT("a_discard"),
          " ",
          this.elUnsavedMsg = SPAN()
        )
      ),
      DIV(
        { "class": "xpage-header" },
        H3(this.elHeading = SPAN())
      ),
      DIV(
        { "class": "xprogress", "style": "margin-top: -2px;position:absolute;" },
        DIV({ "class": "xindeterminate" })
      ),
      DIV(
        { "class": "form-horizontal", "style": "padding: 10px;" },
        this.elContent = DIV()
      )
    );
    return this;
  },
  renderOptions: function() {
    const model = this.model;
    model.getTags(App.labels);
    $(this.elHeading).empty().append(
      TXT("l_options"),
      " - ",
      model.isNew() ? TXT("l_add_monitor") : model.get("name")
    );
    $(this.elContent).empty().append(
      DIV(
        { "class": "form-group" },
        LABEL({ "class": "control-label col-md-2" }, TXT("l_source")),
        DIV(
          { "class": "col-md-10" },
          this.sourceEditor.el,
          P({ "class": "help" }, TXT("h_sieve_source"))
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2", "for": "sieve-device" },
          TXT("l_device")
        ),
        DIV(
          { "class": "col-md-10" },
          this.clientSelector.el,
          P({ "class": "help" }, TXT("h_sieve_device"))
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2", "for": "sieve-name" },
          TXT("l_name")
        ),
        DIV(
          { "class": "col-md-10" },
          this.nameEditor.el,
          P({ "class": "help" }, TXT("h_sieve_name"))
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2", "for": "sieve-schedule" },
          TXT("l_schedule")
        ),
        DIV(
          { "class": "col-md-10" },
          this.scheduleEditor.el
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2" },
          TXT("l_actions")
        ),
        DIV(
          { "class": "col-md-10" },
          this.actionEditor.el,
          P({ "class": "help" }, TXT("h_sieve_actions"))
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2" },
          TXT("l_conditions")
        ),
        DIV(
          { "class": "col-md-10" },
          this.rulesEditor.el,
          P({ "class": "help" }, TXT("h_sieve_rules"))
        )
      ),
      DIV(
        { "class": "form-group" },
        LABEL(
          { "class": "control-label col-md-2" },
          TXT("l_label")
        ),
        DIV(
          { "class": "col-md-10" },
          this.tagsEditor.el
        )
      ),
      DIV(
        { "class": "form-group" },
        DIV(
          { "class": "col-md-offset-2 col-md-10 xtbar-form" },
          BUTTON({
            "class": "btn btn-primary xbtn-default",
            "data-action": "sieve_save"
          }, TXT("a_save")),
          BUTTON({
            "class": "btn btn-default",
            "data-action": "go_back"
          }, TXT("a_discard"))
        )
      )
    );
  },
  onChanges: function() {
  },
  onSaveModel: function(attrs) {
    const model = new this.collection.model(_.defaults(attrs, {
      client_id: this.clients.defaultId,
      content_type: this.model.get("content_type"),
      datasource_id: this.model.get("datasource_id"),
      schedule: {
        type: "INTERVAL",
        params: {
          interval: 10800
        }
      },
      version: 1
    }), { parse: true });
    this.setModel(model);
  },
  onNewSourceSelectorDiscard: function() {
    this.sourceSelector.remove();
    App.navBack();
  },
  setModel: async function(model, options = {
    defaultsModel: null,
    editURL: false
  }) {
    this.showProgress();
    let sieveConstraint = {};
    if (this.model) {
      this.stopListening(this.model);
    }
    this.model = model;
    this.sourceSelector && this.sourceSelector.remove();
    this.listenTo(model, "change", this.onChanges);
    $(this.elUnsavedMsg).text("");
    try {
      sieveConstraint = await checkSieveConstraint(1);
    } catch (e) {
      console.error(e);
      sieveConstraint = { isOverLimit: false };
    }
    let accessInfo = await model.getAccess(App.user);
    if (model.isNew() && !accessInfo.hasAccess) {
      $(this.elHeading).text(TXT("m_upgrade_account"));
      let { minPlan } = accessInfo;
      if (minPlan) {
        $(this.elContent).empty().append(
          `${model.getTypeName()} monitors are available in ${minPlan} or higher subscriptions. `,
          A({
            href: urlCfg.billing
          }, "Manage Subscription")
        );
      } else {
        $(this.elContent).append("Please sign in or contact support to get more information");
      }
    } else if (model.isNew() && sieveConstraint.isOverLimit) {
      $(this.elHeading).text(TXT("m_monitor_limit"));
      $(this.elContent).empty().append(SieveConstraints(sieveConstraint));
    } else if (model.isEmpty()) {
      this.showSourceSelector(model);
    } else {
      await this.initEditors(model, options.defaultsModel);
      this.renderOptions();
      if (options.editURL) {
        this.sourceEditor.action_edit_url();
      }
    }
    this.removeProgress();
  },
  showSourceSelector(model) {
    const sourceSelector = new SieveSourceSelector({
      model,
      parent: this
    }).render();
    sourceSelector.on("save", this.onSaveModel);
    sourceSelector.on("discard", this.onNewSourceSelectorDiscard);
    this.sourceSelector = sourceSelector;
    $(this.elHeading).text(TXT("l_source"));
    $(this.elContent).empty().append(sourceSelector.el);
  }
});
const openConfigEditor = function(model, title, callback) {
  const view = Editor.create("json", {
    param: {
      label: "l_selection_config",
      must: false,
      name: "config",
      type: "json"
    },
    model: new Backbone.Model({
      config: model.get("config").toJSON()
    })
  });
  const modal = new View.SaveDiscardModal({
    name: "SieveSourceEditor$ConfigModal",
    title,
    view
  });
  modal.on("save", function() {
    const config = view.model.get("config");
    model.set({ config: parseConfig(config) });
    callback(modal);
  });
  modal.on("discard", function() {
    modal.remove();
  });
  modal.show();
  view.$el.find("textarea").css("height", 300);
  function parseConfig(config) {
    const ctor2 = model.get("config").constructor;
    return new ctor2(config, { parse: true });
  }
};
var VERSION = "1.13.7";
var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
var push = ArrayProto.push, slice = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
var supportsArrayBuffer = typeof ArrayBuffer !== "undefined", supportsDataView = typeof DataView !== "undefined";
var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
var _isNaN = isNaN, _isFinite = isFinite;
var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
var nonEnumerableProps = [
  "valueOf",
  "isPrototypeOf",
  "toString",
  "propertyIsEnumerable",
  "hasOwnProperty",
  "toLocaleString"
];
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
function restArguments(func2, startIndex) {
  startIndex = startIndex == null ? func2.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index2 = 0;
    for (; index2 < length; index2++) {
      rest2[index2] = arguments[index2 + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func2.call(this, rest2);
      case 1:
        return func2.call(this, arguments[0], rest2);
      case 2:
        return func2.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index2 = 0; index2 < startIndex; index2++) {
      args[index2] = arguments[index2];
    }
    args[startIndex] = rest2;
    return func2.apply(this, args);
  };
}
function isObject(obj) {
  var type = typeof obj;
  return type === "function" || type === "object" && !!obj;
}
function isNull(obj) {
  return obj === null;
}
function isUndefined(obj) {
  return obj === void 0;
}
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj) {
    return toString.call(obj) === tag;
  };
}
var isString = tagTester("String");
var isNumber = tagTester("Number");
var isDate = tagTester("Date");
var isRegExp = tagTester("RegExp");
var isError = tagTester("Error");
var isSymbol = tagTester("Symbol");
var isArrayBuffer = tagTester("ArrayBuffer");
var isFunction = tagTester("Function");
var nodelist = root.document && root.document.childNodes;
if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
  isFunction = function(obj) {
    return typeof obj == "function" || false;
  };
}
var isFunction$1 = isFunction;
var hasObjectTag = tagTester("Object");
var hasDataViewBug = supportsDataView && (!/\[native code\]/.test(String(DataView)) || hasObjectTag(new DataView(new ArrayBuffer(8)))), isIE11 = typeof Map !== "undefined" && hasObjectTag(/* @__PURE__ */ new Map());
var isDataView = tagTester("DataView");
function alternateIsDataView(obj) {
  return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
}
var isDataView$1 = hasDataViewBug ? alternateIsDataView : isDataView;
var isArray = nativeIsArray || tagTester("Array");
function has$1(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}
var isArguments = tagTester("Arguments");
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return has$1(obj, "callee");
    };
  }
})();
var isArguments$1 = isArguments;
function isFinite$1(obj) {
  return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}
function isNaN$1(obj) {
  return isNumber(obj) && _isNaN(obj);
}
function constant(value) {
  return function() {
    return value;
  };
}
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}
var getByteLength = shallowProperty("byteLength");
var isBufferLike = createSizePropertyCheck(getByteLength);
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  return nativeIsView ? nativeIsView(obj) && !isDataView$1(obj) : isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
}
var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);
var getLength = shallowProperty("length");
function emulatedSet(keys2) {
  var hash = {};
  for (var l = keys2.length, i2 = 0; i2 < l; ++i2)
    hash[keys2[i2]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys2.push(key);
    }
  };
}
function collectNonEnumProps(obj, keys2) {
  keys2 = emulatedSet(keys2);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = isFunction$1(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has$1(obj, prop) && !keys2.contains(prop))
    keys2.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys2.contains(prop)) {
      keys2.push(prop);
    }
  }
}
function keys(obj) {
  if (!isObject(obj))
    return [];
  if (nativeKeys)
    return nativeKeys(obj);
  var keys2 = [];
  for (var key in obj)
    if (has$1(obj, key))
      keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}
function isEmpty(obj) {
  if (obj == null)
    return true;
  var length = getLength(obj);
  if (typeof length == "number" && (isArray(obj) || isString(obj) || isArguments$1(obj)))
    return length === 0;
  return getLength(keys(obj)) === 0;
}
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null)
    return !length;
  var obj = Object(object2);
  for (var i2 = 0; i2 < length; i2++) {
    var key = _keys[i2];
    if (attrs[key] !== obj[key] || !(key in obj))
      return false;
  }
  return true;
}
function _$3(obj) {
  if (obj instanceof _$3)
    return obj;
  if (!(this instanceof _$3))
    return new _$3(obj);
  this._wrapped = obj;
}
_$3.VERSION = VERSION;
_$3.prototype.value = function() {
  return this._wrapped;
};
_$3.prototype.valueOf = _$3.prototype.toJSON = _$3.prototype.value;
_$3.prototype.toString = function() {
  return String(this._wrapped);
};
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength(bufferSource)
  );
}
var tagDataView = "[object DataView]";
function eq(a, b, aStack, bStack) {
  if (a === b)
    return a !== 0 || 1 / a === 1 / b;
  if (a == null || b == null)
    return false;
  if (a !== a)
    return b !== b;
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object")
    return false;
  return deepEq(a, b, aStack, bStack);
}
function deepEq(a, b, aStack, bStack) {
  if (a instanceof _$3)
    a = a._wrapped;
  if (b instanceof _$3)
    b = b._wrapped;
  var className = toString.call(a);
  if (className !== toString.call(b))
    return false;
  if (hasDataViewBug && className == "[object Object]" && isDataView$1(a)) {
    if (!isDataView$1(b))
      return false;
    className = tagDataView;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a)
        return +b !== +b;
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray$1(a)) {
    var byteLength = getByteLength(a);
    if (byteLength !== getByteLength(b))
      return false;
    if (a.buffer === b.buffer && a.byteOffset === b.byteOffset)
      return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object")
      return false;
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor && isFunction$1(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a)
      return bStack[length] === b;
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length)
      return false;
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack))
        return false;
    }
  } else {
    var _keys = keys(a), key;
    length = _keys.length;
    if (keys(b).length !== length)
      return false;
    while (length--) {
      key = _keys[length];
      if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack)))
        return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual$1(a, b) {
  return eq(a, b);
}
function allKeys(obj) {
  if (!isObject(obj))
    return [];
  var keys2 = [];
  for (var key in obj)
    keys2.push(key);
  if (hasEnumBug)
    collectNonEnumProps(obj, keys2);
  return keys2;
}
function ie11fingerprint(methods) {
  var length = getLength(methods);
  return function(obj) {
    if (obj == null)
      return false;
    var keys2 = allKeys(obj);
    if (getLength(keys2))
      return false;
    for (var i2 = 0; i2 < length; i2++) {
      if (!isFunction$1(obj[methods[i2]]))
        return false;
    }
    return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
  };
}
var forEachName = "forEach", hasName = "has", commonInit = ["clear", "delete"], mapTail = ["get", hasName, "set"];
var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = ["add"].concat(commonInit, forEachName, hasName);
var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
var isWeakSet = tagTester("WeakSet");
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i2 = 0; i2 < length; i2++) {
    values2[i2] = obj[_keys[i2]];
  }
  return values2;
}
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs2 = Array(length);
  for (var i2 = 0; i2 < length; i2++) {
    pairs2[i2] = [_keys[i2], obj[_keys[i2]]];
  }
  return pairs2;
}
function invert(obj) {
  var result2 = {};
  var _keys = keys(obj);
  for (var i2 = 0, length = _keys.length; i2 < length; i2++) {
    result2[obj[_keys[i2]]] = _keys[i2];
  }
  return result2;
}
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction$1(obj[key]))
      names.push(key);
  }
  return names.sort();
}
function createAssigner(keysFunc, defaults2) {
  return function(obj) {
    var length = arguments.length;
    if (defaults2)
      obj = Object(obj);
    if (length < 2 || obj == null)
      return obj;
    for (var index2 = 1; index2 < length; index2++) {
      var source = arguments[index2], keys2 = keysFunc(source), l = keys2.length;
      for (var i2 = 0; i2 < l; i2++) {
        var key = keys2[i2];
        if (!defaults2 || obj[key] === void 0)
          obj[key] = source[key];
      }
    }
    return obj;
  };
}
var extend = createAssigner(allKeys);
var extendOwn = createAssigner(keys);
var defaults = createAssigner(allKeys, true);
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject(prototype))
    return {};
  if (nativeCreate)
    return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}
function create(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props)
    extendOwn(result2, props);
  return result2;
}
function clone(obj) {
  if (!isObject(obj))
    return obj;
  return isArray(obj) ? obj.slice() : extend({}, obj);
}
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}
function toPath$1(path) {
  return isArray(path) ? path : [path];
}
_$3.toPath = toPath$1;
function toPath(path) {
  return _$3.toPath(path);
}
function deepGet(obj, path) {
  var length = path.length;
  for (var i2 = 0; i2 < length; i2++) {
    if (obj == null)
      return void 0;
    obj = obj[path[i2]];
  }
  return length ? obj : void 0;
}
function get(object2, path, defaultValue) {
  var value = deepGet(object2, toPath(path));
  return isUndefined(value) ? defaultValue : value;
}
function has(obj, path) {
  path = toPath(path);
  var length = path.length;
  for (var i2 = 0; i2 < length; i2++) {
    var key = path[i2];
    if (!has$1(obj, key))
      return false;
    obj = obj[key];
  }
  return !!length;
}
function identity(value) {
  return value;
}
function matcher(attrs) {
  attrs = extendOwn({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}
function property(path) {
  path = toPath(path);
  return function(obj) {
    return deepGet(obj, path);
  };
}
function optimizeCb(func2, context, argCount) {
  if (context === void 0)
    return func2;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func2.call(context, value);
      };
    case 3:
      return function(value, index2, collection) {
        return func2.call(context, value, index2, collection);
      };
    case 4:
      return function(accumulator, value, index2, collection) {
        return func2.call(context, accumulator, value, index2, collection);
      };
  }
  return function() {
    return func2.apply(context, arguments);
  };
}
function baseIteratee(value, context, argCount) {
  if (value == null)
    return identity;
  if (isFunction$1(value))
    return optimizeCb(value, context, argCount);
  if (isObject(value) && !isArray(value))
    return matcher(value);
  return property(value);
}
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
_$3.iteratee = iteratee;
function cb(value, context, argCount) {
  if (_$3.iteratee !== iteratee)
    return _$3.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}
function mapObject(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys(obj), length = _keys.length, results = {};
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys[index2];
    results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
function noop() {
}
function propertyOf(obj) {
  if (obj == null)
    return noop;
  return function(path) {
    return get(obj, path);
  };
}
function times(n, iteratee2, context) {
  var accum = Array(Math.max(0, n));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i2 = 0; i2 < n; i2++)
    accum[i2] = iteratee2(i2);
  return accum;
}
function random(min2, max2) {
  if (max2 == null) {
    max2 = min2;
    min2 = 0;
  }
  return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
}
var now = Date.now || function() {
  return new Date().getTime();
};
function createEscaper(map2) {
  var escaper = function(match) {
    return map2[match];
  };
  var source = "(?:" + keys(map2).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}
var escapeMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};
var escape$1 = createEscaper(escapeMap);
var unescapeMap = invert(escapeMap);
var unescape = createEscaper(unescapeMap);
var templateSettings = _$3.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
};
var noMatch = /(.)^/;
var escapes = {
  "'": "'",
  "\\": "\\",
  "\r": "r",
  "\n": "n",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
function escapeChar(match) {
  return "\\" + escapes[match];
}
var bareIdentifier = /^\s*(\w|\$)+\s*$/;
function template(text2, settings, oldSettings) {
  if (!settings && oldSettings)
    settings = oldSettings;
  settings = defaults({}, settings, _$3.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index2 = 0;
  var source = "__p+='";
  text2.replace(matcher2, function(match, escape2, interpolate, evaluate, offset) {
    source += text2.slice(index2, offset).replace(escapeRegExp, escapeChar);
    index2 = offset + match.length;
    if (escape2) {
      source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument))
      throw new Error(
        "variable is not a bare identifier: " + argument
      );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render2;
  try {
    render2 = new Function(argument, "_", source);
  } catch (e) {
    e.source = source;
    throw e;
  }
  var template2 = function(data) {
    return render2.call(this, data, _$3);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}
function result(obj, path, fallback) {
  path = toPath(path);
  var length = path.length;
  if (!length) {
    return isFunction$1(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i2 = 0; i2 < length; i2++) {
    var prop = obj == null ? void 0 : obj[path[i2]];
    if (prop === void 0) {
      prop = fallback;
      i2 = length;
    }
    obj = isFunction$1(prop) ? prop.call(obj) : prop;
  }
  return obj;
}
var idCounter = 0;
function uniqueId(prefix) {
  var id2 = ++idCounter + "";
  return prefix ? prefix + id2 : id2;
}
function chain(obj) {
  var instance2 = _$3(obj);
  instance2._chain = true;
  return instance2;
}
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc))
    return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject(result2))
    return result2;
  return self2;
}
var partial = restArguments(function(func2, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i2 = 0; i2 < length; i2++) {
      args[i2] = boundArgs[i2] === placeholder ? arguments[position++] : boundArgs[i2];
    }
    while (position < arguments.length)
      args.push(arguments[position++]);
    return executeBound(func2, bound, this, this, args);
  };
  return bound;
});
partial.placeholder = _$3;
var bind = restArguments(function(func2, context, args) {
  if (!isFunction$1(func2))
    throw new TypeError("Bind must be called on a function");
  var bound = restArguments(function(callArgs) {
    return executeBound(func2, bound, context, this, args.concat(callArgs));
  });
  return bound;
});
var isArrayLike = createSizePropertyCheck(getLength);
function flatten$1(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i2 = 0, length = getLength(input); i2 < length; i2++) {
    var value = input[i2];
    if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
      if (depth > 1) {
        flatten$1(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len)
          output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}
var bindAll = restArguments(function(obj, keys2) {
  keys2 = flatten$1(keys2, false, false);
  var index2 = keys2.length;
  if (index2 < 1)
    throw new Error("bindAll must be passed function names");
  while (index2--) {
    var key = keys2[index2];
    obj[key] = bind(obj[key], obj);
  }
  return obj;
});
function memoize(func2, hasher) {
  var memoize2 = function(key) {
    var cache = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has$1(cache, address))
      cache[address] = func2.apply(this, arguments);
    return cache[address];
  };
  memoize2.cache = {};
  return memoize2;
}
var delay = restArguments(function(func2, wait2, args) {
  return setTimeout(function() {
    return func2.apply(null, args);
  }, wait2);
});
var defer = partial(delay, _$3, 1);
function throttle(func2, wait2, options) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : now();
    timeout = null;
    result2 = func2.apply(context, args);
    if (!timeout)
      context = args = null;
  };
  var throttled = function() {
    var _now = now();
    if (!previous && options.leading === false)
      previous = _now;
    var remaining = wait2 - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait2) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func2.apply(context, args);
      if (!timeout)
        context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}
function debounce(func2, wait2, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now() - previous;
    if (wait2 > passed) {
      timeout = setTimeout(later, wait2 - passed);
    } else {
      timeout = null;
      if (!immediate)
        result2 = func2.apply(context, args);
      if (!timeout)
        args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now();
    if (!timeout) {
      timeout = setTimeout(later, wait2);
      if (immediate)
        result2 = func2.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}
function wrap(func2, wrapper) {
  return partial(wrapper, func2);
}
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i2 = start;
    var result2 = args[start].apply(this, arguments);
    while (i2--)
      result2 = args[i2].call(this, result2);
    return result2;
  };
}
function after(times2, func2) {
  return function() {
    if (--times2 < 1) {
      return func2.apply(this, arguments);
    }
  };
}
function before(times2, func2) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func2.apply(this, arguments);
    }
    if (times2 <= 1)
      func2 = null;
    return memo;
  };
}
var once = partial(before, 2);
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj), key;
  for (var i2 = 0, length = _keys.length; i2 < length; i2++) {
    key = _keys[i2];
    if (predicate(obj[key], key, obj))
      return key;
  }
}
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength(array);
    var index2 = dir > 0 ? 0 : length - 1;
    for (; index2 >= 0 && index2 < length; index2 += dir) {
      if (predicate(array[index2], index2, array))
        return index2;
    }
    return -1;
  };
}
var findIndex = createPredicateIndexFinder(1);
var findLastIndex = createPredicateIndexFinder(-1);
function sortedIndex(array, obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj);
  var low = 0, high = getLength(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value)
      low = mid + 1;
    else
      high = mid;
  }
  return low;
}
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i2 = 0, length = getLength(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i2 = idx >= 0 ? idx : Math.max(idx + length, i2);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i2, length), isNaN$1);
      return idx >= 0 ? idx + i2 : -1;
    }
    for (idx = dir > 0 ? i2 : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item)
        return idx;
    }
    return -1;
  };
}
var indexOf = createIndexFinder(1, findIndex, sortedIndex);
var lastIndexOf = createIndexFinder(-1, findLastIndex);
function find(obj, predicate, context) {
  var keyFinder = isArrayLike(obj) ? findIndex : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1)
    return obj[key];
}
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}
function each(obj, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i2, length;
  if (isArrayLike(obj)) {
    for (i2 = 0, length = obj.length; i2 < length; i2++) {
      iteratee2(obj[i2], i2, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i2 = 0, length = _keys.length; i2 < length; i2++) {
      iteratee2(obj[_keys[i2]], _keys[i2], obj);
    }
  }
  return obj;
}
function map(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, results = Array(length);
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    results[index2] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
function createReduce(dir) {
  var reducer = function(obj, iteratee2, memo, initial2) {
    var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, index2 = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj[_keys ? _keys[index2] : index2];
      index2 += dir;
    }
    for (; index2 >= 0 && index2 < length; index2 += dir) {
      var currentKey = _keys ? _keys[index2] : index2;
      memo = iteratee2(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function(obj, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}
var reduce = createReduce(1);
var reduceRight = createReduce(-1);
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj, function(value, index2, list) {
    if (predicate(value, index2, list))
      results.push(value);
  });
  return results;
}
function reject(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}
function every(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    if (!predicate(obj[currentKey], currentKey, obj))
      return false;
  }
  return true;
}
function some(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
  for (var index2 = 0; index2 < length; index2++) {
    var currentKey = _keys ? _keys[index2] : index2;
    if (predicate(obj[currentKey], currentKey, obj))
      return true;
  }
  return false;
}
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike(obj))
    obj = values(obj);
  if (typeof fromIndex != "number" || guard)
    fromIndex = 0;
  return indexOf(obj, item, fromIndex) >= 0;
}
var invoke = restArguments(function(obj, path, args) {
  var contextPath, func2;
  if (isFunction$1(path)) {
    func2 = path;
  } else {
    path = toPath(path);
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return map(obj, function(context) {
    var method = func2;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = deepGet(context, contextPath);
      }
      if (context == null)
        return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
});
function pluck(obj, key) {
  return map(obj, property(key));
}
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}
function max(obj, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike(obj) ? obj : values(obj);
    for (var i2 = 0, length = obj.length; i2 < length; i2++) {
      value = obj[i2];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index2, list) {
      computed = iteratee2(v, index2, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
function min(obj, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike(obj) ? obj : values(obj);
    for (var i2 = 0, length = obj.length; i2 < length; i2++) {
      value = obj[i2];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index2, list) {
      computed = iteratee2(v, index2, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj)
    return [];
  if (isArray(obj))
    return slice.call(obj);
  if (isString(obj)) {
    return obj.match(reStrSymbol);
  }
  if (isArrayLike(obj))
    return map(obj, identity);
  return values(obj);
}
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike(obj))
      obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample2 = toArray(obj);
  var length = getLength(sample2);
  n = Math.max(Math.min(n, length), 0);
  var last2 = length - 1;
  for (var index2 = 0; index2 < n; index2++) {
    var rand = random(index2, last2);
    var temp = sample2[index2];
    sample2[index2] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n);
}
function shuffle(obj) {
  return sample(obj, Infinity);
}
function sortBy(obj, iteratee2, context) {
  var index2 = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map(obj, function(value, key, list) {
    return {
      value,
      index: index2++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0)
        return 1;
      if (a < b || b === void 0)
        return -1;
    }
    return left.index - right.index;
  }), "value");
}
function group(behavior, partition2) {
  return function(obj, iteratee2, context) {
    var result2 = partition2 ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each(obj, function(value, index2) {
      var key = iteratee2(value, index2, obj);
      behavior(result2, value, key);
    });
    return result2;
  };
}
var groupBy = group(function(result2, value, key) {
  if (has$1(result2, key))
    result2[key].push(value);
  else
    result2[key] = [value];
});
var indexBy = group(function(result2, value, key) {
  result2[key] = value;
});
var countBy = group(function(result2, value, key) {
  if (has$1(result2, key))
    result2[key]++;
  else
    result2[key] = 1;
});
var partition = group(function(result2, value, pass) {
  result2[pass ? 0 : 1].push(value);
}, true);
function size(obj) {
  if (obj == null)
    return 0;
  return isArrayLike(obj) ? obj.length : keys(obj).length;
}
function keyInObj(value, key, obj) {
  return key in obj;
}
var pick = restArguments(function(obj, keys2) {
  var result2 = {}, iteratee2 = keys2[0];
  if (obj == null)
    return result2;
  if (isFunction$1(iteratee2)) {
    if (keys2.length > 1)
      iteratee2 = optimizeCb(iteratee2, keys2[1]);
    keys2 = allKeys(obj);
  } else {
    iteratee2 = keyInObj;
    keys2 = flatten$1(keys2, false, false);
    obj = Object(obj);
  }
  for (var i2 = 0, length = keys2.length; i2 < length; i2++) {
    var key = keys2[i2];
    var value = obj[key];
    if (iteratee2(value, key, obj))
      result2[key] = value;
  }
  return result2;
});
var omit = restArguments(function(obj, keys2) {
  var iteratee2 = keys2[0], context;
  if (isFunction$1(iteratee2)) {
    iteratee2 = negate(iteratee2);
    if (keys2.length > 1)
      context = keys2[1];
  } else {
    keys2 = map(flatten$1(keys2, false, false), String);
    iteratee2 = function(value, key) {
      return !contains(keys2, key);
    };
  }
  return pick(obj, iteratee2, context);
});
function initial(array, n, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}
function first(array, n, guard) {
  if (array == null || array.length < 1)
    return n == null || guard ? void 0 : [];
  if (n == null || guard)
    return array[0];
  return initial(array, array.length - n);
}
function rest(array, n, guard) {
  return slice.call(array, n == null || guard ? 1 : n);
}
function last(array, n, guard) {
  if (array == null || array.length < 1)
    return n == null || guard ? void 0 : [];
  if (n == null || guard)
    return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}
function compact(array) {
  return filter(array, Boolean);
}
function flatten(array, depth) {
  return flatten$1(array, depth, false);
}
var difference = restArguments(function(array, rest2) {
  rest2 = flatten$1(rest2, true, true);
  return filter(array, function(value) {
    return !contains(rest2, value);
  });
});
var without = restArguments(function(array, otherArrays) {
  return difference(array, otherArrays);
});
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null)
    iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i2 = 0, length = getLength(array); i2 < length; i2++) {
    var value = array[i2], computed = iteratee2 ? iteratee2(value, i2, array) : value;
    if (isSorted && !iteratee2) {
      if (!i2 || seen !== computed)
        result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}
var union = restArguments(function(arrays) {
  return uniq(flatten$1(arrays, true, true));
});
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i2 = 0, length = getLength(array); i2 < length; i2++) {
    var item = array[i2];
    if (contains(result2, item))
      continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item))
        break;
    }
    if (j === argsLength)
      result2.push(item);
  }
  return result2;
}
function unzip(array) {
  var length = array && max(array, getLength).length || 0;
  var result2 = Array(length);
  for (var index2 = 0; index2 < length; index2++) {
    result2[index2] = pluck(array, index2);
  }
  return result2;
}
var zip = restArguments(unzip);
function object(list, values2) {
  var result2 = {};
  for (var i2 = 0, length = getLength(list); i2 < length; i2++) {
    if (values2) {
      result2[list[i2]] = values2[i2];
    } else {
      result2[list[i2][0]] = list[i2][1];
    }
  }
  return result2;
}
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}
function chunk(array, count2) {
  if (count2 == null || count2 < 1)
    return [];
  var result2 = [];
  var i2 = 0, length = array.length;
  while (i2 < length) {
    result2.push(slice.call(array, i2, i2 += count2));
  }
  return result2;
}
function chainResult(instance2, obj) {
  return instance2._chain ? _$3(obj).chain() : obj;
}
function mixin(obj) {
  each(functions(obj), function(name) {
    var func2 = _$3[name] = obj[name];
    _$3.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func2.apply(_$3, args));
    };
  });
  return _$3;
}
each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
  var method = ArrayProto[name];
  _$3.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === "shift" || name === "splice") && obj.length === 0) {
        delete obj[0];
      }
    }
    return chainResult(this, obj);
  };
});
each(["concat", "join", "slice"], function(name) {
  var method = ArrayProto[name];
  _$3.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null)
      obj = method.apply(obj, arguments);
    return chainResult(this, obj);
  };
});
var allExports = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION,
  restArguments,
  isObject,
  isNull,
  isUndefined,
  isBoolean,
  isElement,
  isString,
  isNumber,
  isDate,
  isRegExp,
  isError,
  isSymbol,
  isArrayBuffer,
  isDataView: isDataView$1,
  isArray,
  isFunction: isFunction$1,
  isArguments: isArguments$1,
  isFinite: isFinite$1,
  isNaN: isNaN$1,
  isTypedArray: isTypedArray$1,
  isEmpty,
  isMatch,
  isEqual: isEqual$1,
  isMap,
  isWeakMap,
  isSet,
  isWeakSet,
  keys,
  allKeys,
  values,
  pairs,
  invert,
  functions,
  methods: functions,
  extend,
  extendOwn,
  assign: extendOwn,
  defaults,
  create,
  clone,
  tap,
  get,
  has,
  mapObject,
  identity,
  constant,
  noop,
  toPath: toPath$1,
  property,
  propertyOf,
  matcher,
  matches: matcher,
  times,
  random,
  now,
  escape: escape$1,
  unescape,
  templateSettings,
  template,
  result,
  uniqueId,
  chain,
  iteratee,
  partial,
  bind,
  bindAll,
  memoize,
  delay,
  defer,
  throttle,
  debounce,
  wrap,
  negate,
  compose,
  after,
  before,
  once,
  findKey,
  findIndex,
  findLastIndex,
  sortedIndex,
  indexOf,
  lastIndexOf,
  find,
  detect: find,
  findWhere,
  each,
  forEach: each,
  map,
  collect: map,
  reduce,
  foldl: reduce,
  inject: reduce,
  reduceRight,
  foldr: reduceRight,
  filter,
  select: filter,
  reject,
  every,
  all: every,
  some,
  any: some,
  contains,
  includes: contains,
  include: contains,
  invoke,
  pluck,
  where,
  max,
  min,
  shuffle,
  sample,
  sortBy,
  groupBy,
  indexBy,
  countBy,
  partition,
  toArray,
  size,
  pick,
  omit,
  first,
  head: first,
  take: first,
  initial,
  last,
  rest,
  tail: rest,
  drop: rest,
  compact,
  flatten,
  without,
  uniq,
  unique: uniq,
  union,
  intersection,
  difference,
  unzip,
  transpose: unzip,
  zip,
  object,
  range,
  chunk,
  mixin,
  "default": _$3
}, Symbol.toStringTag, { value: "Module" }));
var _$2 = mixin(allExports);
_$2._ = _$2;
function getQuery(route2) {
  let query = {};
  switch (route2.prefix) {
    case "all": {
      query = { "state.in": [C$1.STATE_INIT, C$1.STATE_READY, C$1.STATE_PAUSED] };
      break;
    }
    case "error": {
      query = {
        "state.in": [C$1.STATE_INIT, C$1.STATE_READY, C$1.STATE_PAUSED],
        "err.ne": "$null"
      };
      break;
    }
    case "label": {
      query = {
        "state.in": [C$1.STATE_INIT, C$1.STATE_READY, C$1.STATE_PAUSED]
      };
      let id2 = route2.data;
      query["tags.like"] = "%" + id2 + "%";
      break;
    }
    case "search": {
      query = parseQuery(route2.query.q);
      break;
    }
    case "trash": {
      query = { state: C$1.STATE_DISCARD };
      break;
    }
    case "unread": {
      query = {
        "state.in": [C$1.STATE_INIT, C$1.STATE_READY, C$1.STATE_PAUSED],
        "ts_view.lt": { name: "ts_data", type: "field" }
      };
      break;
    }
    default: {
      query = {
        _opt: {
          limit: 0
        }
      };
    }
  }
  if (!query || Object.keys(query).length <= 0) {
    query = {
      _opt: {
        limit: 0
      }
    };
  }
  if (App.store.get("ui.list.clientfilter") == 2) {
    query = { ...query, client_id: App.clients.defaultId };
  }
  return query;
}
function parseQuery(txtQuery) {
  let queryObj = {};
  const Ortokens = txtQuery.split(" OR ");
  txtQuery.split(" AND ");
  if (Ortokens.length > 1) {
    let stateInFound = false;
    for (let i2 = 0; i2 < Ortokens.length; i2++) {
      let orToken = Ortokens[i2].trim();
      const regexForSpaceTokens = /(-?[\w\d]+:"[^"]+")|(-?[\w\d]+:([\w\d-]*)?)|([^\s]+)|(\b(?!AND\b)[^\s:]+\b)/g;
      let matchSpacedTokens = orToken.match(regexForSpaceTokens) || [];
      let groupedTokens = [];
      let tempToken = "";
      let firstTextIndex = -1;
      matchSpacedTokens.forEach((token, index2) => {
        if (token.includes(":") && !token.startsWith(":")) {
          groupedTokens.push(token);
        } else {
          if (token === "AND")
            return;
          if (firstTextIndex === -1) {
            firstTextIndex = groupedTokens.length;
          }
          tempToken += (tempToken ? "%" : "") + token;
        }
      });
      if (tempToken) {
        groupedTokens.splice(firstTextIndex, 0, tempToken.trim());
      }
      let res = groupANDoperations(groupedTokens);
      let queryParams = res.response || [];
      stateInFound = stateInFound && res.stateInFound;
      queryObj = updateQueryWithOr(queryObj, queryParams);
    }
    if (!stateInFound) {
      queryObj["state.in"] = [C$1.STATE_INIT, C$1.STATE_READY, C$1.STATE_PAUSED];
      if (txtQuery.includes("in:trash")) {
        queryObj["state.in"].push(C$1.STATE_DISCARD);
      }
    }
  } else {
    const regexForSpaceTokens = /(-?[\w\d]+:"[^"]+")|(-?[\w\d]+:([\w\d-]*)?)|([^\s]+)|(\b(?!AND\b)[^\s:]+\b)/g;
    let matchSpacedTokens = txtQuery.match(regexForSpaceTokens) || [];
    let stateInFound = false;
    let groupedTokens = [];
    let tempToken = "";
    let firstTextIndex = -1;
    matchSpacedTokens.forEach((token, index2) => {
      if (token.includes(":") && !token.startsWith(":")) {
        groupedTokens.push(token);
      } else {
        if (token === "AND")
          return;
        if (firstTextIndex === -1) {
          firstTextIndex = groupedTokens.length;
        }
        tempToken += (tempToken ? "%" : "") + token;
      }
    });
    if (tempToken) {
      groupedTokens.splice(firstTextIndex, 0, tempToken.trim());
    }
    let res = groupANDoperations(groupedTokens);
    let queryParams = res.response || [];
    stateInFound = stateInFound || res.stateInFound;
    queryObj = updateQueryWithAnd(queryObj, queryParams);
    if (!stateInFound) {
      queryObj["state.in"] = [C$1.STATE_INIT, C$1.STATE_READY, C$1.STATE_PAUSED];
      if (txtQuery.includes("in:trash")) {
        queryObj["state.in"].push(C$1.STATE_DISCARD);
      }
    }
  }
  if (queryObj !== void 0) {
    queryObj = deduplicateQueryObj(queryObj);
  }
  return queryObj;
}
function deduplicateQueryObj(queryObj) {
  let conditionsArray = ["$or", "$and"];
  conditionsArray.forEach((condition) => {
    if (queryObj.hasOwnProperty(condition) && Array.isArray(queryObj[condition])) {
      const conditionsSet = /* @__PURE__ */ new Set();
      queryObj[condition].forEach((item) => {
        if (typeof item === "object" && item !== null) {
          deduplicateQueryObj(item);
        }
        conditionsSet.add(JSON.stringify(item));
      });
      queryObj[condition] = Array.from(conditionsSet).map((item) => JSON.parse(item));
    }
  });
  return queryObj;
}
function updateQueryWithOr(queryObj, queryParams) {
  return {
    ...queryObj,
    $or: [...queryObj["$or"] || [], [...queryParams]]
  };
}
function groupANDoperations(tokens) {
  if (tokens === null)
    return {};
  let queryObj = {};
  let stateInFound = false;
  let ilikesMap = /* @__PURE__ */ new Map();
  let nilikesMap = /* @__PURE__ */ new Map();
  for (let j = 0; j < tokens.length; j++) {
    let andToken = tokens[j].trim();
    let [queryParams, queryKey] = getQueryParams(andToken) || [[], ""];
    const includesTagsIlikeQuery = queryKey === "tags.ilike";
    const includesTagsNilikeQuery = queryKey === "tags.nilike";
    if (includesTagsIlikeQuery) {
      populateIlikesMap(ilikesMap, queryParams);
    } else if (includesTagsNilikeQuery) {
      populateNilikesMap(nilikesMap, queryParams);
    } else {
      queryObj = updateQueryWithAnd(queryObj, queryParams);
      if (queryParams.includes("state.in")) {
        stateInFound = true;
      }
    }
  }
  queryObj = processIlikesMap(ilikesMap, queryObj);
  queryObj = processNilikesMap(nilikesMap, queryObj);
  return {
    response: ["$and", queryObj["$and"]],
    stateInFound
  };
}
function populateIlikesMap(ilikesMap, queryParams) {
  const key = queryParams[0];
  const value = queryParams[1];
  ilikesMap.set(key, ilikesMap.has(key) ? [...ilikesMap.get(key), value] : [value]);
}
function populateNilikesMap(nilikesMap, queryParams) {
  const key = Object.keys(queryParams[1])[0];
  const value = queryParams[1][key];
  nilikesMap.set(key, nilikesMap.has(key) ? [...nilikesMap.get(key), value] : [value]);
}
function processIlikesMap(ilikesMap, queryObj) {
  ilikesMap.forEach((ilikesArray, ilikeKey) => {
    let ilikeRegex = "";
    ilikesArray.sort();
    ilikesArray.forEach(function(part, index2, theArray) {
      part = part.replace(/^%|%$/g, "");
      const regexKey = "(?=.*" + part + ")";
      theArray[index2] = regexKey;
      ilikeRegex += regexKey;
    });
    const newKey = ilikeKey.split(".")[0] + ".ripcre";
    const queryParams = [newKey, ilikeRegex];
    queryObj = updateQueryWithAnd(queryObj, queryParams);
  });
  return queryObj;
}
function processNilikesMap(nilikesMap, queryObj) {
  nilikesMap = new Map([...nilikesMap.entries()].sort());
  nilikesMap.forEach((nilikesArray, nilikeKey) => {
    let nilikeRegex = "";
    nilikesArray.sort();
    nilikesArray.forEach(function(part, index2, theArray) {
      part = part.replace(/^%|%$/g, "");
      theArray[index2] = part;
    });
    nilikeRegex = nilikesArray.join("|");
    nilikeRegex = "(" + nilikeRegex + ")";
    let key = nilikeKey.split(".")[0];
    const newKey = nilikeKey.split(".")[0] + ".rnipcre";
    const queryParams = ["$or", { [newKey]: nilikeRegex, [key]: "$null" }];
    queryObj = updateQueryWithAnd(queryObj, queryParams);
  });
  return queryObj;
}
function updateQueryWithAnd(queryObj, queryParams) {
  return {
    ...queryObj,
    $and: [...queryObj["$and"] || [], [...queryParams]]
  };
}
function getQueryParams(token) {
  let queryObj = [];
  let queryKey;
  const nameVal = token.split(":");
  if (nameVal.length > 1) {
    let currName = nameVal[0];
    let isNegated = currName.startsWith("-");
    let switchName = currName.replace(/^-+/, "");
    let currVal = nameVal[1];
    let expressionString;
    switch (switchName) {
      case "label":
        currVal = currVal.replace(/"/g, "");
        var labels = App.labels.where({ name: currVal });
        expressionString = isNegated ? "tags.nilike" : "tags.ilike";
        if (labels == null ? void 0 : labels.length) {
          _$2.forEach(labels, function(label) {
            if (isNegated) {
              queryObj.push(`$or`);
              queryObj.push({ [expressionString]: "%" + label.id + "%", tags: "$null" });
            } else {
              queryObj.push(expressionString);
              queryObj.push("%" + label.id + "%");
            }
          });
        } else {
          expressionString = isNegated ? "tags.gte" : "tags.lt";
          if (isNegated) {
            queryObj.push("$or");
            queryObj.push({ [expressionString]: "", tags: "$null" });
          } else {
            queryObj.push(expressionString);
            queryObj.push("");
          }
        }
        queryKey = expressionString;
        break;
      case "is":
        if (currVal.match(/on/i) && !queryObj["state.in"]) {
          queryObj.push("state.in");
          queryObj.push([C$1.STATE_READY]);
          break;
        } else if (currVal.match(/on/i) && queryObj["state.in"].indexOf(C$1.STATE_READY) >= 0) {
          break;
        } else if (currVal.match(/off/i) && !queryObj["state.in"]) {
          queryObj.push("state.in");
          queryObj.push([C$1.STATE_PAUSED, C$1.STATE_INIT]);
          break;
        } else if (currVal.match(/off/i) && queryObj["state.in"].indexOf(C$1.STATE_PAUSED) >= 0) {
          break;
        } else if (currVal.match(/unread/i)) {
          queryObj.push("ts_view.lt");
          queryObj.push({ name: "ts_data", type: "field" });
          break;
        } else if (currVal.match(/read/i)) {
          queryObj.push("ts_view.gt");
          queryObj.push({ name: "ts_data", type: "field" });
          break;
        } else {
          queryObj.push("$or");
          queryObj.push({
            "uri.ilike": "%" + currName + ":" + currVal + "%",
            "name.ilike": "%" + currName + ":" + currVal + "%"
          });
          break;
        }
      case "no":
        if (currVal.match(/label/i)) {
          let regexExpression = "";
          var labels = App.labels.toArray();
          if (labels == null ? void 0 : labels.length) {
            regexExpression += labels.map((label) => label.id).join("|");
          } else {
            if (!isNegated) {
              queryObj.push(`$or`);
              queryObj.push({ "tags.gte": "", tags: "$null" });
            } else {
              queryObj.push("tags.lt");
              queryObj.push("");
            }
            break;
          }
          expressionString = "tags.rnipcre";
          regexExpression = "(" + regexExpression + ")";
          if (isNegated) {
            expressionString = "tags.ripcre";
            queryObj.push(expressionString);
            queryObj.push(regexExpression);
            break;
          }
          queryObj.push(`$or`);
          queryObj.push({ [expressionString]: regexExpression, tags: "$null" });
        } else if (currVal.match(/error/i)) {
          expressionString = "err";
          if (isNegated) {
            expressionString = "err.ne";
          }
          queryObj.push(expressionString);
          queryObj.push("$null");
        } else {
          queryObj.push("$or");
          queryObj.push({
            "uri.ilike": "%" + switchName + ":%",
            "name.ilike": "%" + switchName + ":%"
          });
          break;
        }
        queryKey = expressionString;
        break;
      case "has":
        if (currVal.match(/error/i)) {
          expressionString = "err.ne";
          if (isNegated) {
            expressionString = "err";
          }
          queryObj.push(expressionString);
          queryObj.push("$null");
        } else if (currVal.match(/label/i)) {
          let regexExpression = "";
          var labels = App.labels.toArray();
          if (labels == null ? void 0 : labels.length) {
            regexExpression += labels.map((label) => label.id).join("|");
          } else {
            if (isNegated) {
              queryObj.push(`$or`);
              queryObj.push({ "tags.gte": "", tags: "$null" });
            } else {
              queryObj.push("tags.lt");
              queryObj.push("");
            }
            break;
          }
          expressionString = "tags.rnipcre";
          regexExpression = "(" + regexExpression + ")";
          if (!isNegated) {
            expressionString = "tags.ripcre";
            queryObj.push(expressionString);
            queryObj.push(regexExpression);
            break;
          }
          queryObj.push(`$or`);
          queryObj.push({ [expressionString]: regexExpression, tags: "$null" });
        } else {
          queryObj.push("$or");
          queryObj.push({
            "uri.ilike": "%" + switchName + ":%",
            "name.ilike": "%" + switchName + ":%"
          });
        }
        queryKey = expressionString;
        break;
      case "keyword":
        queryObj.push("$or");
        queryObj.push({ "uri.ilike": "%" + currVal + "%", "name.ilike": "%" + currVal + "%" });
        break;
      case "in":
        if (currVal.match(/trash/i) && !queryObj["state.in"]) {
          queryObj.push("state.in");
          queryObj.push([C$1.STATE_DISCARD]);
        } else if (currVal.match(/trash/i) && queryObj["state.in"])
          ;
        else {
          queryObj.push("$or");
          queryObj.push({
            "uri.ilike": "%" + switchName + ":%",
            "name.ilike": "%" + switchName + ":%"
          });
          break;
        }
        break;
      default:
        queryObj.push("$or");
        queryObj.push({
          "uri.ilike": "%" + currName + ":" + currVal + "%",
          "name.ilike": "%" + currName + ":" + currVal + "%"
        });
    }
  } else {
    queryObj.push("$or");
    queryObj.push({ "uri.ilike": "%" + nameVal + "%", "name.ilike": "%" + nameVal + "%" });
  }
  return [queryObj, queryKey];
}
const $$1 = window.jQuery;
if (!$$1) {
  throw new Error("ADD jQuery");
}
const _$1 = window._;
if (!_$1) {
  throw new Error("ADD _");
}
const async$1 = window.async;
if (!async$1) {
  throw new Error("ADD async");
}
const domo = window.domo;
if (!domo) {
  throw new Error("ADD domo");
}
const moment$1 = window.moment;
if (!moment$1) {
  throw new Error("ADD moment");
}
const Backbone$1 = window.Backbone;
if (!Backbone$1) {
  throw new Error("ADD Backbone");
}
const Work$1 = View.Base.extend({
  name: "Work",
  url: function() {
    const attrs = this.model.attributes;
    if (attrs.err) {
      const team = get_store_value(params).team;
      return `#/checks/${team}/${this.options.sieve.id}?work=${attrs.id}`;
    } else {
      return "#";
    }
  },
  render: function() {
    const attrs = this.model.attributes;
    const err = attrs.err;
    if (err) {
      this.$el.append(
        DIV(
          { "class": "flex" },
          DIV(
            { "class": "error popup flex-1 hover:grey", "tabindex": "0" },
            SPAN(formatTime(attrs.ts)),
            " ",
            SPAN(err.code || "EUNKNOWN"),
            " "
          ),
          A({ "href": this.url(), "target": "_blank", class: "ml1" }, "View Details")
        )
      ).find(".popup").popover({
        placement: "left",
        html: true,
        trigger: "click|focus",
        container: "body",
        content: () => {
          return DIV(
            { class: "overflow-y-auto max-h-[300px]" },
            DIV(LABEL("Code:"), " ", SPAN(err.code || "NA")),
            DIV(LABEL("Msg:"), " ", SPAN(err.msg || err.message || JSON.stringify(err))),
            DIV(
              { style: "padding-top: 5px;" },
              STRONG("Recommended Actions"),
              this.getSuggestions(err)
            ),
            DIV(
              { style: "padding-top: 5px;" },
              STRONG("Need help?"),
              DIV("Contact us at support@distill.io")
            )
          ).outerHTML;
        }
      }).click(function(e) {
        e.preventDefault();
      });
    } else {
      this.$el.append(
        SPAN(formatTime(attrs.ts))
      );
    }
    return this;
  },
  getSuggestions: function(err) {
    switch (err.code || "NA") {
      case "SELECTION_EMPTY":
        return UL(
          { "style": "padding-left:14px;" },
          LI("Ensure that selected elements has text content."),
          LI("If website needs login, make sure that you are logged in.")
        );
      case "TIMEOUT":
      case "ENOTFOUND":
      case "EREQUEST":
      case "ETIMEDOUT":
      case "ECONNREFUSED":
        return DIV("Please ensure that the webpage is accessible.");
      case "JAVASCRIPT":
        return DIV("Ensure that JavaScript is working in the page.");
      default:
        if (err.status === 0) {
          return DIV("Ensure that internet connection is working.");
        }
        return DIV("There is no information about this error.");
    }
  }
});
const Works$1 = View.Collection.extend({
  name: "Works",
  postInit: function() {
    this.sieve = this.collection.sieve;
    this.collection.fetch();
    this.collection.on("sync", this.onSync);
  },
  addOne: function(model) {
    const view = new Work$1({
      model,
      parent: this,
      sieve: this.sieve
    });
    this.$msg.empty();
    this.$list.append(view.render().el);
    return view;
  },
  onSync: function() {
    if (this.collection.length == 0) {
      if (this.sieve.get("client_id") == App.clients.defaultId) {
        this.$msg.text(TXT("m_log_na"));
      } else {
        this.$msg.text(TXT("Log for this monitor will be available on device that runs this monitor"));
      }
    }
  },
  renderBase: function() {
    this.$msg = $$1(DIV(TXT("l_loading")));
    this.$list = $$1(DIV());
    this.$el.append(this.$msg, this.$list);
  }
});
var SieveRow$1 = View.Base.extend({
  name: "SieveRow",
  className: "xitem",
  tagName: "tr",
  events: {
    "click :checkbox": "event_check"
  },
  event_check: function() {
    this.model.prop("select", this.$("input[type=checkbox]:checked").length > 0);
  },
  onSelect: function(selected) {
    this.$el[selected ? "addClass" : "removeClass"]("active");
  },
  postInit: function(options) {
    const model = this.model;
    const id2 = model.id;
    this.listenTo(model, "change", this.renderRow);
    this.listenTo(model, "destroy", this.remove);
    this.listenTo(model, "remove", this.remove);
    this.listenTo(model, "sync", this.onSync);
    this.listenTo(model, "prop:select", this.onSelect);
    this.elDetail = TR(TD({ colspan: 8 }));
    this.listenTo(instance$5s, "sieves:" + id2, this.onSieveUpdate);
    this.listenTo(instance$5s, "sieves:run_state:" + id2, this.onSieveRunState);
    this.listenTo(instance$5s, "sieves:on_demand_run_status:" + id2, this.onSieveRunState);
  },
  reattach: function() {
    const parentNode = this.el.parentNode;
    parentNode && parentNode.removeChild(this.el);
    parentNode && parentNode.appendChild(this.el);
    if (this.elDetail.parentNode) {
      parentNode.removeChild(this.elDetail);
      parentNode.appendChild(this.elDetail);
    }
  },
  isSelected: function() {
    return this.model.prop("select");
  },
  onSieveRunState: function(e) {
    this.runState = e.state || e.doc.state || 0;
    this.renderRow();
  },
  onSieveUpdate: function(e) {
    if (e.doc) {
      this.model.set(this.model.parse(e.doc), { silent: true });
      this.model.trigger("change");
    } else {
      this.model.fetch();
    }
  },
  onSync: function() {
    this.render();
  },
  remove: function() {
    SieveRow$1.__super__.remove.call(this);
    $$1(this.elDetail).remove();
  },
  removeDetail: function() {
    this.$el.removeClass("active");
    this.detail && this.detail.remove();
    $$1(this.elDetail).remove();
    this.setSelected(false);
    delete this.detail;
  },
  render: function() {
    this.renderRow();
    this.detail && this.showDetail(this.detail);
    this.setSelected(this.isSelected());
    return this;
  },
  renderRow: function() {
    let { runState } = this;
    let url = this.model.attributes.uri;
    let host = "";
    try {
      host = "//" + new URL(url).host;
    } catch (e) {
    }
    const renderRowTemplate = (model) => html`
      <td data-action = 'void 0'>
        <label class='xtd xdata xaction'>
          <input type="checkbox" style='margin:0;vertical-align:middle;'>
        </label>
      </td>
      <td data-action = 'void 0'>
        <button class='xtd xbtn xaction' style='margin: 0;' data-action= 'sieve context menu' data-action-param= '$parents [data-id]@data-id'>
          <i class="fa fa-caret-down"></i>
        </button>
      </td>
      <td>
        <a @click=${(e) => model.markRead()}
          class='xtd xdata monitor-link' href=${model.attributes.uri || "#"}
          rel='noopener' target='_blank' title=${model.attributes.name}>
          <img width=14 src=${URL_ROOT + "/v1/getfavicon?url=" + escape(host)} loading='lazy'></img>
          ${model.attributes.name || SPRINTF("l_untitled")}
        </a>
      </td>
      <td data-action= 'sieve view' data-action-param=${model.id}>
        <div class= 'xtd xdata xaction' title= 'Click to view history'>
          <i class="xcaret fa fa-angle-double-down fa-lg"></i>
          ${model.attributes.state == C$1.STATE_DISCARD || model.attributes.state == C$1.STATE_DEL ? html`<span class= 'label label-danger xlabel xlabel-small'>Deleted</span>` : html`<span></span>`}
          <span>
            ${_$1.map(model.getTags(App.labels), (tag) => {
      return html`<span class='label label-info xlabel xlabel-small'>${tag.get("name")}</span>`;
    })}
          </span>
          <span>
          ${model.attributes.text != null ? model.attributes.text || "<" + SPRINTF("h_sieve_empty") + ">" : "<" + SPRINTF("h_sieve_new") + ">"}
          </span>
        </div>
      </td>
      <td class= ${model.attributes.schedule ? model.attributes.schedule.getFrequencyClass() : "error"}>
        <a 
          class= 'xtd xdata xaction'
          title= 'Click to edit schedule'
          data-action= 'sieve schedule menu'
          data-action-param= '$parents [data-id]@data-id'
          data-toggle= 'tooltip'>
            <small>${model.attributes.schedule ? model.attributes.schedule.getShortDisplayText() : "err: unset"}</small>
            <i class="xcaret fa fa-caret-down"></i>
        </a>
      </td>
      <td>
        <a
        class= ${"xtd xdata xaction xsieve-ts-data " + (model.attributes.err ? "xsieve-err" : "")}
        title= 'Click to view check/error log'
        data-action= 'sieve log menu'
        data-action-param= '$parents [data-id]@data-id'
        data-toggle= 'tooltip'>
          <small>${runState == C$1.RUN_STATE_WAIT ? "Waiting" : runState == C$1.RUN_STATE_WIP ? "Checking" : formatTime(model.attributes.ts_data, true) || "" || "NA"}</small>
          <i class="xcaret fa fa-caret-down"></i>
        </a>
      </td>
      <td style='padding: 0'>
        <a
        class= 'xtd xdata xaction xbtn'
        title= 'Click to edit device'
        data-action= 'sieve client menu'
        data-action-param= '$parents [data-id]@data-id'
        data-toggle= 'tooltip'
        style= 'text-align:center'>
          <i class="fa fa-lg ${App.clients.get(model.attributes.client_id) ? App.clients.get(model.attributes.client_id).getIcon() : " error fa-question"}"  style= 'margin: auto;'></i>
          <i class="xcaret fa fa-caret-down"></i>
        </a>
      </td>
      <td data-action= 'void 0' style= 'padding: 0'>
        <button
          class= ${"xtd btn btn-sm " + (model.attributes.state == C$1.STATE_READY ? "btn-success" : "btn-default") + (model.attributes.state == C$1.STATE_DISCARD ? " disabled" : "")}
          style= 'border-radius:0'
          data-action= 'sieve switch'
          data-action-param= '$parents [data-id]@data-id'
          title= 'Turn monitor ON or OFF'
          data-placement= 'left'>
          ${model.attributes.state == C$1.STATE_READY ? "ON " : "OFF"}
        </button>
      </td>
    `;
    render(renderRowTemplate(this.model), this.el);
    if (this.model.attributes._state && this.model.attributes._state != 0) {
      this.$el.addClass("xdirty").attr("title", TXT("m_sync_to_save"));
    } else {
      this.$el.removeClass("xdirty").removeAttr("title");
    }
    this.$('[data-toggle="tooltip"]').tooltip({ delay: { show: 400 } });
    if (this.model.isRead()) {
      this.$el.addClass("xfade").removeClass("xunread");
    } else {
      this.$el.addClass("xunread").removeClass("xfade");
    }
  },
  setSelected: function(selected) {
    if (this.$("input[type=checkbox]:checked").length > 0 !== selected) {
      this.$("input[type=checkbox]").prop("checked", selected);
      this.model.prop("select", selected);
    }
  },
  showDetail: function(view) {
    if (this.detail == view)
      return;
    this.listenTo(view, "remove", function() {
      if (this.detail == view) {
        delete this.detail;
        this.removeDetail();
      }
    }, this);
    this.elDetail.children[0].appendChild(view.el);
    this.detail = view;
    this.$el.addClass("active");
    this.$el.after(this.elDetail);
    view.listenTo(view, "remove", () => {
      this.model.markRead();
    });
    this.setSelected(true);
  }
});
const LogMenu$1 = View.ContextMenu.extend({
  name: "LogMenu",
  actions: {
    "log menu close": { fn: "hide" },
    "clear-error": { fn: "clear_error" }
  },
  clear_error: function() {
    const model = this.collection.get(this.id);
    model.save("err", null, {
      error: function() {
        Msg.error("e_err");
      }
    });
  },
  onSync: function() {
    this.show();
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  renderMenu: function() {
    const model = this.collection.get(this.id);
    const works = new Model$2.Works(null, { sieve: model });
    this.$el.empty().append(
      LI(
        BUTTON({
          "class": "btn xbtn-light pull-right",
          "data-action": "log menu close"
        }, I({ "class": "fa fa-times" })),
        SPAN({ style: "margin-left: 18px;" }, I(TXT("l_changed_on")))
      ),
      LI(
        { "class": "xview" },
        SPAN(formatTime(model.get("ts_data"))),
        I(TXT("l_check_log")),
        SPAN(new Works$1({
          parent: this,
          collection: works
        }).render().el)
      ),
      LI(
        { "class": model.get("err") ? "xview" : "hide" },
        A({
          "data-action": "clear-error"
        }, TXT("a_clear_error"))
      )
    );
    this.listenTo(works, "sync", this.onSync);
  }
});
const ScheduleMenu$1 = View.ContextMenu.extend({
  name: "ScheduleMenu",
  actions: {
    "schedule menu close": { fn: "hide" }
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  onScheduleChange: function(schedule) {
    const model = this.collection.get(this.id);
    Msg.start("save", "l_loading");
    model.set("schedule", schedule, { silent: true });
    model.save(null, {
      patch: true,
      silent: true,
      data: {
        schedule: JSON.stringify(schedule)
      },
      error: function() {
        Msg.stop("save", { error: "e_req" });
      },
      success: function() {
        Msg.stop("save", { info: "m_saved_schedule" });
      }
    });
  },
  renderMenu: function() {
    const model = this.collection.get(this.id).clone();
    if (!model) {
      this.$el.text("Model not found:" + this.id);
      return this;
    }
    this.editedModel = model;
    const scheduleEditor = new SieveScheduleEditor({
      model,
      parent: this
    });
    this.$el.empty().append(
      LI(
        BUTTON({
          "class": "btn xbtn-light pull-right",
          "data-action": "schedule menu close"
        }, I({ "class": "fa fa-times" })),
        SPAN({ style: "margin-left: 18px;" }, I(TXT("l_schedule")))
      ),
      LI(
        { "class": "xview" },
        scheduleEditor.render().el
      )
    );
    this.off();
    this.listenTo(model, "change:schedule", this.onScheduleChange);
    setTimeout(() => scheduleEditor.focus(), 10);
  }
});
const SieveClientMenu = View.ContextMenu.extend({
  name: "SieveClientMenu",
  actions: {
    "menu client change": {
      fn: "action_client_change"
    },
    "menu client settings": {
      fn: "action_client_settings"
    }
  },
  action_client_change: function(id2) {
    const model = this.collection.get(this.id);
    Msg.start("save", "l_loading");
    model.save("client_id", id2, {
      wait: true,
      error: function() {
        Msg.stop("save", { error: "e_req" });
      },
      success: () => {
        Msg.stop("save");
        this.hide();
      }
    });
  },
  action_client_settings: function() {
    const modal = new View.Modal({
      parent: this.getRoot(),
      title: "l_devices",
      view: new ViewClients.ClientManager({
        parent: this.getRoot(),
        collection: App.clients
      })
    });
    modal.show();
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  renderMenu: function() {
    const model = this.collection.get(this.id);
    let availableClients = model.getAccessibleClients(App.clients);
    this.$el.empty();
    this.$el.append(
      LI(
        { "class": "xview" },
        SPAN(
          TXT("a_select_device")
        )
      ),
      LI({ "class": "divider" })
    ).append(
      availableClients.map(function(client) {
        return LI(
          client.id == model.get("client_id") ? A(
            { "style": "font-weight:bold;" },
            I({ "class": "fa fa-check" }),
            " ",
            client.getInfo()
          ) : A(
            {
              "data-action": "menu client change",
              "data-action-param": client.id
            },
            I({ "class": client.getIcon() }),
            " ",
            client.getInfo()
          )
        );
      })
    ).append(
      LI({ "class": "divider" }),
      LI(
        A(
          {
            "data-action": "menu client settings"
          },
          I({ "class": "fa fa-edit" }),
          " ",
          TXT("a_edit")
        )
      )
    );
  }
});
const SieveContextMenu$1 = View.ContextMenu.extend({
  name: "SieveContextMenu",
  actions: {
    "menu check changes": {
      fn: "action_check_for_changes"
    },
    "menu del": {
      fn: "action_del"
    },
    "menu del permanent": {
      fn: "action_del_permanent"
    },
    "menu duplicate": {
      fn: "action_duplicate"
    },
    "menu edit": {
      fn: "action_edit"
    },
    "menu_create_tpl": {
      fn: "action_create_tpl"
    }
  },
  action_check_for_changes: async function() {
    const model = this.collection.get(this.id);
    const ids = [this.id];
    if (model.isDeviceWeb()) {
      Msg.info("m_check_local_only");
    } else {
      serviceProxy.service.checkNow(ids);
    }
    this.hide();
    if (!await serviceProxy.isActive()) {
      Msg.error("m_checks_paused");
    }
  },
  action_create_tpl: function() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/tpls/add-from/${this.id}.id`);
    this.hide();
  },
  action_del: function() {
    const model = this.collection.get(this.id);
    Msg.start("discard", "l_loading");
    model.save("state", C$1.STATE_DISCARD, {
      patch: true,
      error: function() {
        Msg.stop("discard", { error: "e_req" });
      },
      success: () => {
        model.collection.remove(model);
        Msg.stop("discard");
        this.hide();
      }
    });
  },
  action_duplicate: function() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/sieve/dup/${this.id}.id`);
    this.hide();
  },
  action_del_permanent: function() {
    const model = this.collection.get(this.id);
    Msg.start("destroy", "l_loading");
    model.destroy({
      error: () => {
        Msg.stop("destroy", { error: "e_req" });
      },
      success: () => {
        Msg.stop("destroy");
        this.hide();
      }
    });
  },
  action_edit: function() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/sieve/edit/${this.id}.id`);
    this.hide();
  },
  onActionAdd: function(model) {
    if (model.id)
      return;
    Msg.start("save", "m_saving");
    model.save(null, {
      error: () => {
        Msg.stop("save", { error: "e_req" });
      },
      success: () => {
        Msg.stop("save", { info: "m_saved_action" });
      }
    });
  },
  onActionChange: function(model) {
    if (!model.id) {
      const data = model.changed;
      model.once("sync", () => {
        model.set(data);
      }, this);
    } else {
      Msg.start("save", "m_saving");
      model.save(null, {
        silent: true,
        error: () => {
          Msg.stop("save", { error: "e_req" });
        },
        success: () => {
          Msg.stop("save", { info: "m_saved_action" });
        }
      });
    }
  },
  onActionRemove: function(model) {
    if (!model.id)
      return;
    Msg.start("save", "m_saving");
    model.destroy({
      error: () => {
        Msg.stop("save", { error: "e_req" });
      },
      success: () => {
        Msg.stop("save", { info: "m_deleted_action" });
      }
    });
  },
  postInit: function(options) {
    this.collection = this.options.collection;
  },
  renderMenu: function() {
    const model = this.collection.get(this.id);
    const actions = new Model$2.SieveActions(null, { parent: model });
    if (!model) {
      this.$el.text("Model not found:" + this.id);
      return this;
    }
    actions.fetch({ data: { state: 0 } });
    this.actionEditor = new SieveActionsEditor({
      actions,
      sieve: model,
      parent: this
    });
    this.$el.empty();
    if (Supports.agents.local) {
      this.$el.append(
        LI(A({ "data-action": "menu check changes" }, TXT("a_check_changes")))
      );
    }
    this.$el.append(
      LI(A({ "data-action": "menu edit" }, TXT("a_edit_options"))),
      LI(A({ "data-action": "menu duplicate" }, TXT("a_duplicate"))),
      LI(A({ "data-action": "menu_create_tpl" }, SPRINTF("a_action_object", "a_create", "l_tpl"))),
      LI({ "class": "divider" }),
      LI(
        { "class": "xview" },
        this.actionEditor.render().el
      ),
      LI({ "class": "divider" }),
      LI(A({ "data-action": "menu del" }, TXT("a_move_to_trash"))),
      LI(A({ "data-action": "menu del permanent" }, TXT("a_del_permanent")))
    );
    this.listenTo(this.actionEditor.models, "add", this.onActionAdd);
    this.listenTo(this.actionEditor.models, "change", this.onActionChange);
    this.listenTo(this.actionEditor.models, "remove", this.onActionRemove);
  }
});
const SievesListMenu = View.ContextMenu.extend({
  name: "SievesListMenu",
  renderMenu: function() {
    this.$el.empty().append(
      LI(
        { "class": "xview" },
        DIV(
          LABEL(TXT("l_sort_by"), ": "),
          this.selSort = SELECT(
            { "class": "pull-right" },
            OPTION({ value: "-ts_data" }, TXT("l_time_changed_on")),
            OPTION({ value: "name" }, TXT("l_name")),
            OPTION({ value: "client_id" }, TXT("l_device"))
          )
        )
      ),
      LI(
        { "class": "xview" },
        DIV(
          LABEL(TXT("l_page_size"), ": "),
          this.selPageSize = SELECT(
            { "class": "pull-right" },
            OPTION({ value: 5 }, 5),
            OPTION({ value: 20 }, 20),
            OPTION({ value: 50 }, 50),
            OPTION({ value: 100 }, 100),
            OPTION({ value: 200 }, "200!!"),
            OPTION({ value: 500 }, "500!!!")
          )
        )
      ),
      LI(
        { "class": "xview" },
        DIV(
          LABEL(TXT("l_device_filter"), ": "),
          this.selClientFilter = SELECT(
            { "class": "pull-right" },
            OPTION({ value: 1 }, TXT("l_devices_all")),
            OPTION({ value: 2 }, TXT("l_device_this"))
          )
        )
      )
    );
    this.selSort.value = App.store.get("ui.list.sortby") || "-ts_data";
    this.selPageSize.value = App.store.get("ui.list.pagesize") || "50";
    this.selClientFilter.value = App.store.get("ui.list.clientfilter") || "1";
    $$1(this.selSort).change(() => {
      App.store.set("ui.list.sortby", this.selSort.value);
      this.parent.reload();
    });
    $$1(this.selPageSize).change(() => {
      const size2 = parseInt(this.selPageSize.value);
      App.store.set("ui.list.pagesize", size2);
      this.parent.reload(true);
    });
    $$1(this.selClientFilter).change(() => {
      App.store.set("ui.list.clientfilter", this.selClientFilter.value);
      this.parent.reload(true);
    });
  }
});
const SievesPageMenu = View.ContextMenu.extend({
  name: "SievesPageMenu",
  actions: {
    "menu topage": { fn: "action_topage" }
  },
  action_topage: function(n) {
    this.parent.navToPage(parseInt(n));
    this.hide();
  },
  renderMenu: function() {
    const { limit, nPages, total_count } = this.parent.collection.info();
    this.$el.empty().append(
      _$1.map(_$1.range(0, nPages), function(n) {
        return LI(
          A(
            {
              "data-action": "menu topage",
              "data-action-param": n
            },
            n * limit + 1 + " - " + Math.min((n + 1) * limit, total_count)
          )
        );
      })
    ).css({
      maxHeight: 600,
      overflowY: "auto",
      fontSize: ".8em"
    });
  }
});
var Sieves = View.Entities.extend({
  name: "Sieves",
  actions: {
    "action_be_action_add": { fn: "action_be_action_add" },
    "action_be_action_remove": { fn: "action_be_action_remove" },
    "action_be_config": { fn: "action_be_config" },
    "action_be_device": { fn: "action_be_device" },
    "action_be_schedule": { fn: "action_be_schedule" },
    "action_be_switch_on": { fn: "action_be_switch_on" },
    "action_be_switch_off": { fn: "action_be_switch_off" },
    "action_global_actions": { fn: "action_global_actions" },
    "action_global_rules": { fn: "action_global_rules" },
    "sieve c4c": { fn: "action_check_for_changes" },
    "sieve client menu": { fn: "action_client_menu" },
    "sieve context menu": { fn: "action_context_menu" },
    "sieve del": { fn: "action_del" },
    "sieve del permanent": { fn: "action_del_permanent" },
    "sieve label apply": { fn: "action_apply_label" },
    "sieve list menu": { fn: "action_list_menu" },
    "sieve log menu": { fn: "action_log_menu" },
    "sieve mark_read": { fn: "action_mark_read" },
    "sieve mark_unread": { fn: "action_mark_unread" },
    "sieve nav next": { fn: "action_next" },
    "sieve nav prev": { fn: "action_prev" },
    "sieve nav topage menu": { fn: "action_topage_menu" },
    "sieve restore": { fn: "action_restore" },
    "sieve schedule menu": { fn: "action_schedule_menu" },
    "sieve select all": { fn: "action_select_all" },
    "sieve select none": { fn: "action_select_none" },
    "sieve select read": { fn: "action_select_read" },
    "sieve select unread": { fn: "action_select_unread" },
    "sieve switch": { fn: "action_switch_on_off" },
    "sieve sync": { fn: "action_sync" },
    "sieve view": { fn: "action_view", doc: "View sieve details" }
  },
  reloadImmediately: true,
  syncState: {
    syncing: false
  },
  events: {
    "click .xselect-all": "event_check"
  },
  action_apply_label: function(id2, target) {
    const models = this.getSelectedModels();
    Msg.info("l_loading");
    async$1.eachSeries(models, function(model, callback) {
      let tags = model.get("tags");
      if (tags) {
        if (tags.indexOf(id2) >= 0) {
          return callback();
        }
        tags += "," + id2;
      } else {
        tags = id2;
      }
      model.save("tags", tags, {
        patch: true,
        error: function() {
          callback("e_req");
        },
        success: function() {
          callback();
        }
      });
    }, function(err) {
      if (err) {
        Msg.error("e_req");
      } else {
        Msg.reset();
      }
    });
  },
  action_be_action_add: function() {
    const sieve = new Backbone$1.Model();
    const actions = new Model$2.SieveActions(null, { parent: sieve });
    const actionEditor = new SieveActionsEditor({
      actions,
      sieve,
      parent: this
    }).render();
    const modal = new View.SaveDiscardModal({
      name: "BatchEdit$ActionAddModal",
      parent: this,
      title: "Add Actions - Batch Editor",
      view: actionEditor
    });
    modal.on("save", async () => {
      const ids = this.getSelectedIds();
      const actions2 = actionEditor.getPosts();
      try {
        for (let i2 = 0; i2 < actions2.length; i2 += 1) {
          const doc = actions2[i2].toJSON();
          await Api.api("/batch/sieves/actions", "POST", { ...doc, ids });
        }
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.on("discard", function() {
      modal.remove();
    });
    modal.show();
    setTimeout(() => actionEditor.$(".dropdown-toggle").click(), 10);
  },
  action_be_action_remove: function() {
    const modal = new View.PromptModal({
      name: "BatchEdit$ActionRemoveModal",
      parent: this.getRoot(),
      title: "Remove Actions - Batch Edit",
      a_save: "Remove",
      msg: "This action will remove all actions for selected monitors. Remove all actions?"
    });
    modal.on("save", async () => {
      const ids = this.getSelectedIds();
      try {
        await Api.api("/batch/sieves/actions", "PUT", { ids, state: C$1.STATE_DEL });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.show();
  },
  action_be_config: function() {
    const selectedModels = this.getSelectedModels();
    const model = new Model$2.Sieve({
      content_type: C$1.TYPE_HTML,
      config: selectedModels[0].get("config").clone(),
      uri: selectedModels[0].get("uri")
    });
    openConfigEditor(model, "Config - Batch Edit", async (modal) => {
      Msg.info("l_loading");
      modal.remove();
      const ids = this.getSelectedIds();
      const config = model.toJSON().config;
      try {
        await Api.api("/batch/sieves", "PUT", { ids, config });
        Msg.reset();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
  },
  action_be_device: function() {
    const selectedModels = this.getSelectedModels();
    if (selectedModels.length == 0) {
      return;
    }
    const modelOne = selectedModels[0];
    const model = new Model$2.Sieve({
      content_type: C$1.TYPE_HTML,
      client_id: modelOne.get("client_id")
    });
    const clientSelector = new ViewClients.ClientSelector({ model });
    const view = new View.Base({
      el: DIV({ style: "margin: 5px;" }, clientSelector.el)
    });
    const modal = new View.SaveDiscardModal({
      name: "BatchEdit$Device",
      parent: this,
      title: "Device - Batch Editor",
      view
    });
    modal.on("save", async () => {
      try {
        const ids = this.getSelectedIds();
        const client_id = model.get("client_id");
        const proxy_id = model.get("proxy_id");
        const session_id = model.get("session_id");
        await Api.api("/batch/sieves", "PUT", { ids, client_id, proxy_id, session_id });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.on("discard", function() {
      modal.remove();
    });
    modal.show();
  },
  action_be_schedule: function() {
    const model = new Backbone$1.Model({ schedule: new Model$2.Schedule() });
    const scheduleEditor = new SieveScheduleEditor({
      model,
      parent: this
    }).render();
    const modal = new View.SaveDiscardModal({
      name: "BatchEdit$ActionAddModal",
      parent: this,
      title: "Schedule - Batch Editor",
      view: scheduleEditor
    });
    modal.on("save", async () => {
      const ids = this.getSelectedIds();
      const schedule = model.toJSON().schedule;
      try {
        await Api.api("/batch/sieves", "PUT", { ids, schedule });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.on("discard", function() {
      modal.remove();
    });
    modal.show();
  },
  action_be_switch_on: function() {
    const ids = this.getSelectedIds();
    const modal = new View.PromptModal({
      name: "BatchEdit$ActionRemoveModal",
      parent: this.getRoot(),
      title: "Switch On Monitors - Batch Edit",
      a_save: "Switch ON",
      msg: `${ids.length} monitors will be switched ON.`
    });
    modal.on("save", async () => {
      try {
        await Api.api("/batch/sieves", "PUT", { ids, state: C$1.STATE_READY });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.show();
  },
  action_be_switch_off: function() {
    const ids = this.getSelectedIds();
    const modal = new View.PromptModal({
      name: "BatchEdit$ActionRemoveModal",
      parent: this.getRoot(),
      title: "Switch Off Monitors - Batch Edit",
      a_save: "Switch OFF",
      msg: `${ids.length} monitors will be switched OFF.`
    });
    modal.on("save", async () => {
      try {
        await Api.api("/batch/sieves", "PUT", { ids, state: C$1.STATE_PAUSED });
        modal.remove();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    });
    modal.show();
  },
  action_global_actions: function() {
    showGlobalActionEditor();
  },
  action_global_rules: function() {
    showGlobalRuleEditor();
  },
  action_run_cloud_sieves: async function(models) {
    Msg.info("l_loading");
    const cloudIds = _$1.pluck(_$1.filter(models, function(model) {
      return model.isDeviceWeb();
    }), "id");
    if (cloudIds.length > 0) {
      try {
        await Api.utils("/sieve/run", "POST", { ids: cloudIds });
        Msg.info("m_started_check_for_changes");
      } catch (err) {
        console.error("Could not check for changes", err);
        Msg.error("m_check_for_changes_failed");
      }
    }
  },
  action_check_for_changes: async function(target) {
    const models = this.getSelectedModels();
    if (!Supports.agents.local) {
      this.action_run_cloud_sieves(models);
      return;
    }
    const ids = _$1.pluck(_$1.filter(models, (model) => model.isDeviceWeb()), "id");
    serviceProxy.service.checkNow(ids);
    if (models.length > ids.length) {
      Msg.info("m_check_local_only");
    }
    if (!await serviceProxy.isActive()) {
      Msg.error("m_checks_paused");
    }
  },
  action_client_menu: function(id2, target) {
    this.clientMenu || (this.clientMenu = new SieveClientMenu({
      parent: this,
      collection: this.collection
    }));
    this.clientMenu.toggle(id2, target.nodeName == "I" ? target.parentNode : target);
  },
  action_context_menu: function(id2, target) {
    this.contextMenu || (this.contextMenu = new SieveContextMenu$1({
      parent: this,
      collection: this.collection
    }));
    this.contextMenu.toggle(
      id2,
      target.nodeName == "I" ? target.parentNode : target
    );
  },
  action_del: function() {
    const models = this.getSelectedModels();
    async$1.map(models, (model, callback) => {
      model.save("state", C$1.STATE_DISCARD, {
        patch: true,
        error: function() {
          callback(new Error("sieve:del:err"));
        },
        success: function() {
          model.collection.remove(model);
          callback();
        }
      });
    }, (err) => {
      if (err) {
        Msg.error("sieve:del:err");
      } else {
        const value = models.length;
        const msg = i18n.translate("m_del_item").ifPlural(value, TXT("m_del_items")).fetch(value);
        Msg.info(msg);
      }
    });
    return true;
  },
  action_del_permanent: function() {
    const models = this.getSelectedModels();
    async$1.eachLimit(models, 5, function(model, callback) {
      model.destroy({
        error: function() {
          callback(new Error("sieve:del:err"));
        },
        success: function() {
          callback();
        }
      });
    }, (err) => {
      if (err) {
        Msg.error("sieve:del:err");
      } else {
        Msg.info("Permanently deleted selected items.");
      }
    });
  },
  action_list_menu: function(param, target) {
    this.listMenu || (this.listMenu = new SievesListMenu({
      parent: this
    }));
    this.listMenu.toggle("list", $$1(target).parent(".btn-group")[0]);
  },
  action_log_menu: function(id2, target) {
    this.logMenu || (this.logMenu = new LogMenu$1({
      parent: this,
      collection: this.collection
    }));
    this.logMenu.toggle(id2, target ? target : this.getRow(id2).$el.find(".xsieve-ts-data")[0]);
  },
  action_mark_read: function() {
    const models = this.getSelectedModels();
    async$1.map(models, function(model, callback) {
      model.save({
        ts_view: dateToDBFormat(Date.now())
      }, {
        patch: true,
        error: function() {
          callback(new Error("sieve:update:err"));
        },
        success: function() {
          callback();
        }
      });
    }, function(err) {
      if (err) {
        Msg.error("sieve:update:err");
      }
    });
  },
  action_mark_unread: async function() {
    const models = this.getSelectedModels();
    for (let i2 = 0; i2 < models.length; i2 += 1) {
      let model = models[i2], ts_view = dateToDBFormat(0);
      await Api.api(`/sieves/${model.id}`, "PATCH", { ts_view });
      model.set({ ts_view });
    }
  },
  action_next: function() {
    let { currentPage, nPages } = this.collection.info();
    if (currentPage >= nPages - 1)
      return;
    this.navToPage(currentPage + 1);
  },
  action_prev: function() {
    let { currentPage } = this.collection.info();
    if (currentPage == 0)
      return;
    this.navToPage(currentPage - 1);
  },
  action_topage_menu: function(param, target) {
    this.pageMenu || (this.pageMenu = new SievesPageMenu({
      parent: this
    }));
    this.pageMenu.toggle("list", target);
  },
  action_restore: async function() {
    const models = this.getSelectedModels();
    let sieveConstraint = {};
    try {
      sieveConstraint = await checkSieveConstraint(models.length);
    } catch (e) {
      console.error(e);
      sieveConstraint = {
        isOverLimit: false
      };
    }
    if (sieveConstraint.isOverLimit) {
      Msg.error("m_monitor_limit");
      return;
    }
    async$1.map(models, function(model, callback) {
      model.save("state", C$1.STATE_READY, {
        patch: true,
        error: function() {
          callback(new Error("sieve:restore:err"));
        },
        success: function() {
          model.collection.remove(model);
          callback();
        }
      });
    }, (err) => {
      if (err) {
        Msg.error("sieve:restore:err");
      } else {
        Msg.info("m_restored_from_trash");
      }
    });
  },
  action_schedule_menu: function(id2, target) {
    this.scheduleMenu || (this.scheduleMenu = new ScheduleMenu$1({
      parent: this,
      collection: this.collection
    }));
    this.scheduleMenu.toggle(id2, target);
  },
  action_select_all: function() {
    this._select(_$1.identity, true);
  },
  action_select_none: function() {
    this._select(_$1.identity, false);
  },
  action_select_read: function() {
    this.action_select_none();
    this._select(function(view) {
      return view.model.isRead();
    }, true);
  },
  action_select_unread: function() {
    this.action_select_none();
    this._select(function(view) {
      return !view.model.isRead();
    }, true);
  },
  action_switch_on_off: function(id2) {
    const model = this.collection.get(id2);
    const state = model.get("state");
    const toggledState = state == C$1.STATE_READY ? C$1.STATE_PAUSED : C$1.STATE_READY;
    Msg.start("sieve:save", { info: "l_saving" });
    model.save(null, {
      data: { state: toggledState },
      patch: true,
      err: function(err, res) {
        Msg.stop("sieve:save", { error: "e_req" });
      },
      success: function() {
        Msg.stop("sieve:save");
        model.set("state", toggledState);
      }
    });
  },
  action_sync: async function() {
    if (!Supports.agents.local)
      return;
    Msg.info("l_syncing");
    let complete = false;
    try {
      await serviceProxy.SyncMan.sync(true);
      complete = true;
      Msg.reset();
    } catch (err) {
      console.error(JSON.stringify(err));
      try {
        complete = true;
        await serviceProxy.service.initSync();
      } catch (err2) {
        console.error(JSON.stringify(err2));
        Msg.error(err2.msg || err2.message || JSON.stringify(err2));
      }
    }
    setTimeout(function() {
      if (!complete) {
        Msg.info("l_syncing_wait");
      }
    }, 5e3);
  },
  action_view: function(id2) {
    let base2 = this._getBasePath();
    let path = base2;
    if (!this.modelView || this.modelView.model.id != id2) {
      path += `${id2}.id`;
    }
    let queryStr = qs.stringify(this.route.query);
    if (queryStr.length > 0) {
      path += `?${queryStr}`;
    }
    push$1(path);
  },
  event_check: function(e) {
    this._select(_$1.identity, e.target.checked);
  },
  _getBasePath() {
    let { module, team, prefix, data } = this.route;
    let base2 = `/w/${team}/${module}/${prefix}/`;
    if (data) {
      base2 = base2 + `${data}.d/`;
    }
    return base2;
  },
  _select: function(selector, selected) {
    _$1.each(this.views, function(view) {
      if (selector(view)) {
        view.setSelected(selected);
      }
    });
  },
  addOne: function(model, top) {
    if (!this.$list)
      return;
    const view = new SieveRow$1({ model, parent: this });
    const modelIndex = this.collection.indexOf(model);
    this.$list[top === true || modelIndex == 0 ? "prepend" : "append"](view.render().el);
    return view;
  },
  close_edit: function() {
    this.optsPanel.remove();
    this.opts = null;
  },
  recentFetchAndShow: function(id2) {
    const tsModMax = this.collection.length > 0 ? this.collection.max(
      (model) => new Date(model.get("ts_mod")).valueOf()
    ).get("ts_mod") : new Date(0).toISOString();
    const tCollection = new Model$2.Sieves();
    Msg.start("fetch", { info: "l_loading" });
    tCollection.fetch({
      data: _$1.extend({
        "ts_mod.gt": tsModMax,
        "_opt": {}
      }, getQuery(this.route)),
      success: () => {
        Msg.stop("fetch");
        this.collection.add(tCollection["models"], { merge: true, at: 0 });
      }
    });
  },
  async fetchAndShow(route2, force = false) {
    const limit = App.store.get("ui.list.pagesize") || 50;
    let oldRoute = this.route;
    let routeKeys = ["team", "prefix", "data", "query"];
    let reloadList = force || !oldRoute || routeKeys.filter((key) => !_$1.isEqual(route2[key], oldRoute[key])).length > 0;
    this.route = { ...route2 };
    if (reloadList) {
      Msg.start("fetch", { info: "l_loading" });
      this.collection.limit = limit;
      let currentPage = parseInt(route2.query.page || "1") - 1;
      await this.collection.goto(currentPage, {
        sort: false,
        data: _$1.extend({
          _opt: {
            order: [this.getSortField()],
            limit,
            "a": "a"
          }
        }, getQuery(this.route)),
        success: (collection, resp, options) => {
          _$1.each(options.previousModels, function(model) {
            model.trigger("remove");
          });
        }
      });
      Msg.stop("fetch");
      this.onSelectionChange();
      if (this.collection.length == 0) {
        this.renderEmpty();
      } else {
        this.removeEmpty();
      }
      this.el.scrollIntoView();
    }
    if (route2.id) {
      this.show(route2.id);
    } else {
      this.removeModelView();
    }
  },
  reload(resetCurrentPage) {
    if (resetCurrentPage && this.route.query.page > 1) {
      push$1(this._getBasePath());
    } else {
      this.fetchAndShow(this.route, true);
    }
  },
  getRow: function(id2) {
    return _$1.find(this.views, function(view) {
      return view.model.id == id2;
    });
  },
  getSelectedIds: function() {
    return _$1.chain(this.children).select(function(child) {
      return child.isSelected && child.isSelected();
    }).map(function(child) {
      return child.model.id;
    }).value();
  },
  getSelectedModels: function() {
    return _$1.chain(this.children).select((child) => {
      return child.isSelected && child.isSelected();
    }).map((child) => {
      return this.collection.get(child.model.id);
    }).value();
  },
  getSortField: function() {
    const field = App.store.get("ui.list.sortby") || "-ts_data";
    this.collection.sortField = field;
    if (field == "name" && Supports.agents.local) {
      return "name nocase";
    }
    return field;
  },
  navToPage: function(n) {
    let base2 = this._getBasePath();
    if (n == 0 || !n) {
      let query = { ...this.route.query };
      delete query.page;
      let queryStr = qs.stringify(query);
      push$1(`${base2}?${queryStr}`);
    } else {
      let query = qs.stringify({ ...this.route.query, page: n + 1 });
      push$1(`${base2}?${query}`);
    }
  },
  onUserStateChange: function(data) {
    const oldError = this.errorUnreadModel.get("error");
    const oldUnread = this.errorUnreadModel.get("unread");
    const { error: error2, unread, sync } = data;
    this.errorUnreadModel.set(data);
    let { currentPage } = this.collection.info();
    if (oldError < error2 && this.route.prefix == "error" && currentPage == 0) {
      this.recentFetchAndShow();
    }
    if (oldUnread < unread && this.route.prefix == "unread" && currentPage == 0) {
      this.recentFetchAndShow();
    }
    sync && this.onSyncStateUpdate(sync);
  },
  onSyncStateUpdate(sync) {
    this.syncState = sync;
    setTimeout(() => {
      const cl = this.elRefreshButton.children[0].classList;
      if (this.syncState.syncing && !cl.contains("fa-spin")) {
        cl.add("fa-spin");
      } else {
        cl.remove("fa-spin");
      }
    }, 200);
  },
  onSelectionChange: function() {
    const n = this.getSelectedModels().length;
    if (n > 0) {
      $$1(this.elTbar).addClass("xselected");
    } else {
      $$1(this.elTbar).removeClass("xselected");
    }
  },
  onSieveInsertDebounced: _$1.debounce(function() {
    this.reload();
    this.reloadImmediately = true;
  }, 2 * 1e3),
  onSieveInsert(e) {
    if (this.reloadImmediately) {
      this.reload();
      this.reloadImmediately = false;
    } else {
      this.onSieveInsertDebounced();
    }
  },
  onSieveUpdate: function(e) {
    if (e.op == "I") {
      if (!this.collection.get(e.id)) {
        this.onSieveInsert();
      }
    }
  },
  onSort: function() {
    const newKeys = this.collection.pluck("id");
    const oldKeys = _$1.keys(this.views);
    if (!_$1.isEqual(newKeys, oldKeys)) {
      this.collection.each(function(model) {
        const view = this.views[model.id];
        view.reattach();
      }, this);
    }
  },
  postInit: function(options) {
    this.listenTo(this.collection, "sort", this.onSort);
    this.listenTo(this.collection, "sync", this.updatePageInfo);
    this.listenTo(this.collection, "prop:select", this.onSelectionChange);
    this.route = {};
    this.clients = options.clients;
    this.labels = options.labels;
    this.labels.on("add", this.labelAddOne);
    this.labels.on("remove", this.labelRemoveOne);
    this.labels.on("reset", this.labelReset);
    this.listenTo(instance$5s, "sieves", this.onSieveUpdate);
    this.errorUnreadModel = new Backbone$1.Model();
    this.listenTo(instance$5s, "user_states", this.onUserStateChange);
  },
  removeOne: function(model) {
    View.Entities.prototype.removeOne.call(this, model);
    if (this.model && this.model.id == model.id) {
      this.removeModelView();
    }
    model.trigger("remove");
  },
  renderBase: function() {
    params.subscribe(this.renderTBar);
    let list;
    let empty2;
    this.$el.append(
      this.renderTBar(),
      TABLE(
        { "class": "xlist", "cellpadding": 0, style: "box-shadow: 3px 3px 3px #ccc" },
        COLGROUP(
          COL({ style: "width:28px" }),
          COL({ style: "width:28px" }),
          COL({ style: "width:304px; padding: 0 10px;" }),
          COL({ style: "" }),
          COL({ style: "width:72px; padding: 0 10px;" }),
          COL({ style: "width:72px" }),
          COL({ style: "width:42px" }),
          COL({ style: "width:40px" })
        ),
        list = TBODY()
      ),
      empty2 = DIV()
    );
    this.$empty = $$1(empty2);
    this.$list = $$1(list);
  },
  renderTBar() {
    let $params = get_store_value(params) || {};
    let team = $params.team;
    let elExport;
    const labelList = UL({
      "class": "dropdown-menu",
      "style": "overflow-y:auto;max-height:" + ($$1(window).height() - 120) + "px"
    });
    let route2 = this.route;
    let isLocal = Supports.agents.local;
    let elTbar = DIV(
      {
        "class": "xtbar xvbar-margin xalt" + (isLocal ? " xlocal" : ""),
        context: (route2 && route2.prefix) + (isLocal ? " local" : " cloud")
      },
      DIV(
        { "class": "btn-group" },
        INPUT({
          "class": "xselect-all",
          "type": "checkbox",
          "style": "margin: 0 6px 0 0;"
        }),
        BUTTON(
          {
            "type": "button",
            "class": "dropdown-toggle xbtn-light",
            "data-toggle": "dropdown"
          },
          SPAN({ "class": "caret" }),
          SPAN({ "class": "sr-only" }, "Dropdown Toggle")
        ),
        UL(
          { "class": "dropdown-menu", "role": "menu" },
          LI(A({ "href": "#", "data-action": "sieve select all" }, TXT("l_all"))),
          LI(A({ "href": "#", "data-action": "sieve select none" }, TXT("l_none"))),
          LI(A({ "href": "#", "data-action": "sieve select read" }, TXT("l_read"))),
          LI(A({ "href": "#", "data-action": "sieve select unread" }, TXT("l_unread")))
        )
      ),
      BUTTON({
        "data-action": "sieve c4c",
        "class": "btn btn-default",
        "context": "selected local notrash",
        "title": TXT("a_check_changes")
      }, I({ "class": "im-run" })),
      BUTTON({
        "data-action": "sieve restore",
        "class": "btn btn-default",
        "context": "trash"
      }, TXT("a_restore")),
      USER.account_id ? DIV(
        {
          "class": "btn-group",
          context: "selected all notrash"
        },
        A({
          "data-action": "sieve mark_read",
          "class": "btn btn-default",
          "context": "selected all notrash",
          "title": TXT("a_mark_read")
        }, I({ "class": "fa fa-check" })),
        BUTTON({
          "class": "btn btn-default dropdown-toggle",
          "data-toggle": "dropdown",
          style: "min-width: 20px"
        }, I({ "class": "caret" })),
        UL(
          { "class": "dropdown-menu", "role": "menu" },
          LI(
            A({
              tabindex: -1,
              href: "#",
              "data-action": "sieve mark_unread"
            }, TXT("Mark as unread"))
          )
        )
      ) : BUTTON({
        "data-action": "sieve mark_read",
        "class": "btn btn-default",
        "context": "selected all notrash",
        "title": TXT("a_mark_read")
      }, I({ "class": "fa fa-check" })),
      BUTTON({
        "data-action": "sieve del",
        "class": "btn btn-default",
        "context": "selected all notrash",
        "title": TXT("a_move_to_trash")
      }, I({ "class": "im-trash" })),
      BUTTON({
        "data-action": "sieve del permanent",
        "class": "btn btn-default",
        "context": "trash"
      }, TXT("a_del_permanent")),
      DIV(
        {
          "class": "btn-group",
          "context": "selected all notrash",
          "title": TXT("l_label")
        },
        BUTTON(
          { "class": "btn btn-default dropdown-toggle", "data-toggle": "dropdown" },
          I({ "class": "fa fa-tags" }),
          " ",
          SPAN({ "class": "caret" })
        ),
        labelList
      ),
      this.elRefreshButton = BUTTON(
        {
          "class": "btn btn-default",
          "context": "all nocloud",
          "data-action": "sieve sync",
          "title": TXT("l_sync")
        },
        I({ "class": "fa fa-refresh }" })
      ),
      DIV(
        {
          "class": "btn-group",
          "context": "all"
        },
        BUTTON(
          { "class": "btn btn-default dropdown-toggle", "data-toggle": "dropdown" },
          I({ "class": "fa fa-bars" }),
          " ",
          SPAN({ "class": "caret" })
        ),
        UL(
          { "class": "dropdown-menu", "role": "menu" },
          LI(
            { "class": "dropdown-submenu" },
            A({ href: "javascript:void(0);" }, TXT("a_export")),
            elExport = UL(
              { "class": "dropdown-menu", "role": "menu" },
              LI(A({ href: "#/w/export/json/", "data-type": "json" }, "JSON")),
              LI(A({ href: "#/w/export/csv/", "data-type": "csv" }, "CSV"))
            )
          ),
          LI(
            { "class": "dropdown-submenu" },
            A({ href: "javascript:void(0);" }, TXT("a_import")),
            UL(
              { "class": "dropdown-menu", "role": "menu" },
              LI(A({ href: `#/w/${team}/import/json/` }, "JSON")),
              LI(A({ href: `#/w/${team}/import/csv/` }, "CSV"))
            )
          ),
          LI(A({ href: `#/w/${team}/macros/` }, TXT("Macros"))),
          LI(A({ href: `#/w/${team}/profiles/` }, TXT("Profiles"))),
          LI(A({ href: `#/w/${team}/proxies/` }, TXT("Proxies"))),
          LI(A({ href: `#/w/${team}/tpls/all/` }, TXT("l_sieve_tpl_list"))),
          LI({ "class": "divider" }),
          LI(A({ "href": "javascript:void(0);", "data-action": "action_global_actions" }, TXT("Global Actions"))),
          LI(A({ "href": "javascript:void(0);", "data-action": "action_global_rules" }, TXT("Global Conditions"))),
          ""
        )
      ),
      DIV(
        {
          "class": "btn-group mr0",
          "context": "selected all"
        },
        BUTTON(
          { "class": "btn btn-default dropdown-toggle", "data-toggle": "dropdown" },
          `${TXT("a_bulk_edit")} `,
          SPAN({ "class": "caret" })
        ),
        !USER.id ? UL(
          { "class": "dropdown-menu", "role": "menu" },
          LI(A({ "href": "/ui/settings.html#general" }, TXT("Sign in")))
        ) : UL(
          { "class": "dropdown-menu", "role": "menu" },
          LI(
            { "class": "dropdown-submenu" },
            A({ href: "#" }, "Actions"),
            UL(
              { "class": "dropdown-menu", "role": "menu" },
              LI(A({ "href": "#", "data-action": "action_be_action_add" }, "Add")),
              LI({ "class": "divider" }),
              LI(A({ "href": "#", "data-action": "action_be_action_remove", "style": "color: red" }, "Remove All"))
            )
          ),
          LI(A({ "href": "#", "data-action": "action_be_config" }, TXT("Config"))),
          LI(A({ "href": "#", "data-action": "action_be_device" }, TXT("l_device"))),
          LI(A({ "href": "#", "data-action": "action_be_schedule" }, TXT("l_schedule"))),
          LI(A({ "href": "#", "data-action": "action_be_switch_on" }, TXT("Switch ON"))),
          LI(A({ "href": "#", "data-action": "action_be_switch_off" }, TXT("Switch OFF"))),
          ""
        )
      ),
      DIV(
        { "class": "btn-group right xoptional" },
        BUTTON(
          {
            "class": "btn btn-default",
            "data-action": "sieve list menu"
          },
          I({ "class": "fa fa-cog" }),
          " ",
          SPAN({ "class": "caret" })
        )
      ),
      UL(
        { "class": "pagination pagination-sm right", "style": "margin: 0 5px 0 0" },
        LI(
          A(
            { "href": "", "data-action": "sieve nav topage menu" },
            this.pageInfo = SPAN(TXT("l_loading")),
            " ",
            I({ "class": "fa fa-caret-down" })
          )
        ),
        this.pagePrev = LI(
          A(
            { "href": "", "data-action": "sieve nav prev" },
            I({ "class": "fa fa-chevron-left" })
          )
        ),
        this.pageNext = LI(
          A(
            { "href": "", "data-action": "sieve nav next" },
            I({ "class": "fa fa-chevron-right" })
          )
        )
      )
    );
    this.$labelList = $$1(labelList);
    elExport.onclick = (e) => {
      e.preventDefault();
      let path = location.hash.slice(1);
      if (path.startsWith(`/w/${team}/export/`)) {
        return;
      }
      let { prefix, data, id: id2, query } = this.route;
      let exportQueryData = { prefix, data, id: id2, query };
      push$1(`/w/${team}/export/${e.target.dataset.type}/${qs.stringify(exportQueryData)}.d/`);
    };
    if (this.elTbar) {
      elTbar.className = this.elTbar.className;
      this.elTbar.replaceWith(elTbar);
    }
    this.elTbar = elTbar;
    this.updatePageInfo();
    this.labelReset();
    return this.elTbar;
  },
  removeEmpty: function() {
    this.$empty.empty();
  },
  renderEmpty: function() {
    App.sieves.reset();
    const isInbox = this.route.prefix == "all";
    this.$empty.empty().append(
      isInbox && !Supports.agents.local ? DIV(
        { "class": "pt-4" },
        P(
          { style: "font-size: 1em" },
          "This is webapp's Watchlist. It contains list of all monitors. ",
          "Start monitoring web by adding a monitor using the Add button. ",
          "Install Distill's browser extension to get the fastest web monitoring experience: ",
          A({ href: "https://distill.io/apps/web-monitor" }, "download extension."),
          BR(),
          A({ "class": "mt3", href: "https://distill.io/help/watchlist" }, "Learn More")
        )
      ) : H4("No monitor found.")
    );
  },
  renderModelView: function(model, view) {
    const row = this.getRow(model.id);
    row && row.showDetail(view.render());
  },
  show: function(id2) {
    if (this.model) {
      if (this.model.id == id2) {
        return;
      }
      this.removeModelView();
    }
    this.model = this.collection.get(id2);
    if (this.model) {
      return this.showModelView(this.model);
    } else {
      return this.show404();
    }
  },
  show404: function() {
    Msg.error("Monitor not found");
    return false;
  },
  showDefault: function() {
    this.removeModelView();
  },
  showModelView: function(model) {
    model.markRead();
    return Sieves.__super__.showModelView.call(this, model);
  },
  updatePageInfo: function() {
    const coll = this.collection;
    const { currentPage, offset, nPages, total_count } = coll.info();
    const { length } = coll;
    this.pageInfo.textContent = SPRINTF(
      "m_start_end_of_total",
      offset + (length > 0 ? 1 : 0),
      offset + length,
      total_count
    );
    $$1(this.pagePrev)[currentPage <= 0 ? "addClass" : "removeClass"]("disabled");
    $$1(this.pageNext)[currentPage + 1 >= nPages ? "addClass" : "removeClass"]("disabled");
  }
});
function dateToDBFormat(date) {
  return moment$1(date).format();
}
var Work_svelte_svelte_type_style_lang = "";
function create_else_block$12(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-check green");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_if_block_6$c(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-2x fa-times-circle red");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_if_block_5$i(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = `${TXT("l_no_snapshot_found")}`;
      attr(p, "class", "pa2");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_4$p(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.innerHTML = `<svg fill="#000000" width="40px" height="40px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg"><title>Play</title><path d="M5.92 24.096q0 1.088 0.928 1.728 0.512 0.288 1.088 0.288 0.448 0 0.896-0.224l16.16-8.064q0.48-0.256 0.8-0.736t0.288-1.088-0.288-1.056-0.8-0.736l-16.16-8.064q-0.448-0.224-0.896-0.224-0.544 0-1.088 0.288-0.928 0.608-0.928 1.728v16.16z"></path></svg>`;
      t1 = space();
      button1 = element("button");
      button1.textContent = "Play recording";
      attr(button0, "class", "btn btn-link");
      attr(button1, "class", "btn btn-outline-secondary");
      attr(div, "class", "playIcon svelte-cofjja");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[7]),
          listen(button1, "click", ctx[7])
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_3$D(ctx) {
  let div;
  let snapshot_1;
  let current;
  snapshot_1 = new SnapShot({
    props: {
      snapshot: ctx[3],
      sieveName: ctx[1].name
    }
  });
  snapshot_1.$on("setLoading", ctx[8]);
  return {
    c() {
      div = element("div");
      create_component(snapshot_1.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(snapshot_1, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const snapshot_1_changes = {};
      if (dirty & 8)
        snapshot_1_changes.snapshot = ctx2[3];
      if (dirty & 2)
        snapshot_1_changes.sieveName = ctx2[1].name;
      snapshot_1.$set(snapshot_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(snapshot_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(snapshot_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(snapshot_1);
    }
  };
}
function create_if_block_2$O(ctx) {
  let loader;
  let current;
  loader = new Loader({ props: { class: "absolute z-1 ma0 mr2" } });
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_if_block$1U(ctx) {
  let t;
  let workflowreplay;
  let current;
  let if_block = (ctx[2].fetchingSnapshot || ctx[6]) && create_if_block_1$1f();
  workflowreplay = new WorkflowReplay({
    props: {
      workStore: ctx[2],
      recordingUrl: ctx[3].signedUrl,
      macroSteps: ctx[3].macro_details.steps,
      updatedMacroUrl: ctx[4],
      setLoading: ctx[8]
    }
  });
  workflowreplay.$on("close", ctx[9]);
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(workflowreplay.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(workflowreplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[2].fetchingSnapshot || ctx2[6]) {
        if (if_block) {
          if (dirty & 68) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$1f();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const workflowreplay_changes = {};
      if (dirty & 4)
        workflowreplay_changes.workStore = ctx2[2];
      if (dirty & 8)
        workflowreplay_changes.recordingUrl = ctx2[3].signedUrl;
      if (dirty & 8)
        workflowreplay_changes.macroSteps = ctx2[3].macro_details.steps;
      if (dirty & 16)
        workflowreplay_changes.updatedMacroUrl = ctx2[4];
      workflowreplay.$set(workflowreplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(workflowreplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(workflowreplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      destroy_component(workflowreplay, detaching);
    }
  };
}
function create_if_block_1$1f(ctx) {
  let loader;
  let current;
  loader = new Loader({ props: { class: "absolute z-1 ma0 mr2" } });
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3l(ctx) {
  let title_value;
  let t0;
  let div13;
  let div10;
  let div9;
  let div8;
  let div0;
  let t1;
  let div7;
  let div2;
  let div1;
  let h2;
  let span0;
  let t2_value = new Date(ctx[0].get("ts")).toDateString() + "";
  let t2;
  let t3;
  let span1;
  let t4_value = new Date(ctx[0].get("ts")).toLocaleTimeString() + "";
  let t4;
  let t5;
  let t6_value = TXT("l_snapshot") + "";
  let t6;
  let t7;
  let div6;
  let div5;
  let div3;
  let label0;
  let t10;
  let span2;
  let t11_value = ctx[0].get("duration") + "";
  let t11;
  let t12;
  let t13_value = ctx[0].get("duration") > 1 ? "seconds" : "second";
  let t13;
  let t14;
  let div4;
  let label1;
  let t17;
  let a;
  let span3;
  let t18_value = ctx[2].uri + "";
  let t18;
  let a_href_value;
  let t19;
  let div12;
  let div11;
  let current_block_type_index;
  let if_block1;
  let current;
  document.title = title_value = ctx[1].get("name") + " | Check Logs";
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].err)
      return create_if_block_6$c;
    return create_else_block$12;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  const if_block_creators = [
    create_if_block$1U,
    create_if_block_2$O,
    create_if_block_3$D,
    create_if_block_4$p,
    create_if_block_5$i
  ];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    var _a, _b;
    if (ctx2[5])
      return 0;
    if (ctx2[2].fetchingSnapshot || ctx2[6])
      return 1;
    if ((_a = ctx2[3]) == null ? void 0 : _a.content)
      return 2;
    if ((_b = ctx2[3]) == null ? void 0 : _b.recording_uri)
      return 3;
    if (!ctx2[2]["snapshot_id"])
      return 4;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      t0 = space();
      div13 = element("div");
      div10 = element("div");
      div9 = element("div");
      div8 = element("div");
      div0 = element("div");
      if_block0.c();
      t1 = space();
      div7 = element("div");
      div2 = element("div");
      div1 = element("div");
      h2 = element("h2");
      span0 = element("span");
      t2 = text(t2_value);
      t3 = space();
      span1 = element("span");
      t4 = text(t4_value);
      t5 = text("\n                | ");
      t6 = text(t6_value);
      t7 = space();
      div6 = element("div");
      div5 = element("div");
      div3 = element("div");
      label0 = element("label");
      label0.textContent = `${TXT("l_duration")}:`;
      t10 = space();
      span2 = element("span");
      t11 = text(t11_value);
      t12 = space();
      t13 = text(t13_value);
      t14 = space();
      div4 = element("div");
      label1 = element("label");
      label1.textContent = `${TXT("l_url")}:`;
      t17 = space();
      a = element("a");
      span3 = element("span");
      t18 = text(t18_value);
      t19 = space();
      div12 = element("div");
      div11 = element("div");
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "mr1 mw2");
      attr(h2, "class", "card-title f3");
      attr(div2, "class", "flex");
      attr(div3, "data-id", "duration");
      attr(a, "href", a_href_value = ctx[2].uri);
      attr(a, "target", "_blank");
      attr(a, "class", "truncate");
      attr(div4, "data-id", "links");
      attr(div4, "class", "ml3");
      attr(div5, "class", "flex");
      attr(div6, "class", "f4 pt1");
      attr(div7, "class", "ml2");
      attr(div8, "class", "flex");
      set_style(div8, "align-items", "center");
      attr(div9, "class", "mt3");
      attr(div10, "class", "card-header overflow-hidden");
      attr(div11, "data-id", "snapshot");
      attr(div11, "class", "flex flex-column relative h-100");
      attr(div12, "class", "card-body pa0");
      attr(div13, "class", "card mb0 panel-default workInfo w-100 svelte-cofjja");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, div13, anchor);
      append(div13, div10);
      append(div10, div9);
      append(div9, div8);
      append(div8, div0);
      if_block0.m(div0, null);
      append(div8, t1);
      append(div8, div7);
      append(div7, div2);
      append(div2, div1);
      append(div1, h2);
      append(h2, span0);
      append(span0, t2);
      append(h2, t3);
      append(h2, span1);
      append(span1, t4);
      append(h2, t5);
      append(h2, t6);
      append(div7, t7);
      append(div7, div6);
      append(div6, div5);
      append(div5, div3);
      append(div3, label0);
      append(div3, t10);
      append(div3, span2);
      append(span2, t11);
      append(span2, t12);
      append(span2, t13);
      append(div5, t14);
      append(div5, div4);
      append(div4, label1);
      append(div4, t17);
      append(div4, a);
      append(a, span3);
      append(span3, t18);
      append(div13, t19);
      append(div13, div12);
      append(div12, div11);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div11, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 2) && title_value !== (title_value = ctx2[1].get("name") + " | Check Logs")) {
        document.title = title_value;
      }
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if ((!current || dirty & 1) && t2_value !== (t2_value = new Date(ctx2[0].get("ts")).toDateString() + ""))
        set_data(t2, t2_value);
      if ((!current || dirty & 1) && t4_value !== (t4_value = new Date(ctx2[0].get("ts")).toLocaleTimeString() + ""))
        set_data(t4, t4_value);
      if ((!current || dirty & 1) && t11_value !== (t11_value = ctx2[0].get("duration") + ""))
        set_data(t11, t11_value);
      if ((!current || dirty & 1) && t13_value !== (t13_value = ctx2[0].get("duration") > 1 ? "seconds" : "second"))
        set_data(t13, t13_value);
      if ((!current || dirty & 4) && t18_value !== (t18_value = ctx2[2].uri + ""))
        set_data(t18, t18_value);
      if (!current || dirty & 4 && a_href_value !== (a_href_value = ctx2[2].uri)) {
        attr(a, "href", a_href_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div11, null);
        } else {
          if_block1 = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div13);
      if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function instance$3h($$self, $$props, $$invalidate) {
  let $sieveStore, $$unsubscribe_sieveStore = noop$1, $$subscribe_sieveStore = () => ($$unsubscribe_sieveStore(), $$unsubscribe_sieveStore = subscribe(sieveStore, ($$value) => $$invalidate(10, $sieveStore = $$value)), sieveStore);
  let $route;
  let $workStore, $$unsubscribe_workStore = noop$1, $$subscribe_workStore = () => ($$unsubscribe_workStore(), $$unsubscribe_workStore = subscribe(workStore, ($$value) => $$invalidate(2, $workStore = $$value)), workStore);
  component_subscribe($$self, route, ($$value) => $$invalidate(11, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieveStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_workStore());
  let { workStore } = $$props;
  $$subscribe_workStore();
  let { sieveStore } = $$props;
  $$subscribe_sieveStore();
  let snapshot;
  let updatedMacroUrl;
  let playing = false;
  let loading2 = false;
  async function playRecording() {
    $$invalidate(6, loading2 = true);
    $$invalidate(5, playing = true);
    fetchUpdatedMacroUrl();
  }
  async function fetchSieveSnapshot() {
    if (snapshot) {
      return;
    }
    if (!workStore.get("err") || !workStore.get("snapshot_id")) {
      console.warn(`invalid work, ${workStore.id}, used for getting the sieve snapshot`);
      return;
    }
    await workStore.fetchScreenshot();
  }
  const setLoading = (event) => {
    $$invalidate(6, loading2 = event.detail);
  };
  fetchSieveSnapshot();
  const fetchUpdatedMacroUrl = async () => {
    if (!$sieveStore.macro_id) {
      return void 0;
    }
    const macro = new Macro$1({ id: $sieveStore.macro_id });
    await macro.fetch();
    if (snapshot.macro_details.ts_mod !== macro.get("ts_mod")) {
      $$invalidate(4, updatedMacroUrl = `/w/${$route.team}/macros?id=${$sieveStore.macro_id}`);
    }
  };
  const close_handler = () => $$invalidate(5, playing = false);
  $$self.$$set = ($$props2) => {
    if ("workStore" in $$props2)
      $$subscribe_workStore($$invalidate(0, workStore = $$props2.workStore));
    if ("sieveStore" in $$props2)
      $$subscribe_sieveStore($$invalidate(1, sieveStore = $$props2.sieveStore));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$invalidate(3, snapshot = $workStore.snapshot);
    }
  };
  return [
    workStore,
    sieveStore,
    $workStore,
    snapshot,
    updatedMacroUrl,
    playing,
    loading2,
    playRecording,
    setLoading,
    close_handler
  ];
}
class Work extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3h, create_fragment$3l, safe_not_equal, { workStore: 0, sieveStore: 1 });
  }
}
function get_each_context$U(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  child_ctx[20] = i2;
  return child_ctx;
}
function create_catch_block$x(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$x(ctx) {
  let a;
  let h3;
  let t2;
  let div7;
  let div5;
  let div4;
  let div0;
  let show_if = ctx[7].get(ctx[0]);
  let t3;
  let div3;
  let div1;
  let t5;
  let div2;
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t6;
  let div6;
  let previous_key = ctx[0];
  let current;
  let if_block = show_if && create_if_block_3$C(ctx);
  let each_value = ctx[5].models;
  const get_key = (ctx2) => ctx2[18].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$U(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$U(key, child_ctx));
  }
  let key_block = create_key_block$6(ctx);
  return {
    c() {
      a = element("a");
      h3 = element("h3");
      h3.textContent = `${ctx[6].get("name")} | Monitor`;
      t2 = space();
      div7 = element("div");
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t3 = space();
      div3 = element("div");
      div1 = element("div");
      div1.textContent = "Logs";
      t5 = space();
      div2 = element("div");
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t6 = space();
      div6 = element("div");
      key_block.c();
      attr(h3, "class", "ph3");
      attr(a, "href", urlCfg.sievePage(ctx[6].id));
      set_style(div0, "height", "35%");
      attr(div0, "class", "overflow-auto");
      attr(div1, "class", "card-header");
      attr(ul, "class", "list-group");
      attr(div2, "class", "card-body pa0 pt1 overflow-scroll");
      set_style(div2, "height", "calc(100% - 40px)");
      attr(div3, "class", "card panel-default");
      set_style(div3, "height", "65%");
      attr(div4, "class", "flex flex-column-l mr2");
      set_style(div4, "height", "calc(100vh - " + ctx[3] + "px)");
      attr(div5, "class", "w-25");
      attr(div6, "class", "border-right-none w-75 flex");
      attr(div7, "class", "flex pa2 w-[calc(100vw-var(--vbar-margin))]");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, h3);
      insert(target, t2, anchor);
      insert(target, div7, anchor);
      append(div7, div5);
      append(div5, div4);
      append(div4, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div4, t3);
      append(div4, div3);
      append(div3, div1);
      append(div3, t5);
      append(div3, div2);
      append(div2, ul);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      ctx[11](ul);
      ctx[12](div4);
      append(div7, t6);
      append(div7, div6);
      key_block.m(div6, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        show_if = ctx2[7].get(ctx2[0]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$C(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty & 35) {
        each_value = ctx2[5].models;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, destroy_block, create_each_block$U, null, get_each_context$U);
      }
      if (!current || dirty & 8) {
        set_style(div4, "height", "calc(100vh - " + ctx2[3] + "px)");
      }
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$6(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div6, null);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div7);
      if (if_block)
        if_block.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      ctx[11](null);
      ctx[12](null);
      key_block.d(detaching);
    }
  };
}
function create_if_block_3$C(ctx) {
  let error2;
  let current;
  error2 = new Error$1({
    props: {
      workStore: ctx[7].get(ctx[0])
    }
  });
  return {
    c() {
      create_component(error2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(error2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const error_changes = {};
      if (dirty & 1)
        error_changes.workStore = ctx2[7].get(ctx2[0]);
      error2.$set(error_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(error2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(error2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(error2, detaching);
    }
  };
}
function create_if_block_2$N(ctx) {
  let span;
  let t_value = (ctx[18].get("err").code || "NA") + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = (ctx2[18].get("err").code || "NA") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block$1T(ctx) {
  let div;
  let span0;
  let t1;
  let span5;
  let span4;
  let span1;
  let t3;
  let span2;
  let span2_class_value;
  let t4;
  let span3;
  let t5_value = ctx[18].get("meta").proxyRegion + "";
  let t5;
  let t6;
  let show_if = ctx[18].get("meta").proxyGrade;
  let if_block = show_if && create_if_block_1$1e(ctx);
  return {
    c() {
      div = element("div");
      span0 = element("span");
      span0.textContent = "Proxy";
      t1 = space();
      span5 = element("span");
      span4 = element("span");
      span1 = element("span");
      span1.textContent = "Region";
      t3 = space();
      span2 = element("span");
      t4 = space();
      span3 = element("span");
      t5 = text(t5_value);
      t6 = space();
      if (if_block)
        if_block.c();
      set_style(span0, "font-size", "0.85rem");
      attr(span1, "class", "pe-1 border-end");
      attr(span2, "class", span2_class_value = "fi " + getProxyIconClass({
        region: ctx[18].get("meta").proxyRegion
      }) + " fs-normal");
      attr(span4, "class", "border rounded px-1");
      set_style(span5, "font-size", "0.85rem");
      attr(div, "class", "text-secondary p-0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(div, t1);
      append(div, span5);
      append(span5, span4);
      append(span4, span1);
      append(span4, t3);
      append(span4, span2);
      append(span4, t4);
      append(span4, span3);
      append(span3, t5);
      append(span5, t6);
      if (if_block)
        if_block.m(span5, null);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && span2_class_value !== (span2_class_value = "fi " + getProxyIconClass({
        region: ctx2[18].get("meta").proxyRegion
      }) + " fs-normal")) {
        attr(span2, "class", span2_class_value);
      }
      if (dirty & 32 && t5_value !== (t5_value = ctx2[18].get("meta").proxyRegion + ""))
        set_data(t5, t5_value);
      if (dirty & 32)
        show_if = ctx2[18].get("meta").proxyGrade;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1e(ctx2);
          if_block.c();
          if_block.m(span5, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$1e(ctx) {
  let span2;
  let span0;
  let t1;
  let span1;
  let t2_value = ctx[18].get("meta").proxyGrade + "";
  let t2;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      span0.textContent = "Grade";
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      attr(span0, "class", "pe-1 border-end");
      attr(span2, "class", "border rounded px-1");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span2, t1);
      append(span2, span1);
      append(span1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t2_value !== (t2_value = ctx2[18].get("meta").proxyGrade + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(span2);
    }
  };
}
function create_each_block$U(key_1, ctx) {
  let li;
  let a;
  let div;
  let span;
  let t0_value = formatTimeV2(ctx[18].get("ts"), false, true) + "";
  let t0;
  let t1;
  let show_if_1 = ctx[18].get("err");
  let t2;
  let show_if = ctx[18].get("meta") && ctx[18].get("meta").proxyRegion;
  let a_href_value;
  let t3;
  let mounted;
  let dispose;
  let if_block0 = show_if_1 && create_if_block_2$N(ctx);
  let if_block1 = show_if && create_if_block$1T(ctx);
  function click_handler(...args) {
    return ctx[10](ctx[18], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      a = element("a");
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      toggle_class(div, "text-danger", !!ctx[18].get("err"));
      toggle_class(div, "text-secondary", !ctx[18].get("err"));
      attr(a, "href", a_href_value = "#" + (ctx[1] + "?work=" + ctx[18].id));
      attr(li, "role", "presentation");
      attr(li, "class", "list-group-item");
      toggle_class(li, "list-group-item-primary", ctx[0] === ctx[18].id);
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, div);
      append(div, span);
      append(span, t0);
      append(div, t1);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      append(li, t3);
      if (!mounted) {
        dispose = listen(a, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && t0_value !== (t0_value = formatTimeV2(ctx[18].get("ts"), false, true) + ""))
        set_data(t0, t0_value);
      if (dirty & 32)
        show_if_1 = ctx[18].get("err");
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_2$N(ctx);
          if_block0.c();
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 32)
        show_if = ctx[18].get("meta") && ctx[18].get("meta").proxyRegion;
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block$1T(ctx);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & 32) {
        toggle_class(div, "text-danger", !!ctx[18].get("err"));
      }
      if (dirty & 32) {
        toggle_class(div, "text-secondary", !ctx[18].get("err"));
      }
      if (dirty & 34 && a_href_value !== (a_href_value = "#" + (ctx[1] + "?work=" + ctx[18].id))) {
        attr(a, "href", a_href_value);
      }
      if (dirty & 33) {
        toggle_class(li, "list-group-item-primary", ctx[0] === ctx[18].id);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_key_block$6(ctx) {
  let work;
  let current;
  work = new Work({
    props: {
      workStore: ctx[7].get(ctx[0]),
      sieveStore: ctx[6]
    }
  });
  return {
    c() {
      create_component(work.$$.fragment);
    },
    m(target, anchor) {
      mount_component(work, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const work_changes = {};
      if (dirty & 1)
        work_changes.workStore = ctx2[7].get(ctx2[0]);
      work.$set(work_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(work.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(work.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(work, detaching);
    }
  };
}
function create_pending_block$x(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3k(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$x,
    then: create_then_block$x,
    catch: create_catch_block$x,
    value: 17,
    blocks: [, , ,]
  };
  handle_promise(ctx[8], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$3g($$self, $$props, $$invalidate) {
  let $worksStore;
  let { sieveID } = $$props;
  let { workID } = $$props;
  let { basePath } = $$props;
  let el2;
  let elTop = 0;
  let workListElem;
  const sieveStore = new Model$2.Sieve({ "id": sieveID });
  let worksStore = new Model$2.Works(null, { sieve: sieveStore });
  component_subscribe($$self, worksStore, (value) => $$invalidate(5, $worksStore = value));
  let worksFetched;
  let worksFetchPromise = new Promise((res, rej) => {
    worksFetched = res;
  });
  async function fetchWorks() {
    await sieveStore.fetch();
    await worksStore.fetch({ reset: true });
    if (!workID) {
      $$invalidate(0, workID = worksStore.at(0).id);
    }
    worksFetched(true);
  }
  fetchWorks();
  onMount(async () => {
    await worksFetchPromise;
    const selectedItemElem = workListElem.querySelector("li.active");
    if (selectedItemElem) {
      selectedItemElem.scrollIntoView({ block: "nearest", inline: "nearest" });
    }
    $$invalidate(3, elTop = el2.getBoundingClientRect().top);
  });
  const click_handler = (work, e) => {
    $$invalidate(0, workID = work.id);
  };
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      workListElem = $$value;
      $$invalidate(4, workListElem);
    });
  }
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el2 = $$value;
      $$invalidate(2, el2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("sieveID" in $$props2)
      $$invalidate(9, sieveID = $$props2.sieveID);
    if ("workID" in $$props2)
      $$invalidate(0, workID = $$props2.workID);
    if ("basePath" in $$props2)
      $$invalidate(1, basePath = $$props2.basePath);
  };
  return [
    workID,
    basePath,
    el2,
    elTop,
    workListElem,
    $worksStore,
    sieveStore,
    worksStore,
    worksFetchPromise,
    sieveID,
    click_handler,
    ul_binding,
    div4_binding
  ];
}
class List$7 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3g, create_fragment$3k, safe_not_equal, { sieveID: 9, workID: 0, basePath: 1 });
  }
}
function create_else_block$11(ctx) {
  let error404;
  let current;
  error404 = new Error404({ props: { useLayout: false } });
  return {
    c() {
      create_component(error404.$$.fragment);
    },
    m(target, anchor) {
      mount_component(error404, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(error404.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(error404.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(error404, detaching);
    }
  };
}
function create_if_block$1S(ctx) {
  let list;
  let current;
  list = new List$7({
    props: {
      sieveID: ctx[0].sieveID,
      workID: ctx[1],
      basePath: ctx[2]
    }
  });
  return {
    c() {
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_changes = {};
      if (dirty & 1)
        list_changes.sieveID = ctx2[0].sieveID;
      if (dirty & 2)
        list_changes.workID = ctx2[1];
      if (dirty & 4)
        list_changes.basePath = ctx2[2];
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
    }
  };
}
function create_default_slot$1c(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1S, create_else_block$11];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    return 0;
  }
  current_block_type_index = select_block_type();
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_topbar_slot$6(ctx) {
  let topbar;
  let current;
  topbar = new Topbar$1({ props: { title: "Check Logs" } });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$3j(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot$6],
        default: [create_default_slot$1c]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 23) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$3f($$self, $$props, $$invalidate) {
  let $querystring;
  let $location;
  component_subscribe($$self, querystring, ($$value) => $$invalidate(3, $querystring = $$value));
  component_subscribe($$self, location$1, ($$value) => $$invalidate(2, $location = $$value));
  let { params: params2 = {} } = $$props;
  Api.setIdentityId(params2.team == 0 ? null : params2.team);
  let workID;
  if ($querystring) {
    const searchParams = new URLSearchParams($querystring);
    workID = searchParams.has("work") && searchParams.get("work");
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(0, params2 = $$props2.params);
  };
  return [params2, workID, $location];
}
class Works extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3f, create_fragment$3j, safe_not_equal, { params: 0 });
  }
}
function parse$2(str, loose) {
  if (str instanceof RegExp)
    return { keys: false, pattern: str };
  var c, o, tmp, ext, keys2 = [], pattern = "", arr = str.split("/");
  arr[0] || arr.shift();
  while (tmp = arr.shift()) {
    c = tmp[0];
    if (c === "*") {
      keys2.push("wild");
      pattern += "/(.*)";
    } else if (c === ":") {
      o = tmp.indexOf("?", 1);
      ext = tmp.indexOf(".", 1);
      keys2.push(tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length));
      pattern += !!~o && !~ext ? "(?:/([^/]+?))?" : "/([^/]+?)";
      if (!!~ext)
        pattern += (!!~o ? "?" : "") + "\\" + tmp.substring(ext);
    } else {
      pattern += "/" + tmp;
    }
  }
  return {
    keys: keys2,
    pattern: new RegExp("^" + pattern + (loose ? "(?=$|/)" : "/?$"), "i")
  };
}
const get_content_slot_changes = (dirty) => ({});
const get_content_slot_context = (ctx) => ({});
function create_if_block$1R(ctx) {
  let div;
  let h3;
  let t;
  return {
    c() {
      div = element("div");
      h3 = element("h3");
      t = text(ctx[0]);
      attr(div, "class", "xpage-header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h3);
      append(h3, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$3i(ctx) {
  let t;
  let div;
  let current;
  let if_block = ctx[0] && create_if_block$1R(ctx);
  const content_slot_template = ctx[2].content;
  const content_slot = create_slot(content_slot_template, ctx, ctx[1], get_content_slot_context);
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      if (content_slot)
        content_slot.c();
      set_style(div, "padding", "10px");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      if (content_slot) {
        content_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1R(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(content_slot_template, ctx2[1], dirty, get_content_slot_changes),
            get_content_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(content_slot, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      if (content_slot)
        content_slot.d(detaching);
    }
  };
}
function instance$3e($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [title, $$scope, slots];
}
class Layout extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3e, create_fragment$3i, safe_not_equal, { title: 0 });
  }
}
function create_else_block$10(ctx) {
  let t;
  return {
    c() {
      t = text("Please sign in or contact support to get more information");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$1Q(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let a;
  let t4;
  return {
    c() {
      t0 = text(ctx[0]);
      t1 = text(" monitors are available in ");
      t2 = text(ctx[1]);
      t3 = text(" or higher subscriptions. ");
      a = element("a");
      t4 = text("Manage Subscription");
      attr(a, "href", urlCfg.billing);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, a, anchor);
      append(a, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t0, ctx2[0]);
      if (dirty & 2)
        set_data(t2, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(a);
    }
  };
}
function create_content_slot$4(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block$1Q;
    return create_else_block$10;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$3h(ctx) {
  let sieveoptionslayout;
  let current;
  sieveoptionslayout = new Layout({
    props: {
      title: TXT("m_upgrade_account"),
      $$slots: { content: [create_content_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(sieveoptionslayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveoptionslayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sieveoptionslayout_changes = {};
      if (dirty & 7) {
        sieveoptionslayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sieveoptionslayout.$set(sieveoptionslayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveoptionslayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveoptionslayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveoptionslayout, detaching);
    }
  };
}
function instance$3d($$self, $$props, $$invalidate) {
  let { type } = $$props;
  let { minPlan } = $$props;
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("minPlan" in $$props2)
      $$invalidate(1, minPlan = $$props2.minPlan);
  };
  return [type, minPlan];
}
class UpgradeAccount extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3d, create_fragment$3h, safe_not_equal, { type: 0, minPlan: 1 });
  }
}
function create_content_slot$3(ctx) {
  let div1;
  let div0;
  let t0_value = SPRINTF("m_monitor_constraint_1", ctx[0].count, ctx[0].limit) + "";
  let t0;
  let t1;
  let t2_value = SPRINTF("m_monitor_constraint_2") + "";
  let t2;
  let t3;
  let ul;
  let li0;
  let a0;
  let i0;
  let t4;
  let t5_value = SPRINTF("a_go_to_watchlist") + "";
  let t5;
  let t6;
  let t7_value = SPRINTF("m_monitor_constraint_3") + "";
  let t7;
  let t8;
  let li1;
  let a1;
  let i1;
  let t9;
  let t10_value = SPRINTF("a_go_to_billing") + "";
  let t10;
  let t11;
  let t12_value = SPRINTF("m_monitor_constraint_4") + "";
  let t12;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      i0 = element("i");
      t4 = space();
      t5 = text(t5_value);
      t6 = text("\n            : ");
      t7 = text(t7_value);
      t8 = space();
      li1 = element("li");
      a1 = element("a");
      i1 = element("i");
      t9 = space();
      t10 = text(t10_value);
      t11 = text(" : ");
      t12 = text(t12_value);
      attr(i0, "class", "fa fa-link");
      attr(a0, "href", urlCfg.watchlist);
      attr(i1, "class", "fa fa-link");
      attr(a1, "href", urlCfg.billing);
      attr(div0, "class", "alert alert-danger");
      attr(div1, "class", "xmonitor-limit");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      append(div0, t2);
      append(div0, t3);
      append(div0, ul);
      append(ul, li0);
      append(li0, a0);
      append(a0, i0);
      append(a0, t4);
      append(a0, t5);
      append(li0, t6);
      append(li0, t7);
      append(ul, t8);
      append(ul, li1);
      append(li1, a1);
      append(a1, i1);
      append(a1, t9);
      append(a1, t10);
      append(a1, t11);
      append(a1, t12);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = SPRINTF("m_monitor_constraint_1", ctx2[0].count, ctx2[0].limit) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_fragment$3g(ctx) {
  let sieveoptionslayout;
  let current;
  sieveoptionslayout = new Layout({
    props: {
      title: SPRINTF("m_monitor_limit"),
      $$slots: { content: [create_content_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(sieveoptionslayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveoptionslayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sieveoptionslayout_changes = {};
      if (dirty & 3) {
        sieveoptionslayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sieveoptionslayout.$set(sieveoptionslayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveoptionslayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveoptionslayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveoptionslayout, detaching);
    }
  };
}
function instance$3c($$self, $$props, $$invalidate) {
  let { constraint } = $$props;
  $$self.$$set = ($$props2) => {
    if ("constraint" in $$props2)
      $$invalidate(0, constraint = $$props2.constraint);
  };
  return [constraint];
}
class SieveConstraint extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3c, create_fragment$3g, safe_not_equal, { constraint: 0 });
  }
}
function create_header_slot$j(ctx) {
  let t;
  return {
    c() {
      t = text("Visual Selector");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$$(ctx) {
  let t_value = TXT("h_opened_selector_in_tab") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$1P(ctx) {
  let t_value = TXT("h_opening_selector_in_new_tab") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$1b(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return create_if_block$1P;
    return create_else_block$$;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$3f(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      $$slots: {
        default: [create_default_slot$1b],
        header: [create_header_slot$j]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[1]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 513) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
async function createTab(info) {
  return new Promise(function(resolve, reject2) {
    chrome.tabs.create(info, async (tab) => {
      if (tab) {
        resolve(tab);
      } else {
        reject2({
          code: "EBROWSER",
          msg: "chrome.tabs.create failed to create a tab"
        });
      }
    });
  });
}
function instance$3b($$self, $$props, $$invalidate) {
  let { formModel } = $$props;
  const { model } = formModel;
  const { uri } = formModel.fields;
  const dispatch = createEventDispatcher();
  model.set("content_type", C$1.TYPE_HTML);
  let tabId;
  let loading2 = false;
  openVisualSelector();
  function onDiscard() {
    serviceProxy.closeSelector(tabId);
    dispatch("discard");
  }
  function openVisualSelector() {
    Msg.reset();
    $$invalidate(0, loading2 = true);
    setTimeout(
      async () => {
        try {
          await renderTab();
        } catch (err) {
          console.error("Error opening Visual Selector", err);
          Msg.error(err.msg || err.message || err);
        }
      },
      400
    );
  }
  async function renderTab() {
    let url = uri.toJSON() || "https://google.com";
    $$invalidate(0, loading2 = false);
    const tab = await createTab({ active: true });
    tabId = tab.id;
    try {
      trackEvent(PHEvents.VS_GOTO_SUCCESS);
      let sieve = await serviceProxy.attachAndOpenSelector({ tabId, url, model: model.toJSON() });
      if (sieve) {
        model.parseAndSet({ ...sieve });
        formModel.copyFromModel(model);
        dispatch("save");
        Msg.info("m_selection_saved");
        trackEvent(PHEvents.VS_SAVED, { uri: sieve.uri });
      } else {
        onDiscard();
        Msg.info("m_selection_discarded");
        trackEvent(PHEvents.VS_CANCELLED);
      }
    } catch (e) {
      Msg.error(`${TXT("e_err")}: ${e.message}`);
    }
    chrome.tabs.getCurrent(function(tab2) {
      chrome.tabs.update(tab2.id, { active: true });
    });
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(2, formModel = $$props2.formModel);
  };
  return [loading2, onDiscard, formModel];
}
class Html extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3b, create_fragment$3f, safe_not_equal, { formModel: 2 });
  }
}
function prepareSchema(parsedJSON) {
  const schema = prepareSchema1(parsedJSON);
  return schema;
}
function prepareSchema1(parsedJSON) {
  const type = jsonType$1(parsedJSON);
  if (type === types$1.ARRAY) {
    if (isArrayOfObject(parsedJSON)) {
      return handleArrayOfObjects(parsedJSON);
    } else {
      return handleArrayOfPrimitives(parsedJSON);
    }
  } else if (type === types$1.OBJECT) {
    return handleObject(parsedJSON);
  } else {
    return parsedJSON;
  }
}
function handleObject(parsedJSON) {
  const deepCopy = JSON.parse(JSON.stringify(parsedJSON));
  const properties = parsedJSON[ParsedPropertyName];
  Object.keys(parsedJSON).filter((k) => k !== ParsedPropertyName).forEach((k) => {
    switch (properties[k]) {
      case types$1.PRIMITIVE:
      case types$1.NULL:
        parsedJSON[k] = handlePrimitive(parsedJSON[k]);
        break;
      case types$1.ARRAY:
        parsedJSON[k] = handleArrayOfPrimitives(parsedJSON[k]);
        break;
      case types$1.ARRAY_OF_OBJECTS:
        parsedJSON[k] = handleArrayOfObjects(parsedJSON[k]);
        break;
      case types$1.OBJECT:
        parsedJSON[k] = handleObject(parsedJSON[k]);
        break;
      case types$1.UNKNOWN:
        parsedJSON[k] = handleUnknown(parsedJSON[k]);
    }
  });
  return {
    schema: parsedJSON,
    type: types$1.OBJECT,
    value: deepCopy
  };
}
function handlePrimitive(value) {
  return {
    value,
    type: Array.isArray(value) ? jsonType$1(findFirstNotNullElemFromArray(value)) : jsonType$1(value)
  };
}
function handleArrayOfPrimitives(value) {
  return {
    value,
    type: types$1.ARRAY
  };
}
function handleArrayOfObjects(value) {
  return {
    value,
    type: types$1.ARRAY_OF_OBJECTS,
    schema: handleObject(value[0])
  };
}
function handleUnknown(value) {
  return {
    value,
    type: types$1.UNKNOWN
  };
}
function findFirstNotNullElemFromArray(arr) {
  if (!arr) {
    return null;
  }
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (arr[i2]) {
      return arr[i2];
    }
  }
  return null;
}
function create_label_slot$1(ctx) {
  let span;
  let t_value = ctx[0].label + "";
  let t;
  let span_title_value;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "slot", "label");
      attr(span, "title", span_title_value = ctx[0].label);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].label + ""))
        set_data(t, t_value);
      if (dirty & 1 && span_title_value !== (span_title_value = ctx2[0].label)) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_icon_slot(ctx) {
  let svelte_fragment;
  let div;
  let typesvg;
  let div_title_value;
  let current;
  typesvg = new TypeSVG({ props: { type: ctx[0].type } });
  return {
    c() {
      svelte_fragment = element("svelte-fragment");
      div = element("div");
      create_component(typesvg.$$.fragment);
      attr(div, "class", "tv-svg");
      attr(div, "title", div_title_value = ctx[0].type);
      set_custom_element_data(svelte_fragment, "slot", "icon");
    },
    m(target, anchor) {
      insert(target, svelte_fragment, anchor);
      append(svelte_fragment, div);
      mount_component(typesvg, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const typesvg_changes = {};
      if (dirty & 1)
        typesvg_changes.type = ctx2[0].type;
      typesvg.$set(typesvg_changes);
      if (!current || dirty & 1 && div_title_value !== (div_title_value = ctx2[0].type)) {
        attr(div, "title", div_title_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(typesvg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typesvg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svelte_fragment);
      destroy_component(typesvg);
    }
  };
}
function create_meta_slot(ctx) {
  let div;
  let nodevalue;
  let div_title_value;
  let current;
  nodevalue = new NodeValue({
    props: {
      content: ctx[0].getPrettyValue()
    }
  });
  return {
    c() {
      div = element("div");
      create_component(nodevalue.$$.fragment);
      attr(div, "slot", "meta");
      set_style(div, "white-space", "normal");
      set_style(div, "overflow-wrap", "anywhere");
      attr(div, "title", div_title_value = ctx[0].getValue());
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(nodevalue, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const nodevalue_changes = {};
      if (dirty & 1)
        nodevalue_changes.content = ctx2[0].getPrettyValue();
      nodevalue.$set(nodevalue_changes);
      if (!current || dirty & 1 && div_title_value !== (div_title_value = ctx2[0].getValue())) {
        attr(div, "title", div_title_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(nodevalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nodevalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(nodevalue);
    }
  };
}
function create_fragment$3e(ctx) {
  let div;
  let treeview;
  let div_style_value;
  let div_class_value;
  let current;
  const treeview_spread_levels = [
    { root: ctx[0] },
    {
      class: "tree-view bg-white min-w-min " + ctx[3]
    },
    ctx[7]
  ];
  let treeview_props = {
    $$slots: {
      meta: [create_meta_slot, ({ node }) => ({ 0: node }), ({ node }) => node ? 1 : 0],
      icon: [create_icon_slot, ({ node }) => ({ 0: node }), ({ node }) => node ? 1 : 0],
      label: [create_label_slot$1, ({ node }) => ({ 0: node }), ({ node }) => node ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < treeview_spread_levels.length; i2 += 1) {
    treeview_props = assign(treeview_props, treeview_spread_levels[i2]);
  }
  treeview = new TreeView$1({ props: treeview_props });
  treeview.$on("check", ctx[13]);
  return {
    c() {
      div = element("div");
      create_component(treeview.$$.fragment);
      attr(div, "style", div_style_value = ctx[2] ? `--tv-key-width: ${ctx[6]()};` : "");
      attr(div, "class", div_class_value = "overflow-auto " + (ctx[1] ? "bb bl br border-bootstrap-border" : ""));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(treeview, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const treeview_changes = dirty & 137 ? get_spread_update(treeview_spread_levels, [
        dirty & 1 && { root: ctx2[0] },
        dirty & 8 && {
          class: "tree-view bg-white min-w-min " + ctx2[3]
        },
        dirty & 128 && get_spread_object(ctx2[7])
      ]) : {};
      if (dirty & 2097153) {
        treeview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      treeview.$set(treeview_changes);
      if (!current || dirty & 4 && div_style_value !== (div_style_value = ctx2[2] ? `--tv-key-width: ${ctx2[6]()};` : "")) {
        attr(div, "style", div_style_value);
      }
      if (!current || dirty & 2 && div_class_value !== (div_class_value = "overflow-auto " + (ctx2[1] ? "bb bl br border-bootstrap-border" : ""))) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(treeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(treeview);
    }
  };
}
const MaxAllowableDepthForWidth = 12;
const MinAllowableDepthForWidth = 8;
function instance$3a($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "obj",
    "rootLabel",
    "includedJqFilter",
    "stores",
    "node",
    "showOuterBorder",
    "showPreviewNode",
    "showMeta",
    "class"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $maxDepth;
  let { obj } = $$props;
  let { rootLabel = "Properties" } = $$props;
  let { includedJqFilter = [] } = $$props;
  let { stores = {} } = $$props;
  let { node } = $$props;
  let { showOuterBorder = true } = $$props;
  let { showPreviewNode = true } = $$props;
  let { showMeta = true } = $$props;
  let maxDepth = writable(0);
  component_subscribe($$self, maxDepth, (value) => $$invalidate(15, $maxDepth = value));
  let { class: clazz = "" } = $$props;
  class Node2 extends BaseNode$1 {
    constructor({ id: id2, label, parent: parent2 = null, type = null, key = null, jqSelector = ".", value = null, checkable = true, disabled = false }) {
      super(id2, label, parent2);
      this.checkable = checkable;
      this.selectable = false;
      this.disabled = disabled;
      this._expanded = true;
      this.type = type;
      this.key = key;
      this.jqSelector = jqSelector;
      this.value = value;
    }
    isSelectable() {
      return false;
    }
    getJqSelector() {
      return this.jqSelector;
    }
    getIncludedSelectors() {
      const res = [];
      (function getSelectors(node2, res2) {
        if (!node2.isCheckable()) {
          return;
        }
        const state = node2.getCheckState();
        if (state === CheckState$1.selected) {
          res2.push(node2.getJqSelector());
        } else {
          (node2.children || []).forEach((child) => {
            getSelectors(child, res2);
          });
        }
      })(this, res);
      return res;
    }
    changeInitialSelector() {
      const selector = this.getJqSelector();
      if (get_store_value(stores.includedJson).some((filter2) => selector === filter2)) {
        this.checkAll(CheckState$1.selected);
      } else {
        (this.children || []).forEach((child) => child.changeInitialSelector());
      }
    }
    firstValue(arrayOrValue) {
      if (arrayOrValue === void 0) {
        return "";
      }
      if (Array.isArray(arrayOrValue) && arrayOrValue && arrayOrValue.length > 0) {
        for (let i2 = 0; i2 < arrayOrValue.length; i2++) {
          if (arrayOrValue[i2]) {
            return arrayOrValue[i2];
          }
        }
        return arrayOrValue[0];
      }
      return arrayOrValue;
    }
    getValue() {
      switch (this.type) {
        case types$1.STRING:
          return this.value;
        default:
          return this.getPrettyValue();
      }
    }
    getPrettyValue() {
      switch (this.type) {
        case types$1.STRING:
        case types$1.NUMBER:
          return this.firstValue(this.value);
        case types$1.BOOLEAN:
          return this.value;
        case types$1.ARRAY:
          return `Array with ${this.value.length} values(s)`;
        case types$1.ARRAY_OF_OBJECTS:
          return "Array containing Objects";
        case types$1.OBJECT:
          return "";
        default:
          return this.value;
      }
    }
  }
  class ArrOfObjectNode extends Node2 {
    constructor({ id: id2, label, parent: parent2 = null, type = null, key = null, jqSelector = ".", value = null, checkable = true, previewJSONStore = null }) {
      super({
        id: id2,
        label,
        parent: parent2,
        type,
        key,
        jqSelector,
        value,
        checkable
      });
      if (this.type === types$1.ARRAY_OF_OBJECTS) {
        this.previewJSONStore = previewJSONStore;
        if (this.previewJSONStore) {
          this.unsubscribe = this.previewJSONStore.subscribe((val) => {
            if (this.unsubscribe) {
              this.updatePreview(val);
            }
          });
        }
      }
    }
    getPreviewNode() {
      if (this.children && this.children.length > 0) {
        const lastChild = this.children[this.children.length - 1];
        if (lastChild && lastChild.label === "Preview") {
          return lastChild;
        }
      }
      return null;
    }
    async updatePreview(newContent) {
      if (this.type !== types$1.ARRAY_OF_OBJECTS) {
        return;
      }
      if (!this.children || this.children.length === 0) {
        return;
      }
      const itemsNode = this.children[0];
      const children = await itemsNode.getChildren();
      const previewValues = {};
      let valueLength = 0;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (isPrimitiveType$1(child.type) && child.checkState === CheckState$1.selected) {
          previewValues[child.key] = child.value;
          valueLength = child.value.length;
        }
      }
      const preview = [];
      for (let i2 = 0; i2 < valueLength; i2++) {
        const previewElem = {};
        Object.keys(previewValues).forEach((k) => {
          previewElem[k] = previewValues[k][i2];
        });
        preview.push(previewElem);
      }
      if (preview) {
        this.getPreviewNode().setChildren(jsonToNodeForPreview(preview, this.getPreviewNode()));
        this.getPreviewNode().setDisabled(false);
      } else {
        this.getPreviewNode().setChildren([]);
        this.getPreviewNode().setDisabled(true);
      }
      this.getPreviewNode().notify();
      this.notify();
    }
  }
  let count2 = 0;
  function createNode(obj2) {
    sanitize(obj2, ParsedPropertyName);
    $$invalidate(0, node = jsonToNode(obj2, rootLabel, null, ".", 0));
    if ($maxDepth > MaxAllowableDepthForWidth) {
      maxDepth.set(MaxAllowableDepthForWidth);
    } else if ($maxDepth < MinAllowableDepthForWidth) {
      maxDepth.set(MinAllowableDepthForWidth);
    }
    node.changeInitialSelector();
    const jq = node.getIncludedSelectors();
    stores.includedJson.update((val) => jq);
  }
  function jsonToNode(json, label, parent2, jq, depth) {
    let type = json.type;
    let value;
    try {
      value = JSON.parse(JSON.stringify(json.value));
    } catch (e) {
      console.error("error while JSON conversion for creating the value", json.value, e);
    }
    let newNode;
    if ($maxDepth < depth) {
      maxDepth.set(depth);
    }
    delete json.value;
    switch (type) {
      case types$1.ARRAY_OF_OBJECTS:
        newNode = new ArrOfObjectNode({
          id: count2++,
          label: `${label}`,
          parent: parent2,
          type,
          key: label,
          jqSelector: jq,
          value,
          previewJSONStore: stores.previewJson
        });
        const schema = json.schema;
        newNode.children = [];
        newNode.children.push(jsonToNode(schema, "Items", newNode, jq + "[]?", depth + 1));
        if (showPreviewNode) {
          newNode.children.push(new Node2({
            id: count2++,
            label: "Preview",
            parent: newNode,
            checkable: false,
            value: "",
            disabled: true,
            expandable: false
          }));
        }
        break;
      case types$1.OBJECT:
        newNode = new Node2({
          id: count2++,
          label: `${label}`,
          parent: parent2,
          type,
          key: label,
          jqSelector: jq,
          value
        });
        newNode.children = Object.keys(json.schema).map((key) => jsonToNode(json.schema[key], key, newNode, jq + (newNode.isRoot() ? "" : ".") + `"${key}"`, depth + 1));
        break;
      case types$1.UNKNOWN:
        newNode = new Node2({
          id: count2++,
          label: `${label}`,
          parent: parent2,
          type,
          key: label,
          jqSelector: jq,
          value: types$1.UNKNOWN + " type"
        });
        break;
      case types$1.NUMBER:
      case types$1.BOOLEAN:
      case types$1.STRING:
      case types$1.PRIMITIVE:
      case types$1.ARRAY:
      default:
        newNode = new Node2({
          id: count2++,
          label: `${label}`,
          parent: parent2,
          type,
          key: label,
          jqSelector: jq,
          value
        });
        break;
    }
    return newNode;
  }
  function onCheck(detail) {
    let { checked, node: node2 } = detail;
    let jqSelectors = node2.getRoot().getIncludedSelectors();
    stores.includedJson.update(function(val) {
      return jqSelectors;
    });
  }
  function jsonToNodeForPreview(obj2, parent2) {
    const newNodes = [];
    for (const key in obj2) {
      let newNode = new Node2({
        id: count2++,
        label: key,
        parent: parent2,
        value: isPrimitive$1(obj2[key]) || isArrayOfPrimitives(obj2[key]) ? obj2[key] : "",
        checkable: false,
        type: jsonType$1(obj2[key])
      });
      if (!isPrimitive$1(obj2[key]) && !Array.isArray(obj2[key])) {
        newNode.children = jsonToNodeForPreview(obj2[key], newNode);
      }
      newNodes.push(newNode);
    }
    return newNodes;
  }
  function getDepth() {
    let minWidth = 30, upper_bound = 40;
    let depth = minWidth + 2 * $maxDepth;
    return `${depth > upper_bound ? upper_bound : depth}%`;
  }
  const check_handler = (e) => onCheck(e.detail);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("obj" in $$new_props)
      $$invalidate(8, obj = $$new_props.obj);
    if ("rootLabel" in $$new_props)
      $$invalidate(9, rootLabel = $$new_props.rootLabel);
    if ("includedJqFilter" in $$new_props)
      $$invalidate(10, includedJqFilter = $$new_props.includedJqFilter);
    if ("stores" in $$new_props)
      $$invalidate(11, stores = $$new_props.stores);
    if ("node" in $$new_props)
      $$invalidate(0, node = $$new_props.node);
    if ("showOuterBorder" in $$new_props)
      $$invalidate(1, showOuterBorder = $$new_props.showOuterBorder);
    if ("showPreviewNode" in $$new_props)
      $$invalidate(12, showPreviewNode = $$new_props.showPreviewNode);
    if ("showMeta" in $$new_props)
      $$invalidate(2, showMeta = $$new_props.showMeta);
    if ("class" in $$new_props)
      $$invalidate(3, clazz = $$new_props.class);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      createNode(obj);
    }
  };
  return [
    node,
    showOuterBorder,
    showMeta,
    clazz,
    maxDepth,
    onCheck,
    getDepth,
    $$restProps,
    obj,
    rootLabel,
    includedJqFilter,
    stores,
    showPreviewNode,
    check_handler
  ];
}
class Tree extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3a, create_fragment$3e, safe_not_equal, {
      obj: 8,
      rootLabel: 9,
      includedJqFilter: 10,
      stores: 11,
      node: 0,
      showOuterBorder: 1,
      showPreviewNode: 12,
      showMeta: 2,
      class: 3
    });
  }
}
function create_fragment$3d(ctx) {
  let div;
  let ul;
  let li0;
  let a0;
  let t1;
  let li1;
  let a1;
  let t3;
  let pre;
  let t4_value = JSON.stringify(
    ctx[0] == "distilled" ? ctx[3] : ctx[1],
    null,
    2
  ) + "";
  let t4;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      a0.textContent = "Distilled";
      t1 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = "Response";
      t3 = space();
      pre = element("pre");
      t4 = text(t4_value);
      attr(a0, "class", "nav-link cursor-pointer");
      attr(a0, "data-toggle", "tab");
      toggle_class(a0, "active", ctx[0] === "distilled");
      attr(li0, "class", "nav-item");
      attr(a1, "class", "nav-link cursor-pointer");
      attr(a1, "data-toggle", "tab");
      toggle_class(a1, "active", ctx[0] === "response");
      attr(li1, "class", "nav-item");
      attr(ul, "class", "nav nav-tabs ");
      attr(pre, "class", "max-h-[600px] bg-white overflow-auto max-w-[40vw]");
      set_style(pre, "border-top", "none");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ul);
      append(ul, li0);
      append(li0, a0);
      append(ul, t1);
      append(ul, li1);
      append(li1, a1);
      append(div, t3);
      append(div, pre);
      append(pre, t4);
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[6]),
          listen(a1, "click", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        toggle_class(a0, "active", ctx2[0] === "distilled");
      }
      if (dirty & 1) {
        toggle_class(a1, "active", ctx2[0] === "response");
      }
      if (dirty & 11 && t4_value !== (t4_value = JSON.stringify(
        ctx2[0] == "distilled" ? ctx2[3] : ctx2[1],
        null,
        2
      ) + ""))
        set_data(t4, t4_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$39($$self, $$props, $$invalidate) {
  let $previewJsonStore, $$unsubscribe_previewJsonStore = noop$1, $$subscribe_previewJsonStore = () => ($$unsubscribe_previewJsonStore(), $$unsubscribe_previewJsonStore = subscribe(previewJsonStore, ($$value) => $$invalidate(5, $previewJsonStore = $$value)), previewJsonStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_previewJsonStore());
  let { output = {} } = $$props;
  let { previewJsonStore } = $$props;
  $$subscribe_previewJsonStore();
  let distilledJSON = {};
  let { preview = "distilled" } = $$props;
  function onClickTabPreview(newValue) {
    $$invalidate(0, preview = newValue);
  }
  const click_handler = () => onClickTabPreview("distilled");
  const click_handler_1 = () => onClickTabPreview("response");
  $$self.$$set = ($$props2) => {
    if ("output" in $$props2)
      $$invalidate(1, output = $$props2.output);
    if ("previewJsonStore" in $$props2)
      $$subscribe_previewJsonStore($$invalidate(2, previewJsonStore = $$props2.previewJsonStore));
    if ("preview" in $$props2)
      $$invalidate(0, preview = $$props2.preview);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 36) {
      $$invalidate(3, distilledJSON = (previewJsonStore ? $previewJsonStore : {}) || {});
    }
  };
  return [
    preview,
    output,
    previewJsonStore,
    distilledJSON,
    onClickTabPreview,
    $previewJsonStore,
    click_handler,
    click_handler_1
  ];
}
class DistilledJSONText extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$39, create_fragment$3d, safe_not_equal, {
      output: 1,
      previewJsonStore: 2,
      preview: 0
    });
  }
}
const generateSchemaFromJSON = (value) => {
  if (value === null) {
    return { type: "null" };
  }
  if (Array.isArray(value)) {
    const arraySchema = {
      type: "array",
      items: value.length > 0 ? generateSchemaFromJSON(value[0]) : {}
    };
    return arraySchema;
  }
  switch (typeof value) {
    case "string":
      return { type: "string" };
    case "number":
      return { type: "number" };
    case "boolean":
      return { type: "boolean" };
    case "object": {
      const properties = {};
      for (const [key, propValue] of Object.entries(value)) {
        properties[key] = generateSchemaFromJSON(propValue);
      }
      return {
        type: "object",
        properties
      };
    }
    default:
      throw new Error(`Unsupported type: ${typeof value}`);
  }
};
function create_catch_block$w(ctx) {
  let p;
  let t0;
  let t1_value = ctx[26] + "";
  let t1;
  return {
    c() {
      p = element("p");
      t0 = text("Retry ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t1_value !== (t1_value = ctx2[26] + ""))
        set_data(t1, t1_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_then_block$w(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[4] && create_if_block$1O(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1O(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$1O(ctx) {
  let div1;
  let div0;
  let ul;
  let li0;
  let a;
  let t1;
  let li1;
  let label;
  let input;
  let t2;
  let t3;
  let tree;
  let t4;
  let t5;
  let div2;
  let button;
  let t7;
  let current;
  let mounted;
  let dispose;
  tree = new Tree({
    props: {
      obj: prepareSchema(jsonParser$1(ctx[4])),
      stores: ctx[8]
    }
  });
  let if_block0 = ctx[2] && create_if_block_2$M(ctx);
  let if_block1 = ctx[3] && create_if_block_1$1d();
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      ul = element("ul");
      li0 = element("li");
      a = element("a");
      a.textContent = `${TXT("a_select_properties")}`;
      t1 = space();
      li1 = element("li");
      label = element("label");
      input = element("input");
      t2 = text("\n              Preview JSON");
      t3 = space();
      create_component(tree.$$.fragment);
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      div2 = element("div");
      button = element("button");
      button.textContent = "Save";
      t7 = space();
      if (if_block1)
        if_block1.c();
      attr(a, "class", "nav-link active");
      attr(a, "href", "#");
      attr(a, "data-toggle", "tab");
      attr(input, "type", "checkbox");
      attr(label, "class", "nav-link");
      attr(li1, "class", "nav-item pull-right");
      attr(ul, "class", "nav nav-tabs");
      attr(div0, "class", "flex flex-col flex-1");
      attr(div1, "class", "flex flex-row mt-4");
      attr(button, "class", "btn btn-primary");
      attr(div2, "class", "mt1");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, ul);
      append(ul, li0);
      append(li0, a);
      append(ul, t1);
      append(ul, li1);
      append(li1, label);
      append(label, input);
      input.checked = ctx[2];
      append(label, t2);
      append(div0, t3);
      mount_component(tree, div0, null);
      append(div1, t4);
      if (if_block0)
        if_block0.m(div1, null);
      insert(target, t5, anchor);
      insert(target, div2, anchor);
      append(div2, button);
      append(div2, t7);
      if (if_block1)
        if_block1.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a, "click", prevent_default(ctx[13])),
          listen(input, "change", ctx[14]),
          listen(button, "click", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        input.checked = ctx2[2];
      }
      const tree_changes = {};
      if (dirty & 16)
        tree_changes.obj = prepareSchema(jsonParser$1(ctx2[4]));
      tree.$set(tree_changes);
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$M(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_1$1d();
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tree.$$.fragment, local);
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(tree.$$.fragment, local);
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(tree);
      if (if_block0)
        if_block0.d();
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div2);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$M(ctx) {
  let div;
  let distilledjsontext;
  let current;
  distilledjsontext = new DistilledJSONText({
    props: {
      output: ctx[4],
      preview: "distilled",
      previewJsonStore: ctx[8].previewJson
    }
  });
  return {
    c() {
      div = element("div");
      create_component(distilledjsontext.$$.fragment);
      attr(div, "class", "flex-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(distilledjsontext, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const distilledjsontext_changes = {};
      if (dirty & 16)
        distilledjsontext_changes.output = ctx2[4];
      distilledjsontext.$set(distilledjsontext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(distilledjsontext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(distilledjsontext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(distilledjsontext);
    }
  };
}
function create_if_block_1$1d(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Invalid api/json";
      attr(p, "class", "text-danger");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_pending_block$w(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$3c(ctx) {
  let requesteditor;
  let t;
  let await_block_anchor;
  let promise;
  let current;
  requesteditor = new RequestEditor({
    props: {
      formModel: ctx[0],
      placeholder: "Enter URL to monitor json"
    }
  });
  requesteditor.$on("go", ctx[11]);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$w,
    then: create_then_block$w,
    catch: create_catch_block$w,
    value: 25,
    error: 26,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[1], info);
  return {
    c() {
      create_component(requesteditor.$$.fragment);
      t = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      insert(target, t, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const requesteditor_changes = {};
      if (dirty & 1)
        requesteditor_changes.formModel = ctx[0];
      requesteditor.$set(requesteditor_changes);
      info.ctx = ctx;
      if (dirty & 2 && promise !== (promise = ctx[1]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$38($$self, $$props, $$invalidate) {
  let $config;
  let $model;
  let $uri;
  let $includedJson;
  let $originalJson;
  let { formModel } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(16, $model = value));
  const { uri, config } = formModel.fields;
  component_subscribe($$self, uri, (value) => $$invalidate(17, $uri = value));
  component_subscribe($$self, config, (value) => $$invalidate(15, $config = value));
  const dispatch = createEventDispatcher();
  const datasource_id = $model.datasource_id;
  const stores = initStores($config.filters.included);
  const { includedJson, originalJson } = stores;
  component_subscribe($$self, includedJson, (value) => $$invalidate(18, $includedJson = value));
  component_subscribe($$self, originalJson, (value) => $$invalidate(4, $originalJson = value));
  let outputPromise;
  let expanded = true;
  let errorred = false;
  if ($uri) {
    fetchData();
  }
  async function fetchDatasource() {
    try {
      $$invalidate(3, errorred = false);
      const data = await Api.utils(`/datasources/${datasource_id}/fetch`, "POST", getSieve(true));
      originalJson.set(data);
    } catch (e) {
      $$invalidate(3, errorred = true);
      console.error(e);
      if (e.error) {
        e = e.error;
      }
      const error2 = {
        status: 0,
        message: "error while fetching the data from the datasource",
        body: {
          code: e.code,
          message: e.message || "Fetch failed",
          details: e.details
        }
      };
      originalJson.set(error2);
    }
  }
  function fetchData() {
    $$invalidate(1, outputPromise = fetchDatasource());
  }
  function getSieve(skipFilters = false) {
    return {
      name: $uri.host,
      uri: uri.toJSON(),
      config: getConfig(skipFilters)
    };
  }
  function getConfig(skipFilters = false) {
    return {
      request: JSON.parse(config.toJSON()).request,
      filters: skipFilters ? void 0 : getFilters()
    };
  }
  function getFilters() {
    return { included: $includedJson };
  }
  function save() {
    set_store_value(model, $model.name = $uri.host, $model);
    set_store_value(
      model,
      $model.prefs = {
        ...model.prefs,
        schema: generateSchemaFromJSON(get_store_value(stores.previewJson))
      },
      $model
    );
    set_store_value(config, $config = getConfig(), $config);
    dispatch("save");
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    expanded = this.checked;
    $$invalidate(2, expanded);
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
  };
  return [
    formModel,
    outputPromise,
    expanded,
    errorred,
    $originalJson,
    model,
    uri,
    config,
    stores,
    includedJson,
    originalJson,
    fetchData,
    save,
    click_handler,
    input_change_handler
  ];
}
class Json extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$38, create_fragment$3c, safe_not_equal, { formModel: 0 });
  }
}
function create_fragment$3b(ctx) {
  let h3;
  let a;
  let t0_value = ctx[0].title + "";
  let t0;
  let a_href_value;
  let t1;
  let div;
  let t2_value = (ctx[0].description || ctx[0].summary || "") + "";
  let t2;
  let t3;
  let feedlist;
  let current;
  feedlist = new FeedList({
    props: { feedItems: ctx[0].entries }
  });
  return {
    c() {
      h3 = element("h3");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      div = element("div");
      t2 = text(t2_value);
      t3 = space();
      create_component(feedlist.$$.fragment);
      attr(a, "href", a_href_value = ctx[0].link);
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener noreferrer");
      attr(div, "class", "pb2 mb2 bb b--black-20");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, a);
      append(a, t0);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      append(div, t2);
      insert(target, t3, anchor);
      mount_component(feedlist, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].title + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 1 && a_href_value !== (a_href_value = ctx2[0].link)) {
        attr(a, "href", a_href_value);
      }
      if ((!current || dirty & 1) && t2_value !== (t2_value = (ctx2[0].description || ctx2[0].summary || "") + ""))
        set_data(t2, t2_value);
      const feedlist_changes = {};
      if (dirty & 1)
        feedlist_changes.feedItems = ctx2[0].entries;
      feedlist.$set(feedlist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(feedlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(feedlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      if (detaching)
        detach(t3);
      destroy_component(feedlist, detaching);
    }
  };
}
function instance$37($$self, $$props, $$invalidate) {
  let { feed } = $$props;
  $$self.$$set = ($$props2) => {
    if ("feed" in $$props2)
      $$invalidate(0, feed = $$props2.feed);
  };
  return [feed];
}
class Feed extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$37, create_fragment$3b, safe_not_equal, { feed: 0 });
  }
}
function get_each_context$T(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2].href;
  child_ctx[23] = list[i2].title;
  return child_ctx;
}
function create_if_block_4$o(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[1]);
      attr(div, "class", "xmsg inline-block my-[5px] px-[5px]");
      toggle_class(div, "xerror", ctx[3]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
      if (dirty & 8) {
        toggle_class(div, "xerror", ctx2[3]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$1c(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return create_if_block_2$L;
    if (ctx2[4])
      return create_if_block_3$B;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "xtbar my-4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block) {
        if_block.d();
      }
    }
  };
}
function create_if_block_3$B(ctx) {
  let each_1_anchor;
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$T(get_each_context$T(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1028) {
        each_value = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$T(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$T(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_2$L(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${TXT("a_select")}`;
      attr(button, "class", "btn btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[11]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$T(ctx) {
  let button;
  let t0_value = TXT("Load feed") + "";
  let t0;
  let t1;
  let t2_value = ctx[23] + "";
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[12](ctx[22]);
  }
  return {
    c() {
      button = element("button");
      t0 = text(t0_value);
      t1 = text(" - ");
      t2 = text(t2_value);
      attr(button, "class", "btn btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4 && t2_value !== (t2_value = ctx[23] + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1N(ctx) {
  let feed_1;
  let current;
  feed_1 = new Feed({ props: { feed: ctx[5] } });
  return {
    c() {
      create_component(feed_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(feed_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const feed_1_changes = {};
      if (dirty & 32)
        feed_1_changes.feed = ctx2[5];
      feed_1.$set(feed_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(feed_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(feed_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(feed_1, detaching);
    }
  };
}
function create_fragment$3a(ctx) {
  let requesteditor;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  requesteditor = new RequestEditor({
    props: {
      formModel: ctx[0],
      placeholder: TXT("m_enter_feed_url")
    }
  });
  requesteditor.$on("go", ctx[9]);
  let if_block0 = ctx[1] && create_if_block_4$o(ctx);
  let if_block1 = (ctx[5] || ctx[4]) && create_if_block_1$1c(ctx);
  let if_block2 = ctx[5] && create_if_block$1N(ctx);
  return {
    c() {
      create_component(requesteditor.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const requesteditor_changes = {};
      if (dirty & 1)
        requesteditor_changes.formModel = ctx2[0];
      requesteditor.$set(requesteditor_changes);
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4$o(ctx2);
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[5] || ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$1c(ctx2);
          if_block1.c();
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[5]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$1N(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function instance$36($$self, $$props, $$invalidate) {
  let $config;
  let $model;
  let $uri;
  let { formModel } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(14, $model = value));
  const { uri, config } = formModel.fields;
  component_subscribe($$self, uri, (value) => $$invalidate(15, $uri = value));
  component_subscribe($$self, config, (value) => $$invalidate(13, $config = value));
  const dispatch = createEventDispatcher();
  let msg = "";
  let feedLinks = [];
  let errorred = false;
  let showFeedLinks = false;
  let feed;
  async function fetchResource(url) {
    if (Supports.agents.local) {
      const options = {
        url,
        headers: {
          "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
        }
      };
      return await serviceProxy.HTTP.get(options);
    } else {
      const htmlContent = await Api.utils(`/datasources/${C$1.DS_ID_TEXT}/fetch`, "POST", {
        name: $uri.host,
        uri: $uri.toJSON(),
        config: { request: $config.request }
      });
      const contentType = htmlContent.headers["content-type"].split(";")[0];
      if (contentType === "text/html" || contentType === "application/xhtml+xml") {
        return {
          response: htmlContent.text,
          headers: htmlContent.headers
        };
      } else {
        const response = await Api.utils(`/v1/http/get?url=${encodeURIComponent(url)}`, "GET", { config: { request: $config.request } });
        return { response, headers: Api.headers };
      }
    }
  }
  async function loadURL() {
    resetMsg();
    $$invalidate(4, showFeedLinks = false);
    $$invalidate(5, feed = void 0);
    setMsg(TXT("l_loading"));
    let xhrObj;
    try {
      xhrObj = await fetchResource(uri.toJSON());
    } catch (e) {
      setError(e.message || TXT("e_load_source"));
      return;
    }
    let response = xhrObj.response;
    let contentType = xhrObj.headers["content-type"];
    contentType = contentType.split(";")[0];
    switch (contentType) {
      case "text/html":
      case "application/xhtml+xml":
        setMsg(TXT("m_feed_finding"));
        const parser = new DOMParser();
        let doc = parser.parseFromString(response, contentType);
        if (!doc) {
          const htmlFragment = response.match(/<link.*\/>/gim).join("");
          doc = parser.parseFromString(htmlFragment, contentType);
        }
        try {
          $$invalidate(2, feedLinks = findFeeds(doc));
          if (feedLinks.length === 0) {
            setError(TXT("e_feed_in_page_na"));
          } else if (feedLinks.length === 1) {
            uri.set(feedLinks[0].href, { parse: true });
            return loadURL();
          } else {
            setMsg(TXT("m_feed_multi_selection"));
            $$invalidate(4, showFeedLinks = true);
          }
        } catch (e) {
        }
        break;
      case "application/xml":
      case "text/xml":
      case "application/rss+xml":
      case "application/atom+xml":
        setMsg("Parsing feed..");
        try {
          if (Supports.agents.local) {
            let result2 = await serviceProxy.Feed.fromString(response, uri.toJSON());
            $$invalidate(5, feed = JSON.parse(JSON.stringify(result2)));
          } else {
            $$invalidate(5, feed = JSON.parse(response));
          }
          resetMsg();
          $$invalidate(4, showFeedLinks = false);
        } catch (e) {
          console.error(e);
          setError(`${TXT("m_try_later")} ${TXT("e_load_source")}`);
        }
        break;
      default:
        setError(SPRINTF("e_unknown_content_type", contentType));
        break;
    }
  }
  function findFeeds(htmlDoc) {
    if (!htmlDoc) {
      throw {
        code: "NULL",
        msg: "HTML document is null"
      };
    }
    const result2 = htmlDoc.querySelectorAll('link[type="application/rss+xml"],link[type="application/atom+xml"]');
    return Array.from(result2).map((link) => ({
      title: link.getAttribute("title"),
      href: new URL(link.getAttribute("href"), uri.toJSON()).href
    }));
  }
  function resetMsg() {
    $$invalidate(1, msg = "");
    $$invalidate(3, errorred = false);
  }
  function setMsg(message) {
    $$invalidate(1, msg = message);
  }
  function setError(error2) {
    $$invalidate(1, msg = error2);
    $$invalidate(3, errorred = true);
  }
  function showFeed(link) {
    uri.set(link, { parse: true });
    loadURL();
  }
  function save() {
    set_store_value(model, $model.name = feed.title, $model);
    set_store_value(config, $config.uri = uri.toJSON(), $config);
    uri.set(feed.link, { parse: true });
    dispatch("save");
  }
  const click_handler = (href2) => showFeed(href2);
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
  };
  return [
    formModel,
    msg,
    feedLinks,
    errorred,
    showFeedLinks,
    feed,
    model,
    uri,
    config,
    loadURL,
    showFeed,
    save,
    click_handler
  ];
}
class Feed_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$36, create_fragment$3a, safe_not_equal, { formModel: 0 });
  }
}
function create_else_block$_(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "PDF monitoring is available to Flexi and Enterprise customers only. Please upgrade your account or contact support\n    for more information.";
      attr(div, "class", "alert alert-info");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$1M(ctx) {
  let requesteditor;
  let current;
  requesteditor = new RequestEditor({
    props: {
      placeholder: TXT("m_enter_pdf_url"),
      formModel: ctx[0],
      label: ctx[1]
    }
  });
  requesteditor.$on("go", ctx[5]);
  return {
    c() {
      create_component(requesteditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const requesteditor_changes = {};
      if (dirty & 1)
        requesteditor_changes.formModel = ctx2[0];
      if (dirty & 2)
        requesteditor_changes.label = ctx2[1];
      requesteditor.$set(requesteditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
    }
  };
}
function create_fragment$39(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1M, create_else_block$_];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a;
    if ((_a = ctx2[2].constraint) == null ? void 0 : _a.flexi)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$35($$self, $$props, $$invalidate) {
  let $model;
  let $user;
  let { formModel } = $$props;
  let { label = "Save" } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(6, $model = value));
  const { uri } = formModel.fields;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(2, $user = value));
  const dispatch = createEventDispatcher();
  function save() {
    const name = uri.toJSON().split("/").at(-1);
    set_store_value(model, $model.name = name + (name.match(/\.pdf$/) ? "" : " pdf"), $model);
    dispatch("save");
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  return [formModel, label, $user, model, user, save];
}
class Pdf extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$35, create_fragment$39, safe_not_equal, { formModel: 0, label: 1 });
  }
}
function create_else_block$Z(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Doc monitoring is available to Flexi and Enterprise customers only. Please upgrade your account or contact support\n    for more information.";
      attr(div, "class", "alert alert-info");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$1L(ctx) {
  let requesteditor;
  let current;
  requesteditor = new RequestEditor({
    props: {
      placeholder: TXT("m_enter_doc_url"),
      formModel: ctx[0],
      label: ctx[1]
    }
  });
  requesteditor.$on("go", ctx[5]);
  return {
    c() {
      create_component(requesteditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const requesteditor_changes = {};
      if (dirty & 1)
        requesteditor_changes.formModel = ctx2[0];
      if (dirty & 2)
        requesteditor_changes.label = ctx2[1];
      requesteditor.$set(requesteditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
    }
  };
}
function create_fragment$38(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1L, create_else_block$Z];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a;
    if ((_a = ctx2[2].constraint) == null ? void 0 : _a.flexi)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$34($$self, $$props, $$invalidate) {
  let $model;
  let $user;
  let { formModel } = $$props;
  let { label = "Save" } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(6, $model = value));
  const { uri } = formModel.fields;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(2, $user = value));
  const dispatch = createEventDispatcher();
  function save() {
    const name = uri.toJSON().split("/").at(-1);
    set_store_value(model, $model.name = name + (name.match(/\.docx?$/) ? "" : " doc"), $model);
    dispatch("save");
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
  };
  return [formModel, label, $user, model, user, save];
}
class Doc extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$34, create_fragment$38, safe_not_equal, { formModel: 0, label: 1 });
  }
}
function create_if_block_1$1b(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[2]);
      attr(div, "class", "xmsg inline-block my-[5px] px-[5px]");
      toggle_class(div, "xerror", ctx[3]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
      if (dirty & 8) {
        toggle_class(div, "xerror", ctx2[3]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$1K(ctx) {
  let div;
  let button;
  let t1;
  let pre;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = `${TXT("a_select")}`;
      t1 = space();
      pre = element("pre");
      t2 = text(ctx[1]);
      attr(button, "class", "btn btn-primary");
      attr(div, "class", "xtbar my-3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      insert(target, t1, anchor);
      insert(target, pre, anchor);
      append(pre, t2);
      if (!mounted) {
        dispose = listen(button, "click", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t2, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(pre);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$37(ctx) {
  let requesteditor;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  requesteditor = new RequestEditor({
    props: { formModel: ctx[0] }
  });
  requesteditor.$on("go", ctx[8]);
  let if_block0 = ctx[2] && create_if_block_1$1b(ctx);
  let if_block1 = ctx[1] && create_if_block$1K(ctx);
  return {
    c() {
      create_component(requesteditor.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const requesteditor_changes = {};
      if (dirty & 1)
        requesteditor_changes.formModel = ctx2[0];
      requesteditor.$set(requesteditor_changes);
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$1b(ctx2);
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$1K(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$33($$self, $$props, $$invalidate) {
  let $model;
  let $config;
  let $uri;
  let { formModel } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(9, $model = value));
  const { uri, config } = formModel.fields;
  component_subscribe($$self, uri, (value) => $$invalidate(11, $uri = value));
  component_subscribe($$self, config, (value) => $$invalidate(10, $config = value));
  const dispatch = createEventDispatcher();
  let xml;
  let msg;
  let errorred = false;
  async function fetchResource() {
    const response = await Api.utils(`/datasources/${C$1.DS_ID_TEXT}/fetch`, "POST", {
      name: $uri.host,
      uri: $uri.toJSON(),
      config: { request: $config.request }
    });
    if (response.headers) {
      return response;
    }
    return { text: response, headers: Api.headers };
  }
  function onXML(str) {
    const xmlEl = new DOMParser().parseFromString(str, "text/xml");
    if (!xmlEl) {
      setError("Failed to parse XML");
    } else {
      $$invalidate(1, xml = str);
      resetMsg();
    }
  }
  function save() {
    const name = uri.toJSON().split("/").at(-1);
    set_store_value(model, $model.name = name + (name.match(/\.xml$/) ? "" : " xml"), $model);
    dispatch("save");
  }
  async function loadXML() {
    $$invalidate(1, xml = void 0);
    resetMsg();
    setMsg(TXT("l_loading"));
    try {
      const xhrObj = await fetchResource();
      let { text: text2 } = xhrObj;
      if (text2.nodeType === Node.DOCUMENT_NODE) {
        text2 = text2.documentElement.outerHTML;
      }
      setMsg("Parsing xml...");
      onXML(text2);
    } catch (e) {
      console.error(e);
      setError(TXT("e_load_source"));
    }
  }
  function setMsg(message) {
    $$invalidate(2, msg = message);
  }
  function setError(err) {
    $$invalidate(2, msg = err);
    $$invalidate(3, errorred = true);
  }
  function resetMsg() {
    $$invalidate(2, msg = "");
    $$invalidate(3, errorred = false);
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
  };
  return [formModel, xml, msg, errorred, model, uri, config, save, loadXML];
}
class Xml extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$33, create_fragment$37, safe_not_equal, { formModel: 0 });
  }
}
function get_each_context$S(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function create_each_block$S(ctx) {
  let a;
  let div0;
  let t0;
  let div1;
  let t1_value = ctx[5].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[3](ctx[5]);
  }
  return {
    c() {
      a = element("a");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      attr(div0, "class", "ba h-[8px]");
      attr(a, "href", "javascript:void(0)");
      attr(a, "class", "flex flex-col items-center");
      set_style(a, "width", "0");
      set_style(a, "margin-left", ctx[5].margin + "%");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, div0);
      append(a, t0);
      append(a, div1);
      append(div1, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t1_value !== (t1_value = ctx[5].label + ""))
        set_data(t1, t1_value);
      if (dirty & 1) {
        set_style(a, "margin-left", ctx[5].margin + "%");
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$36(ctx) {
  let div;
  let div_class_value;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$S(get_each_context$S(ctx, each_value, i2));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", div_class_value = "flex " + ctx[1] + " mx-[4px]");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 5) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$S(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$S(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2 && div_class_value !== (div_class_value = "flex " + ctx2[1] + " mx-[4px]")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$32($$self, $$props, $$invalidate) {
  let { ticks } = $$props;
  const dispatch = createEventDispatcher();
  let { class: classes = "" } = $$props;
  calcMargin();
  function calcMargin() {
    let lastMargin = 0;
    for (let tick2 of ticks) {
      tick2.margin = tick2.value - lastMargin;
      lastMargin = tick2.value;
    }
  }
  const click_handler = (tick2) => dispatch("click", tick2);
  $$self.$$set = ($$props2) => {
    if ("ticks" in $$props2)
      $$invalidate(0, ticks = $$props2.ticks);
    if ("class" in $$props2)
      $$invalidate(1, classes = $$props2.class);
  };
  return [ticks, classes, dispatch, click_handler];
}
class TickBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$32, create_fragment$36, safe_not_equal, { ticks: 0, class: 1 });
  }
}
function create_fragment$35(ctx) {
  let div;
  let input;
  let t;
  let tickbar;
  let current;
  let mounted;
  let dispose;
  tickbar = new TickBar({ props: { ticks: ctx[1] } });
  tickbar.$on("click", ctx[3]);
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      create_component(tickbar.$$.fragment);
      attr(input, "type", "range");
      attr(div, "class", "flex flex-col items-stretch w-full");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[0]);
      append(div, t);
      mount_component(tickbar, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[4]),
          listen(input, "input", ctx[4]),
          listen(input, "change", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        set_input_value(input, ctx2[0]);
      }
      const tickbar_changes = {};
      if (dirty & 2)
        tickbar_changes.ticks = ctx2[1];
      tickbar.$set(tickbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tickbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tickbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(tickbar);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$31($$self, $$props, $$invalidate) {
  let { ticks } = $$props;
  let { value } = $$props;
  const dispatch = createEventDispatcher();
  function updateValue(e) {
    const tick2 = e.detail;
    $$invalidate(0, value = tick2.value);
    dispatch("change", value);
  }
  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  const change_handler = (e) => dispatch("change", e.target.valueAsNumber);
  $$self.$$set = ($$props2) => {
    if ("ticks" in $$props2)
      $$invalidate(1, ticks = $$props2.ticks);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [
    value,
    ticks,
    dispatch,
    updateValue,
    input_change_input_handler,
    change_handler
  ];
}
class Slider extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$31, create_fragment$35, safe_not_equal, { ticks: 1, value: 0 });
  }
}
function create_if_block$1J(ctx) {
  let span1;
  let span0;
  let t0_value = TXT("h_schedule_constraint_1") + "";
  let t0;
  let t1;
  let t2_value = TXT(formatInterval(ctx[3].constraint.interval, false)) + "";
  let t2;
  let t3;
  let br;
  let t4_value = TXT("h_schedule_constraint_2") + "";
  let t4;
  let t5;
  let a;
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = text(".");
      br = element("br");
      t4 = text(t4_value);
      t5 = space();
      a = element("a");
      a.textContent = "Upgrade Account";
      attr(a, "href", "https://distill.io/pricing/");
      attr(a, "target", "_blank");
      attr(span0, "class", "error");
      attr(span1, "class", "help");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, span0);
      append(span0, t0);
      append(span0, t1);
      append(span0, t2);
      append(span0, t3);
      append(span0, br);
      append(span0, t4);
      append(span0, t5);
      append(span0, a);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t2_value !== (t2_value = TXT(formatInterval(ctx2[3].constraint.interval, false)) + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(span1);
    }
  };
}
function create_fragment$34(ctx) {
  let div;
  let slider;
  let updating_value;
  let t0;
  let input;
  let t1;
  let t2;
  let p;
  let current;
  let mounted;
  let dispose;
  function slider_value_binding(value) {
    ctx[15](value);
  }
  let slider_props = { class: "flex-1", ticks: ctx[6] };
  if (ctx[0] !== void 0) {
    slider_props.value = ctx[0];
  }
  slider = new Slider({ props: slider_props });
  binding_callbacks.push(() => bind$1(slider, "value", slider_value_binding));
  slider.$on("change", ctx[9]);
  let if_block = ctx[2] && create_if_block$1J(ctx);
  return {
    c() {
      div = element("div");
      create_component(slider.$$.fragment);
      t0 = space();
      input = element("input");
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      p = element("p");
      p.textContent = `${TXT("h_schedule_interval")}`;
      attr(input, "class", "xschdlr-input self-start");
      input.value = ctx[1];
      attr(div, "class", "flex min-w-[420px]");
      attr(p, "class", "help");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(slider, div, null);
      append(div, t0);
      append(div, input);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t2, anchor);
      insert(target, p, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const slider_changes = {};
      if (!updating_value && dirty & 1) {
        updating_value = true;
        slider_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      slider.$set(slider_changes);
      if (!current || dirty & 2 && input.value !== ctx2[1]) {
        input.value = ctx2[1];
      }
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1J(ctx2);
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(slider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(slider);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(p);
      mounted = false;
      dispose();
    }
  };
}
function instance$30($$self, $$props, $$invalidate) {
  let $schedule;
  let $model;
  let $user;
  let { formModel } = $$props;
  let { minInt } = $$props;
  let { MIN = 5 } = $$props;
  let { MAX = 3600 * 24 * 30 } = $$props;
  let { schedules = [
    { value: MIN, label: "5s" },
    { value: 30, label: "30s" },
    { value: 300, label: "5m" },
    { value: 3600, label: "1h" },
    { value: 3600 * 24, label: "1d" },
    { value: MAX, label: "Never" }
  ] } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(17, $model = value));
  const { schedule } = formModel.fields;
  component_subscribe($$self, schedule, (value) => $$invalidate(16, $schedule = value));
  const ticks = schedules.map(scheduleToTick);
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(3, $user = value));
  const dispatch = createEventDispatcher();
  let sliderValue = valueToPct($schedule.params.interval);
  let inputValue = getShortDisplayText($schedule);
  let showError;
  function scheduleToTick({ value, label }) {
    return { label, value: valueToPct(value) };
  }
  function valueToPct(v) {
    if (!v) {
      return 100;
    }
    return 100 * Math.log(v / MIN) / Math.log(MAX / MIN);
  }
  function pctToValue(pct) {
    return Math.round(Math.pow(Math.E, pct / 100 * Math.log(MAX / MIN)) * MIN);
  }
  function updateValue(seconds) {
    if ($model.client_id == ModelClient.Clients.webAppId && seconds < minInt) {
      set_store_value(schedule, $schedule.params.interval = minInt, $schedule);
      $$invalidate(2, showError = true);
    } else {
      set_store_value(schedule, $schedule.params.interval = seconds, $schedule);
      $$invalidate(2, showError = false);
    }
    $$invalidate(1, inputValue = getShortDisplayText($schedule));
    $$invalidate(0, sliderValue = valueToPct($schedule.params.interval));
    dispatch("change", $schedule);
  }
  function textInputChanged(e) {
    const seconds = getInterval$1(e.target.value, "m", 3600);
    updateValue(seconds);
  }
  function sliderMoved(e) {
    const seconds = pctToValue(e.detail);
    updateValue(seconds);
  }
  function slider_value_binding(value) {
    sliderValue = value;
    $$invalidate(0, sliderValue);
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(10, formModel = $$props2.formModel);
    if ("minInt" in $$props2)
      $$invalidate(11, minInt = $$props2.minInt);
    if ("MIN" in $$props2)
      $$invalidate(12, MIN = $$props2.MIN);
    if ("MAX" in $$props2)
      $$invalidate(13, MAX = $$props2.MAX);
    if ("schedules" in $$props2)
      $$invalidate(14, schedules = $$props2.schedules);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2049) {
      updateValue(pctToValue(sliderValue));
    }
  };
  return [
    sliderValue,
    inputValue,
    showError,
    $user,
    model,
    schedule,
    ticks,
    user,
    textInputChanged,
    sliderMoved,
    formModel,
    minInt,
    MIN,
    MAX,
    schedules,
    slider_value_binding
  ];
}
class IntervalScheduleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$30, create_fragment$34, safe_not_equal, {
      formModel: 10,
      minInt: 11,
      MIN: 12,
      MAX: 13,
      schedules: 14
    });
  }
}
const WEEKS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
const MONTHS = ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
class Unit {
  constructor(options) {
    this.min = 0;
    this.SYMBOL_INDEX = {};
    Object.assign(this, options);
  }
  possilbeValues() {
    let possilbeValuesList = [];
    for (let i2 = 0; i2 <= 59; i2++) {
      possilbeValuesList.push(i2);
    }
    return possilbeValuesList;
  }
  symbolToIndex(symbol) {
    let index2 = this.SYMBOL_INDEX[symbol];
    if (index2 == null) {
      throw new Error(`Invalid symbol ${symbol} for ${this.type}`);
    }
    return index2;
  }
  getName(index2) {
    if (index2 < this.min || index2 > this.max) {
      throw new Error(`${index2} out of range for ${this.type}, it should be in [${this.min}-${this.max}]`);
    }
    return this.indexToName(index2);
  }
  indexToName(index2) {
    return index2 + "";
  }
}
const YEAR = new Unit({
  type: "year",
  min: 1970,
  max: 2099
});
const MINUTE = new Unit({
  type: "minute",
  max: 59,
  prefix: "At"
});
const HOUR = new Unit({
  type: "hour",
  max: 23,
  prefix: "past"
});
const DO_MONTH = new Unit({
  type: "day-of-month",
  min: 1,
  max: 31,
  prefix: "on"
});
const MONTH = new Unit({
  type: "month",
  min: 1,
  max: 12,
  SYMBOL_INDEX: {
    "JAN": 1,
    "FEB": 2,
    "MAR": 3,
    "APR": 4,
    "MAY": 5,
    "JUN": 6,
    "JUL": 7,
    "AUG": 8,
    "SEP": 9,
    "OCT": 10,
    "NOV": 11,
    "DEC": 12
  },
  prefix: "in",
  indexToName(index2) {
    return MONTHS[index2];
  }
});
const DO_WEEK = new Unit({
  type: "day-of-week",
  max: 6,
  SYMBOL_INDEX: {
    "SUN": 0,
    "MON": 1,
    "TUE": 2,
    "WED": 3,
    "THU": 4,
    "FRI": 5,
    "SAT": 6
  },
  prefix: "on",
  indexToName(index2) {
    return WEEKS[index2];
  }
});
class Value {
  constructor(unit, expr) {
    this.step = 1;
    this.expr = expr;
    this.unit = unit;
    if (expr.includes("/")) {
      let parts = expr.split("/");
      if (parts.length != 2) {
        throw new Error(`Unexpected number of steps for ${this.unit.type}`);
      }
      let range2 = parts[0];
      let step = parts[1];
      this.step = parseIntAndValidate(step, `Unexpected step format for ${this.unit.type}`);
      this.parseRange(range2);
    } else {
      this.parseRange(expr);
    }
  }
  getTicks() {
    let listOfElements = [];
    for (let i2 = this.unit.min; i2 <= this.unit.max; i2 = i2 + this.step) {
      listOfElements.push(i2);
    }
    return listOfElements;
  }
  getDescription() {
    return `every ${this.unit.type}`;
  }
}
class Star extends Value {
  constructor(unit, expr) {
    super(unit, expr);
  }
  next(current) {
    return next(current, this.unit.min, this.step, this.unit.max);
  }
  getTicks() {
    let listOfElements = [];
    for (let i2 = this.unit.min; i2 <= this.unit.max; i2 = i2 + this.step) {
      listOfElements.push(i2);
    }
    return listOfElements;
  }
  getDescription() {
    let ordinal = this.step > 1 ? `${this.step}${getOrdinal(this.step)} ` : "";
    return `every ${ordinal}${this.unit.type}`;
  }
  parseRange(expr) {
    if (expr != "*") {
      throw new Error(`Unexpected format of Any value for ${this.unit.type}`);
    }
  }
}
class Range extends Value {
  constructor(unit, expr) {
    super(unit, expr);
  }
  next(current) {
    return next(current, this.start, this.step, this.end);
  }
  getTicks() {
    let listOfElements = [];
    for (let i2 = this.start; i2 <= this.end; i2 = i2 + this.step) {
      listOfElements.push(i2);
    }
    return listOfElements;
  }
  getDescription() {
    let ordinal = this.step > 1 ? `${this.step}${getOrdinal(this.step)} ` : "";
    return `every ${ordinal}${this.unit.type} from ${this.unit.getName(this.start)} through ${this.unit.getName(this.end)}`;
  }
  parseRange(expr) {
    let range2 = expr.split("-");
    if (range2.length == 2) {
      this.start = parseIntAndValidate(range2[0], `Unexpected format of start value of range for ${this.unit.type}`);
      this.end = parseIntAndValidate(range2[1], `Unexpected format of end value of range for ${this.unit.type}`);
      if (this.start < this.unit.min || this.start > this.unit.max) {
        throw new Error(`Start value of range for ${this.unit.type} out of range: Correct Range: [${this.unit.min} - ${this.unit.max}]`);
      } else if (this.end < this.unit.min || this.end > this.unit.max) {
        throw new Error(`End value of range for ${this.unit.type} out of range: Correct Range: [${this.unit.min} - ${this.unit.max}]`);
      } else if (this.start > this.end) {
        throw new Error(`Start value should be less or equal to End for ${this.unit.type}`);
      }
    } else {
      throw new Error(`Unexpected numbers of range values ${this.unit.type}`);
    }
  }
}
class Single extends Value {
  constructor(unit, expr) {
    super(unit, expr);
  }
  next(current) {
    if (this.step == 1) {
      return [this.value, current > this.value];
    }
    return next(current, this.value, this.step, this.unit.max);
  }
  getTicks() {
    let listOfElements = [];
    if (this.step == 1) {
      listOfElements.push(this.value);
    } else {
      for (let i2 = this.value; i2 <= this.unit.max; i2 = i2 + this.step) {
        listOfElements.push(i2);
      }
    }
    return listOfElements;
  }
  getDescription() {
    let start = this.unit.getName(this.value);
    if (this.step == 1) {
      return `${start}`;
    } else {
      let ordinal = `${this.step}${getOrdinal(this.step)} `;
      return `every ${ordinal}${this.unit.type} from ${start} through ${this.unit.getName(this.unit.max)}`;
    }
  }
  parseRange(expr) {
    let numVal = parseInt(expr);
    if (!isNaN(numVal)) {
      this.value = numVal;
    } else {
      let symbolValue = this.unit.SYMBOL_INDEX[expr.toUpperCase()];
      if (symbolValue == null) {
        throw new Error(`Unexpected value for ${this.unit.type}`);
      } else {
        this.value = symbolValue;
      }
    }
    if (this.value < this.unit.min || this.value > this.unit.max) {
      throw new Error(`Value for ${this.unit.type} out of range: Correct Range: [${this.unit.min} - ${this.unit.max}]`);
    }
  }
}
function getOrdinal(step) {
  switch (step) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
    default:
      return "th";
  }
}
function next(current, start, step, max2) {
  if (current < start) {
    return [start, false];
  }
  if (current > max2) {
    return [start, true];
  }
  current -= start;
  let mod = current % step;
  let next2 = start + current + (mod == 0 ? 0 : step - mod);
  let overflow = next2 > max2;
  return [overflow ? start : next2, overflow];
}
function parseIntAndValidate(number, err) {
  let num = parseInt(number);
  if (isNaN(num)) {
    throw new Error(err);
  } else {
    return num;
  }
}
const INDEX_TO_UNIT = {
  0: MINUTE,
  1: HOUR,
  2: DO_MONTH,
  3: MONTH,
  4: DO_WEEK
};
class Cron {
  constructor(str) {
    this.components = {
      minute: [],
      hour: [],
      dom: [],
      month: [],
      dow: []
    };
    this.starDOM = false;
    this.starDOW = false;
    str = str.trim();
    this.expr = str;
    this.parse();
  }
  _next(year, month, dom, hour, minute) {
    let [oYear, nYear] = nextForUnitValues(this.yearComponents, year);
    if (oYear) {
      throw new Error("Unexpected Error");
    }
    if (year != nYear) {
      return this._next(nYear, 0, 1, 0, 0);
    }
    let [oMonth, nMonth] = nextForUnitValues(this.components.month, month + 1);
    nMonth--;
    if (month != nMonth) {
      return this._next(nYear + (oMonth ? 1 : 0), oMonth ? 0 : nMonth, 1, 0, 0);
    }
    let [oDOMon, nDOMon] = nextForUnitValues(this.components.dom, dom);
    if (this.starDOW || this.starDOM) {
      if (dom != nDOMon) {
        return this._next(nYear, nMonth + (oDOMon ? 1 : 0), oDOMon ? 0 : nDOMon, 0, 0);
      }
      let dayOfWeek = new Date(nYear, nMonth, nDOMon, 0, 0).getDay();
      let [oDOW, nDOW] = nextForUnitValues(this.components.dow, dayOfWeek);
      if (nDOW != dayOfWeek) {
        return this._next(nYear, nMonth, nDOMon + 1, 0, 0);
      }
    } else {
      let dayOfWeek = new Date(year, month, dom, 0, 0).getDay();
      let [oDOW, nDOW] = nextForUnitValues(this.components.dow, dayOfWeek);
      if (nDOMon != dom && dayOfWeek != nDOW) {
        let nextDate = new Date(nYear, nMonth, dom + 1);
        return this._next(nextDate.getFullYear(), nextDate.getMonth(), nextDate.getDate(), 0, 0);
      }
      nDOMon = dayOfWeek == nDOW ? dom : nDOMon;
    }
    let [oHour, nHour] = nextForUnitValues(this.components.hour, hour);
    if (hour != nHour) {
      return this._next(nYear, nMonth, nDOMon + (oHour ? 1 : 0), oHour ? 0 : nHour, 0);
    }
    let [oMinute, nMinute] = nextForUnitValues(this.components.minute, minute);
    if (minute != nMinute) {
      return this._next(nYear, nMonth, nDOMon, nHour + (oMinute ? 1 : 0), oMinute ? 0 : nMinute);
    }
    return [nYear, nMonth, nDOMon, nHour, nMinute];
  }
  next(last2 = new Date(), offSetMin = new Date().getTimezoneOffset()) {
    let serverOffSet = new Date().getTimezoneOffset();
    let offSetDelta = (offSetMin - serverOffSet) * 60 * 1e3;
    last2 = new Date(last2.valueOf() - offSetDelta);
    let year = last2.getFullYear();
    let month = last2.getMonth();
    let dom = last2.getDate();
    let hour = last2.getHours();
    let minute = last2.getMinutes();
    this.yearComponents = [new Range(YEAR, `${year}-${year + 1}`)];
    let nextValues = this._next(year, month, dom, hour, minute + 1);
    let nextDate = new Date(...nextValues);
    return new Date(nextDate.valueOf() + offSetDelta);
  }
  parse() {
    this.parts = this.expr.split(/\s+/g);
    if (this.parts.length != 5) {
      throw new Error(`Unexpected number of arguments in cron expression`);
    }
    let components = [];
    for (let i2 = 0; i2 < this.parts.length; i2++) {
      let component = [];
      let componentList = this.parts[i2].split(",");
      for (let j = 0; j < componentList.length; j++) {
        let element2 = componentList[j];
        let range2 = element2.split("/")[0];
        if (range2.includes("-")) {
          component.push(new Range(INDEX_TO_UNIT[i2], element2));
        } else if (range2 == "*") {
          component.push(new Star(INDEX_TO_UNIT[i2], element2));
          this.starDOM = i2 == 2 ? true : this.starDOM;
          this.starDOW = i2 == 4 ? true : this.starDOW;
        } else {
          component.push(new Single(INDEX_TO_UNIT[i2], element2));
        }
      }
      components.push(component);
    }
    let _i = 0;
    for (let key in this.components) {
      this.components[key] = components[_i++];
    }
  }
  getDescription() {
    let description = "";
    let descriptionArr = [];
    let _i = 0;
    for (let i2 in this.components) {
      let component = this.components[i2];
      let componentDescription = "";
      let componentDescriptionArr = [];
      for (let j = 0; j < component.length; j++) {
        if (component[j].constructor.name == "Star" && i2 != "minute" && !component[j].expr.includes("/") && component.length == 1) {
          componentDescriptionArr.push("");
        } else {
          componentDescriptionArr.push(component[j].getDescription());
        }
      }
      if (componentDescriptionArr.length > 1) {
        let last2 = componentDescriptionArr.pop();
        componentDescription = `${componentDescriptionArr.join(", ")} and ${last2}`;
      } else {
        componentDescription = componentDescriptionArr[0];
      }
      if (componentDescription) {
        descriptionArr.push(INDEX_TO_UNIT[_i].prefix);
        descriptionArr.push(componentDescription);
      }
      _i++;
    }
    description = descriptionArr.join(" ") + ".";
    return description;
  }
  getList() {
    let componentObj = {
      minute: [],
      hour: [],
      dom: [],
      month: [],
      dow: []
    };
    let components = [];
    for (let i2 in this.components) {
      let component = this.components[i2];
      let componentSet = /* @__PURE__ */ new Set();
      for (let j = 0; j < component.length; j++) {
        let ticks = component[j].getTicks();
        for (let k = 0; k < ticks.length; k++) {
          componentSet.add(ticks[k]);
        }
      }
      let componentList = Array.from(componentSet).sort(function(a, b) {
        return a - b;
      });
      components.push(componentList);
    }
    let _i = 0;
    for (let key in componentObj) {
      componentObj[key] = components[_i++];
    }
    return componentObj;
  }
}
function nextForUnitValues(unitValues, current) {
  let minNext = Infinity, minStartOnOverflow = Infinity;
  for (let i2 = 0; i2 < unitValues.length; i2++) {
    let unitValue = unitValues[i2];
    let [next2, overflow] = unitValue.next(current);
    if (overflow) {
      minStartOnOverflow = Math.min(minStartOnOverflow, next2);
    } else {
      minNext = Math.min(minNext, next2);
    }
  }
  let overflowed = minNext == Infinity;
  return [overflowed, overflowed ? minStartOnOverflow : minNext];
}
function parse$1(str) {
  let cron = new Cron(str);
  return cron;
}
function get_each_context$R(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2].expr;
  child_ctx[17] = list[i2].name;
  return child_ctx;
}
function get_each_context_1$9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2][0];
  child_ctx[21] = list[i2][1];
  return child_ctx;
}
function create_each_block_1$9(ctx) {
  let div;
  let b;
  let t0_value = ctx[4][ctx[20]] + "";
  let t0;
  let t1;
  let input;
  let input_value_value;
  let input_placeholder_value;
  let mounted;
  let dispose;
  function keyup_handler(...args) {
    return ctx[9](ctx[20], ...args);
  }
  return {
    c() {
      div = element("div");
      b = element("b");
      t0 = text(t0_value);
      t1 = space();
      input = element("input");
      attr(input, "class", "w-[60px] px-[10px]");
      input.value = input_value_value = ctx[21];
      attr(input, "placeholder", input_placeholder_value = ctx[4][ctx[20]]);
      attr(div, "class", "flex flex-col");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, b);
      append(b, t0);
      append(div, t1);
      append(div, input);
      if (!mounted) {
        dispose = listen(input, "keyup", keyup_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t0_value !== (t0_value = ctx[4][ctx[20]] + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && input_value_value !== (input_value_value = ctx[21]) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      if (dirty & 2 && input_placeholder_value !== (input_placeholder_value = ctx[4][ctx[20]])) {
        attr(input, "placeholder", input_placeholder_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$R(ctx) {
  let li;
  let a;
  let t0_value = ctx[17] + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[10](ctx[16]);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "class", "dropdown-item");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$n(ctx) {
  let each_1_anchor;
  let each_value = ctx[5];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$R(get_each_context$R(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 160) {
        each_value = ctx2[5];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$R(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$R(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot$1a(ctx) {
  let div2;
  let div0;
  let t0;
  let menu;
  let t1;
  let div1;
  let t2;
  let current;
  let each_value_1 = Object.entries(ctx[1]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$9(get_each_context_1$9(ctx, each_value_1, i2));
  }
  menu = new Menu({
    props: {
      items: ctx[5],
      class: "self-center",
      defaultActionLabel: "Use Preset",
      $$slots: { default: [create_default_slot_1$n] },
      $$scope: { ctx }
    }
  });
  menu.$on("select", ctx[7]);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      create_component(menu.$$.fragment);
      t1 = space();
      div1 = element("div");
      t2 = text(ctx[0]);
      attr(div0, "class", "flex gap-6 mx-[4px]");
      attr(div1, "class", "help whitespace-normal");
      attr(div2, "class", "flex flex-col");
      toggle_class(div2, "is-invalid", ctx[15]);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div0, t0);
      mount_component(menu, div0, null);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 82) {
        each_value_1 = Object.entries(ctx2[1]);
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$9(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$9(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, t0);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      const menu_changes = {};
      if (dirty & 16777216) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (!current || dirty & 1)
        set_data(t2, ctx2[0]);
      if (!current || dirty & 32768) {
        toggle_class(div2, "is-invalid", ctx2[15]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
      destroy_component(menu);
    }
  };
}
function create_fragment$33(ctx) {
  let fieldwrapper;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[2],
      $$slots: {
        default: [
          create_default_slot$1a,
          ({ showError }) => ({ 15: showError }),
          ({ showError }) => showError ? 32768 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(fieldwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fieldwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 16809987) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldwrapper, detaching);
    }
  };
}
const DEFAULT_CRON = "0 3 * * *";
function instance$2$($$self, $$props, $$invalidate) {
  let $schedule;
  let $error;
  let { formModel } = $$props;
  const { schedule } = formModel.fields;
  component_subscribe($$self, schedule, (value) => $$invalidate(11, $schedule = value));
  const { error: error2 } = schedule;
  component_subscribe($$self, error2, (value) => $$invalidate(12, $error = value));
  const names = {
    m: "Minute",
    h: "Hour",
    dm: "Day",
    mon: "Month",
    dw: "Weekday"
  };
  const presets = [
    {
      expr: "0 9 * * 1-5",
      name: "Weekdays at 9am"
    },
    {
      expr: "0 9-17 * * 1-5",
      name: "Weekdays between 9am to 5pm"
    },
    {
      expr: "0 9 * * *",
      name: "All days at 9am"
    },
    {
      expr: "0 9-17 * * *",
      name: "All days between 9am to 5pm"
    }
  ];
  const dispatch = createEventDispatcher();
  schedule.setTouched(true);
  let desc, attrMap;
  destructureExpr();
  function destructureExpr() {
    const split = $schedule.params.expr.split(/\s/g);
    $$invalidate(1, attrMap = ["m", "h", "dm", "mon", "dw"].reduce(
      (acc, value, index2) => {
        acc[value] = split[index2];
        return acc;
      },
      {}
    ));
    $$invalidate(0, desc = parse$1($schedule.params.expr).getDescription());
  }
  function onChange(name, value) {
    const index2 = ["m", "h", "dm", "mon", "dw"].indexOf(name);
    const params2 = { ...$schedule.params };
    const { expr } = params2;
    const parts = expr.split(/\s/g);
    parts[index2] = value;
    params2.expr = parts.join(" ");
    try {
      $$invalidate(0, desc = parse$1(params2.expr).getDescription());
      set_store_value(schedule, $schedule.params = params2, $schedule);
      dispatch("change", $schedule);
    } catch (e) {
      set_store_value(error2, $error = e, $error);
      $$invalidate(0, desc = "");
      console.error("cannot parse the expression ", params2.expr, e);
    }
  }
  function onPresetClick(preset) {
    set_store_value(schedule, $schedule.params.expr = preset != null ? preset : DEFAULT_CRON, $schedule);
    dispatch("change", $schedule);
    destructureExpr();
  }
  const keyup_handler = (key, e) => onChange(key, e.target.value);
  const click_handler = (expr) => onPresetClick(expr);
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(8, formModel = $$props2.formModel);
  };
  return [
    desc,
    attrMap,
    schedule,
    error2,
    names,
    presets,
    onChange,
    onPresetClick,
    formModel,
    keyup_handler,
    click_handler
  ];
}
class CronScheduleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2$, create_fragment$33, safe_not_equal, { formModel: 8 });
  }
}
function create_if_block$1I(ctx) {
  let div;
  let t0_value = TXT("h_schedule_constraint_1") + "";
  let t0;
  let t1;
  let b;
  let t2_value = TXT(ctx[3].constraint.interval + " seconds. ") + "";
  let t2;
  let t3;
  let br;
  let t4;
  let t5_value = TXT("h_schedule_constraint_2") + "";
  let t5;
  let a;
  return {
    c() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      b = element("b");
      t2 = text(t2_value);
      t3 = space();
      br = element("br");
      t4 = space();
      t5 = text(t5_value);
      a = element("a");
      a.textContent = "Upgrade Account";
      attr(a, "href", "https://distill.io/pricing/");
      attr(a, "target", "_blank");
      attr(div, "class", "mt-2");
      set_style(div, "color", "black");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
      append(div, b);
      append(b, t2);
      append(div, t3);
      append(div, br);
      append(div, t4);
      append(div, t5);
      append(div, a);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t2_value !== (t2_value = TXT(ctx2[3].constraint.interval + " seconds. ") + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$32(ctx) {
  let div2;
  let div0;
  let span0;
  let t1;
  let input0;
  let t2;
  let div1;
  let span1;
  let t4;
  let input1;
  let t5;
  let t6;
  let p;
  let mounted;
  let dispose;
  let if_block = ctx[2].client_id === ModelClient.Clients.webAppId && create_if_block$1I(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span0 = element("span");
      span0.textContent = "Min :";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      span1 = element("span");
      span1.textContent = "Max :";
      t4 = space();
      input1 = element("input");
      t5 = space();
      if (if_block)
        if_block.c();
      t6 = space();
      p = element("p");
      p.textContent = `${TXT("h_schedule_random")}`;
      attr(input0, "type", "number");
      attr(input0, "class", "xschdlr-input");
      attr(input1, "type", "number");
      attr(input1, "class", "xschdlr-input");
      attr(div2, "class", "flex gap-8");
      attr(p, "class", "help");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span0);
      append(div0, t1);
      append(div0, input0);
      set_input_value(input0, ctx[0]);
      append(div2, t2);
      append(div2, div1);
      append(div1, span1);
      append(div1, t4);
      append(div1, input1);
      set_input_value(input1, ctx[1]);
      insert(target, t5, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t6, anchor);
      insert(target, p, anchor);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[10]),
          listen(input0, "change", ctx[7]),
          listen(input1, "input", ctx[11]),
          listen(input1, "change", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && to_number(input0.value) !== ctx2[0]) {
        set_input_value(input0, ctx2[0]);
      }
      if (dirty & 2 && to_number(input1.value) !== ctx2[1]) {
        set_input_value(input1, ctx2[1]);
      }
      if (ctx2[2].client_id === ModelClient.Clients.webAppId) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1I(ctx2);
          if_block.c();
          if_block.m(t6.parentNode, t6);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t5);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(p);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2_($$self, $$props, $$invalidate) {
  let $schedule;
  let $model;
  let $user;
  let { formModel } = $$props;
  let { minInt } = $$props;
  const { schedule } = formModel.fields;
  component_subscribe($$self, schedule, (value) => $$invalidate(12, $schedule = value));
  const model = formModel.model;
  component_subscribe($$self, model, (value) => $$invalidate(2, $model = value));
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(3, $user = value));
  const dispatch = createEventDispatcher();
  let { min: min2, max: max2 } = $schedule.params;
  function updateValue() {
    let maxSecs = getInterval$1(max2, "s");
    let minSecs = Math.max(minInt, getInterval$1(min2, "s"));
    if (minSecs > maxSecs) {
      maxSecs = Math.max(minInt, minSecs + 1);
    } else {
      maxSecs = Math.max(minInt, maxSecs);
    }
    set_store_value(schedule, $schedule.params = { min: minSecs, max: maxSecs }, $schedule);
    $$invalidate(0, min2 = minSecs);
    $$invalidate(1, max2 = maxSecs);
    dispatch("change", $schedule);
  }
  function input0_input_handler() {
    min2 = to_number(this.value);
    $$invalidate(0, min2);
  }
  function input1_input_handler() {
    max2 = to_number(this.value);
    $$invalidate(1, max2);
  }
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(8, formModel = $$props2.formModel);
    if ("minInt" in $$props2)
      $$invalidate(9, minInt = $$props2.minInt);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      updateValue();
    }
  };
  return [
    min2,
    max2,
    $model,
    $user,
    schedule,
    model,
    user,
    updateValue,
    formModel,
    minInt,
    input0_input_handler,
    input1_input_handler
  ];
}
class RandomScheduleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2_, create_fragment$32, safe_not_equal, { formModel: 8, minInt: 9 });
  }
}
function create_fragment$31(ctx) {
  let div0;
  let t1;
  let div1;
  return {
    c() {
      div0 = element("div");
      div0.textContent = "Use it only if page auto-updates content using JavaScript.";
      t1 = space();
      div1 = element("div");
      div1.textContent = `${TXT("l_schedule_live_desc")}`;
      attr(div1, "class", "help");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
    }
  };
}
class LiveScheduleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$31, safe_not_equal, {});
  }
}
function create_fragment$30(ctx) {
  let div2;
  let div0;
  let menu;
  let t;
  let div1;
  let switch_instance;
  let current;
  menu = new Menu({
    props: {
      id: ctx[3],
      items: ctx[10](),
      allowNull: false,
      actionClass: "btn btn-default",
      dropDownClass: "dropdown-menu-start"
    }
  });
  menu.$on("select", ctx[8]);
  const switch_instance_spread_levels = [
    { formModel: ctx[0] },
    { minInt: ctx[2] },
    ctx[11]
  ];
  var switch_value = ctx[1][ctx[3]].component;
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
    switch_instance.$on("change", ctx[9]);
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(menu.$$.fragment);
      t = space();
      div1 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div0, "class", "flex items-start mr-6");
      attr(div1, "class", "flex-1");
      attr(div2, "class", "flex");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(menu, div0, null);
      append(div2, t);
      append(div2, div1);
      if (switch_instance)
        mount_component(switch_instance, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 8)
        menu_changes.id = ctx2[3];
      menu.$set(menu_changes);
      const switch_instance_changes = dirty & 2053 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 1 && { formModel: ctx2[0] },
        dirty & 4 && { minInt: ctx2[2] },
        dirty & 2048 && get_spread_object(ctx2[11])
      ]) : {};
      if (dirty & 10 && switch_value !== (switch_value = ctx2[1][ctx2[3]].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          switch_instance.$on("change", ctx2[9]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div1, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(menu);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function instance$2Z($$self, $$props, $$invalidate) {
  const omit_props_names = ["formModel", "autoSync", "editors"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $showError;
  let $schedule;
  let $user;
  let $model;
  let { formModel } = $$props;
  let { autoSync = false } = $$props;
  const { schedule } = formModel.fields;
  component_subscribe($$self, schedule, (value) => $$invalidate(15, $schedule = value));
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(13, $model = value));
  const { showError } = schedule;
  component_subscribe($$self, showError, (value) => $$invalidate(14, $showError = value));
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(16, $user = value));
  const debouncedScheduleChange = _.debounce(onScheduleChange, 300);
  let minInt = getMinInt();
  let selectedEditor = $schedule.type || "INTERVAL";
  let { editors = {
    INTERVAL: {
      name: "Interval",
      component: IntervalScheduleEditor,
      default: {
        type: "INTERVAL",
        params: { interval: 10800 }
      }
    },
    RANDOM: {
      name: "Random",
      component: RandomScheduleEditor,
      default: {
        type: "RANDOM",
        params: { min: minInt, max: minInt + 60 }
      }
    },
    LIVE: {
      name: "Live (beta)",
      component: LiveScheduleEditor,
      default: { type: "LIVE" }
    },
    CRON: {
      name: "Crontab *",
      disabled: !$user.account_id,
      component: CronScheduleEditor,
      default: {
        type: "CRON",
        params: {
          expr: "0 3 * * *",
          tz: new Date().getTimezoneOffset()
        }
      }
    },
    enterprise: { name: "* For Enterprise", disabled: true }
  } } = $$props;
  function getMinInt() {
    return $model.client_id === ModelClient.Clients.webAppId ? $user.constraint.interval : 5;
  }
  function onTypeChange(e) {
    const type = e.detail;
    set_store_value(schedule, $schedule = editors[type].default, $schedule);
    $$invalidate(3, selectedEditor = type);
    if (autoSync && !$showError) {
      debouncedScheduleChange($schedule);
    }
  }
  function onScheduleChange(schedule2) {
    Msg.start("save", "l_loading");
    formModel.model.save(null, {
      patch: true,
      silent: true,
      data: { schedule: JSON.stringify(schedule2) },
      error() {
        Msg.stop("save", { error: "e_req" });
      },
      success() {
        Msg.stop("save", { info: "m_saved_schedule" });
      }
    });
  }
  function onChange(e) {
    if (!autoSync || $showError) {
      return;
    }
    debouncedScheduleChange(e.detail);
  }
  function getItems() {
    return Object.entries(editors).map(([id2, val]) => ({ id: id2, ...val }));
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("formModel" in $$new_props)
      $$invalidate(0, formModel = $$new_props.formModel);
    if ("autoSync" in $$new_props)
      $$invalidate(12, autoSync = $$new_props.autoSync);
    if ("editors" in $$new_props)
      $$invalidate(1, editors = $$new_props.editors);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8192) {
      $model.client_id, $$invalidate(2, minInt = getMinInt());
    }
  };
  return [
    formModel,
    editors,
    minInt,
    selectedEditor,
    schedule,
    model,
    showError,
    user,
    onTypeChange,
    onChange,
    getItems,
    $$restProps,
    autoSync,
    $model
  ];
}
class ScheduleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Z, create_fragment$30, safe_not_equal, { formModel: 0, autoSync: 12, editors: 1 });
  }
}
function get_each_context$Q(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  child_ctx[7] = i2;
  return child_ctx;
}
function create_each_block$Q(key_1, ctx) {
  let div2;
  let div0;
  let regex;
  let t;
  let div1;
  let button;
  let current;
  let mounted;
  let dispose;
  regex = new Regex({ props: { regex: ctx[5] } });
  function click_handler(...args) {
    return ctx[4](ctx[7], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(regex.$$.fragment);
      t = space();
      div1 = element("div");
      button = element("button");
      button.innerHTML = `<i class="fa fa-times"></i>`;
      attr(div0, "class", "input-group my-1");
      attr(button, "class", "btn py-2 px-3 btn-sm btn-default");
      attr(div1, "class", "mx-2");
      attr(div2, "class", "d-flex align-items-center");
      this.first = div2;
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(regex, div0, null);
      append(div2, t);
      append(div2, div1);
      append(div1, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const regex_changes = {};
      if (dirty & 2)
        regex_changes.regex = ctx[5];
      regex.$set(regex_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(regex.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(regex.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(regex);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2$(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let div;
  let button;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[1];
  const get_key = (ctx2) => ctx2[5];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$Q(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$Q(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      div = element("div");
      button = element("button");
      button.innerHTML = `<i class="fa fa-plus"></i>`;
      attr(button, "class", "btn btn-sm btn-default py-2 px-3");
      attr(div, "class", "flex items-center my-2");
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t, anchor);
      insert(target, div, anchor);
      append(div, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", prevent_default(ctx[2]));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 10) {
        each_value = ctx2[1];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block$Q, t, get_each_context$Q);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function instance$2Y($$self, $$props, $$invalidate) {
  let $list, $$unsubscribe_list = noop$1, $$subscribe_list = () => ($$unsubscribe_list(), $$unsubscribe_list = subscribe(list, ($$value) => $$invalidate(1, $list = $$value)), list);
  $$self.$$.on_destroy.push(() => $$unsubscribe_list());
  let { list } = $$props;
  $$subscribe_list();
  function add() {
    list.add();
  }
  function remove(i2) {
    list.remove(i2);
  }
  const click_handler = (i2, e) => remove(i2);
  $$self.$$set = ($$props2) => {
    if ("list" in $$props2)
      $$subscribe_list($$invalidate(0, list = $$props2.list));
  };
  return [list, $list, add, remove, click_handler];
}
class RegexList$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Y, create_fragment$2$, safe_not_equal, { list: 0 });
  }
}
const crawlerFuncDefs = {
  sort_query: {
    name: "sort_query",
    returnType: C$2.STRING,
    args: {
      query: {
        types: [C$2.STRING]
      }
    },
    fn: async (_context, query) => {
      if (!query) {
        return "";
      }
      let parts = query.split("?");
      if (parts.length === 1) {
        query = parts[0];
      } else {
        query = parts[1];
      }
      parts.pop();
      const searchParams = new URLSearchParams(query);
      const sortedSearchParams = new URLSearchParams([...searchParams.entries()].sort());
      query = sortedSearchParams.toString();
      parts.push(query);
      return parts.join("?");
    }
  },
  join_url_fragments: {
    name: "join_url_fragments",
    returnType: C$2.STRING,
    args: {
      fragment1: {
        types: [C$2.STRING]
      },
      fragment2: {
        types: [C$2.STRING],
        optional: true
      },
      fragment3: {
        types: [C$2.STRING],
        optional: true
      }
    },
    fn: async (_context, fragment1, fragment2, fragment3) => {
      let fragmentMap = {};
      let args = [fragment1, fragment2, fragment3];
      const refType = {
        "path": "",
        "query": "?",
        "hash": "#"
      };
      _context.getExpression().argList.forEach((arg, index2) => {
        var _a;
        if (args[index2]) {
          fragmentMap[arg._ref] = !((_a = args[index2]) === null || _a === void 0 ? void 0 : _a.startsWith(refType[arg._ref])) ? refType[arg._ref] + args[index2] : args[index2];
        }
      });
      let finalString = "";
      ["path", "query", "hash"].forEach((el2) => {
        finalString += fragmentMap[el2] || "";
      });
      return finalString;
    }
  },
  filter_query: {
    name: "filter_query",
    returnType: C$2.STRING,
    args: {
      query: {
        types: [C$2.STRING]
      },
      filters: {
        types: ["array<string>"]
      },
      remove: {
        types: [C$2.BOOLEAN],
        default: true
      }
    },
    fn: async (_context, query, filters, remove) => {
      if (!query) {
        return "";
      }
      let parts = query.split("?");
      if (parts.length === 1) {
        query = parts[0];
      } else {
        query = parts[1];
      }
      parts.pop();
      let paramsArray = query.split("&");
      let newParamsArray = paramsArray.filter((param) => remove ? !filters.includes(param.split("=")[0]) : filters.includes(param.split("=")[0]));
      query = newParamsArray.join("&");
      parts.push(query);
      return parts.join("?");
    }
  }
};
const conditionDefs$1 = getConditionDefs();
const commonStepDefs = getStepDefs();
const crawlerStepDefs = {
  skipURL: {
    name: "skipURL",
    returnType: C$2.VOID,
    args: {},
    fn: async (_context) => {
      _context.crawler.skipURL(true);
    }
  }
};
const stepTypes = ["wait_for_element", "assert", "range"];
for (let stepType of stepTypes) {
  crawlerStepDefs[stepType] = commonStepDefs[stepType];
}
const stepDefs = getStepDefs();
const conditionDefs = getConditionDefs();
const builtInDeclarations = [
  { name: "start_url", dataType: "string", builtIn: true }
];
function parseSteps$3(initialSteps, opts) {
  if (!opts) {
    opts = {};
  }
  if (!opts.declarations) {
    opts.declarations = [];
  }
  opts.declarations = [...opts.declarations, ...builtInDeclarations];
  return new Root(createRegistry$2(), initialSteps, opts);
}
function createRegistry$2() {
  return new Registry({
    funcs: { ...stepDefs, ...conditionDefs },
    structs: { ...structDefs },
    enums: { ...enumDefs }
  });
}
class Player$2 extends Player$3 {
  constructor(source, browser2, opts) {
    super(source, { ...opts, context: { ...opts === null || opts === void 0 ? void 0 : opts.context, browser: new BrowserWrapper(browser2) } });
  }
  getNewRegistry() {
    return createRegistry$2();
  }
}
const procStructDefs = {
  ["regex"]: structDefs["regex"]
};
const procFuncDefs = getProcFuncDefs();
const scraperDefs = {
  "scrape": {
    name: "scrape",
    args: {
      id: {
        types: [C$2.STRING]
      }
    },
    returnType: C$2.VOID,
    fn: async (context, id2) => {
      return await context.scraper.scrape(id2);
    }
  }
};
function getProcFuncDefs() {
  var _a, _b;
  const defs2 = {};
  for (const [stepName, stepDef] of Object.entries(getStepDefs())) {
    if ((_a = stepDef.labels) === null || _a === void 0 ? void 0 : _a.includes("utils")) {
      defs2[stepName] = stepDef;
    }
  }
  for (const [condName, condDef] of Object.entries(getConditionDefs())) {
    if (!((_b = condDef.labels) === null || _b === void 0 ? void 0 : _b.includes("element"))) {
      defs2[condName] = condDef;
    }
  }
  return defs2;
}
const registry$1 = createRegistry$1();
function parseSteps$2(initialSteps, opts) {
  return new Root(registry$1, initialSteps, opts);
}
function createRegistry$1() {
  return new Registry({
    funcs: { ...conditionDefs$1, ...crawlerStepDefs, ...procFuncDefs },
    structs: { ...procStructDefs, ...structDefs },
    enums: { ...enumDefs }
  });
}
class Player$1 extends Player$3 {
  constructor(source, browser2, crawler, opts) {
    super(source, { ...opts, context: { ...opts === null || opts === void 0 ? void 0 : opts.context, browser: new BrowserWrapper(browser2), crawler } });
  }
  getNewRegistry() {
    return createRegistry$1();
  }
}
const rewriteURLRegistry = new Registry({
  funcs: { ...procFuncDefs, ...crawlerFuncDefs },
  structs: { ...procStructDefs, ...structDefs },
  enums: { ...enumDefs }
});
const validatorsRegistry = new Registry({
  funcs: { ...conditionDefs$1, ...crawlerStepDefs, ...procFuncDefs },
  structs: { ...procStructDefs, ...structDefs },
  enums: { ...enumDefs }
});
function getRegistry(type) {
  return type === "rewriteURL" ? rewriteURLRegistry : validatorsRegistry;
}
const parseSteps$1 = (initialSteps, type) => {
  return new Root(getRegistry(type), initialSteps, {
    declarations: [
      {
        name: "hash",
        dataType: "string"
      },
      {
        name: "path",
        dataType: "string"
      },
      {
        name: "query",
        dataType: "string"
      }
    ]
  });
};
const runExpressions$1 = async (expr, urlObj, type) => {
  const mapperExprTree = parseSteps$1(expr, type);
  const context = {};
  const vm = new VM(getRegistry(type), context, mapperExprTree, {
    vars: [
      {
        name: "hash",
        dataType: "string",
        value: urlObj.hash
      },
      {
        name: "path",
        dataType: "string",
        value: urlObj.pathname
      },
      {
        name: "query",
        dataType: "string",
        value: urlObj.search
      }
    ]
  });
  return await vm.run();
};
function getPresetsMap(url) {
  return /* @__PURE__ */ new Map([
    [
      "sort_query",
      {
        label: "Sort query params",
        steps: [
          "=",
          "$query",
          [
            "sort_query",
            "$query"
          ]
        ]
      }
    ],
    [
      "remove_query",
      {
        label: "Remove all query params",
        steps: [
          "=",
          "$query",
          ""
        ]
      }
    ],
    [
      "filter_query",
      {
        label: "Filter query params",
        steps: [
          "=",
          "$query",
          [
            "filter_query",
            "$query",
            [
              "array",
              "string",
              (() => {
                try {
                  let urlObj = new URL(url);
                  return [...urlObj.searchParams.keys()];
                } catch (err) {
                  return [];
                }
              })()
            ],
            true
          ]
        ]
      }
    ],
    [
      "keep_query",
      {
        label: "Keep query params",
        steps: [
          "=",
          "$query",
          [
            "filter_query",
            "$query",
            [
              "array",
              "string",
              (() => {
                try {
                  let urlObj = new URL(url);
                  return [...urlObj.searchParams.keys()];
                } catch (err) {
                  return [];
                }
              })()
            ],
            false
          ]
        ]
      }
    ],
    [
      "return_url",
      {
        label: "Return contstructed URL",
        steps: [
          "return",
          [
            "join_url_fragments",
            "$path",
            "$query",
            "$hash"
          ]
        ]
      }
    ]
  ]);
}
function get_each_context$P(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2][0];
  child_ctx[24] = list[i2][1];
  return child_ctx;
}
function create_if_block$1H(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      onSave: ctx[11],
      disableSave: ctx[4],
      $$slots: { default: [create_default_slot$19] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[10]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 16)
        savemodal_changes.disableSave = ctx2[4];
      if (dirty & 134217843) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot_1$m(ctx) {
  let t0_value = ctx[24].label + "";
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_each_block$P(key_1, ctx) {
  let first2;
  let menuitem;
  let current;
  function click_handler_1(...args) {
    return ctx[15](ctx[23], ...args);
  }
  menuitem = new MenuItem({
    props: {
      title: ctx[24].label,
      $$slots: { default: [create_default_slot_1$m] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", click_handler_1);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(menuitem.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 134217728) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(menuitem, detaching);
    }
  };
}
function create_steps_menu_l_slot(ctx) {
  let div1;
  let div0;
  let t1;
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let mounted;
  let dispose;
  let each_value = [...ctx[7].entries()];
  const get_key = (ctx2) => ctx2[23];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$P(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$P(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "Use Preset";
      t1 = space();
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "btn btn-default btn-sm text-center float-right dropdown dropdown-toggle");
      attr(ul, "class", "dropdown-menu");
      toggle_class(ul, "show", ctx[1]);
      attr(div1, "slot", "steps-menu-l");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t1);
      append(div1, ul);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[14]),
          action_destroyer(clickOutside.call(null, ul)),
          listen(ul, "outclick", ctx[16])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4224) {
        each_value = [...ctx2[7].entries()];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$P, null, get_each_context$P);
        check_outros();
      }
      if (!current || dirty & 2) {
        toggle_class(ul, "show", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$1a(ctx) {
  let code;
  let t;
  let code_class_value;
  return {
    c() {
      code = element("code");
      t = text(ctx[6]);
      attr(code, "class", code_class_value = ctx[4] ? "text-danger" : "");
    },
    m(target, anchor) {
      insert(target, code, anchor);
      append(code, t);
    },
    p(ctx2, dirty) {
      if (dirty & 64)
        set_data(t, ctx2[6]);
      if (dirty & 16 && code_class_value !== (code_class_value = ctx2[4] ? "text-danger" : "")) {
        attr(code, "class", code_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(code);
    }
  };
}
function create_default_slot$19(ctx) {
  let div8;
  let div0;
  let bbxtreeview;
  let t0;
  let div7;
  let div3;
  let div1;
  let t2;
  let div2;
  let input;
  let t3;
  let div6;
  let div4;
  let t5;
  let div5;
  let current;
  let mounted;
  let dispose;
  bbxtreeview = new TreeView({
    props: {
      tree: ctx[5],
      $$slots: {
        "steps-menu-l": [create_steps_menu_l_slot]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[6] && create_if_block_1$1a(ctx);
  return {
    c() {
      div8 = element("div");
      div0 = element("div");
      create_component(bbxtreeview.$$.fragment);
      t0 = space();
      div7 = element("div");
      div3 = element("div");
      div1 = element("div");
      div1.innerHTML = `<label for="testURLInput" class="form-label m-2">Test URL</label>`;
      t2 = space();
      div2 = element("div");
      input = element("input");
      t3 = space();
      div6 = element("div");
      div4 = element("div");
      div4.innerHTML = `<label class="form-label mx-2 mt-1">Result</label>`;
      t5 = space();
      div5 = element("div");
      if (if_block)
        if_block.c();
      attr(div0, "class", "d-flex w-50 me-2");
      attr(div1, "class", "w-100 bg-gray-200");
      attr(input, "id", "testURLInput");
      attr(input, "class", "form-control mt-2 mb-10");
      attr(input, "placeholder", "Enter URL to test");
      attr(div2, "class", "px-2");
      attr(div3, "class", "mb-3");
      set_style(div3, "margin-right", "-15px");
      attr(div4, "class", "w-100 bg-gray-200");
      attr(div5, "class", "my-2 me-1 px-4");
      attr(div6, "class", "border-top");
      set_style(div6, "margin-right", "-15px");
      attr(div7, "class", "d-flex-col w-50 border-start");
      set_style(div7, "margin-top", "-15px");
      set_style(div7, "margin-bottom", "-15px");
      attr(div8, "class", "d-flex");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div0);
      mount_component(bbxtreeview, div0, null);
      append(div8, t0);
      append(div8, div7);
      append(div7, div3);
      append(div3, div1);
      append(div3, t2);
      append(div3, div2);
      append(div2, input);
      set_input_value(input, ctx[0]);
      append(div7, t3);
      append(div7, div6);
      append(div6, div4);
      append(div6, t5);
      append(div6, div5);
      if (if_block)
        if_block.m(div5, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[17]),
          listen(input, "input", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const bbxtreeview_changes = {};
      if (dirty & 32)
        bbxtreeview_changes.tree = ctx2[5];
      if (dirty & 134217730) {
        bbxtreeview_changes.$$scope = { dirty, ctx: ctx2 };
      }
      bbxtreeview.$set(bbxtreeview_changes);
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1a(ctx2);
          if_block.c();
          if_block.m(div5, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(bbxtreeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bbxtreeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div8);
      destroy_component(bbxtreeview);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$2_(ctx) {
  let t0;
  let button;
  let t1;
  let t2;
  let t3;
  let t4;
  let p;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[2] && create_if_block$1H(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      button = element("button");
      t1 = text("Edit Steps (");
      t2 = text(ctx[3]);
      t3 = text(")");
      t4 = space();
      p = element("p");
      p.textContent = "List of step to rewrite the page's URL before crawling";
      attr(button, "class", "btn btn-default");
      attr(p, "class", "help");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, button, anchor);
      append(button, t1);
      append(button, t2);
      append(button, t3);
      insert(target, t4, anchor);
      insert(target, p, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1H(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 8)
        set_data(t2, ctx2[3]);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(button);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(p);
      mounted = false;
      dispose();
    }
  };
}
function instance$2X($$self, $$props, $$invalidate) {
  let result2;
  let { tree } = $$props;
  let { url = "" } = $$props;
  const defaultExprs = {
    and: ["and", ["contains"]],
    or: ["or", ["contains"]],
    not: ["not", ["contains"]],
    sort_query: ["sort_query", "$query"],
    join_url_fragments: ["join_url_fragments", "$path"],
    "if..else": ["cond", [["or", ["and", ["contains"]]]]]
  };
  const ctx = {
    replace: {
      skipControl: false,
      stepNames: [...Object.keys(crawlerFuncDefs), ...Object.keys(procFuncDefs)],
      defaultStep: "sort_query",
      defaultExprs,
      allowVarDecs: true
    }
  };
  setContext("expressionCtx", ctx);
  let show = false;
  let editModal = false;
  let treeLength = tree.toJSON().length;
  let disableSave = false;
  let clonedTree = clone2(tree);
  const REWRITE_URL_PRESETS = getPresetsMap(url);
  const testExprs = async () => {
    var _a;
    if (treeLength === 0) {
      $$invalidate(6, result2 = url);
      return;
    }
    $$invalidate(4, disableSave = false);
    $$invalidate(6, result2 = "");
    if (url === "") {
      return;
    }
    try {
      let urlObj = new URL(url);
      let res = await runExpressions$1(clonedTree.toJSON(), urlObj, "rewriteURL");
      if (res === void 0) {
        $$invalidate(6, result2 = "Obtained undefined value");
        $$invalidate(4, disableSave = true);
        return;
      }
      if (res !== "" && !res.startsWith("/")) {
        $$invalidate(4, disableSave = true);
        $$invalidate(6, result2 = 'Path must start with a "/". Got: ' + res);
        return;
      }
      $$invalidate(6, result2 = urlObj.origin + res);
    } catch (err) {
      $$invalidate(4, disableSave = true);
      const expressionError = (_a = err.stackEx) == null ? void 0 : _a[0];
      if (expressionError) {
        let step = expressionError == null ? void 0 : expressionError.nodeName;
        $$invalidate(6, result2 = `URL Rewrite failed ${step ? "at " + step : ""}`);
      } else {
        $$invalidate(6, result2 = err.message);
      }
    }
  };
  if (url) {
    testExprs();
  }
  function refreshLengthAndTest() {
    $$invalidate(3, treeLength = clonedTree.toJSON().length);
    testExprs();
  }
  function editExpressions() {
    $$invalidate(2, editModal = true);
    if (clonedTree) {
      clonedTree.off("change", refreshLengthAndTest);
    }
    $$invalidate(5, clonedTree = clone2(tree));
    clonedTree.on("change", refreshLengthAndTest);
    refreshLengthAndTest();
  }
  function closeEditModal() {
    $$invalidate(2, editModal = false);
    $$invalidate(3, treeLength = tree.toJSON().length);
  }
  function onSave() {
    $$invalidate(2, editModal = false);
    tree.replace(clonedTree.toJSON());
  }
  function onSelect(key) {
    addPreset(key);
    $$invalidate(1, show = false);
  }
  function clone2(tree2) {
    return parseSteps$1(tree2.toJSON(), "rewriteURL");
  }
  function addPreset(presetKey) {
    clonedTree.replace([...clonedTree.toJSON(), REWRITE_URL_PRESETS.get(presetKey).steps]);
  }
  onDestroy(() => {
    if (clonedTree) {
      clonedTree.off("change", refreshLengthAndTest);
    }
  });
  const click_handler = () => $$invalidate(1, show = !show);
  const click_handler_1 = (key, e) => {
    onSelect(key);
  };
  const outclick_handler = () => {
    $$invalidate(1, show = false);
  };
  function input_input_handler() {
    url = this.value;
    $$invalidate(0, url);
  }
  $$self.$$set = ($$props2) => {
    if ("tree" in $$props2)
      $$invalidate(13, tree = $$props2.tree);
    if ("url" in $$props2)
      $$invalidate(0, url = $$props2.url);
  };
  $$invalidate(6, result2 = "");
  return [
    url,
    show,
    editModal,
    treeLength,
    disableSave,
    clonedTree,
    result2,
    REWRITE_URL_PRESETS,
    testExprs,
    editExpressions,
    closeEditModal,
    onSave,
    onSelect,
    tree,
    click_handler,
    click_handler_1,
    outclick_handler,
    input_input_handler
  ];
}
class RewriteSteps extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2X, create_fragment$2_, safe_not_equal, { tree: 13, url: 0 });
  }
}
function parseSteps(initialSteps, opts) {
  return new Root(createRegistry(), initialSteps, opts);
}
function createRegistry() {
  return new Registry({
    funcs: { ...stepDefs, ...conditionDefs, ...scraperDefs },
    structs: { ...structDefs },
    enums: { ...enumDefs }
  });
}
function createProcRegistry() {
  return new Registry({
    funcs: procFuncDefs,
    structs: procStructDefs,
    enums: { ...enumDefs }
  });
}
class Player extends Player$3 {
  constructor(source, browser2, scraper, opts) {
    super(source, { ...opts, context: { ...opts === null || opts === void 0 ? void 0 : opts.context, browser: new BrowserWrapper(browser2), scraper } });
  }
  getNewRegistry() {
    return createRegistry();
  }
}
class ProcPlayer extends Player$3 {
  constructor(source, opts) {
    super(source, opts);
  }
  getNewRegistry() {
    return createProcRegistry();
  }
}
const trimText = (value) => value.replace(/[\s]+$/gm, "").replace(/\s{2,}/gm, " ");
const runExpressions = (expr, opts) => {
  const player = new ProcPlayer(expr, opts);
  return player.play();
};
const typeAliases = {
  currency: "float",
  number: "float"
};
function resolveAlias(data_type) {
  if (typeAliases[data_type]) {
    return typeAliases[data_type];
  }
  return data_type;
}
function getPrimitive$2(data_type) {
  if (typeAliases[data_type]) {
    return typeAliases[data_type];
  }
  if (isArrayType(data_type)) {
    data_type = data_type.slice(6, -1);
    if (typeAliases[data_type]) {
      return typeAliases[data_type];
    }
  }
  return data_type;
}
function getElementDepth(elem) {
  let depth = 0;
  while (elem) {
    depth++;
    if (elem.parentNode) {
      elem = elem.parentNode;
    } else if (elem.host) {
      elem = elem.host;
      depth++;
    } else if (elem.defaultView && elem.defaultView.frameElement) {
      elem = elem.defaultView.frameElement;
      depth++;
      return depth;
    } else {
      break;
    }
  }
  return depth;
}
function detectBrowser() {
  const userAgent = navigator.userAgent;
  if (userAgent.indexOf("Edg") > -1) {
    return "Microsoft Edge";
  } else if (userAgent.indexOf("Chrome") > -1) {
    return "Chrome";
  } else if (userAgent.indexOf("Firefox") > -1) {
    return "Firefox";
  } else if (userAgent.indexOf("Safari") > -1) {
    return "Safari";
  } else if (userAgent.indexOf("Opera") > -1) {
    return "Opera";
  } else if (userAgent.indexOf("Trident") > -1 || userAgent.indexOf("MSIE") > -1) {
    return "Internet Explorer";
  }
  return "Unknown";
}
function getElementComputedStyle(element2, pseudo) {
  var _a, _b;
  try {
    return (_b = (_a = element2.ownerDocument) == null ? void 0 : _a.defaultView) == null ? void 0 : _b.getComputedStyle(element2, pseudo);
  } catch (err) {
  }
  return void 0;
}
function isVisibleTextNode(node) {
  const range2 = node.ownerDocument.createRange();
  range2.selectNode(node);
  const rect = range2.getBoundingClientRect();
  return rect.width > 0 && rect.height > 0;
}
function isElementStyleVisibilityVisible(element2, style) {
  style = style != null ? style : getElementComputedStyle(element2);
  if (!style)
    return true;
  if (Element.prototype.checkVisibility && detectBrowser() !== "Safari") {
    if (!element2.checkVisibility({ checkOpacity: false, checkVisibilityCSS: false }))
      return false;
  } else {
    const detailsOrSummary = element2.closest("details,summary");
    if (detailsOrSummary !== element2 && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === "DETAILS" && !detailsOrSummary.open)
      return false;
  }
  return style.visibility === "visible";
}
function isElementVisible(element2) {
  const style = getElementComputedStyle(element2);
  if (!style)
    return true;
  if (style.display === "contents") {
    for (let child = element2.firstChild; child; child = child.nextSibling) {
      if (child.nodeType === 1 && isElementVisible(child))
        return true;
      if (child.nodeType === 3 && isVisibleTextNode(child))
        return true;
    }
    return false;
  }
  if (!isElementStyleVisibilityVisible(element2, style))
    return false;
  const rect = element2.getBoundingClientRect();
  return rect.width > 0 && rect.height > 0;
}
var Type;
(function(Type2) {
  Type2["json"] = "json";
  Type2["string"] = "string";
  Type2["number"] = "number";
  Type2["boolean"] = "boolean";
  Type2["currency"] = "currency";
  Type2["date"] = "date";
  Type2["url"] = "url";
})(Type || (Type = {}));
const PRIMITIVES = [
  Type.json,
  Type.string,
  Type.number,
  Type.date,
  Type.boolean,
  Type.url,
  Type.currency
];
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["E_DATATYPE_NA"] = "E_DATATYPE_NA";
  ErrorCode2["E_EXTRACTOR_NA"] = "E_EXTRACTOR_NA";
  ErrorCode2["E_ZERO_SELECTORS"] = "E_ZERO_SELECTORS";
  ErrorCode2["E_ATTRIBUTE_NOT_EXIST"] = "E_ATTRIBUTE_NOT_EXIST";
  ErrorCode2["E_PROP_NOT_EXIST"] = "E_PROP_NOT_EXIST";
  ErrorCode2["E_BUILTIN_NA"] = "E_BUILTIN_NA";
  ErrorCode2["E_NO_REDUCER_EXISTS"] = "E_NO_REDUCER_EXISTS";
  ErrorCode2["E_NO_DATA_EXISTS"] = "E_NO_DATA_EXISTS";
  ErrorCode2["E_TAG_INVALID_SELECTOR"] = "E_TAG_INVALID_SELECTOR";
  ErrorCode2["E_REQUIRED_VALUE_NA"] = "E_REQUIRED_VALUE_NA";
  ErrorCode2["E_TABLE_ROW_ELEMENT_NOT_EXIST"] = "E_TABLE_ROW_ELEMENT_NOT_EXIST";
  ErrorCode2["E_VALIDATION_FAILED"] = "E_VALIDATION_FAILED";
  ErrorCode2["E_INVALID_CONDITION"] = "E_INVALID_CONDITION";
  ErrorCode2["E_ASSERTION"] = "E_ASSERTION";
  ErrorCode2["E_FORMAT"] = "E_FORMAT";
  ErrorCode2["E_SYNTAX"] = "E_SYNTAX";
})(ErrorCode || (ErrorCode = {}));
Error.prototype.toJSON = function() {
  return { code: this.code, message: this.message, stack: this.stack };
};
class UnsupportedBuiltInTypeError extends BaseError {
  constructor(tag) {
    super(ErrorCode.E_BUILTIN_NA, `The builtin extractor '${tag.name}' is not supported`);
  }
}
class UnsupportedDataTypeError extends BaseError {
  constructor(type) {
    super(ErrorCode.E_DATATYPE_NA, `The datatype ${type} is not supported`);
  }
}
class UnsupportedExtractorTypeError extends BaseError {
  constructor(type) {
    super(ErrorCode.E_EXTRACTOR_NA, `The extractor type ${type} is not supported`);
  }
}
class ExtractorReturnedNull extends BaseError {
  constructor(tag) {
    super(ErrorCode.E_REQUIRED_VALUE_NA, `Extracted value of the tag '${tag.name}' is null`);
  }
}
class InvalidSelectorError extends BaseError {
  constructor(selector) {
    super(ErrorCode.E_TAG_INVALID_SELECTOR, `Selector "${selector}" is invalid.`);
  }
}
class ZeroSelectorsError extends BaseError {
  constructor() {
    super(ErrorCode.E_ZERO_SELECTORS, `No selectors are available. Please add a selector.`);
  }
}
class AttributeDoesNotExistError extends BaseError {
  constructor(attr2) {
    super(ErrorCode.E_ATTRIBUTE_NOT_EXIST, `Attribute '${attr2}' does not exist`);
  }
}
class PropDoesNotExistError extends BaseError {
  constructor(prop) {
    super(ErrorCode.E_PROP_NOT_EXIST, `Prop '${prop}' does not exist`);
  }
}
class TableRowElementNotExistError extends BaseError {
  constructor() {
    super(ErrorCode.E_TABLE_ROW_ELEMENT_NOT_EXIST, `Zero table row child elements exist`);
  }
}
class InValidFormatError extends BaseError {
  constructor(type, val) {
    super(ErrorCode.E_FORMAT, `Invalid ${type ? `${type} ` : ""}format: ${val}`);
  }
}
class InValidSyntaxError extends BaseError {
  constructor(type, value, message) {
    super(ErrorCode.E_SYNTAX, `Invalid ${type ? `${type} ` : ""}syntax` + (value ? ` - ${value}` : "") + (message ? `: ${message}` : ""));
  }
}
class DataNotFoundError extends BaseError {
  constructor(reason) {
    super(ErrorCode.E_NO_DATA_EXISTS, reason);
  }
}
class ReducerNotFoundError extends BaseError {
  constructor() {
    super(ErrorCode.E_NO_REDUCER_EXISTS, "No reducers found.");
  }
}
class DataValidationError extends BaseError {
  constructor(reason) {
    super(ErrorCode.E_VALIDATION_FAILED, `Failed while validating tags. '${reason}'`);
  }
}
class TableExtractor {
  constructor(el2, tag) {
    __publicField(this, "output");
    __publicField(this, "el");
    __publicField(this, "tag");
    __publicField(this, "colHeader");
    this.output = [];
    this.el = el2;
    this.tag = tag;
    this.colHeader = true;
    this.extract();
  }
  checkValidity(rowIdx, colIdx) {
    if (rowIdx >= this.output.length) {
      return true;
    } else if (colIdx >= this.output[rowIdx].length) {
      return true;
    } else if (this.output[rowIdx][colIdx] == null) {
      return true;
    } else {
      return false;
    }
  }
  range(start, stop) {
    const arr = [];
    for (let i2 = start; i2 < stop; i2++) {
      arr.push(i2);
    }
    return arr;
  }
  insertCell(rowIdx, colIdx, text2) {
    while (rowIdx >= this.output.length) {
      this.output.push([]);
    }
    while (colIdx >= this.output[rowIdx].length) {
      this.output[rowIdx].push(null);
    }
    if (this.output[rowIdx][colIdx] == null) {
      this.output[rowIdx][colIdx] = text2;
    }
  }
  insert(rowIdx, colIdx, rowSpan, colSpan, text2) {
    for (const ii of this.range(rowIdx, rowIdx + rowSpan)) {
      for (const jj of this.range(colIdx, colIdx + colSpan)) {
        this.insertCell(ii, jj, text2);
      }
    }
  }
  reconstruct() {
    const parsed = [];
    const headers = this.output.splice(0, 1)[0];
    for (const row of this.output) {
      const r = row.reduce((memo, key, index2) => {
        if (memo[headers[index2]]) {
          memo[headers[index2] + index2] = key;
        } else {
          memo[headers[index2]] = key;
        }
        return memo;
      }, {});
      parsed.push(r);
    }
    return parsed;
  }
  extract() {
    let rowIdx = 0;
    let colIdx = 0;
    const rows = Array.from(this.el.querySelectorAll("tr"));
    if (!rows.length) {
      throw new TableRowElementNotExistError();
    }
    for (const row of rows) {
      let smallestRowSpan = 1;
      const children = Array.from(row.querySelectorAll("td, th"));
      for (const cell of children) {
        const rowSpan = cell.rowSpan || 1;
        smallestRowSpan = Math.min(smallestRowSpan, rowSpan);
        const colSpan = cell.colSpan || 1;
        while (true) {
          if (this.checkValidity(rowIdx, colIdx)) {
            break;
          }
          colIdx++;
        }
        this.insert(rowIdx, colIdx, rowSpan, colSpan, cell.textContent);
        colIdx += colSpan;
      }
      rowIdx += smallestRowSpan;
      colIdx = 0;
    }
    return this.output;
  }
}
class DataExtractor$1 {
  constructor(tag, doc) {
    __publicField(this, "tag");
    __publicField(this, "doc", document);
    __publicField(this, "isText", (node) => node.nodeType == document.TEXT_NODE);
    this.tag = tag;
    this.doc = doc;
  }
  extract() {
    const els = this.getElements(this.tag);
    const val = this.getData(this.tag, els);
    if (!val)
      throw new ExtractorReturnedNull(this.tag);
    return val;
  }
  getElements(tag) {
    if (!tag || !tag.selectors || tag.selectors.includes.length == 0) {
      return null;
    }
    const selectors = tag.selectors.includes;
    if (selectors.length === 0) {
      throw new ZeroSelectorsError();
    }
    const excludeElements = this.getElementsForSelectors(tag.selectors.excludes);
    excludeElements.forEach((el2) => el2.remove());
    return this.getElementsForSelectors(selectors);
  }
  getData(tag, els) {
    const selector = tag.selectors;
    if (!selector) {
      return null;
    }
    const extractor2 = selector.field || { type: "text" };
    return els.map((el2) => this.extractDOM(tag, el2, extractor2));
  }
  getElementsForSelectors(selectors) {
    if (!selectors) {
      return [];
    }
    const els = [];
    let res = [];
    for (const selector of selectors) {
      try {
        if (selector.type === "xpath") {
          const resultset = this.doc.evaluate(selector.value, this.doc, null, XPathResult.ANY_TYPE, null);
          let aResult = resultset.iterateNext();
          while (aResult && aResult.nodeType == document.ELEMENT_NODE) {
            res.push(aResult);
            aResult = resultset.iterateNext();
          }
        } else if (selector.type === "css") {
          res = Array.from(this.doc.querySelectorAll(selector.value));
        }
      } catch (e) {
        throw new InvalidSelectorError(selector.value);
      }
      if (res.length > 0) {
        els.push(...Array.from(res));
      }
    }
    return els;
  }
  visit(el2, visitor) {
    if (visitor(el2) !== false && el2.childNodes) {
      for (let child of el2.childNodes) {
        this.visit(child, visitor);
      }
    }
  }
  getElText(el2, buf) {
    this.visit(el2, (node) => {
      if (["NOSCRIPT", "SCRIPT", "STYLE", "style"].includes(node.nodeName)) {
        return false;
      }
      this.getNodeText(node, buf);
    });
  }
  getNodeText(node, buf) {
    if (this.isText(node)) {
      buf.push(node.nodeValue);
    }
  }
  extractByJS(el, extractor) {
    globalThis.el = el;
    const result = eval(extractor.params.script);
    globalThis.el = void 0;
    return result;
  }
  extractDOM(tag, el2, extractor2) {
    switch (extractor2.type) {
      case "attr": {
        const value = el2.getAttribute(extractor2.params.name);
        if (value == null) {
          throw new AttributeDoesNotExistError(extractor2.params.name);
        }
        return value.toString();
      }
      case "prop": {
        const value = el2[extractor2.params.name];
        if (value == null) {
          throw new PropDoesNotExistError(extractor2.params.name);
        }
        return value.toString();
      }
      case "html": {
        return el2.outerHTML;
      }
      case "text": {
        const buf = [];
        this.getElText(el2, buf);
        return trimText(buf.join(" "));
      }
      case "table": {
        const tableExtractor = new TableExtractor(el2, tag);
        return tableExtractor.reconstruct();
      }
      case "js": {
        return this.extractByJS(el2, extractor2);
      }
      default: {
        throw new UnsupportedExtractorTypeError(extractor2.type);
      }
    }
  }
  extractBuiltIn(tag) {
    const selector = tag.selectors;
    if (!selector) {
      return null;
    }
    switch (selector.field.type) {
      case "title": {
        return this.doc.title;
      }
      default: {
        throw new UnsupportedBuiltInTypeError(tag);
      }
    }
  }
  extractMeta(tag) {
    const selector = tag.selectors;
    if (!selector) {
      return null;
    }
    const el2 = this.doc.querySelector(`meta[name=${selector.field.type}]`);
    if (el2 == null) {
      return null;
    }
    const extracted = el2.getAttribute("content");
    if (extracted == null) {
      return null;
    }
    return extracted;
  }
}
class Proc$1 {
  constructor(tag, data) {
    __publicField(this, "tag");
    __publicField(this, "data");
    this.tag = tag;
    this.data = data;
  }
}
class DataValidator extends Proc$1 {
  constructor(tag, data, data_type, validator) {
    super(tag, data);
    __publicField(this, "validator");
    __publicField(this, "data_type");
    this.validator = validator;
    this.data_type = data_type;
  }
  async validate() {
    var _a, _b;
    try {
      if (!this.validator) {
        return true;
      }
      if (((_a = this.validator) == null ? void 0 : _a.required) && !this.data) {
        throw new DataValidationError(`Empty value not allowed for ${this.tag.name}.`);
      }
      if (!((_b = this.validator.exprs) == null ? void 0 : _b.length)) {
        return true;
      }
      let primitiveType = this.data_type;
      let values2 = [this.data];
      if (primitiveType === Type.number) {
        primitiveType = "float";
      } else if (isArrayType(this.data_type)) {
        primitiveType = getPrimitive$2(this.data_type);
        values2 = this.data;
      } else {
        primitiveType = resolveAlias(this.data_type);
      }
      for (const val of values2) {
        await runExpressions(this.validator.exprs, {
          vars: [{ name: "val", dataType: primitiveType, value: val }]
        });
      }
    } catch (err) {
      throw StackedError.handle(err, "validator");
    }
  }
}
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r)
      return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return {
        s: F,
        n: function n() {
          return _n >= r.length ? {
            done: true
          } : {
            done: false,
            value: r[_n++]
          };
        },
        e: function e2(r2) {
          throw r2;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return {
    s: function s() {
      t = t.call(r);
    },
    n: function n() {
      var r2 = t.next();
      return a = r2.done, r2;
    },
    e: function e2(r2) {
      u = true, o = r2;
    },
    f: function f() {
      try {
        a || null == t["return"] || t["return"]();
      } finally {
        if (u)
          throw o;
      }
    }
  };
}
function _assertThisInitialized(e) {
  if (void 0 === e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e))
    return e;
  if (void 0 !== e)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _createSuper(t) {
  var r = _isNativeReflectConstruct();
  return function() {
    var e, o = _getPrototypeOf(t);
    if (r) {
      var s = _getPrototypeOf(this).constructor;
      e = Reflect.construct(o, arguments, s);
    } else
      e = o.apply(this, arguments);
    return _possibleConstructorReturn(this, e);
  };
}
function _classCallCheck(a, n) {
  if (!(a instanceof n))
    throw new TypeError("Cannot call a class as a function");
}
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof(i2))
      return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function toPropertyKey(t) {
  var i2 = toPrimitive(t, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /* @__PURE__ */ function() {
  function Setter2() {
    _classCallCheck(this, Setter2);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", 0);
  }
  _createClass(Setter2, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter2;
}();
var ValueSetter = /* @__PURE__ */ function(_Setter) {
  _inherits(ValueSetter2, _Setter);
  var _super = _createSuper(ValueSetter2);
  function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck(this, ValueSetter2);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass(ValueSetter2, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter2;
}(Setter);
var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
  _inherits(DateToSystemTimezoneSetter2, _Setter2);
  var _super2 = _createSuper(DateToSystemTimezoneSetter2);
  function DateToSystemTimezoneSetter2() {
    var _this2;
    _classCallCheck(this, DateToSystemTimezoneSetter2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass(DateToSystemTimezoneSetter2, [{
    key: "set",
    value: function set(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter2;
}(Setter);
var Parser$1 = /* @__PURE__ */ function() {
  function Parser2() {
    _classCallCheck(this, Parser2);
    _defineProperty(this, "incompatibleTokens", void 0);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", void 0);
  }
  _createClass(Parser2, [{
    key: "run",
    value: function run(dateString, token, match, options) {
      var result2 = this.parse(dateString, token, match, options);
      if (!result2) {
        return null;
      }
      return {
        setter: new ValueSetter(result2.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result2.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser2;
}();
var EraParser = /* @__PURE__ */ function(_Parser) {
  _inherits(EraParser2, _Parser);
  var _super = _createSuper(EraParser2);
  function EraParser2() {
    var _this;
    _classCallCheck(this, EraParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 140);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
    return _this;
  }
  _createClass(EraParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return match.era(dateString, {
            width: "abbreviated"
          }) || match.era(dateString, {
            width: "narrow"
          });
        case "GGGGG":
          return match.era(dateString, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match.era(dateString, {
            width: "wide"
          }) || match.era(dateString, {
            width: "abbreviated"
          }) || match.era(dateString, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser2;
}(Parser$1);
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  date: /^(3[0-1]|[0-2]?\d)/,
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  week: /^(5[0-3]|[0-4]?\d)/,
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  hour11h: /^(1[0-1]|0?\d)/,
  hour12h: /^(1[0-2]|0?\d)/,
  minute: /^[0-5]?\d/,
  second: /^[0-5]?\d/,
  singleDigit: /^\d/,
  twoDigits: /^\d{1,2}/,
  threeDigits: /^\d{1,3}/,
  fourDigits: /^\d{1,4}/,
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  twoDigitsSigned: /^-?\d{1,2}/,
  threeDigitsSigned: /^-?\d{1,3}/,
  fourDigitsSigned: /^-?\d{1,4}/
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result2;
  if (absCurrentYear <= 50) {
    result2 = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result2 = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result2 : 1 - result2;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var YearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(YearParser2, _Parser);
  var _super = _createSuper(YearParser2);
  function YearParser2() {
    var _this;
    _classCallCheck(this, YearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(YearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      var valueCallback = function valueCallback2(year) {
        return {
          year,
          isTwoDigitYear: token === "yy"
        };
      };
      switch (token) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case "yo":
          return mapValue(match.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser2;
}(Parser$1);
var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(LocalWeekYearParser2, _Parser);
  var _super = _createSuper(LocalWeekYearParser2);
  function LocalWeekYearParser2() {
    var _this;
    _classCallCheck(this, LocalWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass(LocalWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      var valueCallback = function valueCallback2(year) {
        return {
          year,
          isTwoDigitYear: token === "YY"
        };
      };
      switch (token) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case "Yo":
          return mapValue(match.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);
  return LocalWeekYearParser2;
}(Parser$1);
var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOWeekYearParser2, _Parser);
  var _super = _createSuper(ISOWeekYearParser2);
  function ISOWeekYearParser2() {
    var _this;
    _classCallCheck(this, ISOWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISOWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser2;
}(Parser$1);
var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ExtendedYearParser2, _Parser);
  var _super = _createSuper(ExtendedYearParser2);
  function ExtendedYearParser2() {
    var _this;
    _classCallCheck(this, ExtendedYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ExtendedYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser2;
}(Parser$1);
var QuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits(QuarterParser2, _Parser);
  var _super = _createSuper(QuarterParser2);
  function QuarterParser2() {
    var _this;
    _classCallCheck(this, QuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(QuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "Q":
        case "QQ":
          return parseNDigits(token.length, dateString);
        case "Qo":
          return match.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "QQQ":
          return match.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser2;
}(Parser$1);
var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits(StandAloneQuarterParser2, _Parser);
  var _super = _createSuper(StandAloneQuarterParser2);
  function StandAloneQuarterParser2() {
    var _this;
    _classCallCheck(this, StandAloneQuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneQuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "q":
        case "qq":
          return parseNDigits(token.length, dateString);
        case "qo":
          return match.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "qqq":
          return match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser2;
}(Parser$1);
var MonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits(MonthParser2, _Parser);
  var _super = _createSuper(MonthParser2);
  function MonthParser2() {
    var _this;
    _classCallCheck(this, MonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    return _this;
  }
  _createClass(MonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      var valueCallback = function valueCallback2(value) {
        return value - 1;
      };
      switch (token) {
        case "M":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback);
        case "Mo":
          return mapValue(match.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback);
        case "MMM":
          return match.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match.month(dateString, {
            width: "wide",
            context: "formatting"
          }) || match.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser2;
}(Parser$1);
var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits(StandAloneMonthParser2, _Parser);
  var _super = _createSuper(StandAloneMonthParser2);
  function StandAloneMonthParser2() {
    var _this;
    _classCallCheck(this, StandAloneMonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneMonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      var valueCallback = function valueCallback2(value) {
        return value - 1;
      };
      switch (token) {
        case "L":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback);
        case "Lo":
          return mapValue(match.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback);
        case "LLL":
          return match.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match.month(dateString, {
            width: "wide",
            context: "standalone"
          }) || match.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser2;
}(Parser$1);
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff2 = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff2 * 7);
  return date;
}
var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits(LocalWeekParser2, _Parser);
  var _super = _createSuper(LocalWeekParser2);
  function LocalWeekParser2() {
    var _this;
    _classCallCheck(this, LocalWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass(LocalWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);
  return LocalWeekParser2;
}(Parser$1);
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff2 = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff2 * 7);
  return date;
}
var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOWeekParser2, _Parser);
  var _super = _createSuper(ISOWeekParser2);
  function ISOWeekParser2() {
    var _this;
    _classCallCheck(this, ISOWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISOWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser2;
}(Parser$1);
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DateParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DateParser2, _Parser);
  var _super = _createSuper(DateParser2);
  function DateParser2() {
    var _this;
    _classCallCheck(this, DateParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DateParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser2;
}(Parser$1);
var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DayOfYearParser2, _Parser);
  var _super = _createSuper(DayOfYearParser2);
  function DayOfYearParser2() {
    var _this;
    _classCallCheck(this, DayOfYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DayOfYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser2;
}(Parser$1);
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff2 = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff2);
  return date;
}
var DayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DayParser2, _Parser);
  var _super = _createSuper(DayParser2);
  function DayParser2() {
    var _this;
    _classCallCheck(this, DayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return match.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser2;
}(Parser$1);
var LocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(LocalDayParser2, _Parser);
  var _super = _createSuper(LocalDayParser2);
  function LocalDayParser2() {
    var _this;
    _classCallCheck(this, LocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
    return _this;
  }
  _createClass(LocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match, options) {
      var valueCallback = function valueCallback2(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "e":
        case "ee":
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        case "eo":
          return mapValue(match.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback);
        case "eee":
          return match.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser2;
}(Parser$1);
var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(StandAloneLocalDayParser2, _Parser);
  var _super = _createSuper(StandAloneLocalDayParser2);
  function StandAloneLocalDayParser2() {
    var _this;
    _classCallCheck(this, StandAloneLocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneLocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match, options) {
      var valueCallback = function valueCallback2(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "c":
        case "cc":
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        case "co":
          return mapValue(match.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback);
        case "ccc":
          return match.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match.day(dateString, {
            width: "wide",
            context: "standalone"
          }) || match.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser2;
}(Parser$1);
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff2 = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff2);
  return date;
}
var ISODayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISODayParser2, _Parser);
  var _super = _createSuper(ISODayParser2);
  function ISODayParser2() {
    var _this;
    _classCallCheck(this, ISODayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISODayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      var valueCallback = function valueCallback2(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        case "i":
        case "ii":
          return parseNDigits(token.length, dateString);
        case "io":
          return match.ordinalNumber(dateString, {
            unit: "day"
          });
        case "iii":
          return mapValue(match.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback);
        case "iiiii":
          return mapValue(match.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback);
        case "iiiiii":
          return mapValue(match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback);
        case "iiii":
        default:
          return mapValue(match.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser2;
}(Parser$1);
var AMPMParser = /* @__PURE__ */ function(_Parser) {
  _inherits(AMPMParser2, _Parser);
  var _super = _createSuper(AMPMParser2);
  function AMPMParser2() {
    var _this;
    _classCallCheck(this, AMPMParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(AMPMParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser2;
}(Parser$1);
var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
  _inherits(AMPMMidnightParser2, _Parser);
  var _super = _createSuper(AMPMMidnightParser2);
  function AMPMMidnightParser2() {
    var _this;
    _classCallCheck(this, AMPMMidnightParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(AMPMMidnightParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser2;
}(Parser$1);
var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DayPeriodParser2, _Parser);
  var _super = _createSuper(DayPeriodParser2);
  function DayPeriodParser2() {
    var _this;
    _classCallCheck(this, DayPeriodParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
    return _this;
  }
  _createClass(DayPeriodParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser2;
}(Parser$1);
var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour1to12Parser2, _Parser);
  var _super = _createSuper(Hour1to12Parser2);
  function Hour1to12Parser2() {
    var _this;
    _classCallCheck(this, Hour1to12Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour1to12Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser2;
}(Parser$1);
var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour0to23Parser2, _Parser);
  var _super = _createSuper(Hour0to23Parser2);
  function Hour0to23Parser2() {
    var _this;
    _classCallCheck(this, Hour0to23Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour0to23Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser2;
}(Parser$1);
var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour0To11Parser2, _Parser);
  var _super = _createSuper(Hour0To11Parser2);
  function Hour0To11Parser2() {
    var _this;
    _classCallCheck(this, Hour0To11Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour0To11Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser2;
}(Parser$1);
var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour1To24Parser2, _Parser);
  var _super = _createSuper(Hour1To24Parser2);
  function Hour1To24Parser2() {
    var _this;
    _classCallCheck(this, Hour1To24Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    return _this;
  }
  _createClass(Hour1To24Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser2;
}(Parser$1);
var MinuteParser = /* @__PURE__ */ function(_Parser) {
  _inherits(MinuteParser2, _Parser);
  var _super = _createSuper(MinuteParser2);
  function MinuteParser2() {
    var _this;
    _classCallCheck(this, MinuteParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 60);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(MinuteParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match.ordinalNumber(dateString, {
            unit: "minute"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser2;
}(Parser$1);
var SecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits(SecondParser2, _Parser);
  var _super = _createSuper(SecondParser2);
  function SecondParser2() {
    var _this;
    _classCallCheck(this, SecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 50);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(SecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match.ordinalNumber(dateString, {
            unit: "second"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser2;
}(Parser$1);
var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits(FractionOfSecondParser2, _Parser);
  var _super = _createSuper(FractionOfSecondParser2);
  function FractionOfSecondParser2() {
    var _this;
    _classCallCheck(this, FractionOfSecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 30);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(FractionOfSecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      var valueCallback = function valueCallback2(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser2;
}(Parser$1);
var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOTimezoneWithZParser2, _Parser);
  var _super = _createSuper(ISOTimezoneWithZParser2);
  function ISOTimezoneWithZParser2() {
    var _this;
    _classCallCheck(this, ISOTimezoneWithZParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "x"]);
    return _this;
  }
  _createClass(ISOTimezoneWithZParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser2;
}(Parser$1);
var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOTimezoneParser2, _Parser);
  var _super = _createSuper(ISOTimezoneParser2);
  function ISOTimezoneParser2() {
    var _this;
    _classCallCheck(this, ISOTimezoneParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "X"]);
    return _this;
  }
  _createClass(ISOTimezoneParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser2;
}(Parser$1);
var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits(TimestampSecondsParser2, _Parser);
  var _super = _createSuper(TimestampSecondsParser2);
  function TimestampSecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampSecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 40);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampSecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser2;
}(Parser$1);
var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits(TimestampMillisecondsParser2, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser2);
  function TimestampMillisecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 20);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampMillisecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser2;
}(Parser$1);
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions = getDefaultOptions();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
  if (!locale.match) {
    throw new RangeError("locale must contain match property");
  }
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters) {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens), _step;
  try {
    var _loop = function _loop2() {
      var token = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function(usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale.match, subFnOptions);
        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        }
        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      if (_typeof(_ret) === "object")
        return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a, b) {
    return b - a;
  }).filter(function(priority, index2, array) {
    return array.indexOf(priority) === index2;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }
      var result2 = setter.set(utcDate, flags, subFnOptions);
      if (Array.isArray(result2)) {
        utcDate = result2[0];
        assign$1(flags, result2[1]);
      } else {
        utcDate = result2;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
const numericParser = (text2, params2) => {
  const groupingSeparator = (params2 == null ? void 0 : params2.groupingSeparator) ? params2.groupingSeparator : ",";
  const decimalSeparator = (params2 == null ? void 0 : params2.decimalSeparator) ? params2.decimalSeparator : ".";
  const regex = new RegExp(`-{0,1}([0-9]+\\${groupingSeparator}{0,1})*\\d+(\\${decimalSeparator}\\d+)*`, "gm");
  const numberText = text2.replace(/\s/g, "");
  const cleaned = numberText.match(regex);
  if (!cleaned)
    throw new InValidFormatError("number", text2);
  let processed = cleaned[0].replace(/[^\d\-.,]/g, "");
  if (decimalSeparator == "," && groupingSeparator == ".") {
    processed = processed.replace(/\./g, ",");
    processed = processed.replace(/,/g, ".");
  } else if (decimalSeparator == "." && groupingSeparator == ",") {
    processed = processed.replace(/,/g, "");
  }
  processed = processed.replace(/\.(?=.*\.)/g, "");
  return Number(processed);
};
const currencyParser = (text2, params2) => {
  const parsed = numericParser(text2, params2);
  if (!parsed)
    throw new InValidFormatError("currency", text2);
  const pow = 10 ** 2;
  return Math.round(parsed * pow) / pow;
};
const booleanParser = async (text2, params2) => await runExpressions([params2.expr], {
  vars: [{ name: "str", dataType: "string", value: text2 }]
});
const textParser = (text2) => String(text2);
const dateParser = (dateString, params2) => {
  const formatString = (params2 == null ? void 0 : params2.format) || "MM-dd-yyyy";
  const parsedDate = parse(dateString, formatString, new Date());
  const valid = isValid(parsedDate) && dateString === format(parsedDate, formatString);
  if (!valid)
    throw new InValidFormatError("date", dateString);
  return parsedDate;
};
const urlParser = (text2) => {
  try {
    return new URL(text2);
  } catch (err) {
    throw new InValidSyntaxError("URL", text2, err.message);
  }
};
const jsonParser = (text2) => {
  try {
    return JSON.parse(text2);
  } catch (err) {
    throw new InValidSyntaxError("JSON", null, err.message);
  }
};
const DATA_PARSERS = {
  [Type.string]: textParser,
  [Type.number]: numericParser,
  [Type.currency]: currencyParser,
  [Type.date]: dateParser,
  [Type.url]: urlParser,
  [Type.boolean]: booleanParser,
  [Type.json]: jsonParser
};
class DataParser extends Proc$1 {
  constructor(tag, data, data_type, parser) {
    super(tag, data);
    __publicField(this, "data_type");
    __publicField(this, "parser");
    this.data_type = data_type;
    this.parser = parser;
  }
  isDatatypeSupported() {
    const primitiveType = getPrimitive$1(this.data_type);
    return PRIMITIVES.includes(primitiveType) && DATA_PARSERS.hasOwnProperty(primitiveType);
  }
  async parse() {
    try {
      if (!this.isDatatypeSupported()) {
        throw new UnsupportedDataTypeError(this.data_type);
      }
      if (!isValidData(this.data)) {
        throw new DataNotFoundError("Data not found for parsing");
      }
      if (isArrayType(this.data_type)) {
        const primitiveType = getPrimitive$1(this.data_type);
        const res = [];
        for (const datum of this.data) {
          res.push(await DATA_PARSERS[primitiveType](datum, this.parser));
        }
        return res;
      } else {
        return await DATA_PARSERS[this.data_type](this.data, this.parser);
      }
    } catch (err) {
      throw StackedError.handle(err, "parser");
    }
  }
}
function getPrimitive$1(data_type) {
  if (isArrayType(data_type)) {
    return data_type.slice(6, -1);
  } else {
    return data_type;
  }
}
function isValidData(data) {
  if (Array.isArray(data)) {
    return data.every((datum) => isValidData(datum));
  }
  return typeof data === "string";
}
class DataMapper extends Proc$1 {
  constructor(tag, data, mappers) {
    super(tag, data);
    __publicField(this, "mappers");
    __publicField(this, "data", []);
    this.data = data;
    this.mappers = mappers != null ? mappers : [];
  }
  async map() {
    if (!this.data) {
      throw StackedError.handle(new DataNotFoundError("Data not found for mapper"), "mapper");
    }
    let data = this.data;
    const mappers = this.mappers;
    for (let idx = 0; idx < mappers.length; idx++) {
      const mapper = mappers[idx];
      try {
        const mapResult = await this.runMapper(mapper, data);
        data = mapResult;
      } catch (err) {
        const mapperSL = err.findLast("mapper");
        mapperSL.mapper_index = idx;
        throw err;
      }
    }
    return data;
  }
  async runMapper(mapper, data) {
    const result2 = [];
    for (const text2 of data) {
      try {
        let val = text2;
        val = await runExpressions([mapper], {
          vars: [{ name: "str", dataType: "string", value: val }]
        });
        result2.push(val);
      } catch (err) {
        throw StackedError.handle(err, "mapper", { text: text2 });
      }
    }
    return result2;
  }
}
class DataReducer extends Proc$1 {
  constructor(tag, data, reducer) {
    super(tag, data);
    __publicField(this, "reducer");
    this.reducer = reducer;
  }
  async reduce() {
    try {
      if (!this.data)
        throw new DataNotFoundError("Data not found for reducer");
      if (!this.reducer)
        throw new ReducerNotFoundError();
      return await runExpressions([this.reducer], {
        vars: [{ name: "val", dataType: "array<string>", value: this.data }]
      });
    } catch (err) {
      throw StackedError.handle(err, "reducer");
    }
  }
}
const extractData = (tag, doc = document) => {
  try {
    return new DataExtractor$1(tag, doc).extract();
  } catch (err) {
    throw StackedError.handle(err, "extractor");
  }
};
async function applyMappers$1(tag, data) {
  var _a;
  return await new DataMapper(tag, data, (_a = tag == null ? void 0 : tag.procs) == null ? void 0 : _a.mappers).map();
}
async function applyReducers$1(tag, data) {
  var _a;
  return await new DataReducer(tag, data, (_a = tag == null ? void 0 : tag.procs) == null ? void 0 : _a.reducer).reduce();
}
async function applyParser$1(tag, data) {
  return await new DataParser(tag, data, tag == null ? void 0 : tag.data_type, tag == null ? void 0 : tag.procs.parser).parse();
}
async function validateTagData$1(tag, data) {
  var _a;
  await new DataValidator(tag, data, tag == null ? void 0 : tag.data_type, (_a = tag == null ? void 0 : tag.procs) == null ? void 0 : _a.validator).validate();
}
async function processTagData(tag, doc = document) {
  const extracted = extractData(tag, doc);
  return await applyProcessors(tag, extracted);
}
async function applyProcessors(tag, extracted) {
  try {
    const mapped = await applyMappers$1(tag, extracted);
    const previousRes = tag.procs.reducer ? await applyReducers$1(tag, mapped) : mapped;
    const parsed = await applyParser$1(tag, previousRes);
    await validateTagData$1(tag, parsed);
    return parsed;
  } catch (err) {
    throw StackedError.handle(err, "processor");
  }
}
async function getStructuredTagData(tags, doc = document) {
  const response = {
    data: {},
    errors: {},
    warnings: {}
  };
  for (const tag of tags) {
    try {
      response.data[tag.name] = await processTagData(tag, doc);
    } catch (err) {
      err = StackedError.handle(err, "tag", {
        id: tag.id,
        name: tag.name,
        version: tag.version,
        schema_property_id: tag.id
      });
      if (!err.code) {
        err.code = "E_UNKNOWN";
      }
      response.errors = {
        [tag.id]: err.toJSON()
      };
      break;
    }
  }
  return response;
}
function getFrameView(view, frameLocator) {
  let pageId = -1, frameId = 0;
  if (frameLocator) {
    if (typeof frameLocator === "number") {
      frameId = frameLocator;
    } else {
      if (frameLocator.page) {
        pageId = frameLocator.page;
      }
      if (frameLocator.hasOwnProperty("index") && typeof frameLocator.index === "number") {
        frameId = frameLocator.index;
      }
    }
  }
  let pageView = view.getPage(pageId);
  let page = pageView.store;
  let frame = page.frames[frameId];
  return pageView.getFrame(frame.id);
}
function getPageView(view, pageLocator) {
  return view.getPage(pageLocator || -1);
}
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const keyCodeMap = {
  "Enter": 13,
  "Backspace": 8
};
class BrowserImpl {
  constructor(browserView) {
    this.documentEventCounter = 0;
    this.status_code = 0;
    this.body_text_length = 0;
    this.browserView = browserView;
    const methods = ["click", "select", "keypress", "mousemove", "drag", "focus", "type", "scroll", "open"];
    methods.forEach((method) => {
      const originalMethod = this[method];
      this[method] = async (...args) => {
        this.documentEventCounter = 0;
        await originalMethod.call(this, ...args);
      };
    });
    const mainFrame = getFrameView(this.browserView);
    mainFrame.on("document", () => {
      this.documentEventCounter++;
    });
    this.status_code = mainFrame.store.response_status;
    mainFrame.store.on("change:response_status", () => {
      this.status_code = mainFrame.store.response_status;
    });
  }
  async click(selector, _pos, opts) {
    let frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    await frameView.store.call("click", selector.value);
  }
  async waitForDoc(opts) {
    var _a;
    const docLoaded = this.documentEventCounter > 0;
    this.documentEventCounter--;
    if (docLoaded) {
      return;
    }
    let frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    await frameView.waitForEvent("document", { timeout: ((_a = opts == null ? void 0 : opts.timeout) != null ? _a : 30) * 1e3 });
    await wait(2e3);
  }
  async waitForDocumentRequest(opts) {
    var _a;
    const frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    const timeout = ((_a = opts == null ? void 0 : opts.timeout) != null ? _a : 30) * 1e3;
    await frameView.waitForEvent("navigated", { timeout });
  }
  async select(selector, value, opts) {
    let frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    await frameView.store.call("select", selector.value, value);
  }
  async keypress(code, count2, opts) {
    let pageView = getPageView(this.browserView, opts == null ? void 0 : opts.page);
    let page = pageView.store;
    let data = {
      code,
      count: count2,
      keyCode: keyCodeMap[code]
    };
    await page.trigger("keypress", data);
  }
  async mousemove(selector, pos, opts) {
    let frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    frameView.dispatchEventMousemove2(selector.value, pos.x, pos.y);
  }
  async drag(selector, pos, targetSelector, targetPos, opts) {
    let frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    let page = frameView.pageView.store;
    frameView.dispatchEventMousemove2(selector.value, pos.x, pos.y);
    await wait(100);
    await page.call("mousedown");
    await wait(100);
    frameView.dispatchEventMousemove2(targetSelector.value, targetPos.x, targetPos.y);
    await wait(100);
    await page.call("mouseup");
  }
  async focus(selector, opts) {
    let frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    await frameView.store.call("focus", selector.value);
  }
  async fill(selector, value, opts) {
    let frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    await frameView.store.call("fill", selector.value, value);
  }
  async type(selector, value, opts) {
    let frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    await frameView.store.call("type", selector.value, value);
  }
  async scroll(selector, left, top, opts) {
    var _a;
    let timeout = ((_a = opts == null ? void 0 : opts.timeout) != null ? _a : 30) * 1e3;
    let startTime = Date.now();
    let frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    let el2 = await this.waitAndGetElement({ selector }, frameView.getDoc(), opts);
    let scrollDiff = Math.max(top - el2.scrollTop, left - el2.scrollLeft);
    while (scrollDiff > 10 && Date.now() - startTime < timeout) {
      frameView.dispatchEventScroll2(selector, left, top);
      await wait(1e3);
      scrollDiff = Math.max(top - el2.scrollTop, left - el2.scrollLeft);
    }
  }
  async open(url, opts) {
    let pageView = getPageView(this.browserView, opts == null ? void 0 : opts.page);
    await pageView.store.goto(url);
  }
  async getElementsCount(selector, opts) {
    let frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    return querySelectorAll(selector, frameView.getDoc()).length;
  }
  async getSelectors(selector, opts) {
    let frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    const elements = querySelectorAll(selector, frameView.getDoc());
    const commonXPath = await getXPATH(elements);
    return elements.map((_el, ind) => ({
      type: "xpath",
      value: `(${commonXPath})[${ind + 1}]`,
      meta: {}
    }));
  }
  async getElementText(selector, opts) {
    return await this.evalOnSelector(selector, (el2) => {
      var _a;
      return (_a = el2.innerText) != null ? _a : "";
    }, null, opts);
  }
  async waitAndGetElement({ selector }, doc, options) {
    var _a;
    let cutoffTime = Date.now() + ((_a = options == null ? void 0 : options.timeout) != null ? _a : 30) * 1e3;
    while (cutoffTime > Date.now()) {
      const els = querySelectorAll(selector, doc);
      if (els.length > 0) {
        return els[0];
      }
      await wait(500);
    }
    throw new Error(`timed out waiting for element ${selector.value}`);
  }
  async evalOnSelector(selector, func2, arg, opts) {
    const frameView = getFrameView(this.browserView, opts == null ? void 0 : opts.frame);
    return await frameView.store.call("evalOnSelector", selector.value, func2.toString(), arg);
  }
  destroy() {
    const mainFrame = getFrameView(this.browserView);
    mainFrame.reset();
    mainFrame.store.reset();
  }
}
class Scraper$1 {
  constructor(browserView, schemaList) {
    this.browserView = browserView;
    this.schemaList = schemaList;
  }
  async scrape(schemaID) {
    if (!this.schemaList) {
      throw new Error("schemaList is not set");
    }
    let schema = this.schemaList.find((schema2) => schema2.get("id") === schemaID);
    if (!schema) {
      throw new Error(`schema ${schemaID} not found`);
    }
    let frameView = getFrameView(this.browserView, schema.frame);
    let res = await getStructuredTagData(schema.toJSON().tags, frameView.getDoc());
    if (Object.keys(res.errors).length > 0) {
      let msg = "";
      for (let tag in res.errors) {
        msg += `${tag}: ${res.errors[tag].message}
`;
      }
      throw new Error(msg);
    }
    return res.data;
  }
}
function querySelectorAll(selector, doc) {
  if (selector.type === "css") {
    return [...doc.querySelectorAll(selector.value)];
  } else if (selector.type === "xpath") {
    let els = [];
    let iterator = doc.evaluate(selector.value, doc, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
    try {
      let thisNode = iterator.iterateNext();
      while (thisNode) {
        els.push(thisNode);
        thisNode = iterator.iterateNext();
      }
      return els;
    } catch (e) {
      throw new Error("Document tree modified during iteration" + e);
    }
  } else {
    throw new Error("unsupported selector type:" + selector.type);
  }
}
class BrowserListener extends EventEmitter {
  constructor(view) {
    super();
    this.view = view;
    this.mgr = view.manager;
    [
      "onAction",
      "onEffect",
      "onFrameAdded",
      "onFrameDetached",
      "onPageAdded",
      "onPageDeleted"
    ].forEach((name) => this[name] = this[name].bind(this));
  }
  onEffect(name, event, fv) {
    this.emit("effect", name, event, fv);
  }
  onAction(name, params2, target, fv) {
    this.emit("action", name, params2, target, fv);
  }
  onFrameAdded(fv) {
    fv.on("bbx", this.onEffect);
    fv.on("trigger", this.onAction);
  }
  onFrameDetached(fv) {
    fv.off("bbx", this.onEffect);
    fv.off("trigger", this.onAction);
  }
  onPageAdded(pv) {
    pv.on("frameadded", this.onFrameAdded);
    pv.on("framedetached", this.onFrameDetached);
    pv.frameViews.forEach(this.onFrameAdded);
  }
  onPageDeleted(pv) {
    pv.off("frameadded", this.onFrameAdded);
    pv.off("framedetached", this.onFrameDetached);
    pv.frameViews.forEach(this.onFrameDetached);
  }
  start() {
    this.view.on("pageadded", this.onPageAdded);
    this.view.on("pagedeleted", this.onPageDeleted);
    this.view.pageViews.forEach(this.onPageAdded);
  }
  stop() {
    this.view.off("pageadded", this.onPageAdded);
    this.view.off("pagedeleted", this.onPageDeleted);
    this.view.pageViews.forEach(this.onPageDeleted);
  }
}
function hasScrape(step) {
  return step instanceof FunctionCall && step.name === StepType.SCRAPE || step.children.some(hasScrape);
}
var StepType = /* @__PURE__ */ ((StepType2) => {
  StepType2["CLICK"] = "click";
  StepType2["DRAG"] = "drag";
  StepType2["FILL"] = "fill";
  StepType2["KEYPRESS"] = "keypress";
  StepType2["SCROLL"] = "scroll";
  StepType2["SELECT"] = "select";
  StepType2["SCRAPE"] = "scrape";
  StepType2["TYPE"] = "type";
  StepType2["TYPE_SECRET"] = "type_secret";
  StepType2["WAIT_DOC"] = "wait_doc";
  return StepType2;
})(StepType || {});
const INPUT_TO_TYPE = ["email", "number", "password", "search", "tel", "text", "url"];
const INPUT_TO_FILL = ["color", "date", "datetime-local", "file", "image", "month", "time", "week"];
function shouldNotClickControl(el2) {
  return el2.tagName == "SELECT" || el2.tagName == "INPUT" && INPUT_TO_FILL.includes(el2 == null ? void 0 : el2.type);
}
class Base extends Store {
  constructor(view, findSelector, root2, opts) {
    var _a;
    super();
    this._latestMousePosition = { x: 0, y: 0 };
    this._mouseActionBuffer = [];
    this.isRecording = false;
    this.optInParams = false;
    this._cursor = 0;
    this.onAction = async (name, params2, target, fv) => {
      let lastAction = this.steps[this.steps.length - 1];
      if (name === "select") {
        const value = escapeDollar(getValueOrLabel(params2.indexes[0], target));
        if (isOfStepType(lastAction, "select") && isLocatorExpression(lastAction.children[0]) && this.lastRecordedEl === target && lastAction.children[1] instanceof Literal) {
          let valueNode = lastAction.children[1];
          valueNode.value = value;
          this.emit("change");
        } else {
          this._recordStep(
            [
              "select",
              await this.createLocator(target),
              value,
              { frame: fv.store.getIndex() }
            ],
            target
          );
        }
        return;
      }
      if (name == "input" && isInputToFill(target)) {
        let lastStep = this.steps[this.cursor - 1];
        if (lastStep instanceof FunctionCall && isLocatorExpression(lastStep.children[0]) && this.lastRecordedEl === target && lastStep.children[1] instanceof Literal) {
          let valueNode = lastStep.children[1];
          valueNode.value = target.value;
          this.emit("change");
        } else {
          this._recordStep([
            "fill",
            await this.createLocator(target),
            escapeDollar(target.value),
            { frame: fv.store.getIndex() }
          ], target);
        }
        return;
      }
      if (name === "scroll") {
        this._recordStep([
          "scroll",
          await this.createLocator(target),
          params2.left | 0,
          params2.top | 0,
          { frame: fv.store.getIndex() }
        ]);
      }
      let isKey = name.startsWith("key");
      let isMouse = name.startsWith("mouse");
      if (isKey) {
        let { key } = params2;
        if (name === "keydown" && key === "Enter") {
          if (isOfStepType(lastAction, "keypress") && lastAction.children[0] instanceof Enum && lastAction.children[0].value === key && lastAction.children[1] instanceof Literal && lastAction.children[1].returnType === "int") {
            lastAction.children[1].value = lastAction.children[1].value + 1;
            this.emit("change");
          } else {
            this._recordStep(["keypress", key, 1, { frame: fv.store.getIndex() }], target);
          }
        }
        return;
      }
      if (isMouse) {
        let pos = this._getTargetPos(target, params2);
        if (pos.x && pos.y) {
          this._latestMousePosition = pos;
        }
        let suffix = name.split("mouse")[1];
        await this._addMouseAction(suffix, target, { ...this._latestMousePosition }, { frame: fv.store.getIndex() });
      } else {
        this._mouseActionBuffer = [];
      }
    };
    this.onEffect = async (name, event, fv) => {
      switch (name) {
        case "navigated":
          if (fv.store.isMain())
            ;
          break;
        case "document":
          if (fv.store.isMain()) {
            this._recordStep(["wait_doc", { frame: fv.store.getIndex() }]);
          }
          break;
        case "input": {
          let target = fv.getNode(event.path);
          if (isInput(target)) {
            let lastStep = this.steps[this.cursor - 1];
            if ((isOfStepType(lastStep, "type") || isOfStepType(lastStep, "type_secret")) && isLocatorExpression(lastStep.children[0]) && this.lastRecordedEl === target) {
              if (lastStep.children[1] instanceof Literal) {
                let valueNode = lastStep.children[1];
                valueNode.value = target.value;
                this.emit("change");
              }
            } else {
              if (target.type === "password") {
                if (this.optInParams) {
                  const name2 = this.params.generateName("password");
                  this.params.add({ name: name2, dataType: C$2.SECRET, default: "" });
                  this._recordStep([
                    "type_secret",
                    await this.createLocator(target),
                    `$${name2}`,
                    { frame: fv.store.getIndex() }
                  ], target);
                } else {
                  this._recordStep([
                    "type_secret",
                    await this.createLocator(target),
                    ["secret", escapeDollar(target.value)],
                    { frame: fv.store.getIndex() }
                  ], target);
                }
              } else {
                this._recordStep([
                  "type",
                  await this.createLocator(target),
                  escapeDollar(target.value),
                  { frame: fv.store.getIndex() }
                ], target);
              }
            }
          }
          break;
        }
      }
    };
    this.browserView = view;
    this.findSelector = findSelector;
    this.root = root2;
    this.expressionBlock = root2.expression;
    this.optInParams = (_a = opts == null ? void 0 : opts.optInParams) != null ? _a : false;
    if (opts == null ? void 0 : opts.optInParams) {
      this.params = opts.params;
    }
    this.resetCursor();
  }
  get browserView() {
    return this._browserView;
  }
  set browserView(view) {
    var _a, _b, _c, _d, _e;
    (_a = this._browserListener) == null ? void 0 : _a.stop();
    (_b = this._browserListener) == null ? void 0 : _b.off("effect", this.onEffect);
    (_c = this._browserListener) == null ? void 0 : _c.off("action", this.onAction);
    this._browserView = view;
    this._browserListener = view ? new BrowserListener(view) : void 0;
    (_d = this._browserListener) == null ? void 0 : _d.on("effect", this.onEffect);
    (_e = this._browserListener) == null ? void 0 : _e.on("action", this.onAction);
  }
  get cursor() {
    return this._cursor;
  }
  set cursor(index2) {
    this._cursor = index2;
    this.emit("change");
  }
  get expressionBlock() {
    return this._expressionBlock;
  }
  set expressionBlock(block) {
    this._expressionBlock = block;
    this.resetCursor();
    this.emit("change");
  }
  get steps() {
    return this.expressionBlock.nodes;
  }
  async _addMouseAction(type, target, position, opts = {}) {
    if (type === "move")
      ;
    else if (type === "down") {
      this._mouseActionBuffer = [];
      this._mouseActionBuffer.push([type, target, position, opts]);
    } else if (type === "up") {
      if (this._mouseActionBuffer.length === 0)
        return;
      let [startType, startTarget, startPosition, startOpts] = this._mouseActionBuffer.pop();
      this._mouseActionBuffer = [];
      if (startType !== "down" || startOpts.frame !== opts.frame)
        return;
      if (startTarget === target && Math.abs(startPosition.x - position.x) <= 3 && Math.abs(startPosition.y - position.y) <= 3) {
        if (shouldNotClickControl(target)) {
          return;
        }
        this._recordStep(["click", await this.createLocator(target), { ...startPosition }, opts], target);
      } else {
        this._recordStep([
          "drag",
          await this.createLocator(startTarget),
          { ...startPosition },
          await this.createLocator(target),
          { ...position },
          opts
        ], target);
      }
    }
  }
  async createLocator(el2) {
    let locator = (await this.findSelector(el2)).toJSON();
    locator.value = escapeDollar(locator.value);
    return locator;
  }
  emit(name, ...args) {
    super.emit(name, ...args);
    this._notify();
  }
  getStoreValue() {
    return this;
  }
  _getTargetPos(el2, { clientX, clientY }) {
    let elRect = el2.getBoundingClientRect();
    let x = clientX - elRect.left;
    let y = clientY - elRect.top;
    return { x, y };
  }
  _notify() {
    this._listeners.forEach((listener) => listener(this));
  }
  _recordStep(newStep, lastRecordedEl) {
    this.lastRecordedEl = lastRecordedEl;
    this.expressionBlock.insertAt(this.cursor, newStep);
    this.cursor += 1;
    this._removeRedundant();
    this.emit("change");
  }
  _removeRedundant() {
    let hasRedundancy = true;
    while (hasRedundancy) {
      let len = this.steps.length;
      if (this.cursor < 2)
        return;
      let lastStep = this.steps[this.cursor - 1];
      let secondLastStep = this.steps[this.cursor - 2];
      hasRedundancy = false;
      if (isOfStepType(lastStep, "wait_doc") && isOfStepType(secondLastStep, "wait_doc")) {
        this.expressionBlock.remove(lastStep);
        hasRedundancy = true;
      } else if (isOfStepType(lastStep, "keypress") && secondLastStep instanceof FunctionCall && secondLastStep.name === "keypress" && (lastStep.children[0] instanceof Literal && lastStep.children[0].returnType === "string") && (secondLastStep.children[0] instanceof Literal && secondLastStep.children[0].returnType === "string") && (lastStep.children[1] instanceof Literal && lastStep.children[1].returnType === "int") && (secondLastStep.children[1] instanceof Literal && secondLastStep.children[1].returnType === "int")) {
        hasRedundancy = true;
        secondLastStep.children[1].value = secondLastStep.children[1].value + lastStep.children[1].value;
        this.expressionBlock.remove(lastStep);
      } else if (isOfStepType(lastStep, "keypress") && isOfStepType(secondLastStep, "type") && lastStep.children[0] instanceof Enum && lastStep.children[0].name === "keypress_code" && lastStep.children[0].value === "Backspace" && isLocatorExpression(secondLastStep.children[0]) && isInput(this.lastRecordedEl) && secondLastStep.children[1] instanceof Literal && secondLastStep.children[1].returnType === "string") {
        hasRedundancy = true;
        secondLastStep.children[1].value = secondLastStep.children[1].value.slice(0, -1);
        this.expressionBlock.remove(lastStep);
      } else if (isOfStepType(lastStep, "select") && secondLastStep instanceof FunctionCall && secondLastStep.name === "click" && isLocatorExpression(lastStep.children[0]) && isLocatorExpression(secondLastStep.children[0]) && isEqual(lastStep.children[0].toJSON(), secondLastStep.children[0].toJSON())) {
        hasRedundancy = true;
        this.expressionBlock.remove(secondLastStep);
      } else if (isOfStepType(lastStep, "keypress") && secondLastStep instanceof FunctionCall && secondLastStep.name === "keypress" && lastStep.children[0] instanceof Literal && secondLastStep.children[0] instanceof Literal && lastStep.children[0].value === secondLastStep.children[0].value) {
        let lastCount = lastStep.children[1];
        let secondLastCount = secondLastStep.children[1];
        if (lastCount instanceof Literal && secondLastCount instanceof Literal) {
          hasRedundancy = true;
          secondLastCount.value = lastCount.value + secondLastCount.value;
          this.expressionBlock.remove(lastStep);
        }
      } else if (isOfStepType(lastStep, "scroll") && secondLastStep instanceof FunctionCall && secondLastStep.name === "scroll" && isLocatorExpression(lastStep.children[0]) && isLocatorExpression(secondLastStep.children[0]) && isEqual(lastStep.children[0].toJSON(), secondLastStep.children[0].toJSON()) && lastStep.children[1] instanceof Literal && secondLastStep.children[1] instanceof Literal && lastStep.children[2] instanceof Literal && secondLastStep.children[2] instanceof Literal) {
        hasRedundancy = true;
        secondLastStep.children[1].value = lastStep.children[1].value;
        secondLastStep.children[2].value = lastStep.children[2].value;
        this.expressionBlock.remove(lastStep);
      }
      if (hasRedundancy) {
        this.cursor -= len - this.steps.length;
      }
    }
  }
  reset() {
    this.expressionBlock = this.root.expression;
    let lastNode = this.steps[this.steps.length - 1];
    let end = this.steps.length - 1;
    if (hasScrape(lastNode)) {
      end -= 1;
    }
    for (let i2 = end; i2 >= 0; i2--) {
      this.expressionBlock.remove(this.steps[i2]);
    }
    if (this.params) {
      for (let param of this.params.list) {
        this.params.remove(param.name);
      }
    }
    this.resetCursor();
    this._mouseActionBuffer = [];
    this._latestMousePosition = { x: 0, y: 0 };
    this.lastRecordedEl = void 0;
    this.emit("change");
  }
  resetCursor() {
    this.cursor = this.steps.length;
    if (this.cursor === 0)
      return;
    if (hasScrape(this.steps[this.cursor - 1])) {
      this.cursor -= 1;
    }
    this.emit("change");
  }
  start() {
    if (!this._browserListener) {
      return;
    }
    this._browserListener.start();
    this.isRecording = true;
    this.emit("change");
  }
  stop() {
    var _a;
    (_a = this._browserListener) == null ? void 0 : _a.stop();
    this.isRecording = false;
    this.emit("change");
  }
  subscribe(listener) {
    this._listeners.push(listener);
    listener(this);
    return () => {
      this._listeners.splice(this._listeners.indexOf(listener), 1);
    };
  }
}
function getValueOrLabel(index2, element2) {
  let options = element2.options;
  return hasDuplicateValue(options[index2].value, options) ? options[index2].label : options[index2].value;
}
function hasDuplicateValue(value, options) {
  let values2 = Array.from(options).filter((option) => option.value === value);
  return values2.length > 1;
}
function isInput(el2) {
  const input = el2;
  const { type } = input;
  const name = el2.tagName.toLowerCase();
  return name === "input" && INPUT_TO_TYPE.includes(type) || name === "textarea";
}
function isInputToFill(el2) {
  const input = el2;
  const { type } = input;
  const name = el2.tagName.toLowerCase();
  return name === "input" && INPUT_TO_FILL.includes(type);
}
function isOfStepType(node, type) {
  return node instanceof FunctionCall && node.name === type;
}
function isEqual(a, b) {
  return JSON.stringify(a) == JSON.stringify(b);
}
function create_if_block$1G(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    var _a;
    if ((_a = ctx2[8]) == null ? void 0 : _a.isRecording)
      return create_if_block_1$19;
    return create_else_block$Y;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$Y(ctx) {
  let button;
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text("Start Recording");
      attr(button, "class", "btn btn-outline-danger btn-sm");
      button.disabled = button_disabled_value = ctx[9].isPlaying;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[2]))
            ctx[2].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 512 && button_disabled_value !== (button_disabled_value = ctx[9].isPlaying)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$19(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Stop Recording";
      attr(button, "class", "btn btn-outline-danger btn-sm");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[1]))
            ctx[1].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$18(ctx) {
  let t;
  return {
    c() {
      t = text("Reset Steps");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_items_slot$3(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem$1({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$18] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", function() {
    if (is_function(ctx[6]))
      ctx[6].apply(this, arguments);
  });
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 1024) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_fragment$2Z(ctx) {
  let div2;
  let t0;
  let div0;
  let t1;
  let button0;
  let t2;
  let button0_disabled_value;
  let t3;
  let button1;
  let t4;
  let button1_disabled_value;
  let t5;
  let div1;
  let menubtn;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[7] && create_if_block$1G(ctx);
  menubtn = new MenuBtn({
    props: {
      $$slots: { items: [create_items_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      button0 = element("button");
      t2 = text("Replay");
      t3 = space();
      button1 = element("button");
      t4 = text("Stop");
      t5 = space();
      div1 = element("div");
      create_component(menubtn.$$.fragment);
      set_style(div0, "flex", "1");
      attr(button0, "class", "btn btn-secondary btn-sm");
      button0.disabled = button0_disabled_value = ctx[9].isPlaying;
      attr(button1, "class", "btn btn-secondary btn-sm");
      button1.disabled = button1_disabled_value = !ctx[9].isPlaying;
      attr(div1, "style", div1_style_value = ctx[9].isPlaying ? "pointer-events: none;" : "");
      attr(div2, "class", "d-flex p-2 py-3 gap-2 bbx-border-b align-items-center");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t0);
      append(div2, div0);
      append(div2, t1);
      append(div2, button0);
      append(button0, t2);
      append(div2, t3);
      append(div2, button1);
      append(button1, t4);
      append(div2, t5);
      append(div2, div1);
      mount_component(menubtn, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(ctx[3]))
              ctx[3].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(ctx[5]))
              ctx[5].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!ctx[7]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$1G(ctx);
          if_block.c();
          if_block.m(div2, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 512 && button0_disabled_value !== (button0_disabled_value = ctx[9].isPlaying)) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty & 512 && button1_disabled_value !== (button1_disabled_value = !ctx[9].isPlaying)) {
        button1.disabled = button1_disabled_value;
      }
      const menubtn_changes = {};
      if (dirty & 1088) {
        menubtn_changes.$$scope = { dirty, ctx };
      }
      menubtn.$set(menubtn_changes);
      if (!current || dirty & 512 && div1_style_value !== (div1_style_value = ctx[9].isPlaying ? "pointer-events: none;" : "")) {
        attr(div1, "style", div1_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menubtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menubtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block)
        if_block.d();
      destroy_component(menubtn);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2W($$self, $$props, $$invalidate) {
  let $recorder, $$unsubscribe_recorder = noop$1, $$subscribe_recorder = () => ($$unsubscribe_recorder(), $$unsubscribe_recorder = subscribe(recorder, ($$value) => $$invalidate(8, $recorder = $$value)), recorder);
  let $replayStatus, $$unsubscribe_replayStatus = noop$1, $$subscribe_replayStatus = () => ($$unsubscribe_replayStatus(), $$unsubscribe_replayStatus = subscribe(replayStatus, ($$value) => $$invalidate(9, $replayStatus = $$value)), replayStatus);
  $$self.$$.on_destroy.push(() => $$unsubscribe_recorder());
  $$self.$$.on_destroy.push(() => $$unsubscribe_replayStatus());
  let { recorder, stopRecording, record, replay: replay2, replayStatus, stopReplay, reset, replayOnly } = $$props;
  $$subscribe_recorder();
  $$subscribe_replayStatus();
  $$self.$$set = ($$props2) => {
    if ("recorder" in $$props2)
      $$subscribe_recorder($$invalidate(0, recorder = $$props2.recorder));
    if ("stopRecording" in $$props2)
      $$invalidate(1, stopRecording = $$props2.stopRecording);
    if ("record" in $$props2)
      $$invalidate(2, record = $$props2.record);
    if ("replay" in $$props2)
      $$invalidate(3, replay2 = $$props2.replay);
    if ("replayStatus" in $$props2)
      $$subscribe_replayStatus($$invalidate(4, replayStatus = $$props2.replayStatus));
    if ("stopReplay" in $$props2)
      $$invalidate(5, stopReplay = $$props2.stopReplay);
    if ("reset" in $$props2)
      $$invalidate(6, reset = $$props2.reset);
    if ("replayOnly" in $$props2)
      $$invalidate(7, replayOnly = $$props2.replayOnly);
  };
  return [
    recorder,
    stopRecording,
    record,
    replay2,
    replayStatus,
    stopReplay,
    reset,
    replayOnly,
    $recorder,
    $replayStatus
  ];
}
class RecorderControl extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2W, create_fragment$2Z, safe_not_equal, {
      recorder: 0,
      stopRecording: 1,
      record: 2,
      replay: 3,
      replayStatus: 4,
      stopReplay: 5,
      reset: 6,
      replayOnly: 7
    });
  }
}
Declarations.prototype.initListening = function() {
  this._listeners = [];
  this.on("change", () => {
    this._listeners.forEach((listener) => {
      listener(this);
    });
  });
  this._listening = true;
};
Declarations.prototype.subscribe = function(listener) {
  if (!this._listening) {
    this.initListening();
  }
  this._listeners.push(listener);
  listener(this);
  return () => {
    this._listeners.splice(this._listeners.indexOf(listener), 1);
  };
};
class Param$2 extends Store {
  constructor(name, declarations) {
    super();
    this._name = name;
    this._declarations = declarations;
  }
  get dataType() {
    return this._param.dataType;
  }
  set dataType(newType) {
    this._declarations.changeType(this.name, newType);
    if (this.default !== void 0) {
      this.default = getDefault(this.dataType);
    }
  }
  get default() {
    return this._param.default;
  }
  set default(newValue) {
    this._param.default = newValue;
    this.emit("change");
  }
  get name() {
    return this._name;
  }
  set name(newName) {
    this._declarations.rename(this.name, newName);
    this._name = newName;
  }
  get note() {
    return this._param.note;
  }
  set note(value) {
    this._param.note = value;
    this.emit("change");
  }
  get _param() {
    return this._declarations.get(this.name);
  }
  getStoreValue() {
    return this;
  }
  toJSON() {
    return { ...this._param };
  }
}
class Params$2 extends Store {
  constructor(declarations) {
    super();
    this.emitChange = () => {
      this.emit("change");
    };
    this.declarations = declarations;
    this.declarations.on("change", this.emitChange);
  }
  get list() {
    return this.declarations.list.filter((p) => !p.builtIn).map((d) => new Param$2(d.name, this.declarations));
  }
  add(param) {
    this.declarations.add(param);
  }
  has(name) {
    return this.declarations.has(name);
  }
  setParam(name, value) {
    let param = this.declarations.list.find((dec) => {
      return dec.name === name;
    });
    if (!param) {
      throw new Error(`Param with name "${name}" doesn't exist`);
    }
    param.default = value;
  }
  create() {
    const name = this.generateName();
    this.add({ name, dataType: "string" });
  }
  generateName(prefix = "param") {
    let i2 = 0;
    let name;
    do {
      name = `${prefix}${i2++ || ""}`;
    } while (this.declarations.has(name));
    return name;
  }
  getStoreValue() {
    return this;
  }
  remove(name) {
    this.declarations.remove(name);
  }
  toJSON() {
    return this.list.map((p) => p.toJSON());
  }
}
function create_fragment$2Y(ctx) {
  let svg;
  let g;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      path = svg_element("path");
      attr(path, "d", "M852.517 606.04C722.804 666.467 612.48 770.67 502.075 923.02c-15.746 21.725-16.38 34.927-.205 46.602 11.372 8.209 17.98 5.583 34.542-12.088 2.217-2.38 2.217-2.38 4.484-4.84 14.318-15.505 25.852-28.662 50.49-57.274 81.407-94.538 121.17-133.45 182.968-169.038 53.478-30.795 100.476 14.462 91.527 72.38-2.51 16.258-6.836 28.257-17.978 54.022-4.432 10.249-6.302 14.707-8.38 20.171-20.085 52.8-37.002 96.846-72.451 188.834l-1.696 4.4c-10.718 27.813-10.718 27.813-21.427 55.62-46.426 120.661-74.598 194.652-103.665 272.901l-1.705 4.587c-7.8 20.975-11.474 30.871-15.534 41.881-33.306 90.321-52.353 149.007-66.84 211.427-2.262 9.713-2.262 9.713-4.556 19.584-8.162 35.31-12.53 58.062-14.972 81.448-4.222 40.439-.827 73.553 11.881 101.382 14.38 31.493 45.278 54.021 80.532 59.138 58.727 8.525 115.393 7.92 163.927-3.123 27.314-6.21 54.338-14.34 80.853-24.306 76.773-28.866 150.735-73.905 222.371-133.442 62.681-52.236 121.988-115.875 184.165-194.965 5.42-6.849 5.42-6.849 10.823-13.686 18.78-23.947 27.981-39.501 31.416-55.93 3.736-17.836-11.342-35.912-23.394-29.864-5.956 2.989-12.187 9.176-21.68 21.15-6.791 8.714-10.483 13.37-14.178 17.555-14.745 16.695-30.315 33.783-47.184 51.837-27.812 29.752-56.07 58.865-97.055 100.308-20.874 21.107-47.126 39.56-75.351 53.435-45.176 22.197-85.929-5.782-81.034-55.857 3.229-33.058 11.238-67.234 23.212-100.275 26.157-72.22 47.544-130.604 94.86-259.27 20.52-55.803 29.38-79.91 40.446-110.086 32.81-89.425 59-161.415 83.919-230.875 30.784-85.803 48.175-149.762 56.227-215.81 6.08-49.817-7.78-97.46-39.389-130.216-35.047-36.312-84.896-53.039-146.979-52.305-68.692.817-148.82 23.261-222.548 57.608Zm470.186-592.224c-123.444-48.028-271.57 34.483-296.373 165.169-17.984 94.72 17.4 176.498 89.622 210.751 143.165 67.897 314.982-40.897 314.989-199.468.007-88.211-37.668-148.991-108.238-176.452Z");
      attr(svg, "fill", ctx[0]);
      attr(svg, "width", ctx[1]);
      attr(svg, "height", ctx[1]);
      attr(svg, "viewBox", "0 0 1920 1920");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "fill", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "width", ctx2[1]);
      }
      if (dirty & 2) {
        attr(svg, "height", ctx2[1]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$2V($$self, $$props, $$invalidate) {
  let { strokeColor = "var(--bs-secondary)" } = $$props;
  let { size: size2 = "0.60rem" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
    if ("size" in $$props2)
      $$invalidate(1, size2 = $$props2.size);
  };
  return [strokeColor, size2];
}
class Info extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2V, create_fragment$2Y, safe_not_equal, { strokeColor: 0, size: 1 });
  }
}
function get_each_context$O(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  return child_ctx;
}
function create_else_block$X(ctx) {
  var _a;
  let div5;
  let div0;
  let button0;
  let t0_value = ctx[0].name + "";
  let t0;
  let t1;
  let div2;
  let div1;
  let button1;
  let t2_value = ((_a = ctx[0].dataType) != null ? _a : "<None>") + "";
  let t2;
  let t3;
  let ul;
  let t4;
  let div3;
  let button2;
  let t5;
  let t6;
  let div4;
  let button3;
  let info;
  let button3_title_value;
  let t7;
  let menubtn;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[8];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$O(get_each_context$O(ctx, each_value, i2));
  }
  info = new Info({});
  menubtn = new MenuBtn({
    props: {
      $$slots: { items: [create_items_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      var _a2;
      div5 = element("div");
      div0 = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      button1 = element("button");
      t2 = text(t2_value);
      t3 = space();
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t4 = space();
      div3 = element("div");
      button2 = element("button");
      t5 = text(ctx[7]);
      t6 = space();
      div4 = element("div");
      button3 = element("button");
      create_component(info.$$.fragment);
      t7 = space();
      create_component(menubtn.$$.fragment);
      attr(button0, "type", "button");
      attr(button0, "class", "btn btn-sm btn-outline-light w-100 border border-1 text-start text-dark text-truncate");
      attr(div0, "class", "col-4");
      attr(button1, "class", "btn btn-sm btn-outline-light w-100 border border-1 text-dark dropdown-toggle");
      attr(button1, "type", "button");
      attr(button1, "id", "typeDropDown");
      attr(button1, "data-bs-toggle", "dropdown");
      attr(button1, "aria-expanded", "false");
      attr(ul, "class", "dropdown-menu");
      attr(ul, "aria-labelledby", "dropdownMenuButton1");
      attr(div1, "class", "dropdown");
      attr(div2, "class", "col-3");
      attr(button2, "type", "button");
      attr(button2, "class", "btn btn-sm btn-outline-light w-100 border border-1 text-start text-dark text-truncate");
      attr(div3, "class", "col-4");
      set_style(button3, "width", "1rem");
      set_style(button3, "height", "1rem");
      set_style(button3, "cursor", "default");
      attr(button3, "class", "btn btn-link d-flex align-items-center p-0 shadow-none");
      attr(button3, "data-bs-toggle", "tooltip");
      attr(button3, "title", button3_title_value = (_a2 = ctx[0].note) != null ? _a2 : ctx[0].name);
      attr(div4, "class", "col-1 px-0 d-flex flex-row align-items-center justify-content-between");
      attr(div5, "class", "row my-1 align-items-center");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      append(div0, button0);
      append(button0, t0);
      append(div5, t1);
      append(div5, div2);
      append(div2, div1);
      append(div1, button1);
      append(button1, t2);
      append(div1, t3);
      append(div1, ul);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul, null);
        }
      }
      append(div5, t4);
      append(div5, div3);
      append(div3, button2);
      append(button2, t5);
      append(div5, t6);
      append(div5, div4);
      append(div4, button3);
      mount_component(info, button3, null);
      append(div4, t7);
      mount_component(menubtn, div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[14]),
          listen(button2, "click", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2, _b;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ((_a2 = ctx2[0].dataType) != null ? _a2 : "<None>") + ""))
        set_data(t2, t2_value);
      if (dirty & 2304) {
        each_value = ctx2[8];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$O(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$O(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ul, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & 128)
        set_data(t5, ctx2[7]);
      if (!current || dirty & 1 && button3_title_value !== (button3_title_value = (_b = ctx2[0].note) != null ? _b : ctx2[0].name)) {
        attr(button3, "title", button3_title_value);
      }
      const menubtn_changes = {};
      if (dirty & 536870915) {
        menubtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menubtn.$set(menubtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      transition_in(menubtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      transition_out(menubtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      destroy_each(each_blocks, detaching);
      destroy_component(info);
      destroy_component(menubtn);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$K(ctx) {
  let div2;
  let div0;
  let t1;
  let div1;
  let editabletext;
  let current;
  editabletext = new Text({
    props: {
      value: ctx[0].default,
      type: ctx[0].dataType,
      editMode: ctx[6]
    }
  });
  editabletext.$on("cancel", ctx[10]);
  editabletext.$on("save", ctx[16]);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "Default";
      t1 = space();
      div1 = element("div");
      create_component(editabletext.$$.fragment);
      attr(div0, "class", "col-3 fw-bold");
      attr(div1, "class", "col-9");
      attr(div2, "class", "row my-1 align-items-center rounded bg-light border border-1 py-1");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      mount_component(editabletext, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const editabletext_changes = {};
      if (dirty & 1)
        editabletext_changes.value = ctx2[0].default;
      if (dirty & 1)
        editabletext_changes.type = ctx2[0].dataType;
      if (dirty & 64)
        editabletext_changes.editMode = ctx2[6];
      editabletext.$set(editabletext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editabletext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editabletext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(editabletext);
    }
  };
}
function create_if_block_1$18(ctx) {
  let div2;
  let div0;
  let t1;
  let div1;
  let editabletext;
  let current;
  editabletext = new Text({
    props: {
      value: ctx[0].name,
      validationMessage: ctx[5],
      editMode: ctx[4]
    }
  });
  editabletext.$on("cancel", ctx[9]);
  editabletext.$on("save", ctx[12]);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "Edit Name";
      t1 = space();
      div1 = element("div");
      create_component(editabletext.$$.fragment);
      attr(div0, "class", "col-3 fw-bold");
      attr(div1, "class", "col-9");
      attr(div2, "class", "row my-1 align-items-center rounded bg-light border border-1 py-1");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      mount_component(editabletext, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const editabletext_changes = {};
      if (dirty & 1)
        editabletext_changes.value = ctx2[0].name;
      if (dirty & 32)
        editabletext_changes.validationMessage = ctx2[5];
      if (dirty & 16)
        editabletext_changes.editMode = ctx2[4];
      editabletext.$set(editabletext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editabletext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editabletext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(editabletext);
    }
  };
}
function create_each_block$O(ctx) {
  let li;
  let a;
  let t0_value = ctx[26] + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[18](ctx[26]);
  }
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "class", "dropdown-item");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
      if (!mounted) {
        dispose = listen(a, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$e(ctx) {
  let t;
  return {
    c() {
      t = text("Remove Default");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$l(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Note");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$17(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_items_slot$2(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuitem2;
  let current;
  menuitem0 = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot_2$e] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", ctx[19]);
  menuitem1 = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot_1$l] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", ctx[20]);
  menuitem2 = new MenuItem$1({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$17] },
      $$scope: { ctx }
    }
  });
  menuitem2.$on("click", ctx[21]);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuitem2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitem2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & 536870912) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 536870912) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & 536870912) {
        menuitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem2.$set(menuitem2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitem2, detaching);
    }
  };
}
function create_if_block$1F(ctx) {
  let div5;
  let div4;
  let div3;
  let div0;
  let h6;
  let t1;
  let button0;
  let t2;
  let div1;
  let input;
  let input_value_value;
  let t3;
  let div2;
  let button1;
  let t5;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      var _a;
      div5 = element("div");
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      h6 = element("h6");
      h6.textContent = "Note";
      t1 = space();
      button0 = element("button");
      t2 = space();
      div1 = element("div");
      input = element("input");
      t3 = space();
      div2 = element("div");
      button1 = element("button");
      button1.textContent = "Cancel";
      t5 = space();
      button2 = element("button");
      button2.textContent = "Apply";
      attr(h6, "class", "modal-title");
      attr(button0, "type", "button");
      attr(button0, "class", "btn-close");
      attr(div0, "class", "modal-header");
      attr(input, "type", "text");
      attr(input, "class", "w-100");
      input.value = input_value_value = (_a = ctx[0].note) != null ? _a : "";
      attr(input, "placeholder", "Write a note about the param");
      attr(div1, "class", "modal-body");
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-secondary");
      attr(button2, "type", "button");
      attr(button2, "class", "btn btn-danger");
      attr(div2, "class", "modal-footer");
      attr(div3, "class", "modal-content");
      attr(div4, "class", "modal-dialog");
      set_style(div4, "margin", "8rem 0 auto auto");
      attr(div5, "class", "modal d-block");
      attr(div5, "tabindex", "-1");
      attr(div5, "data-bs-backdrop", "false");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div3);
      append(div3, div0);
      append(div0, h6);
      append(div0, t1);
      append(div0, button0);
      append(div3, t2);
      append(div3, div1);
      append(div1, input);
      ctx[23](input);
      append(div3, t3);
      append(div3, div2);
      append(div2, button1);
      append(div2, t5);
      append(div2, button2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[22]),
          listen(button1, "click", ctx[24]),
          listen(button2, "click", ctx[25])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a;
      if (dirty & 1 && input_value_value !== (input_value_value = (_a = ctx2[0].note) != null ? _a : "") && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$2X(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_1$18, create_if_block_2$K, create_else_block$X];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return 0;
    if (ctx2[6])
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[2] && create_if_block$1F(ctx);
  return {
    c() {
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t.parentNode, t);
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$1F(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function formatDefault(defaultValue, type) {
  if (defaultValue == null || (type === "string" || type === "secret") && defaultValue.trim() === "") {
    return "<Empty>";
  }
  if (type === "secret") {
    return "*".repeat(defaultValue.length);
  }
  return defaultValue;
}
function instance$2U($$self, $$props, $$invalidate) {
  let defaultText;
  let { param } = $$props;
  let { removeParam } = $$props;
  let editNoteMode = false;
  let noteEditorComponent;
  let renameMode = false;
  let renameError;
  let updateDefaultMode = false;
  let dataTypes = ["string", "secret", "int", "float", "boolean"];
  function cancelNameEditMode() {
    $$invalidate(4, renameMode = false);
    $$invalidate(5, renameError = void 0);
  }
  function cancelUpdateDefaultMode() {
    $$invalidate(6, updateDefaultMode = false);
  }
  function changeType(type) {
    $$invalidate(0, param.dataType = type, param);
    $$invalidate(0, param.default = void 0, param);
  }
  function rename({ detail }) {
    try {
      $$invalidate(0, param.name = detail, param);
    } catch (e) {
      $$invalidate(5, renameError = e.message);
      return;
    }
    $$invalidate(4, renameMode = false);
    $$invalidate(5, renameError = void 0);
  }
  function setEditNoteMode(state = true) {
    $$invalidate(2, editNoteMode = state);
  }
  function setRenameMode() {
    $$invalidate(4, renameMode = true);
  }
  function setUpdateDefaultMode() {
    $$invalidate(6, updateDefaultMode = true);
  }
  function updateDefault({ detail }) {
    $$invalidate(0, param.default = detail, param);
    $$invalidate(6, updateDefaultMode = false);
  }
  function updateNote() {
    let value = noteEditorComponent == null ? void 0 : noteEditorComponent.value;
    $$invalidate(0, param.note = value && value !== "" ? value : void 0, param);
    $$invalidate(2, editNoteMode = false);
  }
  const click_handler = (type) => changeType(type);
  const click_handler_1 = () => updateDefault({ detail: void 0 });
  const click_handler_2 = () => setEditNoteMode();
  const click_handler_3 = () => removeParam(param.name);
  const click_handler_4 = () => setEditNoteMode(false);
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      noteEditorComponent = $$value;
      $$invalidate(3, noteEditorComponent);
    });
  }
  const click_handler_5 = () => setEditNoteMode(false);
  const click_handler_6 = () => updateNote();
  $$self.$$set = ($$props2) => {
    if ("param" in $$props2)
      $$invalidate(0, param = $$props2.param);
    if ("removeParam" in $$props2)
      $$invalidate(1, removeParam = $$props2.removeParam);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(7, defaultText = formatDefault(param.default, param.dataType));
    }
  };
  return [
    param,
    removeParam,
    editNoteMode,
    noteEditorComponent,
    renameMode,
    renameError,
    updateDefaultMode,
    defaultText,
    dataTypes,
    cancelNameEditMode,
    cancelUpdateDefaultMode,
    changeType,
    rename,
    setEditNoteMode,
    setRenameMode,
    setUpdateDefaultMode,
    updateDefault,
    updateNote,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    input_binding,
    click_handler_5,
    click_handler_6
  ];
}
class Param$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2U, create_fragment$2X, safe_not_equal, { param: 0, removeParam: 1 });
  }
}
function get_each_context$N(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  return child_ctx;
}
function create_each_block$N(key_1, ctx) {
  let first2;
  let param;
  let current;
  param = new Param$1({
    props: {
      param: ctx[9],
      removeParam: ctx[4]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(param.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(param, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const param_changes = {};
      if (dirty & 8)
        param_changes.param = ctx[9];
      param.$set(param_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(param.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(param.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(param, detaching);
    }
  };
}
function create_fragment$2W(ctx) {
  let div1;
  let a;
  let angleright;
  let t0;
  let div0;
  let t2;
  let div9;
  let div8;
  let div6;
  let div5;
  let t8;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t9;
  let div7;
  let button;
  let t11;
  let div10;
  let current;
  let mounted;
  let dispose;
  angleright = new AngleRight({
    props: {
      strokeColor: "var(--bs-secondary)",
      class: `${ctx[2] ? "bbx-rotate-90" : ""} bbx-transition-ease`
    }
  });
  let each_value = ctx[3].list;
  const get_key = (ctx2) => ctx2[9];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$N(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$N(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      a = element("a");
      create_component(angleright.$$.fragment);
      t0 = space();
      div0 = element("div");
      div0.textContent = "Input Fields";
      t2 = space();
      div9 = element("div");
      div8 = element("div");
      div6 = element("div");
      div5 = element("div");
      div5.innerHTML = `<div class="col-4">Name</div> 
        <div class="col-3">Type</div> 
        <div class="col-4">Default</div>`;
      t8 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t9 = space();
      div7 = element("div");
      button = element("button");
      button.textContent = "+ New";
      t11 = space();
      div10 = element("div");
      attr(a, "href", "#params-container");
      attr(a, "class", "d-flex justify-content-center align-items-center");
      set_style(a, "width", "1rem");
      set_style(a, "height", "1rem");
      set_style(a, "margin-top", "0.3rem");
      attr(a, "data-bs-toggle", "collapse");
      attr(a, "data-bs-target", "#params-container");
      attr(div0, "class", "fw-bolder fs-6");
      attr(div1, "class", "p-2 d-flex align-items-center gap-2 fw-bold");
      set_style(div1, "color", "var(--bs-secondary)");
      set_style(div1, "width", "fit-content");
      attr(div5, "class", "row my-1 fw-bold text-secondary");
      attr(div6, "class", "container");
      attr(button, "class", "btn btn-secondary btn-sm");
      attr(div7, "class", "m-2 d-flex flex-row-reverse");
      attr(div8, "class", "p-1 rounded bg-white");
      attr(div9, "class", "collapse px-2");
      attr(div9, "id", "params-container");
      attr(div10, "class", "mb-2 bbx-border-b");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, a);
      mount_component(angleright, a, null);
      append(div1, t0);
      append(div1, div0);
      insert(target, t2, anchor);
      insert(target, div9, anchor);
      append(div9, div8);
      append(div8, div6);
      append(div6, div5);
      append(div6, t8);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div6, null);
        }
      }
      append(div8, t9);
      append(div8, div7);
      append(div7, button);
      ctx[6](div9);
      insert(target, t11, anchor);
      insert(target, div10, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const angleright_changes = {};
      if (dirty & 4)
        angleright_changes.class = `${ctx2[2] ? "bbx-rotate-90" : ""} bbx-transition-ease`;
      angleright.$set(angleright_changes);
      if (dirty & 24) {
        each_value = ctx2[3].list;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div6, outro_and_destroy_block, create_each_block$N, null, get_each_context$N);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(angleright.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(angleright.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(angleright);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div9);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      ctx[6](null);
      if (detaching)
        detach(t11);
      if (detaching)
        detach(div10);
      mounted = false;
      dispose();
    }
  };
}
function instance$2T($$self, $$props, $$invalidate) {
  let $params, $$unsubscribe_params = noop$1, $$subscribe_params = () => ($$unsubscribe_params(), $$unsubscribe_params = subscribe(params2, ($$value) => $$invalidate(3, $params = $$value)), params2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_params());
  let { params: params2 } = $$props;
  $$subscribe_params();
  let component;
  let expanded = false;
  function onShow() {
    $$invalidate(2, expanded = true);
  }
  function onHide() {
    $$invalidate(2, expanded = false);
  }
  function removeParam(name) {
    params2.remove(name);
  }
  onMount(() => {
    component == null ? void 0 : component.addEventListener("show.bs.collapse", onShow);
    component == null ? void 0 : component.addEventListener("hide.bs.collapse", onHide);
  });
  onDestroy(() => {
    component == null ? void 0 : component.removeEventListener("show.bs.collapse", onShow);
    component == null ? void 0 : component.removeEventListener("hide.bs.collapse", onHide);
  });
  const click_handler = () => params2.create();
  function div9_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      component = $$value;
      $$invalidate(1, component);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$subscribe_params($$invalidate(0, params2 = $$props2.params));
  };
  return [params2, component, expanded, $params, removeParam, click_handler, div9_binding];
}
class Params$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2T, create_fragment$2W, safe_not_equal, { params: 0 });
  }
}
function create_if_block_3$A(ctx) {
  let select2;
  let option0;
  let t0;
  let option1;
  let t1;
  let option1_selected_value;
  let mounted;
  let dispose;
  return {
    c() {
      select2 = element("select");
      option0 = element("option");
      t0 = text("true");
      option1 = element("option");
      t1 = text("false");
      option0.__value = "true";
      option0.value = option0.__value;
      option0.selected = ctx[0];
      option1.__value = "false";
      option1.value = option1.__value;
      option1.selected = option1_selected_value = !ctx[0];
    },
    m(target, anchor) {
      insert(target, select2, anchor);
      append(select2, option0);
      append(option0, t0);
      append(select2, option1);
      append(option1, t1);
      if (!mounted) {
        dispose = listen(select2, "change", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        option0.selected = ctx2[0];
      }
      if (dirty & 1 && option1_selected_value !== (option1_selected_value = !ctx2[0])) {
        option1.selected = option1_selected_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(select2);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$J(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "number");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[8]),
          listen(input, "input", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && to_number(input.value) !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$17(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "password");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[6]),
          listen(input, "input", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$1E(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[4]),
          listen(input, "input", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$2V(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] === "string")
      return create_if_block$1E;
    if (ctx2[1] === "secret")
      return create_if_block_1$17;
    if (ctx2[1] === "int" || ctx2[1] === "float")
      return create_if_block_2$J;
    if (ctx2[1] === "boolean")
      return create_if_block_3$A;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2S($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { value } = $$props;
  let { type } = $$props;
  function handleInput(e, type2) {
    const inputValue = e.target.value;
    if (type2 === "int") {
      $$invalidate(0, value = parseInt(inputValue));
    } else if (type2 === "float") {
      $$invalidate(0, value = parseFloat(inputValue));
    } else {
      $$invalidate(0, value = inputValue);
    }
    dispatch("change", { newValue: value });
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  const input_handler = (e) => handleInput(e, type);
  function input_input_handler_1() {
    value = this.value;
    $$invalidate(0, value);
  }
  const input_handler_1 = (e) => handleInput(e, type);
  function input_input_handler_2() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  const input_handler_2 = (e) => handleInput(e, type);
  const change_handler = (event) => dispatch("change", { newValue: event.target.value === "true" });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
  };
  return [
    value,
    type,
    dispatch,
    handleInput,
    input_input_handler,
    input_handler,
    input_input_handler_1,
    input_handler_1,
    input_input_handler_2,
    input_handler_2,
    change_handler
  ];
}
class Input extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2S, create_fragment$2V, safe_not_equal, { value: 0, type: 1 });
  }
}
function get_each_context$M(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  child_ctx[8] = list;
  child_ctx[9] = i2;
  return child_ctx;
}
function create_each_block$M(ctx) {
  let div3;
  let div0;
  let code0;
  let t0_value = ctx[7].name + "";
  let t0;
  let t1;
  let div1;
  let code1;
  let t2_value = ctx[7].dataType + "";
  let t2;
  let t3;
  let div2;
  let input;
  let t4;
  let current;
  function change_handler(...args) {
    return ctx[4](ctx[7], ctx[8], ctx[9], ...args);
  }
  input = new Input({
    props: {
      value: ctx[7].value,
      type: ctx[7].dataType
    }
  });
  input.$on("change", change_handler);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      code0 = element("code");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      code1 = element("code");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      create_component(input.$$.fragment);
      t4 = space();
      attr(div0, "class", "col-4 bbx-pad-y bbx-text-left");
      attr(div1, "class", "col-3 bbx-pad-y bbx-text-left");
      attr(div2, "class", "col-4 bbx-pad-y bbx-text-left");
      attr(div3, "class", "row");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, code0);
      append(code0, t0);
      append(div3, t1);
      append(div3, div1);
      append(div1, code1);
      append(code1, t2);
      append(div3, t3);
      append(div3, div2);
      mount_component(input, div2, null);
      append(div3, t4);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[7].name + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx[7].dataType + ""))
        set_data(t2, t2_value);
      const input_changes = {};
      if (dirty & 1)
        input_changes.value = ctx[7].value;
      if (dirty & 1)
        input_changes.type = ctx[7].dataType;
      input.$set(input_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(input);
    }
  };
}
function create_fragment$2U(ctx) {
  let div10;
  let div9;
  let div8;
  let div0;
  let h6;
  let t1;
  let button0;
  let t2;
  let div6;
  let div5;
  let div4;
  let t8;
  let t9;
  let div7;
  let button1;
  let t11;
  let button2;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$M(get_each_context$M(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div10 = element("div");
      div9 = element("div");
      div8 = element("div");
      div0 = element("div");
      h6 = element("h6");
      h6.textContent = "Input Field values";
      t1 = space();
      button0 = element("button");
      t2 = space();
      div6 = element("div");
      div5 = element("div");
      div4 = element("div");
      div4.innerHTML = `<div class="col-4 bbx-pad-y bbx-text-left">Name</div> 
              <div class="col-3 bbx-pad-y bbx-text-left">Type</div> 
              <div class="col-4 bbx-pad-y bbx-text-left">Value</div>`;
      t8 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t9 = space();
      div7 = element("div");
      button1 = element("button");
      button1.textContent = "Cancel";
      t11 = space();
      button2 = element("button");
      button2.textContent = "Apply";
      attr(h6, "class", "modal-title");
      attr(button0, "type", "button");
      attr(button0, "class", "btn-close");
      attr(div0, "class", "modal-header");
      attr(div4, "class", "row");
      attr(div5, "class", "container");
      attr(div5, "style", "");
      attr(div6, "class", "modal-body");
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-secondary");
      attr(button2, "type", "button");
      attr(button2, "class", "btn btn-danger");
      attr(div7, "class", "modal-footer");
      attr(div8, "class", "modal-content");
      attr(div9, "class", "modal-dialog");
      set_style(div9, "margin", "8rem 0 auto auto");
      attr(div10, "class", "modal d-block");
      attr(div10, "tabindex", "-1");
      attr(div10, "data-bs-backdrop", "false");
    },
    m(target, anchor) {
      insert(target, div10, anchor);
      append(div10, div9);
      append(div9, div8);
      append(div8, div0);
      append(div0, h6);
      append(div0, t1);
      append(div0, button0);
      append(div8, t2);
      append(div8, div6);
      append(div6, div5);
      append(div5, div4);
      append(div5, t8);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div5, null);
        }
      }
      append(div8, t9);
      append(div8, div7);
      append(div7, button1);
      append(div7, t11);
      append(div7, button2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[3]),
          listen(button1, "click", ctx[5]),
          listen(button2, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$M(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$M(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div5, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div10);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2R($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { params: params2 } = $$props;
  const paramValues = params2.list.map((p) => {
    var _a;
    return {
      name: p.name,
      dataType: p.dataType,
      value: (_a = p.default) != null ? _a : getDefault(p.dataType)
    };
  });
  const click_handler = () => dispatch("cancel");
  const change_handler = (param, each_value, param_index, e) => $$invalidate(0, each_value[param_index].value = e.detail.newValue, paramValues);
  const click_handler_1 = () => dispatch("cancel");
  const click_handler_2 = () => dispatch("save", paramValues);
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(2, params2 = $$props2.params);
  };
  return [
    paramValues,
    dispatch,
    params2,
    click_handler,
    change_handler,
    click_handler_1,
    click_handler_2
  ];
}
class Prompt extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2R, create_fragment$2U, safe_not_equal, { params: 2 });
  }
}
class DataExtractor {
  constructor(tag, doc, ctx) {
    __publicField(this, "tag");
    __publicField(this, "doc", document);
    __publicField(this, "ctx");
    __publicField(this, "isText", (node) => node.nodeType == document.TEXT_NODE);
    this.tag = tag;
    this.doc = doc;
    this.ctx = ctx;
  }
  async extract(field) {
    var _a, _b;
    try {
      const els = await this.getElements(this.tag);
      const val = this.getData(this.tag, field, els);
      if (!val) {
        throw new ExtractorReturnedNull(this.tag);
      }
      await ((_b = (_a = this.ctx).hook) == null ? void 0 : _b.call(_a, EXTRACT_STAGE.END, { elements: els, tag: this.tag }));
      return val;
    } catch (err) {
      throw StackedError.handle(err, "extractor");
    }
  }
  async getElements(tag) {
    if (!tag.selectors) {
      throw new ZeroSelectorsError();
    }
    const selectors = tag.selectors.includes;
    if (selectors.length === 0) {
      throw new ZeroSelectorsError();
    }
    const excludeElements = this.getElementsForSelectors(tag.selectors.excludes);
    excludeElements.forEach((el2) => el2.remove());
    return this.getElementsForSelectors(selectors, true);
  }
  getData(tag, field, els) {
    const selector = tag.selectors;
    if (!selector) {
      return null;
    }
    const extractor2 = field || { type: "text" };
    return els.map((el2) => this.extractDOM(tag, el2, extractor2));
  }
  getElementsForSelectors(selectors, pickFirst = false) {
    if (!selectors) {
      return [];
    }
    const els = [];
    let res = [];
    for (const selector of selectors) {
      try {
        if (selector.type === "xpath") {
          res = this.ctx.evaluateXPath(selector.value);
        } else if (selector.type === "css") {
          res = Array.from(this.ctx.querySelectorAll(selector.value));
        }
      } catch (e) {
        console.error("error while querying the dom for selector", e);
        throw new InvalidSelectorError(selector.value);
      }
      if (res.length > 0) {
        if (pickFirst) {
          return res;
        }
        els.push(...Array.from(res));
      }
    }
    return els;
  }
  visit(el2, visitor) {
    if (visitor(el2) !== false && el2.childNodes) {
      for (let child of Array.from(el2.childNodes)) {
        this.visit(child, visitor);
      }
    }
  }
  getElText(el2, buf, { visibleOnly } = {}) {
    this.visit(el2, (node) => {
      if (["NOSCRIPT", "SCRIPT", "STYLE", "style"].includes(node.nodeName)) {
        return false;
      }
      if (visibleOnly && !isElementVisible(node)) {
        return false;
      }
      this.getNodeText(node, buf);
    });
  }
  getNodeText(node, buf) {
    if (this.isText(node)) {
      buf.push(node.nodeValue);
    }
  }
  extractByJS(el, extractor) {
    globalThis.el = el;
    const result = eval(extractor.params.script);
    globalThis.el = void 0;
    return result;
  }
  extractDOM(tag, el2, extractor2) {
    el2.setAttribute("distill-tag", tag.name);
    switch (extractor2.type) {
      case "attr": {
        if (!el2.hasAttribute(extractor2.params.name)) {
          return "";
        }
        return el2.getAttribute(extractor2.params.name).toString();
      }
      case "prop": {
        const value = el2[extractor2.params.name];
        if (value == null) {
          throw new PropDoesNotExistError(extractor2.params.name);
        }
        return value.toString();
      }
      case "html": {
        return el2.outerHTML;
      }
      case "text":
      case "text_visible": {
        const visibleOnly = extractor2.type === "text_visible";
        const buf = [];
        this.getElText(el2, buf, { visibleOnly });
        return trimText(buf.join(" "));
      }
      case "js": {
        return this.extractByJS(el2, extractor2);
      }
      default: {
        throw new UnsupportedExtractorTypeError(extractor2.type);
      }
    }
  }
  extractBuiltIn(tag) {
    const selector = tag.selectors;
    if (!selector) {
      return null;
    }
    switch (selector.field.type) {
      case "title": {
        return this.ctx.getDocument().title;
      }
      default: {
        throw new UnsupportedBuiltInTypeError(tag);
      }
    }
  }
  extractMeta(tag) {
    const selector = tag.selectors;
    if (!selector) {
      return null;
    }
    const el2 = this.ctx.getDocument().querySelector(`meta[name=${selector.field.type}]`);
    if (el2 == null) {
      return null;
    }
    const extracted = el2.getAttribute("content");
    if (extracted == null) {
      return null;
    }
    return extracted;
  }
}
async function applyMappers(schemaProperty, data) {
  var _a;
  return await new DataMapper(schemaProperty.tag, data, (_a = schemaProperty.procs) == null ? void 0 : _a.mappers).map();
}
async function applyReducers(schemaProperty, data) {
  var _a;
  return await new DataReducer(schemaProperty.tag, data, (_a = schemaProperty == null ? void 0 : schemaProperty.procs) == null ? void 0 : _a.reducer).reduce();
}
async function applyParser(schemaProperty, data) {
  return await new DataParser(schemaProperty.tag, data, schemaProperty == null ? void 0 : schemaProperty.data_type, schemaProperty == null ? void 0 : schemaProperty.procs.parser).parse();
}
async function validateTagData(schemaProperty, data) {
  var _a;
  await new DataValidator(schemaProperty.tag, data, schemaProperty == null ? void 0 : schemaProperty.data_type, (_a = schemaProperty == null ? void 0 : schemaProperty.procs) == null ? void 0 : _a.validator).validate();
}
const EXTRACT_STAGE = {
  END: "end"
};
class LeafNodeProperty {
  constructor(id2, name, tag, procs, data_type = Type.string, field = null) {
    __publicField(this, "id");
    __publicField(this, "tag");
    __publicField(this, "name");
    __publicField(this, "procs");
    __publicField(this, "data_type");
    __publicField(this, "metadata");
    __publicField(this, "field");
    __publicField(this, "_parent");
    this.id = id2;
    this.name = name;
    this.tag = tag;
    this.procs = procs;
    this.data_type = data_type;
    this.field = field;
  }
  type() {
    return TagTypeLeafNode;
  }
  get parent() {
    return this._parent;
  }
  setParent(p) {
    this._parent = p;
  }
  async applyProcessors(extractedContent) {
    try {
      const mapped = await applyMappers(this, extractedContent);
      let reduced;
      if (this.procs.reducer) {
        reduced = await applyReducers(this, mapped);
      } else {
        reduced = mapped;
      }
      let parsed = await applyParser(this, reduced);
      await validateTagData(this, parsed);
      if (parsed instanceof Date) {
        parsed = parsed.toISOString();
      }
      return parsed;
    } catch (err) {
      throw StackedError.handle(err, "processor");
    }
  }
  async _extract(ctx) {
    const dataExtractor = new DataExtractor(this.tag, ctx.document, ctx);
    const extractedStr = await dataExtractor.extract(this.field);
    if (Array.isArray(extractedStr)) {
      return extractedStr.map((str) => str.trim());
    }
    return [extractedStr.trim()];
  }
  async extract(ctx) {
    try {
      const extractedContent = await this._extract(ctx);
      return await this.applyProcessors(extractedContent);
    } catch (err) {
      throw StackedError.handle(err, "tag", {
        id: this.tag.id,
        name: this.tag.name,
        version: this.tag.version,
        schema_property_id: this.id
      });
    }
  }
  toJSON() {
    return {
      id: this.id,
      name: this.name,
      tag: this.tag,
      procs: this.procs,
      field: this.field,
      data_type: this.data_type,
      type: TagTypeLeafNode
    };
  }
}
class ListOfObjectsProperty {
  constructor(id2, name, tag, properties, treeConversionStrategy) {
    __publicField(this, "id");
    __publicField(this, "properties");
    __publicField(this, "tag");
    __publicField(this, "name");
    __publicField(this, "treeConversionStrategy");
    __publicField(this, "_parent");
    this.id = id2;
    this.name = name;
    this.tag = tag;
    this.properties = properties;
    this.treeConversionStrategy = treeConversionStrategy;
    for (const propertyName of Object.getOwnPropertyNames(this.properties)) {
      this.properties[propertyName].setParent(this);
    }
  }
  get parent() {
    return this._parent;
  }
  setParent(p) {
    this._parent = p;
  }
  type() {
    return TagTypeListOfObject;
  }
  async extract(ctx) {
    var _a;
    let listOfObjects = [];
    const dataExtractor = new DataExtractor(this.tag, ctx.document, ctx);
    const extractedElements = await dataExtractor.getElements(this.tag);
    for (let i2 = 0; i2 < extractedElements.length; i2++) {
      const objectForTheList = {};
      const extractedElement = extractedElements[i2];
      if (!extractedElement) {
        continue;
      }
      for (const propertyName of Object.getOwnPropertyNames(this.properties)) {
        const newCtx = ctx.newContext(extractedElement);
        objectForTheList[propertyName] = await this.properties[propertyName].extract(newCtx);
        objectForTheList["metadata"] = {
          depth: getElementDepth(extractedElement),
          rank: i2
        };
      }
      listOfObjects.push(objectForTheList);
      await ((_a = ctx.hook) == null ? void 0 : _a.call(ctx, EXTRACT_STAGE.END, { elements: [extractedElement], tag: this.tag }));
    }
    if (this.treeConversionStrategy) {
      listOfObjects = this.treeConversionStrategy.toTree(listOfObjects);
    }
    const metadataRemover = (node) => {
      var _a2;
      const newNode = { ...node };
      delete newNode.metadata;
      if (((_a2 = newNode.children) == null ? void 0 : _a2.length) > 0) {
        newNode.children = newNode.children.map(metadataRemover);
      }
      return newNode;
    };
    return listOfObjects.map(metadataRemover);
  }
  toJSON() {
    return {
      id: this.id,
      name: this.name,
      tag: this.tag,
      properties: this.properties,
      type: TagTypeListOfObject
    };
  }
}
class Schema$2 {
  constructor(properties) {
    __publicField(this, "properties");
    this.properties = properties;
    for (const propertyName of Object.getOwnPropertyNames(this.properties)) {
      this.properties[propertyName].setParent(this);
    }
  }
  type() {
    return TagTypeSchema;
  }
  async extract(ctx) {
    const result2 = {};
    for (const propertyName of Object.getOwnPropertyNames(this.properties)) {
      result2[propertyName] = await this.properties[propertyName].extract(ctx);
    }
    return result2;
  }
  toJSON() {
    return {
      properties: this.properties,
      type: TagTypeSchema
    };
  }
}
class ContentLeafNodeProperty$1 extends LeafNodeProperty {
  constructor(id2, name, tag, procs, data_type = Type.string, field) {
    super(id2, name, tag, procs, data_type, field);
    __publicField(this, "data");
    this.data = isArrayType(data_type) ? [] : void 0;
  }
  setData(data) {
    if (isArrayType(this.data_type)) {
      this.data = this.data.concat(data);
    } else {
      this.data = data;
    }
  }
  toJSON() {
    return {
      ...super.toJSON(),
      data: this.data
    };
  }
}
class ContentListOfObjectsProperty$1 extends ListOfObjectsProperty {
  constructor(id2, name, tag, properties, treeConversionStrategy) {
    super(id2, name, tag, properties, treeConversionStrategy);
    __publicField(this, "data");
    this.data = [];
  }
  setData(data) {
    this.data = this.data.concat(data);
  }
  toJSON() {
    return {
      ...super.toJSON(),
      data: this.data
    };
  }
}
class ContentSchema extends Schema$2 {
  constructor(properties, id2PropertyMap2) {
    super(properties);
    __publicField(this, "id2PropertyMap");
    this.id2PropertyMap = id2PropertyMap2;
  }
  getID2PropertyMap() {
    return this.id2PropertyMap;
  }
  getData() {
    const data = {};
    for (const key in this.properties) {
      const property2 = this.properties[key];
      data[key] = property2.data;
    }
    return data;
  }
}
function convertPOJOToSchema$1(pojo, id2PropertyMap2) {
  if (pojo.type === TagTypeLeafNode) {
    const leafNode = new ContentLeafNodeProperty$1(pojo.id, pojo.name, pojo.tag, pojo.procs, pojo.data_type, pojo.field);
    leafNode.id = pojo.id;
    id2PropertyMap2.set(leafNode.id, leafNode);
    return leafNode;
  } else if (pojo.type === TagTypeListOfObject) {
    const properties = {};
    for (const propertyName in pojo.properties) {
      properties[propertyName] = convertPOJOToSchema$1(pojo.properties[propertyName], id2PropertyMap2);
    }
    const looNode = new ContentListOfObjectsProperty$1(pojo.id, pojo.name, pojo.tag, properties);
    looNode.id = pojo.id;
    id2PropertyMap2.set(looNode.id, looNode);
    return looNode;
  } else {
    throw new Error(`Unknown property type: ${pojo.type}`);
  }
}
function parseSchema$1(pojo) {
  const id2PropertyMap2 = /* @__PURE__ */ new Map();
  const properties = {};
  for (const key in pojo.properties) {
    properties[key] = convertPOJOToSchema$1(pojo.properties[key], id2PropertyMap2);
  }
  return new ContentSchema(properties, id2PropertyMap2);
}
const context2PropertyMap = /* @__PURE__ */ new Map();
const id2PropertyMap = /* @__PURE__ */ new Map();
function addToContextPropertyMap(context, property2) {
  context2PropertyMap.has(context) ? context2PropertyMap.get(context).push(property2) : context2PropertyMap.set(context, [property2]);
}
function addToIdMap(id2, property2) {
  id2PropertyMap.set(id2, property2);
}
async function scrape(context, opts = { document }) {
  if (!opts.document) {
    opts.document = document;
  }
  if (!context2PropertyMap.has(context)) {
    return [null, null];
  }
  try {
    const dataMap = {};
    const properties = context2PropertyMap.get(context);
    for (let i2 = 0; i2 < properties.length; i2++) {
      const extractionContext = new ExtractionContext(opts);
      dataMap[properties[i2].id] = await properties[i2].extract(extractionContext);
    }
    return [dataMap, null];
  } catch (err) {
    return [null, err.toJSON()];
  }
}
class ContentLeafNodeProperty extends LeafNodeProperty {
  constructor(id2, name, tag, procs, data_type = Type.string, field) {
    super(id2, name, tag, procs, data_type, field);
    addToIdMap(this.id, this);
  }
}
class ContentListOfObjectsProperty extends ListOfObjectsProperty {
  constructor(id2, name, tag, properties, treeConversionStrategy) {
    super(id2, name, tag, properties, treeConversionStrategy);
    addToIdMap(this.id, this);
  }
}
function convertPOJOToSchema(pojo) {
  if (pojo.type === TagTypeLeafNode) {
    const leafNode = new ContentLeafNodeProperty(pojo.id, pojo.name, pojo.tag, pojo.procs, pojo.data_type, pojo.field);
    leafNode.id = pojo.id;
    return leafNode;
  } else if (pojo.type === TagTypeListOfObject) {
    const properties = {};
    for (const propertyName in pojo.properties) {
      properties[propertyName] = convertPOJOToSchema(pojo.properties[propertyName]);
    }
    const looNode = new ContentListOfObjectsProperty(pojo.id, pojo.name, pojo.tag, properties, null);
    looNode.id = pojo.id;
    return looNode;
  }
}
function parseSchema(pojo) {
  context2PropertyMap.clear();
  id2PropertyMap.clear();
  const properties = {};
  for (const key in pojo.properties) {
    properties[key] = convertPOJOToSchema(pojo.properties[key]);
  }
  const schema = new Schema$2(properties);
  id2PropertyMap.forEach((property2) => {
    switch (property2.type()) {
      case TagTypeLeafNode:
      case TagTypeListOfObject:
        let currentParent = property2.parent;
        while (currentParent && currentParent.type() !== "list") {
          currentParent = currentParent["parent"];
        }
        if ((currentParent == null ? void 0 : currentParent.type()) === "list") {
          return;
        }
        addToContextPropertyMap(property2.tag.context, property2);
        break;
    }
  });
  return schema;
}
function configureScraper(player, schemaPojo, browserView, scrapeHook) {
  const schema = parseSchema$1(schemaPojo);
  const scraper = new Scraper(player, schema, browserView);
  if (scrapeHook) {
    scraper.setScrapeHook(scrapeHook);
  }
  player.vm.addHook(scraper.playerHook.bind(scraper));
  return scraper;
}
class Scraper {
  constructor(player, schema, browserView) {
    this.browserWrapper = player.context.browser;
    this.player = player;
    this.schema = schema;
    this.browserView = browserView;
    this.blockStack = [];
  }
  pushToBlockStack(context) {
    this.blockStack.push({
      name: context,
      scraped: false
    });
  }
  popBlockStack() {
    return this.blockStack.pop();
  }
  peekBlockStack() {
    return this.blockStack[this.blockStack.length - 1];
  }
  async evaluateBeforeRun() {
    parseSchema(JSON.parse(JSON.stringify(this.schema.toJSON())));
  }
  injectHighlightStyle(document2) {
    if (document2.querySelector("head[distill]")) {
      return;
    }
    const style = document2.createElement("style");
    style.textContent = `
            [distill-tag]{
                position: relative;
                border: 1px solid #0066cc;
                box-shadow: 0 0 2px #0066cc;
            }

            [distill-tag]::before {
                content: attr(distill-tag);
                position: absolute;
                left: 0;
                bottom: 0;
                transform: translateY(100%) translateX(-1px);
                color: #0066cc;
                font-size: 10px;
                background-color: #ffffff99;
                border: solid 1px #0066cc99;
                z-index: 1;
                padding: 0 2px;
                font-family: monospace;
                line-height: initial;
            }
    `;
    style.setAttribute("distill", true);
    document2.head.appendChild(style);
  }
  setScrapeHook(hook) {
    this.scrapeHook = hook;
  }
  async scrapeContext(context) {
    var _a;
    let contextNameToScrape = context.name === "_untitled_" ? null : context.name;
    console.log("scraping for the context", "context", context, "contextNameToScrape", contextNameToScrape);
    const activePage = this.browserView.store.getActivePage();
    const bbxMainFrameDoc = this.browserView.getPage(activePage.id).mainFrameView.getDoc();
    this.injectHighlightStyle(bbxMainFrameDoc);
    const [data, error2] = await scrape(contextNameToScrape, {
      document: bbxMainFrameDoc,
      hook: this.scrapeHook
    });
    if (error2) {
      throw StackedError.handle(error2);
    }
    if (data) {
      for (const propertyId in data) {
        (_a = this.schema.getID2PropertyMap().get(propertyId)) == null ? void 0 : _a.setData(data[propertyId]);
      }
    }
  }
  async playerHook(eventName, { node, error: error2 }) {
    var _a;
    if (error2) {
      return;
    }
    if (eventName === HOOK_EVENT.BEFORE_RUN) {
      await this.evaluateBeforeRun();
    } else if (eventName === HOOK_EVENT.BEFORE_EVAL) {
      if (node instanceof Block) {
        const context = this.peekBlockStack();
        if (context && context.name === node.name) {
          this.pushToBlockStack(node.name);
          return;
        }
        if (context && !context.scraped) {
          await this.scrapeContext(context);
          context.scraped = true;
        }
        this.pushToBlockStack(node.name);
      }
    } else if (eventName === HOOK_EVENT.AFTER_EVAL) {
      if (["wait_doc", "open"].includes((_a = node == null ? void 0 : node.toJSON()) == null ? void 0 : _a[0])) {
        await this.evaluateBeforeRun();
      }
      if (node instanceof Block) {
        const context = this.popBlockStack();
        if (context && this.blockStack.length > 0 && context.name === this.peekBlockStack().name) {
          return;
        }
        if (!context.scraped) {
          await this.scrapeContext(context);
        }
      }
    } else if (eventName === HOOK_EVENT.AFTER_RUN) {
      if (this.blockStack.length !== 0)
        ;
    }
  }
}
function isExtractError(e) {
  if (!(e == null ? void 0 : e.toJSON)) {
    return false;
  }
  const errJSON = e.toJSON();
  const stackEx = errJSON == null ? void 0 : errJSON.stackEx;
  if (!stackEx || (stackEx == null ? void 0 : stackEx.length) == 0) {
    return false;
  }
  const firstStack = stackEx[0];
  return firstStack.context === "processor";
}
function create_if_block_1$16(ctx) {
  let params_1;
  let current;
  params_1 = new Params$1({ props: { params: ctx[2] } });
  return {
    c() {
      create_component(params_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(params_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const params_1_changes = {};
      if (dirty[0] & 4)
        params_1_changes.params = ctx2[2];
      params_1.$set(params_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(params_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(params_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(params_1, detaching);
    }
  };
}
function create_if_block$1D(ctx) {
  let paramsprompt;
  let current;
  paramsprompt = new Prompt({ props: { params: ctx[2] } });
  paramsprompt.$on("save", ctx[7]);
  paramsprompt.$on("cancel", ctx[8]);
  return {
    c() {
      create_component(paramsprompt.$$.fragment);
    },
    m(target, anchor) {
      mount_component(paramsprompt, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const paramsprompt_changes = {};
      if (dirty[0] & 4)
        paramsprompt_changes.params = ctx2[2];
      paramsprompt.$set(paramsprompt_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(paramsprompt.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(paramsprompt.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(paramsprompt, detaching);
    }
  };
}
function create_fragment$2T(ctx) {
  let recordercontrol;
  let t0;
  let t1;
  let treeview;
  let t2;
  let if_block1_anchor;
  let current;
  recordercontrol = new RecorderControl({
    props: {
      replayOnly: ctx[3],
      recorder: ctx[5],
      record: ctx[10],
      replayStatus: ctx[6],
      stopRecording: ctx[12],
      replay: ctx[11],
      stopReplay: ctx[13],
      reset: ctx[9]
    }
  });
  let if_block0 = ctx[1] && create_if_block_1$16(ctx);
  treeview = new TreeView({
    props: { tree: ctx[0] }
  });
  let if_block1 = ctx[4] && create_if_block$1D(ctx);
  return {
    c() {
      create_component(recordercontrol.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      create_component(treeview.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(recordercontrol, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(treeview, target, anchor);
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recordercontrol_changes = {};
      if (dirty[0] & 8)
        recordercontrol_changes.replayOnly = ctx2[3];
      if (dirty[0] & 32)
        recordercontrol_changes.recorder = ctx2[5];
      recordercontrol.$set(recordercontrol_changes);
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$16(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const treeview_changes = {};
      if (dirty[0] & 1)
        treeview_changes.tree = ctx2[0];
      treeview.$set(treeview_changes);
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1D(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(recordercontrol.$$.fragment, local);
      transition_in(if_block0);
      transition_in(treeview.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(recordercontrol.$$.fragment, local);
      transition_out(if_block0);
      transition_out(treeview.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(recordercontrol, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      destroy_component(treeview, detaching);
      if (detaching)
        detach(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$2Q($$self, $$props, $$invalidate) {
  let $replayStatus;
  const dispatch = createEventDispatcher();
  let { disablePointer } = $$props;
  let { expressionTree } = $$props;
  let { findSelector } = $$props;
  let { getRecorder } = $$props;
  let { getPlayer } = $$props;
  let { optInParams: optInParams2 = false } = $$props;
  let { params: params2 } = $$props;
  let { url } = $$props;
  let { replayOnly = false } = $$props;
  const browserView = getContext("browserView");
  const Msg2 = getContext("Msg");
  const schemaModel = getContext("schema");
  getContext("taggerOverlay");
  let player;
  let promptMode = false;
  let promptResolve, promptReject;
  let recorder = getRecorder(browserView, findSelector, expressionTree, params2);
  let replayStatus = writable({
    isPlaying: false,
    playing: [],
    completed: [],
    errored: [],
    error: void 0
  });
  component_subscribe($$self, replayStatus, (value) => $$invalidate(22, $replayStatus = value));
  recorder.expressionBlock = expressionTree.expression;
  setContext("optInParams", optInParams2);
  setContext("params", params2);
  setContext("recorder", recorder);
  setContext("replayStatus", replayStatus);
  validateExpressionCtx();
  function validateExpressionCtx() {
    var _a;
    const expressionCtx = getContext("expressionCtx");
    if (!((_a = expressionCtx == null ? void 0 : expressionCtx.replace) == null ? void 0 : _a.defaultExprs)) {
      throw new Error("expressionCtx.replace.defaultExprs not passed");
    }
    const mandatoryDefaultExprs = ["and", "or", "not", "if..else"];
    const missingDefaultExprs = [];
    for (const key of mandatoryDefaultExprs) {
      if (!expressionCtx.replace.defaultExprs[key]) {
        missingDefaultExprs.push(key);
      }
    }
    if (missingDefaultExprs.length) {
      throw new Error(`Missing defaults for expressions: ${missingDefaultExprs.join(", ")}`);
    }
  }
  async function getPrompts() {
    if (!params2 || params2.list.length === 0) {
      return [];
    } else {
      $$invalidate(4, promptMode = true);
      return await new Promise((resolve, reject2) => {
        promptResolve = resolve;
        promptReject = reject2;
      });
    }
  }
  function goto(_url = url) {
    return browserView == null ? void 0 : browserView.store.pages[0].goto(_url);
  }
  async function onBrowserReady() {
    $$invalidate(5, recorder.browserView = browserView, recorder);
    if (expressionTree.expression.children.length === 0 && !replayOnly) {
      record();
    }
    await goto();
  }
  function onPromptApply({ detail }) {
    promptResolve(detail);
    promptResolve = void 0;
    promptReject = void 0;
    $$invalidate(4, promptMode = false);
  }
  function onPromptCancel() {
    promptReject();
    promptResolve = void 0;
    promptReject = void 0;
    $$invalidate(4, promptMode = false);
  }
  async function onReset() {
    stopRecording();
    recorder == null ? void 0 : recorder.reset();
    goto();
    record();
  }
  function record() {
    recorder == null ? void 0 : recorder.start();
  }
  async function replay2() {
    if (expressionTree.hasErrors()) {
      Msg2.error("Cannot replay. One or more steps have errors");
      return;
    }
    let vars;
    try {
      vars = await getPrompts();
    } catch (e) {
      return;
    }
    stopRecording();
    if (!browserView || $replayStatus.isPlaying)
      return;
    set_store_value(
      replayStatus,
      $replayStatus = {
        isPlaying: true,
        playing: [],
        completed: [],
        errored: [],
        error: void 0
      },
      $replayStatus
    );
    disablePointer();
    await browserView.store.newPage();
    await Promise.all(browserView.store.pages.slice(0, -1).map((page) => page.close()));
    goto(url);
    player = getPlayer(browserView, { vars });
    player.vm.on("replay:change", updateReplayStatus);
    let scraper = void 0;
    if (schemaModel) {
      scraper = configureScraper(player, schemaModel.toJSON(), browserView);
    }
    try {
      dispatch("replayStart", { vm: player.vm });
      if (schemaModel) {
        schemaModel.emit("extractError", null);
      }
      let res = await player.play();
      dispatch("replayEnd", res);
      if (scraper) {
        console.log("Replay completed", scraper.schema.getData());
        dispatch("data", scraper.schema.getData());
      }
    } catch (e) {
      console.error(e);
      if (isExtractError(e)) {
        if (schemaModel) {
          schemaModel.emit("extractError", e);
        }
      } else {
        dispatch("replayError", {
          error: $replayStatus.error,
          message: $replayStatus.error.message,
          nodeStack: [...$replayStatus.errored]
        });
      }
      if (!(e instanceof StackedError)) {
        Msg2.error(e.message);
      }
    }
    disablePointer(false);
    set_store_value(replayStatus, $replayStatus.isPlaying = false, $replayStatus);
    player.vm.off("replay:change", updateReplayStatus);
    player.context.browser.destroy();
  }
  function stopRecording() {
    recorder == null ? void 0 : recorder.stop();
  }
  function stopReplay() {
    player == null ? void 0 : player.interrupt();
  }
  function updateReplayStatus(type, node, error2) {
    let parent2 = node.parent;
    switch (type) {
      case HOOK_EVENT.BEFORE_EVAL:
        if (parent2 instanceof Root || parent2 instanceof Block || parent2 instanceof Clause || parent2 instanceof Conditional) {
          set_store_value(replayStatus, $replayStatus.playing = [...$replayStatus.playing, node], $replayStatus);
        }
        break;
      case HOOK_EVENT.AFTER_EVAL:
        if (error2) {
          set_store_value(replayStatus, $replayStatus.playing = [], $replayStatus);
          if (parent2 instanceof Root || parent2 instanceof Block || parent2 instanceof Clause || parent2 instanceof Conditional) {
            set_store_value(replayStatus, $replayStatus.errored = [node, ...$replayStatus.errored], $replayStatus);
          }
          if (!$replayStatus.error) {
            set_store_value(replayStatus, $replayStatus.error = error2, $replayStatus);
          }
        } else {
          let index2 = $replayStatus.playing.indexOf(node);
          if (index2 > -1) {
            set_store_value(replayStatus, $replayStatus.completed = [...$replayStatus.completed, node], $replayStatus);
            set_store_value(replayStatus, $replayStatus.playing = $replayStatus.playing.slice(0, index2), $replayStatus);
          }
        }
        break;
    }
  }
  onBrowserReady();
  onDestroy(() => {
    recorder == null ? void 0 : recorder.stop();
  });
  $$self.$$set = ($$props2) => {
    if ("disablePointer" in $$props2)
      $$invalidate(14, disablePointer = $$props2.disablePointer);
    if ("expressionTree" in $$props2)
      $$invalidate(0, expressionTree = $$props2.expressionTree);
    if ("findSelector" in $$props2)
      $$invalidate(15, findSelector = $$props2.findSelector);
    if ("getRecorder" in $$props2)
      $$invalidate(16, getRecorder = $$props2.getRecorder);
    if ("getPlayer" in $$props2)
      $$invalidate(17, getPlayer = $$props2.getPlayer);
    if ("optInParams" in $$props2)
      $$invalidate(1, optInParams2 = $$props2.optInParams);
    if ("params" in $$props2)
      $$invalidate(2, params2 = $$props2.params);
    if ("url" in $$props2)
      $$invalidate(18, url = $$props2.url);
    if ("replayOnly" in $$props2)
      $$invalidate(3, replayOnly = $$props2.replayOnly);
  };
  return [
    expressionTree,
    optInParams2,
    params2,
    replayOnly,
    promptMode,
    recorder,
    replayStatus,
    onPromptApply,
    onPromptCancel,
    onReset,
    record,
    replay2,
    stopRecording,
    stopReplay,
    disablePointer,
    findSelector,
    getRecorder,
    getPlayer,
    url
  ];
}
class Recorder$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$2Q,
      create_fragment$2T,
      safe_not_equal,
      {
        disablePointer: 14,
        expressionTree: 0,
        findSelector: 15,
        getRecorder: 16,
        getPlayer: 17,
        optInParams: 1,
        params: 2,
        url: 18,
        replayOnly: 3
      },
      null,
      [-1, -1]
    );
  }
}
function create_fragment$2S(ctx) {
  let div1;
  let div0;
  let t1;
  let recordercomponent;
  let div1_class_value;
  let current;
  recordercomponent = new Recorder$1({
    props: {
      replayOnly: true,
      disablePointer: ctx[7],
      expressionTree: ctx[1],
      findSelector: ctx[2],
      getRecorder: ctx[8],
      getPlayer: ctx[9],
      optInParams: ctx[3],
      params: ctx[4],
      url: ctx[5]
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.innerHTML = `<span class="bbx-flex-grow">Crawler</span>`;
      t1 = space();
      create_component(recordercomponent.$$.fragment);
      attr(div0, "class", "bbx-subheader bbx-flex");
      attr(div1, "class", div1_class_value = "bbx-sidebar " + ctx[0]);
      toggle_class(div1, "active", ctx[6]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t1);
      mount_component(recordercomponent, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const recordercomponent_changes = {};
      if (dirty & 2)
        recordercomponent_changes.expressionTree = ctx2[1];
      if (dirty & 4)
        recordercomponent_changes.findSelector = ctx2[2];
      if (dirty & 8)
        recordercomponent_changes.optInParams = ctx2[3];
      if (dirty & 16)
        recordercomponent_changes.params = ctx2[4];
      if (dirty & 32)
        recordercomponent_changes.url = ctx2[5];
      recordercomponent.$set(recordercomponent_changes);
      if (!current || dirty & 1 && div1_class_value !== (div1_class_value = "bbx-sidebar " + ctx2[0])) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & 65) {
        toggle_class(div1, "active", ctx2[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(recordercomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recordercomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(recordercomponent);
    }
  };
}
function instance$2P($$self, $$props, $$invalidate) {
  let { browserView } = $$props;
  let { class: clazz = "" } = $$props;
  let { expressionTree } = $$props;
  let { findSelector } = $$props;
  let { optInParams: optInParams2 = false } = $$props;
  let { params: params2 } = $$props;
  let { url } = $$props;
  let isPointerDisabled = false;
  setContext("browserView", browserView);
  setContext("expressionCtx", {
    replace: {
      skipControl: false,
      stepNames: [
        ...Object.keys(conditionDefs$1),
        ...Object.keys(crawlerStepDefs),
        ...Object.keys(procFuncDefs)
      ],
      defaultStep: "element_exists",
      defaultExprs: {
        and: ["and", ["element_exists"]],
        or: ["or", ["element_exists"]],
        not: ["not", ["element_exists"]],
        "if..else": ["cond", [["or", ["and", ["element_exists"]]]]],
        "while loop": ["while", ["or", ["and", ["element_exists"]]], []],
        "for loop": ["for", "item", ["range", 10, 0, 1], []]
      }
    }
  });
  function disablePointer(disable = true) {
    $$invalidate(6, isPointerDisabled = disable);
  }
  function getRecorder(bv, findSelector2, tree) {
    return new Base(bv, findSelector2, tree);
  }
  function getPlayer(bv, opts) {
    const crawler = {
      skipURL: () => {
      }
    };
    return new Player$1(expressionTree, new BrowserImpl(bv), crawler, opts);
  }
  $$self.$$set = ($$props2) => {
    if ("browserView" in $$props2)
      $$invalidate(10, browserView = $$props2.browserView);
    if ("class" in $$props2)
      $$invalidate(0, clazz = $$props2.class);
    if ("expressionTree" in $$props2)
      $$invalidate(1, expressionTree = $$props2.expressionTree);
    if ("findSelector" in $$props2)
      $$invalidate(2, findSelector = $$props2.findSelector);
    if ("optInParams" in $$props2)
      $$invalidate(3, optInParams2 = $$props2.optInParams);
    if ("params" in $$props2)
      $$invalidate(4, params2 = $$props2.params);
    if ("url" in $$props2)
      $$invalidate(5, url = $$props2.url);
  };
  return [
    clazz,
    expressionTree,
    findSelector,
    optInParams2,
    params2,
    url,
    isPointerDisabled,
    disablePointer,
    getRecorder,
    getPlayer,
    browserView
  ];
}
class App$3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2P, create_fragment$2S, safe_not_equal, {
      browserView: 10,
      class: 0,
      expressionTree: 1,
      findSelector: 2,
      optInParams: 3,
      params: 4,
      url: 5
    });
  }
}
function create_fragment$2R(ctx) {
  let div1;
  let div0;
  let div1_class_value;
  let div1_levels = [
    {
      class: div1_class_value = "bbx-progress " + ctx[0]
    },
    ctx[1]
  ];
  let div_data_1 = {};
  for (let i2 = 0; i2 < div1_levels.length; i2 += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i2]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "bbx-indeterminate");
      set_attributes(div1, div_data_1);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
    },
    p(ctx2, [dirty]) {
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        dirty & 1 && div1_class_value !== (div1_class_value = "bbx-progress " + ctx2[0]) && { class: div1_class_value },
        dirty & 2 && ctx2[1]
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function instance$2O($$self, $$props, $$invalidate) {
  const omit_props_names = ["classes"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { classes = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("classes" in $$new_props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  return [classes, $$restProps];
}
class Progress extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2O, create_fragment$2R, safe_not_equal, { classes: 0 });
  }
}
function create_if_block_1$15(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$1C(ctx) {
  let progress;
  let current;
  progress = new Progress({});
  return {
    c() {
      create_component(progress.$$.fragment);
    },
    m(target, anchor) {
      mount_component(progress, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(progress.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progress.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(progress, detaching);
    }
  };
}
function create_fragment$2Q(ctx) {
  let div1;
  let t0;
  let t1;
  let div0;
  let current;
  let if_block0 = ctx[1] && create_if_block_1$15(ctx);
  let if_block1 = ctx[0] && create_if_block$1C();
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      attr(div0, "class", "bbx-browser-body bbx-border");
      attr(div1, "class", "bbx-browser");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t1);
      append(div1, div0);
      ctx[4](div0);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$15(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0]) {
        if (if_block1) {
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1C();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[4](null);
    }
  };
}
function instance$2N($$self, $$props, $$invalidate) {
  let { bbx } = $$props;
  let { loading: loading2 = true } = $$props;
  let loadError;
  let view;
  let viewPromise;
  const dispatch = createEventDispatcher();
  let container;
  onMount(async () => {
    try {
      viewPromise = createView({ ...bbx, container });
      view = await viewPromise;
      dispatch("ready", view);
    } catch (e) {
      $$invalidate(1, loadError = e);
      dispatch("error", e);
    }
    $$invalidate(0, loading2 = false);
  });
  onDestroy(async () => {
    await viewPromise;
    view.close();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(2, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("bbx" in $$props2)
      $$invalidate(3, bbx = $$props2.bbx);
    if ("loading" in $$props2)
      $$invalidate(0, loading2 = $$props2.loading);
  };
  return [loading2, loadError, container, bbx, div0_binding];
}
class Browser$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2N, create_fragment$2Q, safe_not_equal, { bbx: 3, loading: 0 });
  }
}
function create_fragment$2P(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "stroke", ctx[0]);
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "2");
      attr(path, "d", "M17.651 7.65a7.131 7.131 0 0 0-12.68 3.15M18.001 4v4h-4m-7.652 8.35a7.13 7.13 0 0 0 12.68-3.15M6 20v-4h4");
      attr(svg, "class", "w-6 h-6 text-gray-800 dark:text-white");
      attr(svg, "aria-hidden", "true");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "24");
      attr(svg, "height", "24");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(path, "stroke", ctx2[0]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$2M($$self, $$props, $$invalidate) {
  let { strokeColor = "#009900" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("strokeColor" in $$props2)
      $$invalidate(0, strokeColor = $$props2.strokeColor);
  };
  return [strokeColor];
}
class Reload extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2M, create_fragment$2P, safe_not_equal, { strokeColor: 0 });
  }
}
function create_fragment$2O(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill-opacity", "0");
      attr(path, "stroke", "currentColor");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(path, "stroke-width", "32");
      attr(path, "d", "M413.66,246.1H386a2,2,0,0,1-2-2V166.86A38.86,38.86,0,0,0,345.14,128H267.9a2,2,0,0,1-2-2V98.34c0-27.14-21.5-49.86-48.64-50.33a49.53,49.53,0,0,0-50.4,49.51V126a2,2,0,0,1-2,2H87.62A39.74,39.74,0,0,0,48,167.62V238a2,2,0,0,0,2,2H76.91c29.37,0,53.68,25.48,54.09,54.85.42,29.87-23.51,57.15-53.29,57.15H50a2,2,0,0,0-2,2v70.38A39.74,39.74,0,0,0,87.62,464H158a2,2,0,0,0,2-2V441.07c0-30.28,24.75-56.35,55-57.06,30.1-.7,57,20.31,57,50.28V462a2,2,0,0,0,2,2h71.14A38.86,38.86,0,0,0,384,425.14v-78a2,2,0,0,1,2-2h28.48c27.63,0,49.52-22.67,49.52-50.4S440.8,246.1,413.66,246.1Z");
      attr(svg, "width", ctx[0]);
      attr(svg, "height", ctx[1]);
      attr(svg, "viewBox", "0 0 512 512");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "width", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "height", ctx2[1]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$2L($$self, $$props, $$invalidate) {
  let { width = "23" } = $$props;
  let { height = "23" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
  };
  return [width, height];
}
class Puzzle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2L, create_fragment$2O, safe_not_equal, { width: 0, height: 1 });
  }
}
const get_tb_save_slot_changes$4 = (dirty) => ({ onSave: dirty & 16 });
const get_tb_save_slot_context$4 = (ctx) => ({ onSave: ctx[4] });
function get_each_context$L(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  child_ctx[21] = i2;
  return child_ctx;
}
const get_tb_r_r_slot_changes$4 = (dirty) => ({});
const get_tb_r_r_slot_context$4 = (ctx) => ({});
const get_tb_r_l_slot_changes$4 = (dirty) => ({});
const get_tb_r_l_slot_context$4 = (ctx) => ({});
const get_tb_url_r_slot_changes$4 = (dirty) => ({});
const get_tb_url_r_slot_context$4 = (ctx) => ({});
const get_tb_url_l_slot_changes$4 = (dirty) => ({});
const get_tb_url_l_slot_context$4 = (ctx) => ({});
const get_tb_l_slot_changes$4 = (dirty) => ({});
const get_tb_l_slot_context$4 = (ctx) => ({});
function create_if_block$1B(ctx) {
  let menu;
  let current;
  menu = new Menu$1({
    props: {
      toggle: false,
      $$slots: {
        default: [create_default_slot$16],
        label: [create_label_slot]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menu_changes = {};
      if (dirty & 65920) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function create_label_slot(ctx) {
  let puzzle;
  let current;
  puzzle = new Puzzle({});
  return {
    c() {
      create_component(puzzle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(puzzle, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(puzzle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(puzzle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(puzzle, detaching);
    }
  };
}
function create_else_block$W(ctx) {
  let input;
  let input_id_value;
  let input_checked_value;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[15](ctx[19]);
  }
  return {
    c() {
      input = element("input");
      attr(input, "class", "form-check-input");
      attr(input, "type", "checkbox");
      attr(input, "role", "switch");
      attr(input, "id", input_id_value = ctx[19].id);
      input.checked = input_checked_value = ctx[19].enabled;
    },
    m(target, anchor) {
      insert(target, input, anchor);
      if (!mounted) {
        dispose = listen(input, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 128 && input_id_value !== (input_id_value = ctx[19].id)) {
        attr(input, "id", input_id_value);
      }
      if (dirty & 128 && input_checked_value !== (input_checked_value = ctx[19].enabled)) {
        input.checked = input_checked_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$14(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span class="sr-only">Loading...</span>`;
      attr(div, "class", "spinner-border spinner-border-sm text-primary bbx-ml-n2em mr-3");
      attr(div, "role", "status");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$L(ctx) {
  let li;
  let div;
  let show_if;
  let t0;
  let label;
  let t1;
  let label_for_value;
  let t2;
  function select_block_type(ctx2, dirty) {
    if (dirty & 384)
      show_if = null;
    if (show_if == null)
      show_if = !!ctx2[8].get(ctx2[19].id);
    if (show_if)
      return create_if_block_1$14;
    return create_else_block$W;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      li = element("li");
      div = element("div");
      if_block.c();
      t0 = space();
      label = element("label");
      t1 = text("Block Ads and Cookies");
      t2 = space();
      attr(label, "class", "form-check-label");
      attr(label, "for", label_for_value = ctx[19].id);
      attr(div, "class", "form-check form-switch ml-2");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div);
      if_block.m(div, null);
      append(div, t0);
      append(div, label);
      append(label, t1);
      append(li, t2);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, t0);
        }
      }
      if (dirty & 128 && label_for_value !== (label_for_value = ctx2[19].id)) {
        attr(label, "for", label_for_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if_block.d();
    }
  };
}
function create_default_slot$16(ctx) {
  let each_1_anchor;
  let each_value = ctx[7];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$L(get_each_context$L(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 896) {
        each_value = ctx2[7];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$L(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$L(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function fallback_block$7(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Save";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-sm btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[4]))
            ctx[4].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2N(ctx) {
  var _a;
  let div3;
  let div0;
  let button0;
  let angleright0;
  let t0;
  let button1;
  let angleright1;
  let t1;
  let t2;
  let div2;
  let form;
  let div1;
  let span;
  let svg;
  let image;
  let image_href_value;
  let t3;
  let input;
  let t4;
  let button2;
  let reload;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  let t11;
  let button3;
  let current;
  let mounted;
  let dispose;
  angleright0 = new AngleRight({
    props: {
      strokeColor: "#0d6efd",
      flip: true,
      strokeWidth: "8",
      size: "15px"
    }
  });
  angleright1 = new AngleRight({
    props: {
      strokeColor: "#0d6efd",
      strokeWidth: "8",
      size: "15px"
    }
  });
  const tb_l_slot_template = ctx[12]["tb-l"];
  const tb_l_slot = create_slot(tb_l_slot_template, ctx, ctx[16], get_tb_l_slot_context$4);
  reload = new Reload({ props: { strokeColor: "#0d6efd" } });
  const tb_url_l_slot_template = ctx[12]["tb-url-l"];
  const tb_url_l_slot = create_slot(tb_url_l_slot_template, ctx, ctx[16], get_tb_url_l_slot_context$4);
  const tb_url_r_slot_template = ctx[12]["tb-url-r"];
  const tb_url_r_slot = create_slot(tb_url_r_slot_template, ctx, ctx[16], get_tb_url_r_slot_context$4);
  const tb_r_l_slot_template = ctx[12]["tb-r-l"];
  const tb_r_l_slot = create_slot(tb_r_l_slot_template, ctx, ctx[16], get_tb_r_l_slot_context$4);
  const tb_r_r_slot_template = ctx[12]["tb-r-r"];
  const tb_r_r_slot = create_slot(tb_r_r_slot_template, ctx, ctx[16], get_tb_r_r_slot_context$4);
  let if_block = ((_a = ctx[7]) == null ? void 0 : _a.length) > 0 && create_if_block$1B(ctx);
  const tb_save_slot_template = ctx[12]["tb-save"];
  const tb_save_slot = create_slot(tb_save_slot_template, ctx, ctx[16], get_tb_save_slot_context$4);
  const tb_save_slot_or_fallback = tb_save_slot || fallback_block$7(ctx);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      button0 = element("button");
      create_component(angleright0.$$.fragment);
      t0 = space();
      button1 = element("button");
      create_component(angleright1.$$.fragment);
      t1 = space();
      if (tb_l_slot)
        tb_l_slot.c();
      t2 = space();
      div2 = element("div");
      form = element("form");
      div1 = element("div");
      span = element("span");
      svg = svg_element("svg");
      image = svg_element("image");
      t3 = space();
      input = element("input");
      t4 = space();
      button2 = element("button");
      create_component(reload.$$.fragment);
      t5 = space();
      if (tb_url_l_slot)
        tb_url_l_slot.c();
      t6 = space();
      if (tb_url_r_slot)
        tb_url_r_slot.c();
      t7 = space();
      if (tb_r_l_slot)
        tb_r_l_slot.c();
      t8 = space();
      if (tb_r_r_slot)
        tb_r_r_slot.c();
      t9 = space();
      if (if_block)
        if_block.c();
      t10 = space();
      if (tb_save_slot_or_fallback)
        tb_save_slot_or_fallback.c();
      t11 = space();
      button3 = element("button");
      button3.textContent = "Cancel";
      attr(button0, "title", "Go Back");
      attr(button0, "class", "btn text-decoration-none");
      attr(button1, "class", "btn text-decoration-none");
      attr(button1, "title", "Go Forward");
      attr(div0, "class", "btn-group btn-group-sm");
      attr(image, "href", image_href_value = "https://monitor.distill.io/v1/getfavicon?url=" + ctx[0]);
      attr(image, "width", "20");
      attr(image, "height", "20");
      attr(svg, "class", "bbx-favicon");
      attr(span, "class", "input-group-text");
      attr(span, "id", "inputGroup-sizing-sm");
      attr(input, "class", "form-control");
      attr(button2, "class", "btn btn-default");
      attr(button2, "id", "inputGroup-sizing-sm");
      attr(button2, "title", "Reload");
      attr(div1, "class", "input-group input-group-sm my-1 flex-nowrap");
      attr(form, "class", "w-100");
      attr(div2, "class", "d-flex align-self-center w-100");
      attr(button3, "type", "button");
      attr(button3, "class", "btn btn-sm btn-secondary");
      attr(div3, "class", "d-flex p-1 gap-2 align-items-center");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, button0);
      mount_component(angleright0, button0, null);
      append(div0, t0);
      append(div0, button1);
      mount_component(angleright1, button1, null);
      append(div3, t1);
      if (tb_l_slot) {
        tb_l_slot.m(div3, null);
      }
      append(div3, t2);
      append(div3, div2);
      append(div2, form);
      append(form, div1);
      append(div1, span);
      append(span, svg);
      append(svg, image);
      append(div1, t3);
      append(div1, input);
      set_input_value(input, ctx[0]);
      append(div1, t4);
      append(div1, button2);
      mount_component(reload, button2, null);
      append(div1, t5);
      if (tb_url_l_slot) {
        tb_url_l_slot.m(div1, null);
      }
      append(div1, t6);
      if (tb_url_r_slot) {
        tb_url_r_slot.m(div1, null);
      }
      append(div3, t7);
      if (tb_r_l_slot) {
        tb_r_l_slot.m(div3, null);
      }
      append(div3, t8);
      if (tb_r_r_slot) {
        tb_r_r_slot.m(div3, null);
      }
      append(div3, t9);
      if (if_block)
        if_block.m(div3, null);
      append(div3, t10);
      if (tb_save_slot_or_fallback) {
        tb_save_slot_or_fallback.m(div3, null);
      }
      append(div3, t11);
      append(div3, button3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(ctx[2]))
              ctx[2].apply(this, arguments);
          }),
          listen(input, "input", ctx[13]),
          listen(button2, "click", function() {
            if (is_function(ctx[3]))
              ctx[3].apply(this, arguments);
          }),
          listen(form, "submit", prevent_default(ctx[14])),
          listen(button3, "click", function() {
            if (is_function(ctx[5]))
              ctx[5].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      var _a2;
      ctx = new_ctx;
      if (tb_l_slot) {
        if (tb_l_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tb_l_slot,
            tb_l_slot_template,
            ctx,
            ctx[16],
            !current ? get_all_dirty_from_scope(ctx[16]) : get_slot_changes(tb_l_slot_template, ctx[16], dirty, get_tb_l_slot_changes$4),
            get_tb_l_slot_context$4
          );
        }
      }
      if (!current || dirty & 1 && image_href_value !== (image_href_value = "https://monitor.distill.io/v1/getfavicon?url=" + ctx[0])) {
        attr(image, "href", image_href_value);
      }
      if (dirty & 1 && input.value !== ctx[0]) {
        set_input_value(input, ctx[0]);
      }
      if (tb_url_l_slot) {
        if (tb_url_l_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tb_url_l_slot,
            tb_url_l_slot_template,
            ctx,
            ctx[16],
            !current ? get_all_dirty_from_scope(ctx[16]) : get_slot_changes(tb_url_l_slot_template, ctx[16], dirty, get_tb_url_l_slot_changes$4),
            get_tb_url_l_slot_context$4
          );
        }
      }
      if (tb_url_r_slot) {
        if (tb_url_r_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tb_url_r_slot,
            tb_url_r_slot_template,
            ctx,
            ctx[16],
            !current ? get_all_dirty_from_scope(ctx[16]) : get_slot_changes(tb_url_r_slot_template, ctx[16], dirty, get_tb_url_r_slot_changes$4),
            get_tb_url_r_slot_context$4
          );
        }
      }
      if (tb_r_l_slot) {
        if (tb_r_l_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tb_r_l_slot,
            tb_r_l_slot_template,
            ctx,
            ctx[16],
            !current ? get_all_dirty_from_scope(ctx[16]) : get_slot_changes(tb_r_l_slot_template, ctx[16], dirty, get_tb_r_l_slot_changes$4),
            get_tb_r_l_slot_context$4
          );
        }
      }
      if (tb_r_r_slot) {
        if (tb_r_r_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tb_r_r_slot,
            tb_r_r_slot_template,
            ctx,
            ctx[16],
            !current ? get_all_dirty_from_scope(ctx[16]) : get_slot_changes(tb_r_r_slot_template, ctx[16], dirty, get_tb_r_r_slot_changes$4),
            get_tb_r_r_slot_context$4
          );
        }
      }
      if (((_a2 = ctx[7]) == null ? void 0 : _a2.length) > 0) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1B(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, t10);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (tb_save_slot) {
        if (tb_save_slot.p && (!current || dirty & 65552)) {
          update_slot_base(
            tb_save_slot,
            tb_save_slot_template,
            ctx,
            ctx[16],
            !current ? get_all_dirty_from_scope(ctx[16]) : get_slot_changes(tb_save_slot_template, ctx[16], dirty, get_tb_save_slot_changes$4),
            get_tb_save_slot_context$4
          );
        }
      } else {
        if (tb_save_slot_or_fallback && tb_save_slot_or_fallback.p && (!current || dirty & 16)) {
          tb_save_slot_or_fallback.p(ctx, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(angleright0.$$.fragment, local);
      transition_in(angleright1.$$.fragment, local);
      transition_in(tb_l_slot, local);
      transition_in(reload.$$.fragment, local);
      transition_in(tb_url_l_slot, local);
      transition_in(tb_url_r_slot, local);
      transition_in(tb_r_l_slot, local);
      transition_in(tb_r_r_slot, local);
      transition_in(if_block);
      transition_in(tb_save_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(angleright0.$$.fragment, local);
      transition_out(angleright1.$$.fragment, local);
      transition_out(tb_l_slot, local);
      transition_out(reload.$$.fragment, local);
      transition_out(tb_url_l_slot, local);
      transition_out(tb_url_r_slot, local);
      transition_out(tb_r_l_slot, local);
      transition_out(tb_r_r_slot, local);
      transition_out(if_block);
      transition_out(tb_save_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(angleright0);
      destroy_component(angleright1);
      if (tb_l_slot)
        tb_l_slot.d(detaching);
      destroy_component(reload);
      if (tb_url_l_slot)
        tb_url_l_slot.d(detaching);
      if (tb_url_r_slot)
        tb_url_r_slot.d(detaching);
      if (tb_r_l_slot)
        tb_r_l_slot.d(detaching);
      if (tb_r_r_slot)
        tb_r_r_slot.d(detaching);
      if (if_block)
        if_block.d();
      if (tb_save_slot_or_fallback)
        tb_save_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2K($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { goBack, goForward, onReload, onSave, url, onCancel, disableUrlBar, goto, extensions, toggleExtension } = $$props;
  let isExtBeingToggled = /* @__PURE__ */ new Map();
  function initializeExtStatuses() {
    for (const ext of extensions) {
      setToggleStatus(ext.id, false);
    }
  }
  initializeExtStatuses();
  function setToggleStatus(extId, status) {
    isExtBeingToggled.set(extId, status);
    $$invalidate(8, isExtBeingToggled);
  }
  async function updateStatusAndToggle(extId) {
    setToggleStatus(extId, true);
    await toggleExtension(extId);
    setToggleStatus(extId, false);
  }
  function input_input_handler() {
    url = this.value;
    $$invalidate(0, url);
  }
  const submit_handler = () => {
    goto(url);
  };
  const click_handler = (extension) => updateStatusAndToggle(extension.id);
  $$self.$$set = ($$props2) => {
    if ("goBack" in $$props2)
      $$invalidate(1, goBack = $$props2.goBack);
    if ("goForward" in $$props2)
      $$invalidate(2, goForward = $$props2.goForward);
    if ("onReload" in $$props2)
      $$invalidate(3, onReload = $$props2.onReload);
    if ("onSave" in $$props2)
      $$invalidate(4, onSave = $$props2.onSave);
    if ("url" in $$props2)
      $$invalidate(0, url = $$props2.url);
    if ("onCancel" in $$props2)
      $$invalidate(5, onCancel = $$props2.onCancel);
    if ("disableUrlBar" in $$props2)
      $$invalidate(10, disableUrlBar = $$props2.disableUrlBar);
    if ("goto" in $$props2)
      $$invalidate(6, goto = $$props2.goto);
    if ("extensions" in $$props2)
      $$invalidate(7, extensions = $$props2.extensions);
    if ("toggleExtension" in $$props2)
      $$invalidate(11, toggleExtension = $$props2.toggleExtension);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  return [
    url,
    goBack,
    goForward,
    onReload,
    onSave,
    onCancel,
    goto,
    extensions,
    isExtBeingToggled,
    updateStatusAndToggle,
    disableUrlBar,
    toggleExtension,
    slots,
    input_input_handler,
    submit_handler,
    click_handler,
    $$scope
  ];
}
class TopBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2K, create_fragment$2N, safe_not_equal, {
      goBack: 1,
      goForward: 2,
      onReload: 3,
      onSave: 4,
      url: 0,
      onCancel: 5,
      disableUrlBar: 10,
      goto: 6,
      extensions: 7,
      toggleExtension: 11
    });
  }
}
function getResizerLocalStorageKey(resizerName) {
  return `resizer-${resizerName}`;
}
function horizontalResizer(resizerElement, params2) {
  return setUpResizer(resizerElement, "horizontal", params2);
}
function setUpResizer(resizerElement, direction = "vertical", params2) {
  if (!params2) {
    params2 = {
      min: 10,
      max: 90,
      initRatio: 0.5
    };
  }
  params2.resizerName = resizerElement.getAttribute("data-resizer-name");
  if (params2.resizerName) {
    const savedValue = localStorage.getItem(getResizerLocalStorageKey(params2.resizerName));
    if (savedValue) {
      params2.initRatio = parseFloat(savedValue) || 0.5;
    }
  }
  const debouncedSave = debounce$1((newRatio) => {
    const initRatio = newRatio / 100;
    localStorage.setItem(getResizerLocalStorageKey(params2.resizerName), initRatio.toString());
  }, 200);
  const firstElement = resizerElement.previousElementSibling;
  let x = 0;
  let y = 0;
  let firstElementWidthOrHeight = 0;
  const isVertical = direction === "vertical";
  const styleProp = isVertical ? "height" : "width";
  let cursorStylePropValue = isVertical ? "row-resize" : "col-resize";
  if (params2.initRatio) {
    firstElement.style[styleProp] = params2.initRatio * 100 + "%";
    firstElement.style[`${styleProp === "height" ? "minHeight" : "minWidth"}`] = params2.initRatio * 100 + "%";
  }
  const mouseDownHandler = function(e) {
    x = e.clientX;
    y = e.clientY;
    firstElementWidthOrHeight = firstElement.getBoundingClientRect()[styleProp];
    document.addEventListener("mousemove", mouseMoveHandler);
    document.addEventListener("mouseup", mouseUpHandler);
  };
  const mouseMoveHandler = function(e) {
    const secondElement = resizerElement.nextElementSibling;
    const dx = e.clientX - x;
    const dy = e.clientY - y;
    let change = isVertical ? dy : dx;
    const parentNode = resizerElement.parentNode;
    let newPropValue = (firstElementWidthOrHeight + change) * 100 / parentNode.getBoundingClientRect()[styleProp];
    newPropValue = Math.min(params2.max, Math.max(params2.min, newPropValue));
    if (params2.resizerName) {
      debouncedSave(newPropValue);
    }
    firstElement.style[styleProp] = newPropValue + "%";
    firstElement.style[`${styleProp === "height" ? "minHeight" : "minWidth"}`] = newPropValue + "%";
    resizerElement.style.cursor = cursorStylePropValue;
    document.body.style.cursor = cursorStylePropValue;
    firstElement.style.userSelect = "none";
    firstElement.style.pointerEvents = "none";
    secondElement.style.userSelect = "none";
    secondElement.style.pointerEvents = "none";
  };
  const mouseUpHandler = function() {
    const secondElement = resizerElement.nextElementSibling;
    resizerElement.style.removeProperty("cursor");
    document.body.style.removeProperty("cursor");
    firstElement.style.removeProperty("user-select");
    firstElement.style.removeProperty("pointer-events");
    secondElement.style.removeProperty("user-select");
    secondElement.style.removeProperty("pointer-events");
    document.removeEventListener("mousemove", mouseMoveHandler);
    document.removeEventListener("mouseup", mouseUpHandler);
  };
  resizerElement.addEventListener("mousedown", mouseDownHandler);
}
const get_browser_r_slot_changes = (dirty) => ({});
const get_browser_r_slot_context = (ctx) => ({});
const get_tb_l_slot_changes$3 = (dirty) => ({});
const get_tb_l_slot_context$3 = (ctx) => ({});
const get_tb_url_l_slot_changes$3 = (dirty) => ({});
const get_tb_url_l_slot_context$3 = (ctx) => ({});
const get_tb_url_r_slot_changes$3 = (dirty) => ({});
const get_tb_url_r_slot_context$3 = (ctx) => ({});
const get_tb_r_l_slot_changes$3 = (dirty) => ({});
const get_tb_r_l_slot_context$3 = (ctx) => ({});
const get_tb_r_r_slot_changes$3 = (dirty) => ({});
const get_tb_r_r_slot_context$3 = (ctx) => ({});
const get_tb_save_slot_changes$3 = (dirty) => ({ onSave: dirty & 32 });
const get_tb_save_slot_context$3 = (ctx) => ({
  slot: "tb-save",
  onSave: ctx[5]
});
function create_tb_l_slot$3(ctx) {
  let current;
  const tb_l_slot_template = ctx[17]["tb-l"];
  const tb_l_slot = create_slot(tb_l_slot_template, ctx, ctx[20], get_tb_l_slot_context$3);
  return {
    c() {
      if (tb_l_slot)
        tb_l_slot.c();
    },
    m(target, anchor) {
      if (tb_l_slot) {
        tb_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_l_slot) {
        if (tb_l_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            tb_l_slot,
            tb_l_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(tb_l_slot_template, ctx2[20], dirty, get_tb_l_slot_changes$3),
            get_tb_l_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_l_slot)
        tb_l_slot.d(detaching);
    }
  };
}
function create_tb_url_l_slot$3(ctx) {
  let current;
  const tb_url_l_slot_template = ctx[17]["tb-url-l"];
  const tb_url_l_slot = create_slot(tb_url_l_slot_template, ctx, ctx[20], get_tb_url_l_slot_context$3);
  return {
    c() {
      if (tb_url_l_slot)
        tb_url_l_slot.c();
    },
    m(target, anchor) {
      if (tb_url_l_slot) {
        tb_url_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_url_l_slot) {
        if (tb_url_l_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            tb_url_l_slot,
            tb_url_l_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(tb_url_l_slot_template, ctx2[20], dirty, get_tb_url_l_slot_changes$3),
            get_tb_url_l_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_url_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_url_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_url_l_slot)
        tb_url_l_slot.d(detaching);
    }
  };
}
function create_tb_url_r_slot$4(ctx) {
  let current;
  const tb_url_r_slot_template = ctx[17]["tb-url-r"];
  const tb_url_r_slot = create_slot(tb_url_r_slot_template, ctx, ctx[20], get_tb_url_r_slot_context$3);
  return {
    c() {
      if (tb_url_r_slot)
        tb_url_r_slot.c();
    },
    m(target, anchor) {
      if (tb_url_r_slot) {
        tb_url_r_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_url_r_slot) {
        if (tb_url_r_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            tb_url_r_slot,
            tb_url_r_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(tb_url_r_slot_template, ctx2[20], dirty, get_tb_url_r_slot_changes$3),
            get_tb_url_r_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_url_r_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_url_r_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_url_r_slot)
        tb_url_r_slot.d(detaching);
    }
  };
}
function create_tb_r_l_slot$3(ctx) {
  let current;
  const tb_r_l_slot_template = ctx[17]["tb-r-l"];
  const tb_r_l_slot = create_slot(tb_r_l_slot_template, ctx, ctx[20], get_tb_r_l_slot_context$3);
  return {
    c() {
      if (tb_r_l_slot)
        tb_r_l_slot.c();
    },
    m(target, anchor) {
      if (tb_r_l_slot) {
        tb_r_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_r_l_slot) {
        if (tb_r_l_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            tb_r_l_slot,
            tb_r_l_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(tb_r_l_slot_template, ctx2[20], dirty, get_tb_r_l_slot_changes$3),
            get_tb_r_l_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_r_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_r_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_r_l_slot)
        tb_r_l_slot.d(detaching);
    }
  };
}
function create_tb_r_r_slot$3(ctx) {
  let current;
  const tb_r_r_slot_template = ctx[17]["tb-r-r"];
  const tb_r_r_slot = create_slot(tb_r_r_slot_template, ctx, ctx[20], get_tb_r_r_slot_context$3);
  return {
    c() {
      if (tb_r_r_slot)
        tb_r_r_slot.c();
    },
    m(target, anchor) {
      if (tb_r_r_slot) {
        tb_r_r_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_r_r_slot) {
        if (tb_r_r_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            tb_r_r_slot,
            tb_r_r_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(tb_r_r_slot_template, ctx2[20], dirty, get_tb_r_r_slot_changes$3),
            get_tb_r_r_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_r_r_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_r_r_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_r_r_slot)
        tb_r_r_slot.d(detaching);
    }
  };
}
function fallback_block$6(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Save";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-sm btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[5]))
            ctx[5].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_tb_save_slot$3(ctx) {
  let current;
  const tb_save_slot_template = ctx[17]["tb-save"];
  const tb_save_slot = create_slot(tb_save_slot_template, ctx, ctx[20], get_tb_save_slot_context$3);
  const tb_save_slot_or_fallback = tb_save_slot || fallback_block$6(ctx);
  return {
    c() {
      if (tb_save_slot_or_fallback)
        tb_save_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (tb_save_slot_or_fallback) {
        tb_save_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_save_slot) {
        if (tb_save_slot.p && (!current || dirty & 1048608)) {
          update_slot_base(
            tb_save_slot,
            tb_save_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(tb_save_slot_template, ctx2[20], dirty, get_tb_save_slot_changes$3),
            get_tb_save_slot_context$3
          );
        }
      } else {
        if (tb_save_slot_or_fallback && tb_save_slot_or_fallback.p && (!current || dirty & 32)) {
          tb_save_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_save_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(tb_save_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (tb_save_slot_or_fallback)
        tb_save_slot_or_fallback.d(detaching);
    }
  };
}
function create_fragment$2M(ctx) {
  let div2;
  let topbar;
  let updating_url;
  let updating_extensions;
  let t0;
  let div1;
  let browsercomponent;
  let t1;
  let div0;
  let t2;
  let t3;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  function topbar_url_binding(value) {
    ctx[18](value);
  }
  function topbar_extensions_binding(value) {
    ctx[19](value);
  }
  let topbar_props = {
    goBack: ctx[7],
    goForward: ctx[8],
    onReload: ctx[11],
    onSave: ctx[5],
    onCancel: ctx[4],
    goto: ctx[9],
    toggleExtension: ctx[12],
    $$slots: {
      "tb-save": [
        create_tb_save_slot$3,
        ({ onSave }) => ({ 5: onSave }),
        ({ onSave }) => onSave ? 32 : 0
      ],
      "tb-r-r": [create_tb_r_r_slot$3],
      "tb-r-l": [create_tb_r_l_slot$3],
      "tb-url-r": [create_tb_url_r_slot$4],
      "tb-url-l": [create_tb_url_l_slot$3],
      "tb-l": [create_tb_l_slot$3]
    },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    topbar_props.url = ctx[0];
  }
  if (ctx[1] !== void 0) {
    topbar_props.extensions = ctx[1];
  }
  topbar = new TopBar({ props: topbar_props });
  binding_callbacks.push(() => bind$1(topbar, "url", topbar_url_binding));
  binding_callbacks.push(() => bind$1(topbar, "extensions", topbar_extensions_binding));
  browsercomponent = new Browser$1({
    props: {
      bbx: ctx[3],
      loading: ctx[6]
    }
  });
  browsercomponent.$on("ready", ctx[10]);
  browsercomponent.$on("error", onBrowserError);
  const browser_r_slot_template = ctx[17]["browser-r"];
  const browser_r_slot = create_slot(browser_r_slot_template, ctx, ctx[20], get_browser_r_slot_context);
  let if_block = inspector;
  let div2_levels = [
    {
      class: div2_class_value = "bbx-recorder " + ctx[2]
    },
    ctx[13]
  ];
  let div_data_2 = {};
  for (let i2 = 0; i2 < div2_levels.length; i2 += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      create_component(topbar.$$.fragment);
      t0 = space();
      div1 = element("div");
      create_component(browsercomponent.$$.fragment);
      t1 = space();
      div0 = element("div");
      t2 = space();
      if (browser_r_slot)
        browser_r_slot.c();
      t3 = space();
      attr(div0, "class", "resizer h-resizer");
      attr(div0, "data-resizer-name", "sidebar-h-1");
      attr(div1, "class", "bbx-recorder-body");
      set_attributes(div2, div_data_2);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(topbar, div2, null);
      append(div2, t0);
      append(div2, div1);
      mount_component(browsercomponent, div1, null);
      append(div1, t1);
      append(div1, div0);
      append(div1, t2);
      if (browser_r_slot) {
        browser_r_slot.m(div1, null);
      }
      append(div2, t3);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(horizontalResizer.call(null, div0, { min: 10, max: 90, initRatio: 0.75 }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const topbar_changes = {};
      if (dirty & 32)
        topbar_changes.onSave = ctx2[5];
      if (dirty & 16)
        topbar_changes.onCancel = ctx2[4];
      if (dirty & 1048608) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_url && dirty & 1) {
        updating_url = true;
        topbar_changes.url = ctx2[0];
        add_flush_callback(() => updating_url = false);
      }
      if (!updating_extensions && dirty & 2) {
        updating_extensions = true;
        topbar_changes.extensions = ctx2[1];
        add_flush_callback(() => updating_extensions = false);
      }
      topbar.$set(topbar_changes);
      const browsercomponent_changes = {};
      if (dirty & 8)
        browsercomponent_changes.bbx = ctx2[3];
      if (dirty & 64)
        browsercomponent_changes.loading = ctx2[6];
      browsercomponent.$set(browsercomponent_changes);
      if (browser_r_slot) {
        if (browser_r_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            browser_r_slot,
            browser_r_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(browser_r_slot_template, ctx2[20], dirty, get_browser_r_slot_changes),
            get_browser_r_slot_context
          );
        }
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        (!current || dirty & 4 && div2_class_value !== (div2_class_value = "bbx-recorder " + ctx2[2])) && { class: div2_class_value },
        dirty & 8192 && ctx2[13]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      transition_in(browsercomponent.$$.fragment, local);
      transition_in(browser_r_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      transition_out(browsercomponent.$$.fragment, local);
      transition_out(browser_r_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(topbar);
      destroy_component(browsercomponent);
      if (browser_r_slot)
        browser_r_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
let inspector = false;
function onBrowserError(e) {
  console.error("onBrowserError", e.detail);
}
function instance$2J($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "class",
    "bbx",
    "onCancel",
    "onSave",
    "proxy",
    "session",
    "url",
    "extensions",
    "onProxyChange"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  let { class: clazz = "" } = $$props;
  let { bbx } = $$props;
  let { onCancel } = $$props;
  let { onSave } = $$props;
  let { proxy = void 0 } = $$props;
  let { session = void 0 } = $$props;
  let { url = "https://example.com/" } = $$props;
  let { extensions = [] } = $$props;
  let { onProxyChange = void 0 } = $$props;
  let browserView;
  let browser2;
  let loading2 = false;
  if (!onProxyChange) {
    onProxyChange = (proxy2) => {
      return browserView == null ? void 0 : browserView.client.api("proxy", "PUT", { id: (proxy2 == null ? void 0 : proxy2.id) || null });
    };
  }
  function getActivePage() {
    return browser2 == null ? void 0 : browser2.getActivePage();
  }
  function goBack() {
    var _a;
    (_a = getActivePage()) == null ? void 0 : _a.goBack();
  }
  function goForward() {
    var _a;
    (_a = getActivePage()) == null ? void 0 : _a.goForward();
  }
  async function proxyChangeWrapper(proxy2) {
    if (!browserView) {
      return;
    }
    await onProxyChange(proxy2, browserView);
  }
  async function goto(_url = url) {
    var _a;
    $$invalidate(6, loading2 = true);
    try {
      await ((_a = browser2 == null ? void 0 : browser2.pages[0]) == null ? void 0 : _a.goto(_url));
    } catch (e) {
    }
    $$invalidate(6, loading2 = false);
    dispatch("goto", _url);
  }
  async function onBrowserReady(e) {
    browserView = e.detail;
    browser2 = browserView.store;
    if (!browser2) {
      await wait$3(2e3);
    }
    await onProxyChange(proxy, browserView);
    if (session) {
      await onSessionChange(session);
    }
    if (extensions.length) {
      await comparePrevExtStatus();
    }
    dispatch("ready", browserView);
  }
  function onReload() {
    let page = getActivePage();
    if (!page)
      return;
    if (page.mainFrame.url && page.mainFrame.url.startsWith("http")) {
      page.reload();
    } else {
      page.goto(url);
    }
  }
  function onSessionChange(session2) {
    return browserView == null ? void 0 : browserView.store.call("setCookies", (session2 == null ? void 0 : session2.cookies) || []);
  }
  async function comparePrevExtStatus() {
    for (const ext of browser2.extensions) {
      const macroExt = extensions.find((e) => e.id === ext.id);
      if (macroExt && ext.enabled != macroExt.enabled) {
        await toggleExtension(ext.id);
      }
    }
  }
  async function toggleExtension(extId) {
    const ext = browser2.extensions.find((e) => e.id === extId);
    await browserView.manager.browser.call("setExtensionState", extId, !ext.enabled);
    await reloadAllPages();
    for (const ext2 of browser2.extensions) {
      const macroExt = extensions.find((e) => e.id === ext2.id);
      macroExt.enabled = ext2.enabled;
    }
  }
  async function reloadAllPages() {
    await Promise.all(browserView.manager.browser.pages.map((page) => page.reload()));
  }
  function topbar_url_binding(value) {
    url = value;
    $$invalidate(0, url);
  }
  function topbar_extensions_binding(value) {
    extensions = value;
    $$invalidate(1, extensions);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, clazz = $$new_props.class);
    if ("bbx" in $$new_props)
      $$invalidate(3, bbx = $$new_props.bbx);
    if ("onCancel" in $$new_props)
      $$invalidate(4, onCancel = $$new_props.onCancel);
    if ("onSave" in $$new_props)
      $$invalidate(5, onSave = $$new_props.onSave);
    if ("proxy" in $$new_props)
      $$invalidate(15, proxy = $$new_props.proxy);
    if ("session" in $$new_props)
      $$invalidate(16, session = $$new_props.session);
    if ("url" in $$new_props)
      $$invalidate(0, url = $$new_props.url);
    if ("extensions" in $$new_props)
      $$invalidate(1, extensions = $$new_props.extensions);
    if ("onProxyChange" in $$new_props)
      $$invalidate(14, onProxyChange = $$new_props.onProxyChange);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32768) {
      proxyChangeWrapper(proxy);
    }
    if ($$self.$$.dirty & 65536) {
      onSessionChange(session);
    }
  };
  return [
    url,
    extensions,
    clazz,
    bbx,
    onCancel,
    onSave,
    loading2,
    goBack,
    goForward,
    goto,
    onBrowserReady,
    onReload,
    toggleExtension,
    $$restProps,
    onProxyChange,
    proxy,
    session,
    slots,
    topbar_url_binding,
    topbar_extensions_binding,
    $$scope
  ];
}
class BrowserContainer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2J, create_fragment$2M, safe_not_equal, {
      class: 2,
      bbx: 3,
      onCancel: 4,
      onSave: 5,
      proxy: 15,
      session: 16,
      url: 0,
      extensions: 1,
      onProxyChange: 14
    });
  }
}
class MsgClass {
  constructor(_Msg, delay2 = 5e3) {
    this._Msg = _Msg;
    this.delay = delay2;
    this.reset = () => {
      var _a;
      (_a = this._Msg) == null ? void 0 : _a.reset();
    };
  }
  clearAfterDelay() {
    this.timeout = setTimeout(this.reset, this.delay);
  }
  error(msg) {
    clearTimeout(this.timeout);
    this.reset();
    if (this._Msg) {
      this._Msg.error(msg);
      this.clearAfterDelay();
    } else {
      alert(msg);
    }
  }
  info(msg) {
    clearTimeout(this.timeout);
    this.reset();
    if (this._Msg) {
      this._Msg.info(msg);
      this.clearAfterDelay();
    } else {
      alert(msg);
    }
  }
}
const get_tb_l_slot_changes$2 = (dirty) => ({});
const get_tb_l_slot_context$2 = (ctx) => ({});
const get_tb_url_l_slot_changes$2 = (dirty) => ({});
const get_tb_url_l_slot_context$2 = (ctx) => ({});
const get_tb_url_r_slot_changes$2 = (dirty) => ({});
const get_tb_url_r_slot_context$2 = (ctx) => ({});
const get_tb_r_l_slot_changes$2 = (dirty) => ({});
const get_tb_r_l_slot_context$2 = (ctx) => ({});
const get_tb_r_r_slot_changes$2 = (dirty) => ({});
const get_tb_r_r_slot_context$2 = (ctx) => ({});
const get_tb_save_slot_changes$2 = (dirty) => ({ onSave: dirty & 2048 });
const get_tb_save_slot_context$2 = (ctx) => ({
  slot: "tb-save",
  onSave: ctx[11]
});
function create_tb_l_slot$2(ctx) {
  let current;
  const tb_l_slot_template = ctx[14]["tb-l"];
  const tb_l_slot = create_slot(tb_l_slot_template, ctx, ctx[16], get_tb_l_slot_context$2);
  return {
    c() {
      if (tb_l_slot)
        tb_l_slot.c();
    },
    m(target, anchor) {
      if (tb_l_slot) {
        tb_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_l_slot) {
        if (tb_l_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tb_l_slot,
            tb_l_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tb_l_slot_template, ctx2[16], dirty, get_tb_l_slot_changes$2),
            get_tb_l_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_l_slot)
        tb_l_slot.d(detaching);
    }
  };
}
function create_tb_url_l_slot$2(ctx) {
  let current;
  const tb_url_l_slot_template = ctx[14]["tb-url-l"];
  const tb_url_l_slot = create_slot(tb_url_l_slot_template, ctx, ctx[16], get_tb_url_l_slot_context$2);
  return {
    c() {
      if (tb_url_l_slot)
        tb_url_l_slot.c();
    },
    m(target, anchor) {
      if (tb_url_l_slot) {
        tb_url_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_url_l_slot) {
        if (tb_url_l_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tb_url_l_slot,
            tb_url_l_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tb_url_l_slot_template, ctx2[16], dirty, get_tb_url_l_slot_changes$2),
            get_tb_url_l_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_url_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_url_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_url_l_slot)
        tb_url_l_slot.d(detaching);
    }
  };
}
function create_tb_url_r_slot$3(ctx) {
  let current;
  const tb_url_r_slot_template = ctx[14]["tb-url-r"];
  const tb_url_r_slot = create_slot(tb_url_r_slot_template, ctx, ctx[16], get_tb_url_r_slot_context$2);
  return {
    c() {
      if (tb_url_r_slot)
        tb_url_r_slot.c();
    },
    m(target, anchor) {
      if (tb_url_r_slot) {
        tb_url_r_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_url_r_slot) {
        if (tb_url_r_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tb_url_r_slot,
            tb_url_r_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tb_url_r_slot_template, ctx2[16], dirty, get_tb_url_r_slot_changes$2),
            get_tb_url_r_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_url_r_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_url_r_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_url_r_slot)
        tb_url_r_slot.d(detaching);
    }
  };
}
function create_tb_r_l_slot$2(ctx) {
  let current;
  const tb_r_l_slot_template = ctx[14]["tb-r-l"];
  const tb_r_l_slot = create_slot(tb_r_l_slot_template, ctx, ctx[16], get_tb_r_l_slot_context$2);
  return {
    c() {
      if (tb_r_l_slot)
        tb_r_l_slot.c();
    },
    m(target, anchor) {
      if (tb_r_l_slot) {
        tb_r_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_r_l_slot) {
        if (tb_r_l_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tb_r_l_slot,
            tb_r_l_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tb_r_l_slot_template, ctx2[16], dirty, get_tb_r_l_slot_changes$2),
            get_tb_r_l_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_r_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_r_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_r_l_slot)
        tb_r_l_slot.d(detaching);
    }
  };
}
function create_tb_r_r_slot$2(ctx) {
  let current;
  const tb_r_r_slot_template = ctx[14]["tb-r-r"];
  const tb_r_r_slot = create_slot(tb_r_r_slot_template, ctx, ctx[16], get_tb_r_r_slot_context$2);
  return {
    c() {
      if (tb_r_r_slot)
        tb_r_r_slot.c();
    },
    m(target, anchor) {
      if (tb_r_r_slot) {
        tb_r_r_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_r_r_slot) {
        if (tb_r_r_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            tb_r_r_slot,
            tb_r_r_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tb_r_r_slot_template, ctx2[16], dirty, get_tb_r_r_slot_changes$2),
            get_tb_r_r_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_r_r_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_r_r_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_r_r_slot)
        tb_r_r_slot.d(detaching);
    }
  };
}
function fallback_block$5(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Save";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-sm btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[11]))
            ctx[11].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_tb_save_slot$2(ctx) {
  let current;
  const tb_save_slot_template = ctx[14]["tb-save"];
  const tb_save_slot = create_slot(tb_save_slot_template, ctx, ctx[16], get_tb_save_slot_context$2);
  const tb_save_slot_or_fallback = tb_save_slot || fallback_block$5(ctx);
  return {
    c() {
      if (tb_save_slot_or_fallback)
        tb_save_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (tb_save_slot_or_fallback) {
        tb_save_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_save_slot) {
        if (tb_save_slot.p && (!current || dirty & 67584)) {
          update_slot_base(
            tb_save_slot,
            tb_save_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(tb_save_slot_template, ctx2[16], dirty, get_tb_save_slot_changes$2),
            get_tb_save_slot_context$2
          );
        }
      } else {
        if (tb_save_slot_or_fallback && tb_save_slot_or_fallback.p && (!current || dirty & 2048)) {
          tb_save_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_save_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(tb_save_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (tb_save_slot_or_fallback)
        tb_save_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block$1A(ctx) {
  let app;
  let current;
  app = new App$3({
    props: {
      browserView: ctx[5],
      expressionTree: ctx[6],
      findSelector: ctx[3],
      optInParams: ctx[4],
      params: ctx[7],
      url: ctx[0]
    }
  });
  return {
    c() {
      create_component(app.$$.fragment);
    },
    m(target, anchor) {
      mount_component(app, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const app_changes = {};
      if (dirty & 32)
        app_changes.browserView = ctx2[5];
      if (dirty & 8)
        app_changes.findSelector = ctx2[3];
      if (dirty & 16)
        app_changes.optInParams = ctx2[4];
      if (dirty & 1)
        app_changes.url = ctx2[0];
      app.$set(app_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(app.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(app.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(app, detaching);
    }
  };
}
function create_browser_r_slot$2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[5] && create_if_block$1A(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1A(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$2L(ctx) {
  let browsercontainer;
  let updating_url;
  let current;
  function browsercontainer_url_binding(value) {
    ctx[15](value);
  }
  let browsercontainer_props = {
    bbx: ctx[1],
    class: ctx[2],
    onCancel: ctx[8],
    onSave: ctx[11],
    $$slots: {
      "browser-r": [create_browser_r_slot$2],
      "tb-save": [
        create_tb_save_slot$2,
        ({ onSave }) => ({ 11: onSave }),
        ({ onSave }) => onSave ? 2048 : 0
      ],
      "tb-r-r": [create_tb_r_r_slot$2],
      "tb-r-l": [create_tb_r_l_slot$2],
      "tb-url-r": [create_tb_url_r_slot$3],
      "tb-url-l": [create_tb_url_l_slot$2],
      "tb-l": [create_tb_l_slot$2]
    },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    browsercontainer_props.url = ctx[0];
  }
  browsercontainer = new BrowserContainer({ props: browsercontainer_props });
  binding_callbacks.push(() => bind$1(browsercontainer, "url", browsercontainer_url_binding));
  browsercontainer.$on("goto", ctx[9]);
  browsercontainer.$on("ready", ctx[10]);
  return {
    c() {
      create_component(browsercontainer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(browsercontainer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const browsercontainer_changes = {};
      if (dirty & 2)
        browsercontainer_changes.bbx = ctx2[1];
      if (dirty & 4)
        browsercontainer_changes.class = ctx2[2];
      if (dirty & 67641) {
        browsercontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_url && dirty & 1) {
        updating_url = true;
        browsercontainer_changes.url = ctx2[0];
        add_flush_callback(() => updating_url = false);
      }
      browsercontainer.$set(browsercontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(browsercontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(browsercontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(browsercontainer, detaching);
    }
  };
}
function instance$2I($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  const _Msg = getContext("Msg");
  const Msg2 = new MsgClass(_Msg);
  setContext("Msg", Msg2);
  let { bbx } = $$props;
  let { class: clazz = "" } = $$props;
  let { findSelector } = $$props;
  let { url } = $$props;
  let { initialParams = [] } = $$props;
  let { initialSteps = [] } = $$props;
  let { optInParams: optInParams2 = false } = $$props;
  let browserView;
  const expressionTree = parseSteps$2(initialSteps, { declarations: initialParams });
  let params2 = new Params$2(expressionTree.declarations);
  function onCancel() {
    dispatch("cancel");
  }
  function onSave() {
    let steps;
    try {
      steps = expressionTree.toJSON();
    } catch (e) {
      Msg2.error("Cannot save steps with errors. Please resolve ");
      throw e;
    }
    dispatch("save", { steps, params: params2.toJSON() });
  }
  function constructParams(event) {
    let newURL = event.detail;
    let urlObj = new URL(newURL);
    let newParams = [
      { name: "hash", newDefault: urlObj.hash },
      {
        name: "path",
        newDefault: urlObj.pathname
      },
      { name: "query", newDefault: urlObj.search }
    ];
    newParams.forEach(({ name, newDefault }) => {
      params2.setParam(name, newDefault);
    });
  }
  function onBrowserContainerReady(event) {
    $$invalidate(5, browserView = event.detail);
    dispatch("ready", event.detail);
  }
  function browsercontainer_url_binding(value) {
    url = value;
    $$invalidate(0, url);
  }
  $$self.$$set = ($$props2) => {
    if ("bbx" in $$props2)
      $$invalidate(1, bbx = $$props2.bbx);
    if ("class" in $$props2)
      $$invalidate(2, clazz = $$props2.class);
    if ("findSelector" in $$props2)
      $$invalidate(3, findSelector = $$props2.findSelector);
    if ("url" in $$props2)
      $$invalidate(0, url = $$props2.url);
    if ("initialParams" in $$props2)
      $$invalidate(12, initialParams = $$props2.initialParams);
    if ("initialSteps" in $$props2)
      $$invalidate(13, initialSteps = $$props2.initialSteps);
    if ("optInParams" in $$props2)
      $$invalidate(4, optInParams2 = $$props2.optInParams);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  return [
    url,
    bbx,
    clazz,
    findSelector,
    optInParams2,
    browserView,
    expressionTree,
    params2,
    onCancel,
    constructParams,
    onBrowserContainerReady,
    onSave,
    initialParams,
    initialSteps,
    slots,
    browsercontainer_url_binding,
    $$scope
  ];
}
class Index$2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2I, create_fragment$2L, safe_not_equal, {
      bbx: 1,
      class: 2,
      findSelector: 3,
      url: 0,
      initialParams: 12,
      initialSteps: 13,
      optInParams: 4
    });
  }
}
var Modal_svelte_svelte_type_style_lang = "";
function create_fragment$2K(ctx) {
  let div3;
  let div2;
  let div1;
  let div0;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "modal-body p-0");
      attr(div1, "class", "modal-content");
      attr(div2, "class", div2_class_value = "modal-dialog " + ctx[0] + " svelte-17wlcl9");
      attr(div2, "role", "document");
      attr(div3, "class", "modal");
      attr(div3, "tabindex", "-1");
      attr(div3, "role", "dialog");
      set_style(div3, "display", "block");
      set_style(div3, "background-color", "#fffc");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[5](div3);
      current = true;
      if (!mounted) {
        dispose = listen(window, "keydown", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1 && div2_class_value !== (div2_class_value = "modal-dialog " + ctx2[0] + " svelte-17wlcl9")) {
        attr(div2, "class", div2_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (default_slot)
        default_slot.d(detaching);
      ctx[5](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$2H($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { widthClass = "" } = $$props;
  let elModal;
  createEventDispatcher();
  const handle_keydown = (e) => {
    if (e.key === "Tab") {
      const nodes = elModal.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter((n) => n.tabIndex >= 0);
      let index2 = tabbable.indexOf(document.activeElement);
      if (index2 === -1 && e.shiftKey)
        index2 = 0;
      index2 += tabbable.length + (e.shiftKey ? -1 : 1);
      index2 %= tabbable.length;
      tabbable[index2].focus();
      e.preventDefault();
    }
  };
  const lastFocued = document.activeElement;
  if (lastFocued) {
    onDestroy(() => {
      lastFocued.focus();
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elModal = $$value;
      $$invalidate(1, elModal);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("widthClass" in $$props2)
      $$invalidate(0, widthClass = $$props2.widthClass);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [widthClass, elModal, handle_keydown, $$scope, slots, div3_binding];
}
class Modal$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2H, create_fragment$2K, safe_not_equal, { widthClass: 0 });
  }
}
function create_catch_block$v(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$v(ctx) {
  let div;
  let bbxrecorder;
  let current;
  bbxrecorder = new Index$2({
    props: {
      bbx: ctx[1],
      initialSteps: ctx[2],
      initialParams: ctx[3],
      findSelector: ctx[6],
      url: ctx[0]
    }
  });
  bbxrecorder.$on("save", ctx[4]);
  bbxrecorder.$on("cancel", ctx[8]);
  return {
    c() {
      div = element("div");
      create_component(bbxrecorder.$$.fragment);
      attr(div, "class", "w-100");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(bbxrecorder, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const bbxrecorder_changes = {};
      if (dirty & 2)
        bbxrecorder_changes.bbx = ctx2[1];
      if (dirty & 1)
        bbxrecorder_changes.url = ctx2[0];
      bbxrecorder.$set(bbxrecorder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(bbxrecorder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bbxrecorder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(bbxrecorder);
    }
  };
}
function create_pending_block$v(ctx) {
  let loader;
  let t0;
  let div;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
      t0 = space();
      div = element("div");
      div.textContent = "Creating browser...";
      attr(div, "class", "fs-2 pt-2 text-center");
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$2J(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$v,
    then: create_then_block$v,
    catch: create_catch_block$v,
    value: 12,
    blocks: [, , ,]
  };
  handle_promise(ctx[5](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$2G($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { tree } = $$props;
  let { url } = $$props;
  let urlObj = new URL(url);
  let api = getContext("api");
  let initialSteps = tree.toJSON();
  let initialParams = [
    {
      name: "hash",
      dataType: "string",
      default: urlObj.hash
    },
    {
      name: "path",
      dataType: "string",
      default: urlObj.pathname
    },
    {
      name: "query",
      dataType: "string",
      default: urlObj.search
    }
  ];
  let bbx;
  function onSave(e) {
    let newSteps = e.detail.steps;
    tree.replace(newSteps);
    dispatch("save");
  }
  async function createBBX() {
    try {
      Msg.reset();
      $$invalidate(1, bbx = await api("/selectors2", "POST"));
    } catch (e) {
      dispatch("cancel");
      Msg.error("Failed to create remote browser. Please try again later.");
    }
  }
  async function findSelector(el2, type = "css") {
    return type === "css" ? new CSSSelector(await getCSS([el2], el2.ownerDocument)) : new XPathSelector(await getXpath([el2], el2.ownerDocument));
  }
  function cancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("tree" in $$props2)
      $$invalidate(7, tree = $$props2.tree);
    if ("url" in $$props2)
      $$invalidate(0, url = $$props2.url);
  };
  return [
    url,
    bbx,
    initialSteps,
    initialParams,
    onSave,
    createBBX,
    findSelector,
    tree,
    cancel_handler
  ];
}
class PageFunctionRecorder extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2G, create_fragment$2J, safe_not_equal, { tree: 7, url: 0 });
  }
}
function create_if_block$1z(ctx) {
  let div3;
  let div2;
  let div1;
  let div0;
  let recordermodal;
  let current;
  recordermodal = new Modal$1({
    props: {
      widthClass: "modal-fullscreen",
      $$slots: { default: [create_default_slot$15] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(recordermodal.$$.fragment);
      attr(div0, "class", "modal-body p-0");
      attr(div1, "class", "modal-content");
      attr(div2, "class", "modal-dialog");
      attr(div2, "role", "document");
      attr(div3, "class", "modal");
      attr(div3, "tabindex", "-1");
      attr(div3, "role", "dialog");
      set_style(div3, "display", "block");
      set_style(div3, "background-color", "#fffc");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      mount_component(recordermodal, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const recordermodal_changes = {};
      if (dirty & 139) {
        recordermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      recordermodal.$set(recordermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recordermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recordermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(recordermodal);
    }
  };
}
function create_default_slot$15(ctx) {
  let pagefunctionrecorder;
  let current;
  pagefunctionrecorder = new PageFunctionRecorder({
    props: {
      tree: ctx[0],
      url: ctx[1]
    }
  });
  pagefunctionrecorder.$on("save", ctx[5]);
  pagefunctionrecorder.$on("cancel", ctx[6]);
  return {
    c() {
      create_component(pagefunctionrecorder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pagefunctionrecorder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pagefunctionrecorder_changes = {};
      if (dirty & 1)
        pagefunctionrecorder_changes.tree = ctx2[0];
      if (dirty & 2)
        pagefunctionrecorder_changes.url = ctx2[1];
      pagefunctionrecorder.$set(pagefunctionrecorder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pagefunctionrecorder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pagefunctionrecorder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pagefunctionrecorder, detaching);
    }
  };
}
function create_fragment$2I(ctx) {
  let button;
  let t0;
  let t1;
  let t2;
  let t3;
  let p;
  let t5;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[3] && create_if_block$1z(ctx);
  return {
    c() {
      button = element("button");
      t0 = text("Edit Steps (");
      t1 = text(ctx[2]);
      t2 = text(")");
      t3 = space();
      p = element("p");
      p.textContent = "List of validation steps taken before a page is crawled";
      t5 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(button, "class", "btn btn-default");
      attr(p, "class", "help");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      insert(target, t3, anchor);
      insert(target, p, anchor);
      insert(target, t5, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 4)
        set_data(t1, ctx2[2]);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1z(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(p);
      if (detaching)
        detach(t5);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$2F($$self, $$props, $$invalidate) {
  let { tree } = $$props;
  let { url } = $$props;
  let treeLength = tree.toJSON().length;
  let bbxRecorderModal = false;
  tree == null ? void 0 : tree.on("change", (event) => {
    $$invalidate(2, treeLength = tree.toJSON().length);
  });
  function openBBXRecorderModal() {
    $$invalidate(3, bbxRecorderModal = true);
  }
  const save_handler = () => $$invalidate(3, bbxRecorderModal = false);
  const cancel_handler = () => $$invalidate(3, bbxRecorderModal = false);
  $$self.$$set = ($$props2) => {
    if ("tree" in $$props2)
      $$invalidate(0, tree = $$props2.tree);
    if ("url" in $$props2)
      $$invalidate(1, url = $$props2.url);
  };
  return [
    tree,
    url,
    treeLength,
    bbxRecorderModal,
    openBBXRecorderModal,
    save_handler,
    cancel_handler
  ];
}
class PageFunctions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2F, create_fragment$2I, safe_not_equal, { tree: 0, url: 1 });
  }
}
const get_buttons_slot_changes$1 = (dirty) => ({});
const get_buttons_slot_context$1 = (ctx) => ({});
function create_if_block_2$I(ctx) {
  let div1;
  let label0;
  let br0;
  let t1;
  let div0;
  let inputedit;
  let t2;
  let p;
  let t4;
  let div4;
  let label1;
  let br1;
  let t6;
  let div3;
  let div2;
  let scheduleeditor;
  let current;
  inputedit = new InputEdit({
    props: {
      field: ctx[0].fields.name,
      id: "name",
      name: "name"
    }
  });
  scheduleeditor = new ScheduleEditor({
    props: {
      formModel: ctx[0],
      minInt: ctx[8],
      MIN: ctx[9],
      MAX: ctx[10],
      schedules: ctx[11],
      editors: ctx[7]
    }
  });
  return {
    c() {
      div1 = element("div");
      label0 = element("label");
      label0.textContent = "Name:";
      br0 = element("br");
      t1 = space();
      div0 = element("div");
      create_component(inputedit.$$.fragment);
      t2 = space();
      p = element("p");
      p.textContent = "Crawler name";
      t4 = space();
      div4 = element("div");
      label1 = element("label");
      label1.textContent = "Schedule: ";
      br1 = element("br");
      t6 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(scheduleeditor.$$.fragment);
      attr(label0, "class", "xoption-label form-label");
      attr(label0, "for", "name");
      attr(p, "class", "help");
      attr(div0, "class", "flex-1");
      attr(div1, "class", "flex gap-x-6 mt-5");
      attr(label1, "class", "xoption-label form-label");
      attr(label1, "for", "url");
      attr(div2, "class", "gap-2");
      set_style(div3, "width", "100%");
      attr(div4, "class", "flex gap-x-6 mt-5");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, label0);
      append(div1, br0);
      append(div1, t1);
      append(div1, div0);
      mount_component(inputedit, div0, null);
      append(div0, t2);
      append(div0, p);
      insert(target, t4, anchor);
      insert(target, div4, anchor);
      append(div4, label1);
      append(div4, br1);
      append(div4, t6);
      append(div4, div3);
      append(div3, div2);
      mount_component(scheduleeditor, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const inputedit_changes = {};
      if (dirty & 1)
        inputedit_changes.field = ctx2[0].fields.name;
      inputedit.$set(inputedit_changes);
      const scheduleeditor_changes = {};
      if (dirty & 1)
        scheduleeditor_changes.formModel = ctx2[0];
      scheduleeditor.$set(scheduleeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      transition_in(scheduleeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      transition_out(scheduleeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(inputedit);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(div4);
      destroy_component(scheduleeditor);
    }
  };
}
function create_if_block$1y(ctx) {
  let div;
  let p;
  return {
    c() {
      div = element("div");
      p = element("p");
      p.textContent = `${ctx[12]}`;
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$2H(ctx) {
  let div14;
  let div2;
  let label0;
  let br0;
  let t1;
  let div1;
  let div0;
  let urledit;
  let t2;
  let p0;
  let t4;
  let t5;
  let div5;
  let label1;
  let br1;
  let t7;
  let div4;
  let div3;
  let inputedit;
  let t8;
  let p1;
  let t10;
  let div7;
  let label2;
  let br2;
  let t12;
  let div6;
  let regexlist;
  let t13;
  let p2;
  let t15;
  let div9;
  let label3;
  let br3;
  let t17;
  let div8;
  let rewritesteps;
  let t18;
  let div11;
  let label4;
  let br4;
  let t20;
  let div10;
  let pagefunctions;
  let t21;
  let t22;
  let t23;
  let div13;
  let label5;
  let br5;
  let t24;
  let div12;
  let current;
  urledit = new UrlEdit({
    props: { field: ctx[0].fields.url }
  });
  let if_block0 = ctx[1] && create_if_block_2$I(ctx);
  inputedit = new InputEdit({
    props: {
      type: "number",
      field: ctx[3].fields.maxPages
    }
  });
  regexlist = new RegexList$1({ props: { list: ctx[4] } });
  rewritesteps = new RewriteSteps({
    props: {
      tree: ctx[5],
      url: ctx[2].url
    }
  });
  pagefunctions = new PageFunctions({
    props: {
      tree: ctx[6],
      url: ctx[2].url
    }
  });
  let if_block1 = loading;
  let if_block2 = ctx[12] && create_if_block$1y(ctx);
  const buttons_slot_template = ctx[14].buttons;
  const buttons_slot = create_slot(buttons_slot_template, ctx, ctx[13], get_buttons_slot_context$1);
  return {
    c() {
      div14 = element("div");
      div2 = element("div");
      label0 = element("label");
      label0.textContent = "Start URL:";
      br0 = element("br");
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      create_component(urledit.$$.fragment);
      t2 = space();
      p0 = element("p");
      p0.textContent = "The url to start crawling. Only the sub-paths of this url will be crawled.";
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      div5 = element("div");
      label1 = element("label");
      label1.textContent = "URL limit:";
      br1 = element("br");
      t7 = space();
      div4 = element("div");
      div3 = element("div");
      create_component(inputedit.$$.fragment);
      t8 = space();
      p1 = element("p");
      p1.textContent = "Maximum limit of urls to crawl";
      t10 = space();
      div7 = element("div");
      label2 = element("label");
      label2.textContent = "Excludes: ";
      br2 = element("br");
      t12 = space();
      div6 = element("div");
      create_component(regexlist.$$.fragment);
      t13 = space();
      p2 = element("p");
      p2.textContent = "Regular expressions list for filtering (filter to exclude images added by default)";
      t15 = space();
      div9 = element("div");
      label3 = element("label");
      label3.textContent = "Rewrite URL: ";
      br3 = element("br");
      t17 = space();
      div8 = element("div");
      create_component(rewritesteps.$$.fragment);
      t18 = space();
      div11 = element("div");
      label4 = element("label");
      label4.textContent = "Page Macros: ";
      br4 = element("br");
      t20 = space();
      div10 = element("div");
      create_component(pagefunctions.$$.fragment);
      t21 = space();
      t22 = space();
      if (if_block2)
        if_block2.c();
      t23 = space();
      div13 = element("div");
      label5 = element("label");
      br5 = element("br");
      t24 = space();
      div12 = element("div");
      if (buttons_slot)
        buttons_slot.c();
      attr(label0, "class", "xoption-label form-label");
      attr(label0, "for", "url");
      attr(div0, "class", "flex gap-2");
      attr(p0, "class", "help");
      attr(div1, "class", "flex-1");
      attr(div2, "class", "flex gap-x-6 mt-5");
      attr(label1, "class", "xoption-label form-label");
      attr(label1, "for", "url");
      attr(div3, "class", "flex gap-2");
      attr(p1, "class", "help");
      attr(div4, "class", "flex-1");
      attr(div5, "class", "flex gap-x-6 mt-5");
      attr(label2, "class", "xoption-label form-label");
      attr(label2, "for", "url");
      attr(p2, "class", "help");
      attr(div6, "class", "gap-1");
      set_style(div6, "width", "100%");
      attr(div7, "class", "flex gap-x-6 mt-5");
      attr(label3, "class", "xoption-label form-label");
      attr(label3, "for", "url");
      attr(div8, "class", "gap-1");
      set_style(div8, "width", "100%");
      attr(div9, "class", "flex gap-x-6 mt-5");
      attr(label4, "class", "xoption-label form-label");
      attr(label4, "for", "url");
      attr(div10, "class", "gap-1");
      set_style(div10, "width", "100%");
      attr(div11, "class", "flex gap-x-6 mt-5");
      attr(label5, "class", "xoption-label form-label");
      attr(label5, "for", "url");
      attr(div12, "class", "gap-1");
      set_style(div12, "width", "100%");
      attr(div13, "class", "flex gap-x-6 mt-5 mb-4");
    },
    m(target, anchor) {
      insert(target, div14, anchor);
      append(div14, div2);
      append(div2, label0);
      append(div2, br0);
      append(div2, t1);
      append(div2, div1);
      append(div1, div0);
      mount_component(urledit, div0, null);
      append(div1, t2);
      append(div1, p0);
      append(div14, t4);
      if (if_block0)
        if_block0.m(div14, null);
      append(div14, t5);
      append(div14, div5);
      append(div5, label1);
      append(div5, br1);
      append(div5, t7);
      append(div5, div4);
      append(div4, div3);
      mount_component(inputedit, div3, null);
      append(div4, t8);
      append(div4, p1);
      append(div14, t10);
      append(div14, div7);
      append(div7, label2);
      append(div7, br2);
      append(div7, t12);
      append(div7, div6);
      mount_component(regexlist, div6, null);
      append(div6, t13);
      append(div6, p2);
      append(div14, t15);
      append(div14, div9);
      append(div9, label3);
      append(div9, br3);
      append(div9, t17);
      append(div9, div8);
      mount_component(rewritesteps, div8, null);
      append(div14, t18);
      append(div14, div11);
      append(div11, label4);
      append(div11, br4);
      append(div11, t20);
      append(div11, div10);
      mount_component(pagefunctions, div10, null);
      append(div14, t21);
      append(div14, t22);
      if (if_block2)
        if_block2.m(div14, null);
      append(div14, t23);
      append(div14, div13);
      append(div13, label5);
      append(div13, br5);
      append(div13, t24);
      append(div13, div12);
      if (buttons_slot) {
        buttons_slot.m(div12, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const urledit_changes = {};
      if (dirty & 1)
        urledit_changes.field = ctx2[0].fields.url;
      urledit.$set(urledit_changes);
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$I(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div14, t5);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const rewritesteps_changes = {};
      if (dirty & 4)
        rewritesteps_changes.url = ctx2[2].url;
      rewritesteps.$set(rewritesteps_changes);
      const pagefunctions_changes = {};
      if (dirty & 4)
        pagefunctions_changes.url = ctx2[2].url;
      pagefunctions.$set(pagefunctions_changes);
      if (ctx2[12])
        if_block2.p(ctx2, dirty);
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(buttons_slot_template, ctx2[13], dirty, get_buttons_slot_changes$1),
            get_buttons_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(urledit.$$.fragment, local);
      transition_in(if_block0);
      transition_in(inputedit.$$.fragment, local);
      transition_in(regexlist.$$.fragment, local);
      transition_in(rewritesteps.$$.fragment, local);
      transition_in(pagefunctions.$$.fragment, local);
      transition_in(if_block1);
      transition_in(buttons_slot, local);
      current = true;
    },
    o(local) {
      transition_out(urledit.$$.fragment, local);
      transition_out(if_block0);
      transition_out(inputedit.$$.fragment, local);
      transition_out(regexlist.$$.fragment, local);
      transition_out(rewritesteps.$$.fragment, local);
      transition_out(pagefunctions.$$.fragment, local);
      transition_out(if_block1);
      transition_out(buttons_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div14);
      destroy_component(urledit);
      if (if_block0)
        if_block0.d();
      destroy_component(inputedit);
      destroy_component(regexlist);
      destroy_component(rewritesteps);
      destroy_component(pagefunctions);
      if (if_block2)
        if_block2.d();
      if (buttons_slot)
        buttons_slot.d(detaching);
    }
  };
}
let loading = false;
function instance$2E($$self, $$props, $$invalidate) {
  let $crawler, $$unsubscribe_crawler = noop$1, $$subscribe_crawler = () => ($$unsubscribe_crawler(), $$unsubscribe_crawler = subscribe(crawler, ($$value) => $$invalidate(2, $crawler = $$value)), crawler);
  $$self.$$.on_destroy.push(() => $$unsubscribe_crawler());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { crawler } = $$props;
  $$subscribe_crawler();
  let { showNameAndSchedule = true } = $$props;
  const { config } = crawler.fields;
  const { excludes, rewriteURLSteps, validationSteps } = config.fields;
  const editors = {
    INTERVAL: {
      name: "Interval",
      component: IntervalScheduleEditor,
      default: {
        type: "INTERVAL",
        params: { interval: 10800 }
      }
    },
    CRON: {
      name: "Crontab *",
      disabled: !App.user.isEnterprise(),
      component: CronScheduleEditor,
      default: {
        type: "CRON",
        params: {
          expr: "0 3 * * *",
          tz: new Date().getTimezoneOffset()
        }
      }
    },
    enterprise: { name: "* For Enterprise", disabled: true }
  };
  const minInt = 3600 * 24;
  const MIN = 3600 * 24;
  const MAX = 3600 * 24 * 50;
  const schedules = [
    { value: MIN, label: "1d" },
    { value: 3600 * 24 * 2, label: "2d" },
    { value: 3600 * 24 * 3, label: "3d" },
    { value: 3600 * 24 * 5, label: "5d" },
    { value: 3600 * 24 * 10, label: "10d" },
    { value: 3600 * 24 * 15, label: "15d" },
    { value: MAX, label: "Never" }
  ];
  let errorMsg;
  $$self.$$set = ($$props2) => {
    if ("crawler" in $$props2)
      $$subscribe_crawler($$invalidate(0, crawler = $$props2.crawler));
    if ("showNameAndSchedule" in $$props2)
      $$invalidate(1, showNameAndSchedule = $$props2.showNameAndSchedule);
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  return [
    crawler,
    showNameAndSchedule,
    $crawler,
    config,
    excludes,
    rewriteURLSteps,
    validationSteps,
    editors,
    minInt,
    MIN,
    MAX,
    schedules,
    errorMsg,
    $$scope,
    slots
  ];
}
class CrawlEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2E, create_fragment$2H, safe_not_equal, { crawler: 0, showNameAndSchedule: 1 });
  }
}
const JOB_ERR_TYPES = {
  "onDemand": "A new job is running",
  "retry": "A job is being retried",
  "scheduled": "A scheduled job is running",
  "unknown": "Please check the console for more info"
};
function checkLimitConstraint(limit) {
  limit = parseInt(limit);
  let crawlPageConstraint = App.user.get("constraint").crawl_pages;
  if (crawlPageConstraint < limit) {
    return `URL limit cannot exceed ${crawlPageConstraint}`;
  }
  if (limit <= 0) {
    return `URL limit should be greater than 0`;
  }
  return;
}
function getJobErrFromErr(err) {
  return JOB_ERR_TYPES[err.type] || JOB_ERR_TYPES["unknown"];
}
function escapeRegex(input) {
  const specialChars = ["\\", "^", "$", ".", "|", "?", "*", "+", "(", ")", "[", "]", "{", "}", "/"];
  const regex = new RegExp(`([${specialChars.join("\\")})])`, "gm");
  return `^${input.replace(regex, "\\$1")}$`;
}
class StepListType extends TYPES.base {
  static toJSON(obj) {
    return obj.toJSON();
  }
  static parse(values2) {
    return parseSteps$1(values2);
  }
}
__publicField(StepListType, "default", []);
class RewriteStepListType extends StepListType {
  static toJSON(obj) {
    return obj.toJSON();
  }
  static parse(values2) {
    return parseSteps$1(values2, "rewriteURL");
  }
}
__publicField(RewriteStepListType, "default", []);
register("rewriteStepListType", RewriteStepListType);
register("validateStepListType", StepListType);
class RegexList extends FieldList {
  constructor(values2) {
    super({ type: "regex" }, values2);
  }
  getDefaultValue() {
    return { expr: "", flags: "gim" };
  }
}
const _ConfigFormModel = class extends FormModel {
  constructor(json) {
    super(_ConfigFormModel.fields, json);
  }
};
let ConfigFormModel = _ConfigFormModel;
__publicField(ConfigFormModel, "fields", {
  maxPages: {
    type: "int",
    required: true,
    validators: [
      checkLimitConstraint
    ]
  },
  excludes: {
    type: "list:regex"
  },
  rewriteURLSteps: {
    type: "rewriteStepListType"
  },
  validationSteps: {
    type: "validateStepListType"
  }
});
class ConfigType extends TYPES.json {
  static toJSON(config) {
    return config.toJSON();
  }
  static parse(json) {
    return new ConfigFormModel(json);
  }
}
class RegexListType extends TYPES.base {
  static toJSON(config) {
    return config.toJSON();
  }
  static parse(json) {
    return new RegexList(json);
  }
}
__publicField(RegexListType, "default");
register("crawlerConfig", ConfigType);
register("list:regex", RegexListType);
const _Crawler$1 = class extends FormModel {
  constructor(model) {
    super(_Crawler$1.fields, model.toJSON());
    this.model = model;
  }
  getURLRoot() {
    return "/crawlers";
  }
};
let Crawler$1 = _Crawler$1;
__publicField(Crawler$1, "fields", {
  name: {
    type: "string",
    required: true
  },
  schedule: {
    type: "json",
    required: true
  },
  url: {
    type: "url",
    required: true
  },
  config: {
    type: "crawlerConfig",
    required: true
  }
});
const get_buttons_slot_changes = (dirty) => ({});
const get_buttons_slot_context = (ctx) => ({ slot: "buttons" });
function create_catch_block$u(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$u(ctx) {
  let crawleditor;
  let current;
  crawleditor = new CrawlEditor({
    props: {
      crawler: ctx[0],
      showNameAndSchedule: false,
      rewriteURLSteps: ctx[0].fields.config.fields.rewriteURLSteps,
      validationSteps: ctx[0].fields.config.fields.validationSteps,
      $$slots: { buttons: [create_buttons_slot$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(crawleditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(crawleditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const crawleditor_changes = {};
      if (dirty & 1)
        crawleditor_changes.crawler = ctx2[0];
      if (dirty & 1)
        crawleditor_changes.rewriteURLSteps = ctx2[0].fields.config.fields.rewriteURLSteps;
      if (dirty & 1)
        crawleditor_changes.validationSteps = ctx2[0].fields.config.fields.validationSteps;
      if (dirty & 1028) {
        crawleditor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      crawleditor.$set(crawleditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(crawleditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(crawleditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(crawleditor, detaching);
    }
  };
}
function fallback_block$4(ctx) {
  let div1;
  let div0;
  let button0;
  let t0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      t0 = text("Done");
      t1 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      button0.disabled = ctx[2];
      attr(button0, "class", "btn btn-primary xbtn-default");
      attr(button1, "class", "btn btn-default");
      attr(div0, "class", "flex-1 mt-4 pt-2");
      attr(div1, "class", "flex mb-[30px]");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      append(button0, t0);
      append(div0, t1);
      append(div0, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[6]),
          listen(button1, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        button0.disabled = ctx2[2];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_buttons_slot$6(ctx) {
  let current;
  const buttons_slot_template = ctx[8].buttons;
  const buttons_slot = create_slot(buttons_slot_template, ctx, ctx[10], get_buttons_slot_context);
  const buttons_slot_or_fallback = buttons_slot || fallback_block$4(ctx);
  return {
    c() {
      if (buttons_slot_or_fallback)
        buttons_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (buttons_slot_or_fallback) {
        buttons_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (buttons_slot) {
        if (buttons_slot.p && (!current || dirty & 1024)) {
          update_slot_base(
            buttons_slot,
            buttons_slot_template,
            ctx2,
            ctx2[10],
            !current ? get_all_dirty_from_scope(ctx2[10]) : get_slot_changes(buttons_slot_template, ctx2[10], dirty, get_buttons_slot_changes),
            get_buttons_slot_context
          );
        }
      } else {
        if (buttons_slot_or_fallback && buttons_slot_or_fallback.p && (!current || dirty & 4)) {
          buttons_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(buttons_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(buttons_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (buttons_slot_or_fallback)
        buttons_slot_or_fallback.d(detaching);
    }
  };
}
function create_pending_block$u(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$2G(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$u,
    then: create_then_block$u,
    catch: create_catch_block$u,
    value: 12,
    blocks: [, , ,]
  };
  handle_promise(ctx[5], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$2D($$self, $$props, $$invalidate) {
  let $model;
  let $error, $$unsubscribe_error = noop$1, $$subscribe_error = () => ($$unsubscribe_error(), $$unsubscribe_error = subscribe(error2, ($$value) => $$invalidate(2, $error = $$value)), error2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_error());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { formModel } = $$props;
  let { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(11, $model = value));
  let crawlerForm;
  let error2;
  const dispatch = createEventDispatcher();
  const crawlerLoadPromise = model.loadCrawler();
  crawlerLoadPromise.then(() => {
    $$invalidate(0, crawlerForm = new Crawler$1($model.crawler));
    $$subscribe_error($$invalidate(1, error2 = crawlerForm.error));
  });
  async function updateSieveWithCrawler() {
    try {
      let crawler = crawlerForm.toJSON();
      model.set("crawler", crawlerForm);
      model.set("uri", crawler.url);
      model.set("name", `Sitemap | ${getNameFromURL(crawler.url)}`);
      dispatch("save");
    } catch (err) {
      console.error("Error saving", err);
    }
  }
  const click_handler = (e) => dispatch("discard");
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(7, formModel = $$props2.formModel);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  return [
    crawlerForm,
    error2,
    $error,
    model,
    dispatch,
    crawlerLoadPromise,
    updateSieveWithCrawler,
    formModel,
    slots,
    click_handler,
    $$scope
  ];
}
class Sitemap extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2D, create_fragment$2G, safe_not_equal, { formModel: 7 });
  }
}
function create_default_slot_2$d(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Before");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$k(ctx) {
  let t;
  return {
    c() {
      t = text("Insert After");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$14(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_parent_context_menu_slot$1(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuitem2;
  let current;
  menuitem0 = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot_2$d] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", function() {
    if (is_function(ctx[2]))
      ctx[2].apply(this, arguments);
  });
  menuitem1 = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot_1$k] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", function() {
    if (is_function(ctx[1]))
      ctx[1].apply(this, arguments);
  });
  menuitem2 = new MenuItem$1({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$14] },
      $$scope: { ctx }
    }
  });
  menuitem2.$on("click", ctx[6]);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuitem2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitem2, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem0_changes = {};
      if (dirty & 128) {
        menuitem0_changes.$$scope = { dirty, ctx };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 128) {
        menuitem1_changes.$$scope = { dirty, ctx };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & 128) {
        menuitem2_changes.$$scope = { dirty, ctx };
      }
      menuitem2.$set(menuitem2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitem2, detaching);
    }
  };
}
function create_fragment$2F(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = getComponent(ctx[4]);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[4],
        level: 0,
        $$slots: {
          "parent-context-menu": [create_parent_context_menu_slot$1]
        },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const switch_instance_changes = {};
      if (dirty & 16)
        switch_instance_changes.node = ctx2[4];
      if (dirty & 143) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & 16 && switch_value !== (switch_value = getComponent(ctx2[4]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function instance$2C($$self, $$props, $$invalidate) {
  let expression;
  let $mapper, $$unsubscribe_mapper = noop$1, $$subscribe_mapper = () => ($$unsubscribe_mapper(), $$unsubscribe_mapper = subscribe(mapper, ($$value) => $$invalidate(5, $mapper = $$value)), mapper);
  $$self.$$.on_destroy.push(() => $$unsubscribe_mapper());
  let { deleteMapper } = $$props;
  let { insertAfter } = $$props;
  let { insertBefore } = $$props;
  let { mapper } = $$props;
  $$subscribe_mapper();
  const click_handler = () => deleteMapper(mapper);
  $$self.$$set = ($$props2) => {
    if ("deleteMapper" in $$props2)
      $$invalidate(0, deleteMapper = $$props2.deleteMapper);
    if ("insertAfter" in $$props2)
      $$invalidate(1, insertAfter = $$props2.insertAfter);
    if ("insertBefore" in $$props2)
      $$invalidate(2, insertBefore = $$props2.insertBefore);
    if ("mapper" in $$props2)
      $$subscribe_mapper($$invalidate(3, mapper = $$props2.mapper));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $$invalidate(4, expression = $mapper.root.expression.children[1]);
    }
  };
  return [
    deleteMapper,
    insertAfter,
    insertBefore,
    mapper,
    expression,
    $mapper,
    click_handler
  ];
}
class Mapper extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2C, create_fragment$2F, safe_not_equal, {
      deleteMapper: 0,
      insertAfter: 1,
      insertBefore: 2,
      mapper: 3
    });
  }
}
function get_each_context$K(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  child_ctx[14] = i2;
  return child_ctx;
}
function create_else_block$V(ctx) {
  let t;
  return {
    c() {
      t = text("<none>");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$K(key_1, ctx) {
  let first2;
  let mapper;
  let current;
  function func2() {
    return ctx[4](ctx[14]);
  }
  function func_12() {
    return ctx[5](ctx[14]);
  }
  function delete_handler() {
    return ctx[6](ctx[12]);
  }
  mapper = new Mapper({
    props: {
      mapper: ctx[12],
      deleteMapper: ctx[3],
      insertBefore: func2,
      insertAfter: func_12
    }
  });
  mapper.$on("delete", delete_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(mapper.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(mapper, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const mapper_changes = {};
      if (dirty & 2)
        mapper_changes.mapper = ctx[12];
      if (dirty & 2)
        mapper_changes.insertBefore = func2;
      if (dirty & 2)
        mapper_changes.insertAfter = func_12;
      mapper.$set(mapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(mapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(mapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(mapper, detaching);
    }
  };
}
function create_fragment$2E(ctx) {
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let div0;
  let button;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[1].models;
  const get_key = (ctx2) => ctx2[12];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$K(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$K(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$V();
  }
  return {
    c() {
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t0 = space();
      div0 = element("div");
      button = element("button");
      button.textContent = "+Mapper";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-secondary btn-sm");
      attr(div0, "class", "bbx-flex-rev");
      attr(div1, "class", "d-flex flex-column gap-2");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(div1, null);
      }
      append(div1, t0);
      append(div1, div0);
      append(div0, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 14) {
        each_value = ctx2[1].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$K, t0, get_each_context$K);
        check_outros();
        if (each_value.length) {
          if (each_1_else) {
            each_1_else.d(1);
            each_1_else = null;
          }
        } else if (!each_1_else) {
          each_1_else = create_else_block$V();
          each_1_else.c();
          each_1_else.m(div1, t0);
        }
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$2B($$self, $$props, $$invalidate) {
  let $mappers, $$unsubscribe_mappers = noop$1, $$subscribe_mappers = () => ($$unsubscribe_mappers(), $$unsubscribe_mappers = subscribe(mappers, ($$value) => $$invalidate(1, $mappers = $$value)), mappers);
  $$self.$$.on_destroy.push(() => $$unsubscribe_mappers());
  getContext("extractErrorStore");
  let { mappers } = $$props;
  $$subscribe_mappers();
  const allowedMapperNames = Object.keys(procFuncDefs).filter((name) => {
    let def = procFuncDefs[name];
    let argDefs = Object.values(def.args);
    if (argDefs.length === 0)
      return false;
    let argDef = argDefs[0];
    if (!argDef.types.includes("string") && !argDef.types.includes("array<string>"))
      return false;
    return def.returnType === "string" || def.returnType === "array<string>";
  });
  const defaultExprs = {
    "lower": ["lower", "$str"],
    "upper": ["upper", "$str"],
    "trim": ["trim", "$str"],
    "substring": ["substring", "$str", 0, 2],
    "index": ["index", ["array", "string", []], 0],
    "re_match": ["re_match", "$str", "", "gim"],
    "re_replace": ["re_replace", "$str", "", "", 0, -1, "gim"]
  };
  function addMapper(index2) {
    let stepName = allowedMapperNames[0];
    mappers.create(defaultExprs[stepName], { at: index2 });
  }
  function deleteMapper(mapper) {
    mappers.remove(mapper);
  }
  const ctx = {
    replace: {
      labels: ["utils"],
      skipControl: true,
      stepNames: allowedMapperNames,
      defaultExprs
    }
  };
  setContext("expressionCtx", ctx);
  const func2 = (i2) => addMapper(i2);
  const func_12 = (i2) => addMapper(i2 + 1);
  const delete_handler = (mapper) => deleteMapper(mapper);
  const click_handler = () => addMapper(mappers.length);
  $$self.$$set = ($$props2) => {
    if ("mappers" in $$props2)
      $$subscribe_mappers($$invalidate(0, mappers = $$props2.mappers));
  };
  return [
    mappers,
    $mappers,
    addMapper,
    deleteMapper,
    func2,
    func_12,
    delete_handler,
    click_handler
  ];
}
class Mappers extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2B, create_fragment$2E, safe_not_equal, { mappers: 0 });
  }
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
const registry = new Registry({
  funcs: { ...procFuncDefs, ...stepDefs },
  structs: { ...procStructDefs, ...structDefs },
  enums: enumDefs
});
class Model$1 extends Store {
  constructor(attribs = {}) {
    super();
    this.attributes = { ...attribs };
  }
  clear() {
    this.attributes = {};
    this.emit("change");
  }
  getStoreValue() {
    return this.attributes;
  }
  get(key) {
    return this.attributes[key];
  }
  isNew() {
    return this.attributes.id === void 0;
  }
  set(attribs) {
    this.attributes = { ...this.attributes, ...attribs };
    this.emit("change");
  }
  toJSON() {
    var _a;
    let attribs = {};
    for (let key in this.attributes) {
      if (typeof ((_a = this.attributes[key]) == null ? void 0 : _a.toJSON) === "function") {
        attribs[key] = this.attributes[key].toJSON();
      } else {
        attribs[key] = this.attributes[key];
      }
    }
    return attribs;
  }
}
class Collection extends Store {
  constructor(model, models = []) {
    super();
    this.models = [];
    this.model = model;
    this.add(models);
  }
  add(items, opts) {
    var _a;
    if (!Array.isArray(items))
      items = [items];
    let index2 = (_a = opts == null ? void 0 : opts.at) != null ? _a : this.length;
    if (index2 < 0 || index2 > this.length) {
      throw new Error("Index out of bounds: " + index2);
    }
    for (let item of items) {
      if (!(item instanceof this.model))
        continue;
      if (this.has(item))
        continue;
      this.models.splice(index2, 0, item);
      index2 += 1;
      item.on("change", () => {
        this.emit("change");
      });
    }
    this.emit("change");
  }
  at(index2) {
    index2 = index2 < 0 ? this.models.length + index2 : index2;
    return this.models[index2];
  }
  create(attributes, opts) {
    let model = new this.model(attributes, opts);
    this.add(model, opts);
    return model;
  }
  each(callback) {
    this.models.forEach(callback);
  }
  filter(callback) {
    return this.models.filter(callback);
  }
  getStoreValue() {
    return this;
  }
  has(item) {
    return this.models.includes(item) || this.models.some((model) => model.id && item.id && model.id === item.id);
  }
  get length() {
    return this.models.length;
  }
  replaceAll(items) {
    if (!Array.isArray(items))
      items = [items];
    this.models = items;
    this.emit("change");
    return this.models;
  }
  remove(item) {
    if (!Array.isArray(item))
      item = [item];
    item.forEach((item2) => {
      let index2 = this.models.indexOf(item2);
      if (index2 > -1)
        this.models.splice(this.models.indexOf(item2), 1);
    });
    this.emit("change");
  }
  reset() {
    this.models = [];
    this.emit("change");
  }
  toJSON() {
    return this.models.map((model) => model.toJSON());
  }
}
class SchemaCollection extends Collection {
  constructor(schemas) {
    super(Schema$1, schemas);
  }
  generateID() {
    return v4();
  }
  create(attributes, opts) {
    if (!attributes.id)
      attributes.id = this.generateID();
    return super.create(attributes, opts);
  }
  replaceAll(schemas) {
    const newSchemas = schemas.map((schema) => new Schema$1(schema));
    return super.replaceAll(newSchemas);
  }
}
class DataTypeParams extends Model$1 {
  constructor(params2) {
    super(params2 != null ? params2 : {});
    if (this.attributes.expr && !(this.attributes.expr instanceof ExpressionWrapper)) {
      this.attributes.expr = new ExpressionWrapper(this.attributes.expr);
      this.attributes.expr.on("change", () => {
        this.emit("change");
      });
    }
  }
}
class ExpressionWrapper extends Model$1 {
  constructor(source) {
    super({
      root: new Root(registry, [
        declareVariable(source),
        source
      ])
    });
    this.emitChange = (node) => {
      if (node === this.expression.parent)
        ;
      this.emit("change");
    };
    this.root.on("change", this.emitChange);
  }
  get expression() {
    return this.root.expression.children[1];
  }
  get name() {
    return this.expression.name;
  }
  get root() {
    return this.get("root");
  }
  toJSON() {
    return this.root.expression.children[1].toJSON();
  }
}
function declareVariable(source, parent2 = null, varIndex = -1) {
  if (Array.isArray(source)) {
    const idx = -1;
    for (const item of source) {
      const result2 = declareVariable(item, source, idx + 1);
      if (result2) {
        return result2;
      }
    }
  } else if (typeof source === "string" && source.startsWith("$")) {
    const funDefVar = getFunDefVariable(source, parent2, varIndex);
    if (funDefVar) {
      return funDefVar;
    }
    throw new Error(`Definition not found for key: ${parent2[0]}`);
  }
  return null;
}
function getFunDefVariable(source, parent2 = null, varIndex = -1) {
  if (typeof source === "string") {
    if (!parent2 || parent2.length === 0) {
      throw new Error("Expression is empty or not provided.");
    }
    const parentKey = parent2[0];
    const procDef = procFuncDefs[parentKey];
    if (procDef) {
      const dataType = Object.values(procDef.args)[varIndex].types[0];
      const varName = source.substring(1);
      return ["var", varName, dataType];
    }
  }
  return null;
}
class ExtractorField extends Model$1 {
  constructor(field = { type: "text" }) {
    var _a;
    super({
      type: field.type,
      params: new ExtractorParams(field["params"])
    });
    (_a = this.attributes["params"]) == null ? void 0 : _a.on("change", () => {
      this.emit("change");
    });
  }
  set(attribs) {
    var _a, _b;
    if (attribs["params"]) {
      (_a = this.attributes["params"]) == null ? void 0 : _a.off("change");
    }
    super.set(attribs);
    (_b = attribs["params"]) == null ? void 0 : _b.on("change", () => {
      this.emit("change");
    });
  }
}
class ExtractorParams extends Model$1 {
  constructor(params2 = {}) {
    super(params2);
  }
}
class Proc extends Model$1 {
  constructor(proc, dataType) {
    var _a, _b;
    super({
      mappers: new Collection(ExpressionWrapper, ((_a = proc.mappers) != null ? _a : []).map((mapper) => new ExpressionWrapper(mapper))),
      reducer: proc.reducer ? new ExpressionWrapper(proc.reducer) : void 0,
      parser: proc.parser ? new DataTypeParams(proc.parser) : void 0,
      validator: new Validator$1((_b = proc.validator) != null ? _b : { required: true, exprs: [] })
    });
  }
}
class Selector$2 extends Model$1 {
  constructor(selector) {
    super(selector);
  }
  toJSON() {
    return super.toJSON();
  }
}
class SelectorGroup extends Model$1 {
  constructor(selectors) {
    super({
      includes: new Collection(Selector$2, selectors.includes.map((selector) => new Selector$2(selector))),
      excludes: new Collection(Selector$2, selectors.excludes.map((selector) => new Selector$2(selector))),
      field: new ExtractorField(selectors.field)
    });
  }
}
class Tag$1 extends Model$1 {
  constructor(tag) {
    super({
      ...tag,
      selectors: new SelectorGroup(tag.selectors),
      procs: new Proc(tag.procs, tag.data_type)
    });
    if (!isValidName(this.attributes.name)) {
      throw new Error(`Invalid tag name: ${this.attributes.name}`);
    }
  }
}
class Schema$1 extends Model$1 {
  constructor(schema, opts) {
    var _a;
    super(schema);
    if (!isValidName(this.attributes.name)) {
      throw new Error(`Invalid schema name: ${this.attributes.name}`);
    }
    this.attributes.tags = new Collection(Tag$1, schema.tags.map((tag) => new Tag$1(tag)));
    this._isNew = (_a = opts == null ? void 0 : opts.isNew) != null ? _a : false;
  }
  isNew() {
    return this._isNew;
  }
}
class Validator$1 extends Model$1 {
  constructor(validator = { required: true, exprs: [] }) {
    super({
      required: validator.required || false,
      exprs: getNewValidatorExprs(validator.exprs)
    });
    this.attributes["exprs"].on("change", () => {
      this.emit("change");
    });
  }
  toJSON() {
    var _a, _b;
    const json = super.toJSON();
    if ((_a = json.exprs) == null ? void 0 : _a.models) {
      json.exprs = (_b = json.exprs) == null ? void 0 : _b.models.toJSON();
    }
    return json;
  }
}
function getNewValidatorExprs(exprs = []) {
  return new Collection(ExpressionWrapper, exprs.map((expr) => new ExpressionWrapper(expr)));
}
function getModel(schemas) {
  return new SchemaCollection(schemas.map((schema) => new Schema$1(schema)));
}
function create_if_block$1x(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = getComponent(ctx[3]);
  function switch_props(ctx2) {
    return {
      props: { node: ctx2[3], level: 0 }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 8)
        switch_instance_changes.node = ctx2[3];
      if (dirty & 8 && switch_value !== (switch_value = getComponent(ctx2[3]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$2D(ctx) {
  let div;
  let label;
  let t1;
  let input;
  let input_checked_value;
  let t2;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[2].reducer && create_if_block$1x(ctx);
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Use Reducer";
      t1 = space();
      input = element("input");
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(label, "class", "form-check-label");
      attr(label, "for", "switchUseReducer");
      attr(input, "type", "checkbox");
      attr(input, "class", "form-check-input");
      attr(input, "id", "switchUseReducer");
      input.checked = input_checked_value = !ctx[0].startsWith("array<");
      attr(div, "class", "form-check form-switch");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, input);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(input, "input", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1 && input_checked_value !== (input_checked_value = !ctx2[0].startsWith("array<"))) {
        input.checked = input_checked_value;
      }
      if (ctx2[2].reducer) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1x(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$2A($$self, $$props, $$invalidate) {
  let reducer;
  let expression;
  let $reducer, $$unsubscribe_reducer = noop$1, $$subscribe_reducer = () => ($$unsubscribe_reducer(), $$unsubscribe_reducer = subscribe(reducer, ($$value) => $$invalidate(6, $reducer = $$value)), reducer);
  let $procs, $$unsubscribe_procs = noop$1, $$subscribe_procs = () => ($$unsubscribe_procs(), $$unsubscribe_procs = subscribe(procs, ($$value) => $$invalidate(2, $procs = $$value)), procs);
  $$self.$$.on_destroy.push(() => $$unsubscribe_reducer());
  $$self.$$.on_destroy.push(() => $$unsubscribe_procs());
  let { procs } = $$props;
  $$subscribe_procs();
  let { data_type } = $$props;
  const defaultExprs = {
    "join": ["join", "$val", "\\n"],
    "index": ["index", "$val", 0]
  };
  const allowedReducerNames = Object.keys(procFuncDefs).filter((name) => {
    let def = procFuncDefs[name];
    let argDefs = Object.values(def.args);
    if (argDefs.length === 0)
      return false;
    let argDef = argDefs[0];
    if (!argDef.types.includes("array<string>"))
      return false;
    return def.returnType === "string";
  });
  const ctx = {
    replace: {
      labels: ["utils"],
      skipControl: true,
      stepNames: allowedReducerNames,
      defaultExprs
    }
  };
  setContext("expressionCtx", ctx);
  function toggleReduceToArray() {
    if (data_type.startsWith("array<")) {
      $$invalidate(0, data_type = data_type.replace("array<", "").replace(">", ""));
      let stepName = allowedReducerNames[0];
      set_store_value(procs, $procs.reducer = new ExpressionWrapper(defaultExprs[stepName]), $procs);
    } else {
      $$invalidate(0, data_type = `array<${data_type}>`);
      set_store_value(procs, $procs.reducer = void 0, $procs);
    }
  }
  const input_handler = () => toggleReduceToArray();
  $$self.$$set = ($$props2) => {
    if ("procs" in $$props2)
      $$subscribe_procs($$invalidate(1, procs = $$props2.procs));
    if ("data_type" in $$props2)
      $$invalidate(0, data_type = $$props2.data_type);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $$subscribe_reducer($$invalidate(4, reducer = $procs.reducer));
    }
    if ($$self.$$.dirty & 64) {
      $$invalidate(3, expression = $reducer == null ? void 0 : $reducer.root.expression.children[1]);
    }
  };
  return [
    data_type,
    procs,
    $procs,
    expression,
    reducer,
    toggleReduceToArray,
    $reducer,
    input_handler
  ];
}
class Reducer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2A, create_fragment$2D, safe_not_equal, { procs: 1, data_type: 0 });
  }
}
function create_else_block$U(ctx) {
  let div;
  let input;
  let input_value_value;
  let t0;
  let iconbtn0;
  let t1;
  let iconbtn1;
  let current;
  let mounted;
  let dispose;
  iconbtn0 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot_2$c] },
      $$scope: { ctx }
    }
  });
  iconbtn0.$on("click", ctx[5]);
  iconbtn1 = new IconBtn({
    props: {
      $$slots: { default: [create_default_slot_1$j] },
      $$scope: { ctx }
    }
  });
  iconbtn1.$on("click", ctx[10]);
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      create_component(iconbtn0.$$.fragment);
      t1 = space();
      create_component(iconbtn1.$$.fragment);
      attr(input, "class", "bbx-flex-grow");
      input.value = input_value_value = ctx[3].value;
      attr(div, "class", "bbx-flex bbx-flex-grow bbx-gap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      append(div, t0);
      mount_component(iconbtn0, div, null);
      append(div, t1);
      mount_component(iconbtn1, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[8]),
          listen(input, "keydown", ctx[9]),
          action_destroyer(clickOutside$1.call(null, div)),
          listen(div, "outclick", ctx[15])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & 8 && input_value_value !== (input_value_value = ctx2[3].value) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
      const iconbtn0_changes = {};
      if (dirty & 262144) {
        iconbtn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn0.$set(iconbtn0_changes);
      const iconbtn1_changes = {};
      if (dirty & 262144) {
        iconbtn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      iconbtn1.$set(iconbtn1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbtn0.$$.fragment, local);
      transition_in(iconbtn1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbtn0.$$.fragment, local);
      transition_out(iconbtn1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(iconbtn0);
      destroy_component(iconbtn1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$13(ctx) {
  let div;
  let t_value = ctx[3].value + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "bbx-flex-grow bbx-inline-editable");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (!mounted) {
        dispose = [
          listen(div, "click", ctx[11]),
          listen(div, "keydown", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = ctx2[3].value + ""))
        set_data(t, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_2$c(ctx) {
  let cross;
  let current;
  cross = new Cross$1({ props: { strokeColor: "red" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_default_slot_1$j(ctx) {
  let tick_1;
  let current;
  tick_1 = new Tick({ props: { strokeColor: "blue" } });
  return {
    c() {
      create_component(tick_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tick_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(tick_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tick_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tick_1, detaching);
    }
  };
}
function create_if_block$1w(ctx) {
  let menubtn;
  let current;
  menubtn = new MenuBtn({
    props: {
      $$slots: { items: [create_items_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menubtn.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menubtn, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menubtn_changes = {};
      if (dirty & 262144) {
        menubtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menubtn.$set(menubtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menubtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menubtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menubtn, detaching);
    }
  };
}
function create_default_slot$13(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_items_slot$1(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot$13] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[6]);
  menuitem.$on("keydown", ctx[6]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 262144) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_fragment$2C(ctx) {
  let div;
  let select_1;
  let option0;
  let option1;
  let select_1_value_value;
  let t2;
  let current_block_type_index;
  let if_block0;
  let t3;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$13, create_else_block$U];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = !ctx[2] && create_if_block$1w(ctx);
  return {
    c() {
      div = element("div");
      select_1 = element("select");
      option0 = element("option");
      option0.textContent = "css";
      option1 = element("option");
      option1.textContent = "xpath";
      t2 = space();
      if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      option0.__value = "css";
      option0.value = option0.__value;
      option1.__value = "xpath";
      option1.value = option1.__value;
      attr(div, "class", "d-flex gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, select_1);
      append(select_1, option0);
      append(select_1, option1);
      select_option(select_1, ctx[3].type);
      append(div, t2);
      if_blocks[current_block_type_index].m(div, null);
      append(div, t3);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(select_1, "change", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 8 && select_1_value_value !== (select_1_value_value = ctx2[3].type)) {
        select_option(select_1, ctx2[3].type);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t3);
      }
      if (!ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1w(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$2z($$self, $$props, $$invalidate) {
  let $taggerOverlay;
  let $selector, $$unsubscribe_selector = noop$1, $$subscribe_selector = () => ($$unsubscribe_selector(), $$unsubscribe_selector = subscribe(selector, ($$value) => $$invalidate(3, $selector = $$value)), selector);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selector());
  let { selector } = $$props;
  $$subscribe_selector();
  let { selectorList } = $$props;
  let { frame } = $$props;
  let oldValue = $selector.value;
  let valueEditMode = false;
  const browserView = getContext("browserView");
  const taggerOverlay = getContext("taggerOverlay");
  component_subscribe($$self, taggerOverlay, (value) => $$invalidate(16, $taggerOverlay = value));
  function cancelValueEdit(e) {
    if (e.type !== "click" && (e.type !== "keydown" || e.key !== "Enter"))
      return;
    set_store_value(selector, $selector.value = oldValue, $selector);
    unsetValueEditMode();
  }
  function handleDelete(e) {
    if (e.type !== "click" && (e.type !== "keydown" || e.key !== "Enter"))
      return;
    selectorList.remove(selector);
  }
  async function handleTypeChange(e) {
    let newType = e.target.value;
    let pageView, frameView;
    if (browserView)
      pageView = browserView.getPage(-1);
    if (pageView) {
      let frameIndex = typeof frame === "number" ? frame : frame.index;
      frameView = pageView.getFrame(pageView.store.frames[frameIndex].id);
    }
    if (newType !== $selector.type) {
      let newValue;
      let els = [];
      if (frameView) {
        els = await select(selector.toJSON(), frameView == null ? void 0 : frameView.getDoc());
      }
      if (els.length === 0) {
        newValue = newType === "css" ? "#change-this-to-valid-css-selector" : "//change-this-to-valid-xpath-selector";
      } else {
        newValue = newType === "css" ? await getCSS$1(els) : await getXPATH$1(els);
      }
      set_store_value(selector, $selector = { type: newType, value: newValue }, $selector);
    }
  }
  function handleValueChange(e) {
    set_store_value(selector, $selector.value = e.target.value, $selector);
  }
  function onKeypressInValue(e) {
    if (e.key === "Enter") {
      unsetValueEditMode();
    } else if (e.key === "Escape") {
      set_store_value(selector, $selector.value = oldValue, $selector);
      unsetValueEditMode();
    }
  }
  function saveValueEdit(e) {
    if (e.type !== "click" && (e.type !== "keydown" || e.key !== "Enter"))
      return;
    unsetValueEditMode();
  }
  function setValueEditMode(e) {
    if (e.type !== "click" && (e.type !== "keydown" || e.key !== "Enter"))
      return;
    $$invalidate(1, oldValue = $selector.value);
    $$invalidate(2, valueEditMode = true);
    if ($taggerOverlay && $taggerOverlay.active) {
      $taggerOverlay.setMode("edit", selector);
    }
  }
  function unsetValueEditMode() {
    $$invalidate(2, valueEditMode = false);
    if ($taggerOverlay && $taggerOverlay.mode === "edit") {
      $taggerOverlay.setMode("tag");
    }
  }
  const outclick_handler = () => {
    set_store_value(selector, $selector.value = oldValue, $selector);
    unsetValueEditMode();
  };
  $$self.$$set = ($$props2) => {
    if ("selector" in $$props2)
      $$subscribe_selector($$invalidate(0, selector = $$props2.selector));
    if ("selectorList" in $$props2)
      $$invalidate(13, selectorList = $$props2.selectorList);
    if ("frame" in $$props2)
      $$invalidate(14, frame = $$props2.frame);
  };
  return [
    selector,
    oldValue,
    valueEditMode,
    $selector,
    taggerOverlay,
    cancelValueEdit,
    handleDelete,
    handleTypeChange,
    handleValueChange,
    onKeypressInValue,
    saveValueEdit,
    setValueEditMode,
    unsetValueEditMode,
    selectorList,
    frame,
    outclick_handler
  ];
}
class Selector$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2z, create_fragment$2C, safe_not_equal, { selector: 0, selectorList: 13, frame: 14 });
  }
}
function get_each_context$J(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function create_else_block$T(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "<none>";
      attr(div, "class", "");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$J(key_1, ctx) {
  let first2;
  let selector;
  let current;
  selector = new Selector$1({
    props: {
      selector: ctx[5],
      selectorList: ctx[0],
      frame: ctx[1]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(selector.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(selector, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const selector_changes = {};
      if (dirty & 4)
        selector_changes.selector = ctx[5];
      if (dirty & 1)
        selector_changes.selectorList = ctx[0];
      if (dirty & 2)
        selector_changes.frame = ctx[1];
      selector.$set(selector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(selector, detaching);
    }
  };
}
function create_fragment$2B(ctx) {
  let div1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let div0;
  let button;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[2].models;
  const get_key = (ctx2) => ctx2[5];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$J(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$J(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$T();
  }
  return {
    c() {
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t0 = space();
      div0 = element("div");
      button = element("button");
      button.textContent = "+Selector";
      attr(button, "class", "btn btn-secondary btn-sm");
      attr(div0, "class", "bbx-flex-rev");
      attr(div1, "class", "d-flex flex-column gap-2");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(div1, null);
      }
      append(div1, t0);
      append(div1, div0);
      append(div0, button);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", ctx[3]),
          listen(button, "keydown", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = ctx2[2].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$J, t0, get_each_context$J);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$T();
          each_1_else.c();
          each_1_else.m(div1, t0);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function addSelector(e, list) {
  if (e.type !== "click" && (e.type !== "keydown" || e.key !== "Enter"))
    return;
  list.create({
    value: "#enter-your-selector-here",
    type: "css"
  });
}
function instance$2y($$self, $$props, $$invalidate) {
  let $selectorList, $$unsubscribe_selectorList = noop$1, $$subscribe_selectorList = () => ($$unsubscribe_selectorList(), $$unsubscribe_selectorList = subscribe(selectorList, ($$value) => $$invalidate(2, $selectorList = $$value)), selectorList);
  $$self.$$.on_destroy.push(() => $$unsubscribe_selectorList());
  let { selectorList } = $$props;
  $$subscribe_selectorList();
  let { frame } = $$props;
  const click_handler = (e) => addSelector(e, selectorList);
  const keydown_handler = (e) => addSelector(e, selectorList);
  $$self.$$set = ($$props2) => {
    if ("selectorList" in $$props2)
      $$subscribe_selectorList($$invalidate(0, selectorList = $$props2.selectorList));
    if ("frame" in $$props2)
      $$invalidate(1, frame = $$props2.frame);
  };
  return [selectorList, frame, $selectorList, click_handler, keydown_handler];
}
class Selectors extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2y, create_fragment$2B, safe_not_equal, { selectorList: 0, frame: 1 });
  }
}
function get_each_context$I(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2][0];
  child_ctx[15] = list[i2][1];
  return child_ctx;
}
function get_each_context_1$8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function create_each_block_1$8(ctx) {
  let option;
  let t_value = ctx[18] + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[18];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_if_block_1$12(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = Object.entries(ctx[3]);
  const get_key = (ctx2) => ctx2[14];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$I(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$I(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 72) {
        each_value = Object.entries(ctx2[3]);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$I, each_1_anchor, get_each_context$I);
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$I(key_1, ctx) {
  let div2;
  let div0;
  let t0_value = ctx[14] + "";
  let t0;
  let t1;
  let div1;
  let input;
  let input_value_value;
  let t2;
  let mounted;
  let dispose;
  function input_handler(...args) {
    return ctx[8](ctx[14], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      input = element("input");
      t2 = space();
      attr(div0, "class", "col");
      attr(div0, "style", ";width: 50%");
      input.value = input_value_value = ctx[15];
      set_style(input, "width", "100%");
      attr(div1, "class", "col");
      attr(div2, "class", "row px-0");
      this.first = div2;
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, input);
      append(div2, t2);
      if (!mounted) {
        dispose = listen(input, "input", input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 8 && t0_value !== (t0_value = ctx[14] + ""))
        set_data(t0, t0_value);
      if (dirty & 8 && input_value_value !== (input_value_value = ctx[15]) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1v(ctx) {
  let div1;
  let div0;
  let switch_instance;
  let current;
  var switch_value = getComponent(ctx[3].expr.expression);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[3].expr.expression,
        level: 0
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div0, "class", "col");
      attr(div1, "class", "row px-0");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 8)
        switch_instance_changes.node = ctx2[3].expr.expression;
      if (dirty & 8 && switch_value !== (switch_value = getComponent(ctx2[3].expr.expression))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_fragment$2A(ctx) {
  let div3;
  let div2;
  let div0;
  let t1;
  let div1;
  let select2;
  let select_value_value;
  let t2;
  let show_if_1 = ["number", "currency", "date"].includes(getPrimitive(ctx[0]));
  let t3;
  let show_if = getPrimitive(ctx[0]) === "boolean";
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ctx[4];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i2));
  }
  let if_block0 = show_if_1 && create_if_block_1$12(ctx);
  let if_block1 = show_if && create_if_block$1v(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "Type";
      t1 = space();
      div1 = element("div");
      select2 = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "col");
      set_style(select2, "width", "100%");
      attr(div1, "class", "col");
      attr(div2, "class", "row px-0");
      attr(div3, "class", "container d-flex flex-column gap-2");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, select2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      select_option(select2, getPrimitive(ctx[0]));
      append(div3, t2);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t3);
      if (if_block1)
        if_block1.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = listen(select2, "change", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 16) {
        each_value_1 = ctx2[4];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$8(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$8(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (!current || dirty & 17 && select_value_value !== (select_value_value = getPrimitive(ctx2[0]))) {
        select_option(select2, getPrimitive(ctx2[0]));
      }
      if (dirty & 1)
        show_if_1 = ["number", "currency", "date"].includes(getPrimitive(ctx2[0]));
      if (show_if_1) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$12(ctx2);
          if_block0.c();
          if_block0.m(div3, t3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 1)
        show_if = getPrimitive(ctx2[0]) === "boolean";
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1v(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_each(each_blocks, detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function getPrimitive(data_type) {
  if (data_type.startsWith("array<")) {
    return data_type.replace("array<", "").replace(">", "");
  } else {
    return data_type;
  }
}
function instance$2x($$self, $$props, $$invalidate) {
  let parser;
  let $procs, $$unsubscribe_procs = noop$1, $$subscribe_procs = () => ($$unsubscribe_procs(), $$unsubscribe_procs = subscribe(procs, ($$value) => $$invalidate(7, $procs = $$value)), procs);
  let $parser, $$unsubscribe_parser = noop$1, $$subscribe_parser = () => ($$unsubscribe_parser(), $$unsubscribe_parser = subscribe(parser, ($$value) => $$invalidate(3, $parser = $$value)), parser);
  $$self.$$.on_destroy.push(() => $$unsubscribe_procs());
  $$self.$$.on_destroy.push(() => $$unsubscribe_parser());
  let { data_type } = $$props;
  let { procs } = $$props;
  $$subscribe_procs();
  const allowedDataTypes = ["string", "number", "boolean", "currency", "date", "url", "json"];
  const allowedParserNames = Object.keys(procFuncDefs).filter((name) => {
    const def = procFuncDefs[name];
    let argDefs = Object.values(def.args);
    if (argDefs.length === 0)
      return false;
    let argDef = argDefs[0];
    if (!argDef.types.includes("string"))
      return false;
    return def.returnType === "boolean";
  });
  const defaultExprs = {
    "contains": ["contains", "$str", ""],
    "not_contains": ["not_contains", "$str", ""],
    "starts_with": ["starts_with", "$str", ""],
    "not_starts_with": ["not_starts_with", "$str", ""],
    "ends-with": ["ends_with", "$str", ""],
    "not_ends-with": ["not_ends_with", "$str", ""],
    "is_empty": ["is_empty", "$str"],
    "not_is_empty": ["not_is_empty", "$str"],
    "match_regex": ["match_regex", "$str", { expr: ".*" }],
    "not_match_regex": ["not_match_regex", "$str", { expr: ".*" }]
  };
  function changeDataType(e) {
    if (getPrimitive(data_type) === e.target.value)
      return;
    let newDataType = e.target.value;
    if (data_type.startsWith("array<")) {
      newDataType = `array<${newDataType}>`;
    }
    $$invalidate(0, data_type = newDataType);
    set_store_value(procs, $procs.parser = new DataTypeParams(getDefaultParams(newDataType)), $procs);
  }
  function changeParamValue(name, value) {
    parser.set({ [name]: value });
  }
  function getDefaultBooleanParser() {
    let stepName = allowedParserNames[0];
    return new ExpressionWrapper(defaultExprs[stepName]);
  }
  function getDefaultParams(data_type2) {
    data_type2 = getPrimitive(data_type2);
    switch (data_type2) {
      case "string":
      case "url":
      case "json":
        return void 0;
      case "number":
      case "currency":
        return {
          decimalSeparator: ".",
          groupingSeparator: ","
        };
      case "boolean":
        return { expr: getDefaultBooleanParser() };
      case "date":
        return { format: "MM-dd-yyyy" };
      default:
        throw new Error(`Unknown data type: ${data_type2}`);
    }
  }
  const ctx = {
    replace: {
      skipControl: true,
      stepNames: allowedParserNames,
      defaultExprs
    }
  };
  setContext("expressionCtx", ctx);
  const input_handler = (name, e) => changeParamValue(name, e.target.value);
  $$self.$$set = ($$props2) => {
    if ("data_type" in $$props2)
      $$invalidate(0, data_type = $$props2.data_type);
    if ("procs" in $$props2)
      $$subscribe_procs($$invalidate(1, procs = $$props2.procs));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $$subscribe_parser($$invalidate(2, parser = $procs.parser));
    }
  };
  return [
    data_type,
    procs,
    parser,
    $parser,
    allowedDataTypes,
    changeDataType,
    changeParamValue,
    $procs,
    input_handler
  ];
}
class Parser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2x, create_fragment$2A, safe_not_equal, { data_type: 0, procs: 1 });
  }
}
function get_each_context$H(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2][0];
  child_ctx[9] = list[i2][1];
  return child_ctx;
}
function get_each_context_1$7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  return child_ctx;
}
function create_each_block_1$7(ctx) {
  let option;
  let t_value = ctx[12] + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[12];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_else_block$S(ctx) {
  let div;
  let input;
  let input_value_value;
  let mounted;
  let dispose;
  function input_handler_1(...args) {
    return ctx[7](ctx[8], ...args);
  }
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "text");
      input.value = input_value_value = ctx[9];
      set_style(input, "width", "100%");
      attr(div, "class", "col");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      if (!mounted) {
        dispose = listen(input, "input", input_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 8 && input_value_value !== (input_value_value = ctx[9]) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1u(ctx) {
  let div;
  let textarea;
  let textarea_value_value;
  let mounted;
  let dispose;
  function input_handler(...args) {
    return ctx[6](ctx[8], ...args);
  }
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      set_style(textarea, "width", "100%");
      set_style(textarea, "height", "10rem");
      textarea.value = textarea_value_value = ctx[9];
      attr(div, "class", "col-12");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      if (!mounted) {
        dispose = listen(textarea, "input", input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 8 && textarea_value_value !== (textarea_value_value = ctx[9])) {
        textarea.value = textarea_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$H(key_1, ctx) {
  let div1;
  let div0;
  let t0_value = ctx[8] + "";
  let t0;
  let t1;
  let t2;
  function select_block_type(ctx2, dirty) {
    if (ctx2[8] === "script")
      return create_if_block$1u;
    return create_else_block$S;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      if_block.c();
      t2 = space();
      attr(div0, "class", "col");
      set_style(div0, "grid-column", "1");
      attr(div1, "class", "row");
      this.first = div1;
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      if_block.m(div1, null);
      append(div1, t2);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 8 && t0_value !== (t0_value = ctx[8] + ""))
        set_data(t0, t0_value);
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div1, t2);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_block.d();
    }
  };
}
function create_fragment$2z(ctx) {
  let div3;
  let div2;
  let div0;
  let t1;
  let div1;
  let select2;
  let select_value_value;
  let t2;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value_1 = Object.keys(getExtractor());
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i2));
  }
  let each_value = Object.entries(ctx[3]);
  const get_key = (ctx2) => ctx2[8];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$H(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each1_lookup.set(key, each_blocks[i2] = create_each_block$H(key, child_ctx));
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "Type";
      t1 = space();
      div1 = element("div");
      select2 = element("select");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "col");
      set_style(select2, "width", "100%");
      attr(div1, "class", "col");
      attr(div2, "class", "row");
      attr(div3, "class", "container d-flex flex-column gap-2");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      append(div1, select2);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(select2, null);
        }
      }
      select_option(select2, ctx[1].type);
      append(div3, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div3, null);
        }
      }
      if (!mounted) {
        dispose = listen(select2, "change", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 0) {
        each_value_1 = Object.keys(getExtractor());
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$7(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
          } else {
            each_blocks_1[i2] = create_each_block_1$7(child_ctx);
            each_blocks_1[i2].c();
            each_blocks_1[i2].m(select2, null);
          }
        }
        for (; i2 < each_blocks_1.length; i2 += 1) {
          each_blocks_1[i2].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & 2 && select_value_value !== (select_value_value = ctx2[1].type)) {
        select_option(select2, ctx2[1].type);
      }
      if (dirty & 40) {
        each_value = Object.entries(ctx2[3]);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each1_lookup, div3, destroy_block, create_each_block$H, null, get_each_context$H);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_each(each_blocks_1, detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function getExtractor() {
  return {
    attr: { name: { type: "string", optional: true } },
    prop: { name: { type: "string", optional: true } },
    text: {},
    text_visible: {},
    html: {},
    js: {
      script: { type: "string", optional: false }
    }
  };
}
function instance$2w($$self, $$props, $$invalidate) {
  let fieldParams;
  let $fieldParams, $$unsubscribe_fieldParams = noop$1, $$subscribe_fieldParams = () => ($$unsubscribe_fieldParams(), $$unsubscribe_fieldParams = subscribe(fieldParams, ($$value) => $$invalidate(3, $fieldParams = $$value)), fieldParams);
  let $field, $$unsubscribe_field = noop$1, $$subscribe_field = () => ($$unsubscribe_field(), $$unsubscribe_field = subscribe(field, ($$value) => $$invalidate(1, $field = $$value)), field);
  $$self.$$.on_destroy.push(() => $$unsubscribe_fieldParams());
  $$self.$$.on_destroy.push(() => $$unsubscribe_field());
  let { field } = $$props;
  $$subscribe_field();
  function setFieldType(e) {
    const extractorType = e.target.value;
    const extractor2 = getExtractor()[extractorType];
    let params2 = {};
    for (const [name, { type }] of Object.entries(extractor2)) {
      params2[name] = getDefault(type);
    }
    set_store_value(
      field,
      $field = {
        type: extractorType,
        params: new ExtractorParams(params2)
      },
      $field
    );
  }
  function setParamValue(name, value) {
    set_store_value(fieldParams, $fieldParams[name] = value, $fieldParams);
  }
  const input_handler = (name, e) => setParamValue(name, e.target.value);
  const input_handler_1 = (name, e) => setParamValue(name, e.target.value);
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$subscribe_field($$invalidate(0, field = $$props2.field));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $$subscribe_fieldParams($$invalidate(2, fieldParams = $field.params));
    }
  };
  return [
    field,
    $field,
    fieldParams,
    $fieldParams,
    setFieldType,
    setParamValue,
    input_handler,
    input_handler_1
  ];
}
class SelectorField extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2w, create_fragment$2z, safe_not_equal, { field: 0 });
  }
}
function get_each_context$G(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  child_ctx[15] = i2;
  return child_ctx;
}
function create_if_block$1t(ctx) {
  var _a;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = (_a = ctx[3]) == null ? void 0 : _a.models;
  const get_key = (ctx2) => ctx2[13];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$G(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$G(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$R();
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 104) {
        each_value = (_a2 = ctx2[3]) == null ? void 0 : _a2.models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$G, each_1_anchor, get_each_context$G);
        check_outros();
        if (each_value.length) {
          if (each_1_else) {
            each_1_else.d(1);
            each_1_else = null;
          }
        } else if (!each_1_else) {
          each_1_else = create_else_block$R();
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        }
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_else_block$R(ctx) {
  let t;
  return {
    c() {
      t = text("<none>");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$11(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = getComponent(ctx[13].root.expression.children[1]);
  function switch_props(ctx2) {
    return {
      props: {
        node: ctx2[13].root.expression.children[1],
        level: 0,
        $$slots: {
          "parent-context-menu": [create_parent_context_menu_slot]
        },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 8)
        switch_instance_changes.node = ctx2[13].root.expression.children[1];
      if (dirty & 65544) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (dirty & 8 && switch_value !== (switch_value = getComponent(ctx2[13].root.expression.children[1]))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_2$b(ctx) {
  let t;
  return {
    c() {
      t = text("Insert Before");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$i(ctx) {
  let t;
  return {
    c() {
      t = text("Insert After");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$12(ctx) {
  let t;
  return {
    c() {
      t = text("Delete");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_parent_context_menu_slot(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuitem2;
  let t2;
  let current;
  menuitem0 = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot_2$b] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", function() {
    if (is_function(ctx[5](ctx[15])))
      ctx[5](ctx[15]).apply(this, arguments);
  });
  menuitem1 = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot_1$i] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", function() {
    if (is_function(ctx[5](ctx[15] + 1)))
      ctx[5](ctx[15] + 1).apply(this, arguments);
  });
  function click_handler() {
    return ctx[8](ctx[13]);
  }
  menuitem2 = new MenuItem$1({
    props: {
      class: "bbx-danger",
      $$slots: { default: [create_default_slot$12] },
      $$scope: { ctx }
    }
  });
  menuitem2.$on("click", click_handler);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuitem2.$$.fragment);
      t2 = space();
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitem2, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem0_changes = {};
      if (dirty & 65536) {
        menuitem0_changes.$$scope = { dirty, ctx };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 65536) {
        menuitem1_changes.$$scope = { dirty, ctx };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty & 65536) {
        menuitem2_changes.$$scope = { dirty, ctx };
      }
      menuitem2.$set(menuitem2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitem2, detaching);
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block$G(key_1, ctx) {
  let first2;
  let if_block_anchor;
  let current;
  let if_block = ctx[13].root.expression.children && create_if_block_1$11(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[13].root.expression.children) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$11(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$2y(ctx) {
  let div2;
  let div0;
  let label;
  let t1;
  let input;
  let input_checked_value;
  let t2;
  let t3;
  let div1;
  let button;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[3] && create_if_block$1t(ctx);
  return {
    c() {
      var _a;
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = "Allow Null";
      t1 = space();
      input = element("input");
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      div1 = element("div");
      button = element("button");
      button.textContent = "+Validator";
      attr(label, "class", "form-check-label");
      attr(label, "for", "switchAllowEmpty");
      attr(input, "type", "checkbox");
      attr(input, "class", "form-check-input");
      attr(input, "id", "switchAllowEmpty");
      input.checked = input_checked_value = !((_a = ctx[1]) == null ? void 0 : _a.required);
      attr(div0, "class", "form-check form-switch");
      attr(button, "type", "button");
      attr(button, "class", "btn btn-secondary btn-sm");
      attr(div1, "class", "bbx-flex-rev");
      attr(div2, "class", "d-flex flex-column gap-2");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(div0, t1);
      append(div0, input);
      append(div2, t2);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t3);
      append(div2, div1);
      append(div1, button);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[4]),
          listen(button, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a;
      if (!current || dirty & 2 && input_checked_value !== (input_checked_value = !((_a = ctx2[1]) == null ? void 0 : _a.required))) {
        input.checked = input_checked_value;
      }
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1t(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t3);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2v($$self, $$props, $$invalidate) {
  let exprs;
  let $exprs, $$unsubscribe_exprs = noop$1, $$subscribe_exprs = () => ($$unsubscribe_exprs(), $$unsubscribe_exprs = subscribe(exprs, ($$value) => $$invalidate(3, $exprs = $$value)), exprs);
  let $validator, $$unsubscribe_validator = noop$1, $$subscribe_validator = () => ($$unsubscribe_validator(), $$unsubscribe_validator = subscribe(validator, ($$value) => $$invalidate(1, $validator = $$value)), validator);
  $$self.$$.on_destroy.push(() => $$unsubscribe_exprs());
  $$self.$$.on_destroy.push(() => $$unsubscribe_validator());
  let { data_type } = $$props;
  let { validator } = $$props;
  $$subscribe_validator();
  const defaultAssertsForDataTypes = {
    string: ["assert", ["not_is_empty", "$val"], "E_ASSERTION_FAILED"],
    url: ["assert", ["starts_with", "$val", "http"], "E_ASSERTION_FAILED"],
    number: ["assert", ["gt", "$val", 0], "E_ASSERTION_FAILED"],
    currency: ["assert", ["gt", "$val", 0], "E_ASSERTION_FAILED"],
    boolean: ["assert", ["not_is_empty", "$val"], "E_ASSERTION_FAILED"],
    date: ["assert", ["not_is_empty", "$val"], "E_ASSERTION_FAILED"]
  };
  const defaultExprs = {
    assert: defaultAssertsForDataTypes["string"]
  };
  const ctx = {
    replace: {
      skipControl: true,
      stepNames: ["assert"],
      defaultExprs
    }
  };
  setContext("expressionCtx", ctx);
  function toggleValidorSwitch(e) {
    set_store_value(validator, $validator.required = !e.target.checked, $validator);
  }
  function addValidator(index2 = 0) {
    $exprs.create(defaultAssertsForDataTypes[data_type] || defaultExprs["assert"], { at: index2 });
    set_store_value(validator, $validator.exprs = $exprs, $validator);
  }
  function deleteValidator(expr) {
    $exprs.remove(expr);
    set_store_value(validator, $validator.exprs = $exprs, $validator);
  }
  const click_handler = (expr) => deleteValidator(expr);
  const click_handler_1 = () => {
    var _a;
    return addValidator((_a = validator == null ? void 0 : validator.exprs) == null ? void 0 : _a.length);
  };
  $$self.$$set = ($$props2) => {
    if ("data_type" in $$props2)
      $$invalidate(7, data_type = $$props2.data_type);
    if ("validator" in $$props2)
      $$subscribe_validator($$invalidate(0, validator = $$props2.validator));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $$subscribe_exprs($$invalidate(2, exprs = $validator.exprs));
    }
  };
  return [
    validator,
    $validator,
    exprs,
    $exprs,
    toggleValidorSwitch,
    addValidator,
    deleteValidator,
    data_type,
    click_handler,
    click_handler_1
  ];
}
class Validator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2v, create_fragment$2y, safe_not_equal, { data_type: 7, validator: 0 });
  }
}
function create_else_block$Q(ctx) {
  let editabletext;
  let current;
  editabletext = new Text({
    props: {
      value: ctx[6].name,
      validationMessage: ctx[8],
      editMode: true
    }
  });
  editabletext.$on("cancel", ctx[20]);
  editabletext.$on("save", ctx[21]);
  return {
    c() {
      create_component(editabletext.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editabletext, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editabletext_changes = {};
      if (dirty & 64)
        editabletext_changes.value = ctx2[6].name;
      if (dirty & 256)
        editabletext_changes.validationMessage = ctx2[8];
      editabletext.$set(editabletext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editabletext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editabletext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editabletext, detaching);
    }
  };
}
function create_if_block$1s(ctx) {
  let button0;
  let t1;
  let button1;
  let t2;
  let button1_data_bs_target_value;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.textContent = "Rename";
      t1 = space();
      button1 = element("button");
      t2 = text("Delete");
      attr(button0, "type", "button");
      attr(button0, "class", "btn btn-sm btn-outline-secondary");
      attr(button1, "type", "button");
      attr(button1, "class", "btn btn-sm btn-outline-danger");
      attr(button1, "data-bs-toggle", "modal");
      attr(button1, "data-bs-target", button1_data_bs_target_value = "#deleteModal" + ctx[0]);
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      append(button1, t2);
      if (!mounted) {
        dispose = listen(button0, "click", ctx[22]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && button1_data_bs_target_value !== (button1_data_bs_target_value = "#deleteModal" + ctx2[0])) {
        attr(button1, "data-bs-target", button1_data_bs_target_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(button0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(button1);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2x(ctx) {
  let div36;
  let div0;
  let button0;
  let t0_value = ctx[6].name + "";
  let t0;
  let button0_class_value;
  let button0_aria_expanded_value;
  let button0_aria_controls_value;
  let button0_data_bs_target_value;
  let div0_id_value;
  let t1;
  let div35;
  let div34;
  let div4;
  let div1;
  let button1;
  let t2;
  let t3_value = `(${ctx[16].length})`;
  let t3;
  let button1_aria_controls_value;
  let button1_data_bs_target_value;
  let div1_id_value;
  let t4;
  let div3;
  let div2;
  let selectors0;
  let div3_id_value;
  let div3_aria_labelledby_value;
  let t5;
  let div8;
  let div5;
  let button2;
  let t6;
  let t7_value = `(${ctx[17].length})`;
  let t7;
  let button2_aria_controls_value;
  let button2_data_bs_target_value;
  let div5_id_value;
  let t8;
  let div7;
  let div6;
  let selectors1;
  let div7_id_value;
  let div7_aria_labelledby_value;
  let t9;
  let div12;
  let div9;
  let button3;
  let t10;
  let button3_aria_controls_value;
  let button3_data_bs_target_value;
  let div9_id_value;
  let t11;
  let div11;
  let div10;
  let selectorfield;
  let div11_id_value;
  let div11_aria_labelledby_value;
  let t12;
  let div16;
  let div13;
  let button4;
  let t13;
  let t14_value = `(${ctx[18].length})`;
  let t14;
  let button4_aria_controls_value;
  let button4_data_bs_target_value;
  let div13_id_value;
  let t15;
  let div15;
  let div14;
  let mappers_1;
  let div15_id_value;
  let div15_aria_labelledby_value;
  let t16;
  let div20;
  let div17;
  let button5;
  let t17;
  let button5_aria_controls_value;
  let button5_data_bs_target_value;
  let div17_id_value;
  let t18;
  let div19;
  let div18;
  let reducer;
  let updating_data_type;
  let div19_id_value;
  let div19_aria_labelledby_value;
  let t19;
  let div24;
  let div21;
  let button6;
  let t20;
  let button6_aria_controls_value;
  let button6_data_bs_target_value;
  let div21_id_value;
  let t21;
  let div23;
  let div22;
  let parser;
  let updating_data_type_1;
  let div23_id_value;
  let div23_aria_labelledby_value;
  let t22;
  let div28;
  let div25;
  let button7;
  let t23;
  let button7_aria_controls_value;
  let button7_data_bs_target_value;
  let div25_id_value;
  let t24;
  let div27;
  let div26;
  let validator_1;
  let div27_id_value;
  let div27_aria_labelledby_value;
  let t25;
  let div33;
  let div29;
  let button8;
  let span0;
  let button8_aria_controls_value;
  let button8_data_bs_target_value;
  let div29_id_value;
  let t27;
  let div32;
  let div31;
  let div30;
  let current_block_type_index;
  let if_block;
  let div32_id_value;
  let div32_aria_labelledby_value;
  let div34_id_value;
  let div35_id_value;
  let div35_aria_labelledby_value;
  let t28;
  let div42;
  let div41;
  let div40;
  let div37;
  let t31;
  let div38;
  let p;
  let t32;
  let span1;
  let t33_value = ctx[6].name + "";
  let t33;
  let t34;
  let t35;
  let div39;
  let button10;
  let t37;
  let button11;
  let div42_id_value;
  let current;
  let mounted;
  let dispose;
  selectors0 = new Selectors({
    props: {
      selectorList: ctx[14],
      frame: ctx[6].frame
    }
  });
  selectors1 = new Selectors({
    props: {
      selectorList: ctx[13],
      frame: ctx[6].frame
    }
  });
  selectorfield = new SelectorField({
    props: { field: ctx[7].field }
  });
  mappers_1 = new Mappers({ props: { mappers: ctx[11] } });
  function reducer_data_type_binding(value) {
    ctx[25](value);
  }
  let reducer_props = { procs: ctx[12] };
  if (ctx[6].data_type !== void 0) {
    reducer_props.data_type = ctx[6].data_type;
  }
  reducer = new Reducer({ props: reducer_props });
  binding_callbacks.push(() => bind$1(reducer, "data_type", reducer_data_type_binding));
  function parser_data_type_binding(value) {
    ctx[26](value);
  }
  let parser_props = { procs: ctx[12] };
  if (ctx[6].data_type !== void 0) {
    parser_props.data_type = ctx[6].data_type;
  }
  parser = new Parser({ props: parser_props });
  binding_callbacks.push(() => bind$1(parser, "data_type", parser_data_type_binding));
  validator_1 = new Validator({
    props: {
      data_type: ctx[6].data_type,
      validator: ctx[10]
    }
  });
  const if_block_creators = [create_if_block$1s, create_else_block$Q];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[9])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div36 = element("div");
      div0 = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      div35 = element("div");
      div34 = element("div");
      div4 = element("div");
      div1 = element("div");
      button1 = element("button");
      t2 = text("Includes ");
      t3 = text(t3_value);
      t4 = space();
      div3 = element("div");
      div2 = element("div");
      create_component(selectors0.$$.fragment);
      t5 = space();
      div8 = element("div");
      div5 = element("div");
      button2 = element("button");
      t6 = text("Excludes ");
      t7 = text(t7_value);
      t8 = space();
      div7 = element("div");
      div6 = element("div");
      create_component(selectors1.$$.fragment);
      t9 = space();
      div12 = element("div");
      div9 = element("div");
      button3 = element("button");
      t10 = text("Field");
      t11 = space();
      div11 = element("div");
      div10 = element("div");
      create_component(selectorfield.$$.fragment);
      t12 = space();
      div16 = element("div");
      div13 = element("div");
      button4 = element("button");
      t13 = text("Mappers ");
      t14 = text(t14_value);
      t15 = space();
      div15 = element("div");
      div14 = element("div");
      create_component(mappers_1.$$.fragment);
      t16 = space();
      div20 = element("div");
      div17 = element("div");
      button5 = element("button");
      t17 = text("Reducer");
      t18 = space();
      div19 = element("div");
      div18 = element("div");
      create_component(reducer.$$.fragment);
      t19 = space();
      div24 = element("div");
      div21 = element("div");
      button6 = element("button");
      t20 = text("Parser");
      t21 = space();
      div23 = element("div");
      div22 = element("div");
      create_component(parser.$$.fragment);
      t22 = space();
      div28 = element("div");
      div25 = element("div");
      button7 = element("button");
      t23 = text("Validator");
      t24 = space();
      div27 = element("div");
      div26 = element("div");
      create_component(validator_1.$$.fragment);
      t25 = space();
      div33 = element("div");
      div29 = element("div");
      button8 = element("button");
      span0 = element("span");
      span0.textContent = "Options";
      t27 = space();
      div32 = element("div");
      div31 = element("div");
      div30 = element("div");
      if_block.c();
      t28 = space();
      div42 = element("div");
      div41 = element("div");
      div40 = element("div");
      div37 = element("div");
      div37.innerHTML = `<h5 class="modal-title">Delete Tag</h5> 
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>`;
      t31 = space();
      div38 = element("div");
      p = element("p");
      t32 = text("Are you sure you want to delete ");
      span1 = element("span");
      t33 = text(t33_value);
      t34 = text("?");
      t35 = space();
      div39 = element("div");
      button10 = element("button");
      button10.textContent = "Cancel";
      t37 = space();
      button11 = element("button");
      button11.textContent = "Delete";
      attr(button0, "type", "button");
      attr(button0, "class", button0_class_value = "accordion-button " + (ctx[4] ? "" : "collapsed") + " py-1 px-2 fw-bold");
      attr(button0, "aria-expanded", button0_aria_expanded_value = ctx[4] ? "true" : "false");
      attr(button0, "aria-controls", button0_aria_controls_value = "collapse" + ctx[0]);
      attr(button0, "data-bs-toggle", "collapse");
      attr(button0, "data-bs-target", button0_data_bs_target_value = "#collapse" + ctx[0]);
      attr(div0, "class", "accordion-header bbx-tag");
      attr(div0, "id", div0_id_value = "heading" + ctx[0]);
      attr(button1, "type", "button");
      attr(button1, "class", "accordion-button py-0 px-2");
      attr(button1, "aria-expanded", "true");
      attr(button1, "aria-controls", button1_aria_controls_value = "collapse-includes-" + ctx[0]);
      attr(button1, "data-bs-toggle", "collapse");
      attr(button1, "data-bs-target", button1_data_bs_target_value = "#collapse-includes-" + ctx[0]);
      attr(div1, "class", "accordion-header bbx-section");
      attr(div1, "id", div1_id_value = "includes" + ctx[0]);
      attr(div2, "class", "accordion-body");
      attr(div3, "id", div3_id_value = "collapse-includes-" + ctx[0]);
      attr(div3, "class", "accordion-collapse collapse show");
      attr(div3, "aria-labelledby", div3_aria_labelledby_value = "includes" + ctx[0]);
      attr(div4, "class", "accordion-item");
      attr(button2, "type", "button");
      attr(button2, "class", "accordion-button collapsed py-0 px-2");
      attr(button2, "aria-expanded", "false");
      attr(button2, "aria-controls", button2_aria_controls_value = "collapse-excludes-" + ctx[0]);
      attr(button2, "data-bs-toggle", "collapse");
      attr(button2, "data-bs-target", button2_data_bs_target_value = "#collapse-excludes-" + ctx[0]);
      attr(div5, "class", "accordion-header bbx-section");
      attr(div5, "id", div5_id_value = "excludes" + ctx[0]);
      attr(div6, "class", "accordion-body");
      attr(div7, "id", div7_id_value = "collapse-excludes-" + ctx[0]);
      attr(div7, "class", "accordion-collapse collapse");
      attr(div7, "aria-labelledby", div7_aria_labelledby_value = "excludes" + ctx[0]);
      attr(div8, "class", "accordion-item");
      attr(button3, "type", "button");
      attr(button3, "class", "accordion-button py-0 px-2 collapsed");
      attr(button3, "aria-expanded", "false");
      attr(button3, "aria-controls", button3_aria_controls_value = "collapse-field-" + ctx[0]);
      attr(button3, "data-bs-toggle", "collapse");
      attr(button3, "data-bs-target", button3_data_bs_target_value = "#collapse-field-" + ctx[0]);
      attr(div9, "class", "accordion-header bbx-section");
      attr(div9, "id", div9_id_value = "field" + ctx[0]);
      attr(div10, "class", "accordion-body");
      attr(div11, "id", div11_id_value = "collapse-field-" + ctx[0]);
      attr(div11, "class", "accordion-collapse collapse");
      attr(div11, "aria-labelledby", div11_aria_labelledby_value = "field" + ctx[0]);
      attr(div12, "class", "accordion-item");
      attr(button4, "type", "button");
      attr(button4, "class", "accordion-button py-0 px-2 collapsed");
      attr(button4, "aria-expanded", "false");
      attr(button4, "aria-controls", button4_aria_controls_value = "collapse-mappers-" + ctx[0]);
      attr(button4, "data-bs-toggle", "collapse");
      attr(button4, "data-bs-target", button4_data_bs_target_value = "#collapse-mappers-" + ctx[0]);
      attr(div13, "class", "accordion-header bbx-section");
      attr(div13, "id", div13_id_value = "mappers" + ctx[0]);
      attr(div14, "class", "accordion-body");
      attr(div15, "id", div15_id_value = "collapse-mappers-" + ctx[0]);
      attr(div15, "class", "accordion-collapse collapse");
      attr(div15, "aria-labelledby", div15_aria_labelledby_value = "mappers" + ctx[0]);
      attr(div16, "class", "accordion-item");
      attr(button5, "type", "button");
      attr(button5, "class", "accordion-button py-0 px-2 collapsed");
      attr(button5, "aria-expanded", "false");
      attr(button5, "aria-controls", button5_aria_controls_value = "collapse-reducer-" + ctx[0]);
      attr(button5, "data-bs-toggle", "collapse");
      attr(button5, "data-bs-target", button5_data_bs_target_value = "#collapse-reducer-" + ctx[0]);
      attr(div17, "class", "accordion-header bbx-section");
      attr(div17, "id", div17_id_value = "reducer" + ctx[0]);
      attr(div18, "class", "accordion-body");
      attr(div19, "id", div19_id_value = "collapse-reducer-" + ctx[0]);
      attr(div19, "class", "accordion-collapse collapse");
      attr(div19, "aria-labelledby", div19_aria_labelledby_value = "reducer" + ctx[0]);
      attr(div20, "class", "accordion-item");
      attr(button6, "type", "button");
      attr(button6, "class", "accordion-button py-0 px-2 collapsed");
      attr(button6, "aria-expanded", "false");
      attr(button6, "aria-controls", button6_aria_controls_value = "collapse-parser-" + ctx[0]);
      attr(button6, "data-bs-toggle", "collapse");
      attr(button6, "data-bs-target", button6_data_bs_target_value = "#collapse-parser-" + ctx[0]);
      attr(div21, "class", "accordion-header bbx-section");
      attr(div21, "id", div21_id_value = "parser" + ctx[0]);
      attr(div22, "class", "accordion-body");
      attr(div23, "id", div23_id_value = "collapse-parser-" + ctx[0]);
      attr(div23, "class", "accordion-collapse collapse");
      attr(div23, "aria-labelledby", div23_aria_labelledby_value = "parser" + ctx[0]);
      attr(div24, "class", "accordion-item");
      attr(button7, "type", "button");
      attr(button7, "class", "accordion-button py-0 px-2 collapsed");
      attr(button7, "aria-expanded", "false");
      attr(button7, "aria-controls", button7_aria_controls_value = "collapse-validator-" + ctx[0]);
      attr(button7, "data-bs-toggle", "collapse");
      attr(button7, "data-bs-target", button7_data_bs_target_value = "#collapse-validator-" + ctx[0]);
      attr(div25, "class", "accordion-header bbx-section");
      attr(div25, "id", div25_id_value = "validator" + ctx[0]);
      attr(div26, "class", "accordion-body");
      attr(div27, "id", div27_id_value = "collapse-validator-" + ctx[0]);
      attr(div27, "class", "accordion-collapse collapse");
      attr(div27, "aria-labelledby", div27_aria_labelledby_value = "validator" + ctx[0]);
      attr(div28, "class", "accordion-item");
      attr(span0, "class", "text-danger");
      attr(button8, "type", "button");
      attr(button8, "class", "accordion-button collapsed py-0 px-2");
      attr(button8, "aria-expanded", "false");
      attr(button8, "aria-controls", button8_aria_controls_value = "collapse-info-" + ctx[0]);
      attr(button8, "data-bs-toggle", "collapse");
      attr(button8, "data-bs-target", button8_data_bs_target_value = "#collapse-info-" + ctx[0]);
      attr(div29, "class", "accordion-header bbx-section");
      attr(div29, "id", div29_id_value = "info" + ctx[0]);
      attr(div30, "class", "d-flex gap-2");
      attr(div31, "class", "accordion-body");
      attr(div32, "id", div32_id_value = "collapse-info-" + ctx[0]);
      attr(div32, "class", "accordion-collapse collapse");
      attr(div32, "aria-labelledby", div32_aria_labelledby_value = "info" + ctx[0]);
      attr(div33, "class", "accordion-item");
      attr(div34, "class", "accordion accordion-flush");
      attr(div34, "id", div34_id_value = "sectionList" + ctx[0]);
      attr(div35, "id", div35_id_value = "collapse" + ctx[0]);
      attr(div35, "class", "accordion-collapse collapse mb-4");
      attr(div35, "aria-labelledby", div35_aria_labelledby_value = "heading" + ctx[0]);
      attr(div35, "data-bs-parent", "#tagList");
      attr(div36, "class", "accordion-item");
      attr(div37, "class", "modal-header");
      attr(span1, "class", "fw-bold");
      attr(div38, "class", "modal-body");
      attr(button10, "type", "button");
      attr(button10, "class", "btn btn-secondary");
      attr(button10, "data-bs-dismiss", "modal");
      attr(button11, "type", "button");
      attr(button11, "class", "btn btn-danger");
      attr(button11, "data-bs-dismiss", "modal");
      attr(div39, "class", "modal-footer");
      attr(div40, "class", "modal-content");
      attr(div41, "class", "modal-dialog");
      set_style(div41, "z-index", "101");
      attr(div42, "class", "modal");
      attr(div42, "tabindex", "-1");
      attr(div42, "id", div42_id_value = "deleteModal" + ctx[0]);
      attr(div42, "aria-hidden", "true");
      attr(div42, "data-bs-backdrop", "false");
    },
    m(target, anchor) {
      insert(target, div36, anchor);
      append(div36, div0);
      append(div0, button0);
      append(button0, t0);
      append(div36, t1);
      append(div36, div35);
      append(div35, div34);
      append(div34, div4);
      append(div4, div1);
      append(div1, button1);
      append(button1, t2);
      append(button1, t3);
      append(div4, t4);
      append(div4, div3);
      append(div3, div2);
      mount_component(selectors0, div2, null);
      append(div34, t5);
      append(div34, div8);
      append(div8, div5);
      append(div5, button2);
      append(button2, t6);
      append(button2, t7);
      append(div8, t8);
      append(div8, div7);
      append(div7, div6);
      mount_component(selectors1, div6, null);
      append(div34, t9);
      append(div34, div12);
      append(div12, div9);
      append(div9, button3);
      append(button3, t10);
      append(div12, t11);
      append(div12, div11);
      append(div11, div10);
      mount_component(selectorfield, div10, null);
      append(div34, t12);
      append(div34, div16);
      append(div16, div13);
      append(div13, button4);
      append(button4, t13);
      append(button4, t14);
      append(div16, t15);
      append(div16, div15);
      append(div15, div14);
      mount_component(mappers_1, div14, null);
      append(div34, t16);
      append(div34, div20);
      append(div20, div17);
      append(div17, button5);
      append(button5, t17);
      append(div20, t18);
      append(div20, div19);
      append(div19, div18);
      mount_component(reducer, div18, null);
      append(div34, t19);
      append(div34, div24);
      append(div24, div21);
      append(div21, button6);
      append(button6, t20);
      append(div24, t21);
      append(div24, div23);
      append(div23, div22);
      mount_component(parser, div22, null);
      append(div34, t22);
      append(div34, div28);
      append(div28, div25);
      append(div25, button7);
      append(button7, t23);
      append(div28, t24);
      append(div28, div27);
      append(div27, div26);
      mount_component(validator_1, div26, null);
      append(div34, t25);
      append(div34, div33);
      append(div33, div29);
      append(div29, button8);
      append(button8, span0);
      append(div33, t27);
      append(div33, div32);
      append(div32, div31);
      append(div31, div30);
      if_blocks[current_block_type_index].m(div30, null);
      ctx[27](div35);
      insert(target, t28, anchor);
      insert(target, div42, anchor);
      append(div42, div41);
      append(div41, div40);
      append(div40, div37);
      append(div40, t31);
      append(div40, div38);
      append(div38, p);
      append(p, t32);
      append(p, span1);
      append(span1, t33);
      append(p, t34);
      append(div40, t35);
      append(div40, div39);
      append(div39, button10);
      append(div39, t37);
      append(div39, button11);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[24]),
          listen(button11, "click", ctx[28])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 64) && t0_value !== (t0_value = ctx2[6].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 16 && button0_class_value !== (button0_class_value = "accordion-button " + (ctx2[4] ? "" : "collapsed") + " py-1 px-2 fw-bold")) {
        attr(button0, "class", button0_class_value);
      }
      if (!current || dirty & 16 && button0_aria_expanded_value !== (button0_aria_expanded_value = ctx2[4] ? "true" : "false")) {
        attr(button0, "aria-expanded", button0_aria_expanded_value);
      }
      if (!current || dirty & 1 && button0_aria_controls_value !== (button0_aria_controls_value = "collapse" + ctx2[0])) {
        attr(button0, "aria-controls", button0_aria_controls_value);
      }
      if (!current || dirty & 1 && button0_data_bs_target_value !== (button0_data_bs_target_value = "#collapse" + ctx2[0])) {
        attr(button0, "data-bs-target", button0_data_bs_target_value);
      }
      if (!current || dirty & 1 && div0_id_value !== (div0_id_value = "heading" + ctx2[0])) {
        attr(div0, "id", div0_id_value);
      }
      if ((!current || dirty & 65536) && t3_value !== (t3_value = `(${ctx2[16].length})`))
        set_data(t3, t3_value);
      if (!current || dirty & 1 && button1_aria_controls_value !== (button1_aria_controls_value = "collapse-includes-" + ctx2[0])) {
        attr(button1, "aria-controls", button1_aria_controls_value);
      }
      if (!current || dirty & 1 && button1_data_bs_target_value !== (button1_data_bs_target_value = "#collapse-includes-" + ctx2[0])) {
        attr(button1, "data-bs-target", button1_data_bs_target_value);
      }
      if (!current || dirty & 1 && div1_id_value !== (div1_id_value = "includes" + ctx2[0])) {
        attr(div1, "id", div1_id_value);
      }
      const selectors0_changes = {};
      if (dirty & 16384)
        selectors0_changes.selectorList = ctx2[14];
      if (dirty & 64)
        selectors0_changes.frame = ctx2[6].frame;
      selectors0.$set(selectors0_changes);
      if (!current || dirty & 1 && div3_id_value !== (div3_id_value = "collapse-includes-" + ctx2[0])) {
        attr(div3, "id", div3_id_value);
      }
      if (!current || dirty & 1 && div3_aria_labelledby_value !== (div3_aria_labelledby_value = "includes" + ctx2[0])) {
        attr(div3, "aria-labelledby", div3_aria_labelledby_value);
      }
      if ((!current || dirty & 131072) && t7_value !== (t7_value = `(${ctx2[17].length})`))
        set_data(t7, t7_value);
      if (!current || dirty & 1 && button2_aria_controls_value !== (button2_aria_controls_value = "collapse-excludes-" + ctx2[0])) {
        attr(button2, "aria-controls", button2_aria_controls_value);
      }
      if (!current || dirty & 1 && button2_data_bs_target_value !== (button2_data_bs_target_value = "#collapse-excludes-" + ctx2[0])) {
        attr(button2, "data-bs-target", button2_data_bs_target_value);
      }
      if (!current || dirty & 1 && div5_id_value !== (div5_id_value = "excludes" + ctx2[0])) {
        attr(div5, "id", div5_id_value);
      }
      const selectors1_changes = {};
      if (dirty & 8192)
        selectors1_changes.selectorList = ctx2[13];
      if (dirty & 64)
        selectors1_changes.frame = ctx2[6].frame;
      selectors1.$set(selectors1_changes);
      if (!current || dirty & 1 && div7_id_value !== (div7_id_value = "collapse-excludes-" + ctx2[0])) {
        attr(div7, "id", div7_id_value);
      }
      if (!current || dirty & 1 && div7_aria_labelledby_value !== (div7_aria_labelledby_value = "excludes" + ctx2[0])) {
        attr(div7, "aria-labelledby", div7_aria_labelledby_value);
      }
      if (!current || dirty & 1 && button3_aria_controls_value !== (button3_aria_controls_value = "collapse-field-" + ctx2[0])) {
        attr(button3, "aria-controls", button3_aria_controls_value);
      }
      if (!current || dirty & 1 && button3_data_bs_target_value !== (button3_data_bs_target_value = "#collapse-field-" + ctx2[0])) {
        attr(button3, "data-bs-target", button3_data_bs_target_value);
      }
      if (!current || dirty & 1 && div9_id_value !== (div9_id_value = "field" + ctx2[0])) {
        attr(div9, "id", div9_id_value);
      }
      const selectorfield_changes = {};
      if (dirty & 128)
        selectorfield_changes.field = ctx2[7].field;
      selectorfield.$set(selectorfield_changes);
      if (!current || dirty & 1 && div11_id_value !== (div11_id_value = "collapse-field-" + ctx2[0])) {
        attr(div11, "id", div11_id_value);
      }
      if (!current || dirty & 1 && div11_aria_labelledby_value !== (div11_aria_labelledby_value = "field" + ctx2[0])) {
        attr(div11, "aria-labelledby", div11_aria_labelledby_value);
      }
      if ((!current || dirty & 262144) && t14_value !== (t14_value = `(${ctx2[18].length})`))
        set_data(t14, t14_value);
      if (!current || dirty & 1 && button4_aria_controls_value !== (button4_aria_controls_value = "collapse-mappers-" + ctx2[0])) {
        attr(button4, "aria-controls", button4_aria_controls_value);
      }
      if (!current || dirty & 1 && button4_data_bs_target_value !== (button4_data_bs_target_value = "#collapse-mappers-" + ctx2[0])) {
        attr(button4, "data-bs-target", button4_data_bs_target_value);
      }
      if (!current || dirty & 1 && div13_id_value !== (div13_id_value = "mappers" + ctx2[0])) {
        attr(div13, "id", div13_id_value);
      }
      const mappers_1_changes = {};
      if (dirty & 2048)
        mappers_1_changes.mappers = ctx2[11];
      mappers_1.$set(mappers_1_changes);
      if (!current || dirty & 1 && div15_id_value !== (div15_id_value = "collapse-mappers-" + ctx2[0])) {
        attr(div15, "id", div15_id_value);
      }
      if (!current || dirty & 1 && div15_aria_labelledby_value !== (div15_aria_labelledby_value = "mappers" + ctx2[0])) {
        attr(div15, "aria-labelledby", div15_aria_labelledby_value);
      }
      if (!current || dirty & 1 && button5_aria_controls_value !== (button5_aria_controls_value = "collapse-reducer-" + ctx2[0])) {
        attr(button5, "aria-controls", button5_aria_controls_value);
      }
      if (!current || dirty & 1 && button5_data_bs_target_value !== (button5_data_bs_target_value = "#collapse-reducer-" + ctx2[0])) {
        attr(button5, "data-bs-target", button5_data_bs_target_value);
      }
      if (!current || dirty & 1 && div17_id_value !== (div17_id_value = "reducer" + ctx2[0])) {
        attr(div17, "id", div17_id_value);
      }
      const reducer_changes = {};
      if (dirty & 4096)
        reducer_changes.procs = ctx2[12];
      if (!updating_data_type && dirty & 64) {
        updating_data_type = true;
        reducer_changes.data_type = ctx2[6].data_type;
        add_flush_callback(() => updating_data_type = false);
      }
      reducer.$set(reducer_changes);
      if (!current || dirty & 1 && div19_id_value !== (div19_id_value = "collapse-reducer-" + ctx2[0])) {
        attr(div19, "id", div19_id_value);
      }
      if (!current || dirty & 1 && div19_aria_labelledby_value !== (div19_aria_labelledby_value = "reducer" + ctx2[0])) {
        attr(div19, "aria-labelledby", div19_aria_labelledby_value);
      }
      if (!current || dirty & 1 && button6_aria_controls_value !== (button6_aria_controls_value = "collapse-parser-" + ctx2[0])) {
        attr(button6, "aria-controls", button6_aria_controls_value);
      }
      if (!current || dirty & 1 && button6_data_bs_target_value !== (button6_data_bs_target_value = "#collapse-parser-" + ctx2[0])) {
        attr(button6, "data-bs-target", button6_data_bs_target_value);
      }
      if (!current || dirty & 1 && div21_id_value !== (div21_id_value = "parser" + ctx2[0])) {
        attr(div21, "id", div21_id_value);
      }
      const parser_changes = {};
      if (dirty & 4096)
        parser_changes.procs = ctx2[12];
      if (!updating_data_type_1 && dirty & 64) {
        updating_data_type_1 = true;
        parser_changes.data_type = ctx2[6].data_type;
        add_flush_callback(() => updating_data_type_1 = false);
      }
      parser.$set(parser_changes);
      if (!current || dirty & 1 && div23_id_value !== (div23_id_value = "collapse-parser-" + ctx2[0])) {
        attr(div23, "id", div23_id_value);
      }
      if (!current || dirty & 1 && div23_aria_labelledby_value !== (div23_aria_labelledby_value = "parser" + ctx2[0])) {
        attr(div23, "aria-labelledby", div23_aria_labelledby_value);
      }
      if (!current || dirty & 1 && button7_aria_controls_value !== (button7_aria_controls_value = "collapse-validator-" + ctx2[0])) {
        attr(button7, "aria-controls", button7_aria_controls_value);
      }
      if (!current || dirty & 1 && button7_data_bs_target_value !== (button7_data_bs_target_value = "#collapse-validator-" + ctx2[0])) {
        attr(button7, "data-bs-target", button7_data_bs_target_value);
      }
      if (!current || dirty & 1 && div25_id_value !== (div25_id_value = "validator" + ctx2[0])) {
        attr(div25, "id", div25_id_value);
      }
      const validator_1_changes = {};
      if (dirty & 64)
        validator_1_changes.data_type = ctx2[6].data_type;
      if (dirty & 1024)
        validator_1_changes.validator = ctx2[10];
      validator_1.$set(validator_1_changes);
      if (!current || dirty & 1 && div27_id_value !== (div27_id_value = "collapse-validator-" + ctx2[0])) {
        attr(div27, "id", div27_id_value);
      }
      if (!current || dirty & 1 && div27_aria_labelledby_value !== (div27_aria_labelledby_value = "validator" + ctx2[0])) {
        attr(div27, "aria-labelledby", div27_aria_labelledby_value);
      }
      if (!current || dirty & 1 && button8_aria_controls_value !== (button8_aria_controls_value = "collapse-info-" + ctx2[0])) {
        attr(button8, "aria-controls", button8_aria_controls_value);
      }
      if (!current || dirty & 1 && button8_data_bs_target_value !== (button8_data_bs_target_value = "#collapse-info-" + ctx2[0])) {
        attr(button8, "data-bs-target", button8_data_bs_target_value);
      }
      if (!current || dirty & 1 && div29_id_value !== (div29_id_value = "info" + ctx2[0])) {
        attr(div29, "id", div29_id_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div30, null);
      }
      if (!current || dirty & 1 && div32_id_value !== (div32_id_value = "collapse-info-" + ctx2[0])) {
        attr(div32, "id", div32_id_value);
      }
      if (!current || dirty & 1 && div32_aria_labelledby_value !== (div32_aria_labelledby_value = "info" + ctx2[0])) {
        attr(div32, "aria-labelledby", div32_aria_labelledby_value);
      }
      if (!current || dirty & 1 && div34_id_value !== (div34_id_value = "sectionList" + ctx2[0])) {
        attr(div34, "id", div34_id_value);
      }
      if (!current || dirty & 1 && div35_id_value !== (div35_id_value = "collapse" + ctx2[0])) {
        attr(div35, "id", div35_id_value);
      }
      if (!current || dirty & 1 && div35_aria_labelledby_value !== (div35_aria_labelledby_value = "heading" + ctx2[0])) {
        attr(div35, "aria-labelledby", div35_aria_labelledby_value);
      }
      if ((!current || dirty & 64) && t33_value !== (t33_value = ctx2[6].name + ""))
        set_data(t33, t33_value);
      if (!current || dirty & 1 && div42_id_value !== (div42_id_value = "deleteModal" + ctx2[0])) {
        attr(div42, "id", div42_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(selectors0.$$.fragment, local);
      transition_in(selectors1.$$.fragment, local);
      transition_in(selectorfield.$$.fragment, local);
      transition_in(mappers_1.$$.fragment, local);
      transition_in(reducer.$$.fragment, local);
      transition_in(parser.$$.fragment, local);
      transition_in(validator_1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(selectors0.$$.fragment, local);
      transition_out(selectors1.$$.fragment, local);
      transition_out(selectorfield.$$.fragment, local);
      transition_out(mappers_1.$$.fragment, local);
      transition_out(reducer.$$.fragment, local);
      transition_out(parser.$$.fragment, local);
      transition_out(validator_1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div36);
      destroy_component(selectors0);
      destroy_component(selectors1);
      destroy_component(selectorfield);
      destroy_component(mappers_1);
      destroy_component(reducer);
      destroy_component(parser);
      destroy_component(validator_1);
      if_blocks[current_block_type_index].d();
      ctx[27](null);
      if (detaching)
        detach(t28);
      if (detaching)
        detach(div42);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2u($$self, $$props, $$invalidate) {
  let selectors;
  let includes;
  let excludes;
  let procs;
  let mappers;
  let validator;
  let $tag, $$unsubscribe_tag = noop$1, $$subscribe_tag = () => ($$unsubscribe_tag(), $$unsubscribe_tag = subscribe(tag, ($$value) => $$invalidate(6, $tag = $$value)), tag);
  let $tags, $$unsubscribe_tags = noop$1, $$subscribe_tags = () => ($$unsubscribe_tags(), $$unsubscribe_tags = subscribe(tags, ($$value) => $$invalidate(29, $tags = $$value)), tags);
  let $procs, $$unsubscribe_procs = noop$1, $$subscribe_procs = () => ($$unsubscribe_procs(), $$unsubscribe_procs = subscribe(procs, ($$value) => $$invalidate(23, $procs = $$value)), procs);
  let $selectors, $$unsubscribe_selectors = noop$1, $$subscribe_selectors = () => ($$unsubscribe_selectors(), $$unsubscribe_selectors = subscribe(selectors, ($$value) => $$invalidate(7, $selectors = $$value)), selectors);
  let $includes, $$unsubscribe_includes = noop$1, $$subscribe_includes = () => ($$unsubscribe_includes(), $$unsubscribe_includes = subscribe(includes, ($$value) => $$invalidate(16, $includes = $$value)), includes);
  let $excludes, $$unsubscribe_excludes = noop$1, $$subscribe_excludes = () => ($$unsubscribe_excludes(), $$unsubscribe_excludes = subscribe(excludes, ($$value) => $$invalidate(17, $excludes = $$value)), excludes);
  let $mappers, $$unsubscribe_mappers = noop$1, $$subscribe_mappers = () => ($$unsubscribe_mappers(), $$unsubscribe_mappers = subscribe(mappers, ($$value) => $$invalidate(18, $mappers = $$value)), mappers);
  $$self.$$.on_destroy.push(() => $$unsubscribe_tag());
  $$self.$$.on_destroy.push(() => $$unsubscribe_tags());
  $$self.$$.on_destroy.push(() => $$unsubscribe_procs());
  $$self.$$.on_destroy.push(() => $$unsubscribe_selectors());
  $$self.$$.on_destroy.push(() => $$unsubscribe_includes());
  $$self.$$.on_destroy.push(() => $$unsubscribe_excludes());
  $$self.$$.on_destroy.push(() => $$unsubscribe_mappers());
  const dispatch = createEventDispatcher();
  getContext("Msg");
  let { index: index2 } = $$props;
  let { removeTag } = $$props;
  let { tag } = $$props;
  $$subscribe_tag();
  let { tags } = $$props;
  $$subscribe_tags();
  let { isActive = false } = $$props;
  let accordionCollapse;
  let renameError = void 0;
  let renameMode = false;
  function cancelRenameMode() {
    $$invalidate(8, renameError = void 0);
    $$invalidate(9, renameMode = false);
  }
  function rename({ detail }) {
    $$invalidate(8, renameError = void 0);
    let name = detail.trim();
    if (!isValidName(name)) {
      $$invalidate(8, renameError = "Invalid tag name: " + name);
    } else if ($tags.models.some(
      (t) => t.get("name") === name
    )) {
      $$invalidate(8, renameError = "Tag name already exists");
    } else {
      set_store_value(tag, $tag.name = name, $tag);
      $$invalidate(9, renameMode = false);
    }
  }
  function setRenameMode() {
    $$invalidate(9, renameMode = true);
    $$invalidate(8, renameError = void 0);
  }
  const click_handler = () => dispatch("active", !isActive);
  function reducer_data_type_binding(value) {
    if ($$self.$$.not_equal($tag.data_type, value)) {
      $tag.data_type = value;
      tag.set($tag);
    }
  }
  function parser_data_type_binding(value) {
    if ($$self.$$.not_equal($tag.data_type, value)) {
      $tag.data_type = value;
      tag.set($tag);
    }
  }
  function div35_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      accordionCollapse = $$value;
      $$invalidate(5, accordionCollapse);
    });
  }
  const click_handler_1 = () => removeTag(tag);
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(0, index2 = $$props2.index);
    if ("removeTag" in $$props2)
      $$invalidate(1, removeTag = $$props2.removeTag);
    if ("tag" in $$props2)
      $$subscribe_tag($$invalidate(2, tag = $$props2.tag));
    if ("tags" in $$props2)
      $$subscribe_tags($$invalidate(3, tags = $$props2.tags));
    if ("isActive" in $$props2)
      $$invalidate(4, isActive = $$props2.isActive);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      $$subscribe_selectors($$invalidate(15, selectors = $tag.selectors));
    }
    if ($$self.$$.dirty & 128) {
      $$subscribe_includes($$invalidate(14, includes = $selectors.includes));
    }
    if ($$self.$$.dirty & 128) {
      $$subscribe_excludes($$invalidate(13, excludes = $selectors.excludes));
    }
    if ($$self.$$.dirty & 64) {
      $$subscribe_procs($$invalidate(12, procs = $tag.procs));
    }
    if ($$self.$$.dirty & 8388608) {
      $$subscribe_mappers($$invalidate(11, mappers = $procs.mappers));
    }
    if ($$self.$$.dirty & 8388608) {
      $$invalidate(10, validator = $procs.validator);
    }
    if ($$self.$$.dirty & 48) {
      if (isActive) {
        accordionCollapse == null ? void 0 : accordionCollapse.classList.add("show");
      } else {
        accordionCollapse == null ? void 0 : accordionCollapse.classList.remove("show");
      }
    }
  };
  return [
    index2,
    removeTag,
    tag,
    tags,
    isActive,
    accordionCollapse,
    $tag,
    $selectors,
    renameError,
    renameMode,
    validator,
    mappers,
    procs,
    excludes,
    includes,
    selectors,
    $includes,
    $excludes,
    $mappers,
    dispatch,
    cancelRenameMode,
    rename,
    setRenameMode,
    $procs,
    click_handler,
    reducer_data_type_binding,
    parser_data_type_binding,
    div35_binding,
    click_handler_1
  ];
}
class Tag extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2u, create_fragment$2x, safe_not_equal, {
      index: 0,
      removeTag: 1,
      tag: 2,
      tags: 3,
      isActive: 4
    });
  }
}
function create_else_block_1$f(ctx) {
  let editabletext;
  let current;
  editabletext = new Text({
    props: {
      value: ctx[10].name,
      validationMessage: ctx[2],
      editMode: true
    }
  });
  editabletext.$on("cancel", ctx[12]);
  editabletext.$on("save", ctx[17]);
  return {
    c() {
      create_component(editabletext.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editabletext, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editabletext_changes = {};
      if (dirty[0] & 1024)
        editabletext_changes.value = ctx2[10].name;
      if (dirty[0] & 4)
        editabletext_changes.validationMessage = ctx2[2];
      editabletext.$set(editabletext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editabletext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editabletext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editabletext, detaching);
    }
  };
}
function create_if_block_3$z(ctx) {
  let searchselect;
  let current;
  searchselect = new SearchSelect({
    props: {
      actionClass: "bbx-pointer bbx-header bbx-semi-bold bbx-flex bbx-gap",
      defaultActionLabel: ctx[10].name,
      value: "",
      options: ctx[11].models.map(func),
      labels: ctx[11].models.map(func_1),
      addNew: true,
      validationMessage: ctx[5],
      $$slots: { "label-post": [create_label_post_slot] },
      $$scope: { ctx }
    }
  });
  searchselect.$on("select", ctx[14]);
  searchselect.$on("create", ctx[15]);
  searchselect.$on("cancel", ctx[24]);
  return {
    c() {
      create_component(searchselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const searchselect_changes = {};
      if (dirty[0] & 1024)
        searchselect_changes.defaultActionLabel = ctx2[10].name;
      if (dirty[0] & 2048)
        searchselect_changes.options = ctx2[11].models.map(func);
      if (dirty[0] & 2048)
        searchselect_changes.labels = ctx2[11].models.map(func_1);
      if (dirty[0] & 32)
        searchselect_changes.validationMessage = ctx2[5];
      if (dirty[1] & 8) {
        searchselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      searchselect.$set(searchselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchselect, detaching);
    }
  };
}
function create_label_post_slot(ctx) {
  let div;
  let angleright;
  let current;
  angleright = new AngleRight({
    props: { size: "8", strokeColor: "#999" }
  });
  return {
    c() {
      div = element("div");
      create_component(angleright.$$.fragment);
      attr(div, "slot", "label-post");
      attr(div, "class", "bbx-rotate-90");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(angleright, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(angleright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(angleright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(angleright);
    }
  };
}
function create_else_block$P(ctx) {
  let editabletext;
  let current;
  editabletext = new Text({
    props: {
      value: ctx[10].url,
      editMode: true
    }
  });
  editabletext.$on("cancel", ctx[25]);
  editabletext.$on("save", ctx[18]);
  return {
    c() {
      create_component(editabletext.$$.fragment);
    },
    m(target, anchor) {
      mount_component(editabletext, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editabletext_changes = {};
      if (dirty[0] & 1024)
        editabletext_changes.value = ctx2[10].url;
      editabletext.$set(editabletext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editabletext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editabletext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(editabletext, detaching);
    }
  };
}
function create_if_block_2$H(ctx) {
  let div;
  let a;
  let t0_value = ctx[10].url + "";
  let t0;
  let a_href_value;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      button = element("button");
      button.textContent = "Load";
      attr(a, "href", a_href_value = ctx[10].url);
      attr(a, "target", "_blank");
      attr(button, "type", "button");
      attr(button, "class", "btn btn-outline-secondary btn-sm py-0 px-1");
      attr(div, "class", "bbx-flex bbx-gap bbx-align-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(a, t0);
      append(div, t1);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t0_value !== (t0_value = ctx2[10].url + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 1024 && a_href_value !== (a_href_value = ctx2[10].url)) {
        attr(a, "href", a_href_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3$7(ctx) {
  let t;
  return {
    c() {
      t = text("Switch schema");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$a(ctx) {
  let t;
  return {
    c() {
      t = text("Rename");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$h(ctx) {
  let t;
  return {
    c() {
      t = text("Edit URL");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$11(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Source");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_items_slot(ctx) {
  let menuitem0;
  let t0;
  let menuitem1;
  let t1;
  let menuitem2;
  let t2;
  let menuitem3;
  let current;
  menuitem0 = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot_3$7] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", ctx[26]);
  menuitem1 = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot_2$a] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", ctx[16]);
  menuitem2 = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot_1$h] },
      $$scope: { ctx }
    }
  });
  menuitem2.$on("click", ctx[27]);
  menuitem3 = new MenuItem$1({
    props: {
      $$slots: { default: [create_default_slot$11] },
      $$scope: { ctx }
    }
  });
  menuitem3.$on("click", ctx[28]);
  return {
    c() {
      create_component(menuitem0.$$.fragment);
      t0 = space();
      create_component(menuitem1.$$.fragment);
      t1 = space();
      create_component(menuitem2.$$.fragment);
      t2 = space();
      create_component(menuitem3.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem0, target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitem1, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitem2, target, anchor);
      insert(target, t2, anchor);
      mount_component(menuitem3, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty[1] & 8) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty[1] & 8) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitem2_changes = {};
      if (dirty[1] & 8) {
        menuitem2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem2.$set(menuitem2_changes);
      const menuitem3_changes = {};
      if (dirty[1] & 8) {
        menuitem3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem3.$set(menuitem3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitem2.$$.fragment, local);
      transition_in(menuitem3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitem2.$$.fragment, local);
      transition_out(menuitem3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitem1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitem2, detaching);
      if (detaching)
        detach(t2);
      destroy_component(menuitem3, detaching);
    }
  };
}
function create_if_block_1$10(ctx) {
  let searchselect;
  let current;
  searchselect = new SearchSelect({
    props: {
      value: "",
      rect: ctx[6].getBoundingClientRect(),
      options: ctx[11].models.map(func_2),
      labels: ctx[11].models.map(func_3),
      addNew: true,
      validationMessage: ctx[5]
    }
  });
  searchselect.$on("select", ctx[14]);
  searchselect.$on("create", ctx[15]);
  searchselect.$on("cancel", ctx[30]);
  return {
    c() {
      create_component(searchselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const searchselect_changes = {};
      if (dirty[0] & 64)
        searchselect_changes.rect = ctx2[6].getBoundingClientRect();
      if (dirty[0] & 2048)
        searchselect_changes.options = ctx2[11].models.map(func_2);
      if (dirty[0] & 2048)
        searchselect_changes.labels = ctx2[11].models.map(func_3);
      if (dirty[0] & 32)
        searchselect_changes.validationMessage = ctx2[5];
      searchselect.$set(searchselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchselect, detaching);
    }
  };
}
function create_if_block$1r(ctx) {
  let sourceeditor;
  let current;
  sourceeditor = new SourceEditor$1({
    props: {
      errorMessage: ctx[9],
      source: ctx[11].toJSON(),
      rect: ctx[20]()
    }
  });
  sourceeditor.$on("cancel", ctx[19]);
  sourceeditor.$on("save", ctx[21]);
  return {
    c() {
      create_component(sourceeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sourceeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sourceeditor_changes = {};
      if (dirty[0] & 512)
        sourceeditor_changes.errorMessage = ctx2[9];
      if (dirty[0] & 2048)
        sourceeditor_changes.source = ctx2[11].toJSON();
      sourceeditor.$set(sourceeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sourceeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sourceeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sourceeditor, detaching);
    }
  };
}
function create_fragment$2w(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t0;
  let current_block_type_index_1;
  let if_block1;
  let t1;
  let menubtn;
  let t2;
  let t3;
  let if_block3_anchor;
  let current;
  const if_block_creators = [create_if_block_3$z, create_else_block_1$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const if_block_creators_1 = [create_if_block_2$H, create_else_block$P];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[7])
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_1(ctx);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  menubtn = new MenuBtn({
    props: {
      $$slots: { items: [create_items_slot] },
      $$scope: { ctx }
    }
  });
  let if_block2 = ctx[4] && create_if_block_1$10(ctx);
  let if_block3 = ctx[8] && create_if_block$1r(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      create_component(menubtn.$$.fragment);
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      attr(div0, "class", "bbx-flex-col bbx-gap");
      attr(div1, "class", "bbx-flex bbx-pad");
      set_style(div1, "margin-bottom", "1rem");
      set_style(div1, "justify-content", "space-between");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div0, t0);
      if_blocks_1[current_block_type_index_1].m(div0, null);
      append(div1, t1);
      mount_component(menubtn, div1, null);
      ctx[29](div1);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, t0);
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block1 = if_blocks_1[current_block_type_index_1];
        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div0, null);
      }
      const menubtn_changes = {};
      if (dirty[0] & 400 | dirty[1] & 8) {
        menubtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menubtn.$set(menubtn_changes);
      if (ctx2[4]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$10(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[8]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 256) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$1r(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(menubtn.$$.fragment, local);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(menubtn.$$.fragment, local);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if_blocks[current_block_type_index].d();
      if_blocks_1[current_block_type_index_1].d();
      destroy_component(menubtn);
      ctx[29](null);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(if_block3_anchor);
    }
  };
}
const func = (s) => s.get("id");
const func_1 = (s) => s.get("name");
const func_2 = (s) => s.get("id");
const func_3 = (s) => s.get("name");
function instance$2t($$self, $$props, $$invalidate) {
  let $activeSchema, $$unsubscribe_activeSchema = noop$1, $$subscribe_activeSchema = () => ($$unsubscribe_activeSchema(), $$unsubscribe_activeSchema = subscribe(activeSchema, ($$value) => $$invalidate(10, $activeSchema = $$value)), activeSchema);
  let $schemaList, $$unsubscribe_schemaList = noop$1, $$subscribe_schemaList = () => ($$unsubscribe_schemaList(), $$unsubscribe_schemaList = subscribe(schemaList, ($$value) => $$invalidate(11, $schemaList = $$value)), schemaList);
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeSchema());
  $$self.$$.on_destroy.push(() => $$unsubscribe_schemaList());
  let { activeSchema } = $$props;
  $$subscribe_activeSchema();
  let { createSchema } = $$props;
  let { setActiveSchema } = $$props;
  let { schemaList } = $$props;
  $$subscribe_schemaList();
  let renameError = void 0;
  let renameMode = false;
  let replaceSchema = false;
  let schemaCreationError;
  let titleComponent;
  let urlEditMode = false;
  let sourceEditMode = false;
  let sourceEditError;
  const browserView = getContext("browserView");
  const replaceSchemas = getContext("replaceSchemas");
  function cancelRenameMode() {
    $$invalidate(3, renameMode = false);
    $$invalidate(2, renameError = void 0);
  }
  async function gotoURL() {
    await (browserView == null ? void 0 : browserView.store.pages[0].goto($activeSchema.url));
  }
  function onSelectId({ detail }) {
    if (detail !== $activeSchema.id) {
      const matchingSchemas = $schemaList.filter((s) => s.get("id") === detail);
      setActiveSchema(matchingSchemas[0]);
    }
    $$invalidate(4, replaceSchema = false);
  }
  function onCreate({ detail }) {
    try {
      const schema = createSchema(detail);
      setActiveSchema(schema);
      $$invalidate(4, replaceSchema = false);
    } catch (e) {
      $$invalidate(5, schemaCreationError = e.message);
    }
  }
  function setRenameMode() {
    $$invalidate(3, renameMode = true);
    $$invalidate(2, renameError = void 0);
  }
  function updateSchemaName({ detail }) {
    $$invalidate(2, renameError = void 0);
    if (!isValidName(detail)) {
      $$invalidate(2, renameError = "Invalid name for schema: " + detail);
    } else {
      set_store_value(activeSchema, $activeSchema.name = detail, $activeSchema);
      $$invalidate(3, renameMode = false);
    }
  }
  function updateUrl({ detail }) {
    set_store_value(activeSchema, $activeSchema.url = detail, $activeSchema);
    $$invalidate(7, urlEditMode = false);
  }
  function cancelSourceEdit() {
    $$invalidate(9, sourceEditError = void 0);
    $$invalidate(8, sourceEditMode = false);
  }
  function getRect() {
    let { left, top, right } = titleComponent.getBoundingClientRect();
    return {
      left: left - 10,
      top: top - 10,
      right: right - 10
    };
  }
  function saveSource({ detail }) {
    try {
      const updatedSchemas = replaceSchemas(detail);
      if (updatedSchemas && updatedSchemas.length > 0) {
        setActiveSchema(updatedSchemas[0]);
      }
    } catch (e) {
      console.error(e);
      $$invalidate(9, sourceEditError = e.message);
      return;
    }
    $$invalidate(9, sourceEditError = void 0);
    $$invalidate(8, sourceEditMode = false);
  }
  const cancel_handler = () => $$invalidate(4, replaceSchema = false);
  const cancel_handler_1 = () => $$invalidate(7, urlEditMode = false);
  const click_handler = () => $$invalidate(4, replaceSchema = true);
  const click_handler_1 = () => $$invalidate(7, urlEditMode = true);
  const click_handler_2 = () => $$invalidate(8, sourceEditMode = true);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      titleComponent = $$value;
      $$invalidate(6, titleComponent);
    });
  }
  const cancel_handler_2 = () => $$invalidate(4, replaceSchema = false);
  $$self.$$set = ($$props2) => {
    if ("activeSchema" in $$props2)
      $$subscribe_activeSchema($$invalidate(0, activeSchema = $$props2.activeSchema));
    if ("createSchema" in $$props2)
      $$invalidate(22, createSchema = $$props2.createSchema);
    if ("setActiveSchema" in $$props2)
      $$invalidate(23, setActiveSchema = $$props2.setActiveSchema);
    if ("schemaList" in $$props2)
      $$subscribe_schemaList($$invalidate(1, schemaList = $$props2.schemaList));
  };
  return [
    activeSchema,
    schemaList,
    renameError,
    renameMode,
    replaceSchema,
    schemaCreationError,
    titleComponent,
    urlEditMode,
    sourceEditMode,
    sourceEditError,
    $activeSchema,
    $schemaList,
    cancelRenameMode,
    gotoURL,
    onSelectId,
    onCreate,
    setRenameMode,
    updateSchemaName,
    updateUrl,
    cancelSourceEdit,
    getRect,
    saveSource,
    createSchema,
    setActiveSchema,
    cancel_handler,
    cancel_handler_1,
    click_handler,
    click_handler_1,
    click_handler_2,
    div1_binding,
    cancel_handler_2
  ];
}
class SchemaInfo extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$2t,
      create_fragment$2w,
      safe_not_equal,
      {
        activeSchema: 0,
        createSchema: 22,
        setActiveSchema: 23,
        schemaList: 1
      },
      null,
      [-1, -1]
    );
  }
}
function get_each_context$F(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  child_ctx[14] = i2;
  return child_ctx;
}
function create_each_block$F(key_1, ctx) {
  let first2;
  let tag;
  let current;
  function active_handler(...args) {
    return ctx[11](ctx[12], ...args);
  }
  tag = new Tag({
    props: {
      tag: ctx[12],
      tags: ctx[7],
      removeTag: ctx[9],
      index: ctx[14],
      isActive: ctx[12] === ctx[4]
    }
  });
  tag.$on("active", active_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(tag.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(tag, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tag_changes = {};
      if (dirty & 256)
        tag_changes.tag = ctx[12];
      if (dirty & 128)
        tag_changes.tags = ctx[7];
      if (dirty & 256)
        tag_changes.index = ctx[14];
      if (dirty & 272)
        tag_changes.isActive = ctx[12] === ctx[4];
      tag.$set(tag_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(tag, detaching);
    }
  };
}
function create_fragment$2v(ctx) {
  let div1;
  let schemainfo;
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div0;
  let button;
  let current;
  let mounted;
  let dispose;
  schemainfo = new SchemaInfo({
    props: {
      activeSchema: ctx[3],
      setActiveSchema: ctx[5],
      schemaList: ctx[2],
      createSchema: ctx[0]
    }
  });
  let each_value = ctx[8].models;
  const get_key = (ctx2) => ctx2[12];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$F(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$F(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      create_component(schemainfo.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      div0 = element("div");
      button = element("button");
      button.textContent = "New Tag";
      attr(button, "class", "btn btn-secondary btn-sm");
      attr(div0, "class", "bbx-flex-rev mt-4 mx-2");
      set_style(div1, "overflow", "auto");
      set_style(div1, "margin-top", "0.5rem");
      attr(div1, "class", "accordion accordion-flush");
      attr(div1, "id", "tagList");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(schemainfo, div1, null);
      append(div1, t0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(div1, t1);
      append(div1, div0);
      append(div0, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[1]))
            ctx[1].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const schemainfo_changes = {};
      if (dirty & 8)
        schemainfo_changes.activeSchema = ctx[3];
      if (dirty & 32)
        schemainfo_changes.setActiveSchema = ctx[5];
      if (dirty & 4)
        schemainfo_changes.schemaList = ctx[2];
      if (dirty & 1)
        schemainfo_changes.createSchema = ctx[0];
      schemainfo.$set(schemainfo_changes);
      if (dirty & 976) {
        each_value = ctx[8].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$F, t1, get_each_context$F);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(schemainfo.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(schemainfo.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(schemainfo);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$2s($$self, $$props, $$invalidate) {
  let tags;
  let $activeSchema, $$unsubscribe_activeSchema = noop$1, $$subscribe_activeSchema = () => ($$unsubscribe_activeSchema(), $$unsubscribe_activeSchema = subscribe(activeSchema, ($$value) => $$invalidate(10, $activeSchema = $$value)), activeSchema);
  let $tags, $$unsubscribe_tags = noop$1, $$subscribe_tags = () => ($$unsubscribe_tags(), $$unsubscribe_tags = subscribe(tags, ($$value) => $$invalidate(8, $tags = $$value)), tags);
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeSchema());
  $$self.$$.on_destroy.push(() => $$unsubscribe_tags());
  let { createSchema } = $$props;
  let { createTag } = $$props;
  let { schemaList } = $$props;
  let { activeSchema } = $$props;
  $$subscribe_activeSchema();
  let { activeTag } = $$props;
  let { setActiveSchema } = $$props;
  let { setActiveTag } = $$props;
  function removeTag(tag) {
    if (activeTag === tag) {
      setActiveTag();
    }
    tags.remove(tag);
  }
  const active_handler = (tag, { detail }) => detail ? setActiveTag(tag) : setActiveTag();
  $$self.$$set = ($$props2) => {
    if ("createSchema" in $$props2)
      $$invalidate(0, createSchema = $$props2.createSchema);
    if ("createTag" in $$props2)
      $$invalidate(1, createTag = $$props2.createTag);
    if ("schemaList" in $$props2)
      $$invalidate(2, schemaList = $$props2.schemaList);
    if ("activeSchema" in $$props2)
      $$subscribe_activeSchema($$invalidate(3, activeSchema = $$props2.activeSchema));
    if ("activeTag" in $$props2)
      $$invalidate(4, activeTag = $$props2.activeTag);
    if ("setActiveSchema" in $$props2)
      $$invalidate(5, setActiveSchema = $$props2.setActiveSchema);
    if ("setActiveTag" in $$props2)
      $$invalidate(6, setActiveTag = $$props2.setActiveTag);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      $$subscribe_tags($$invalidate(7, tags = $activeSchema.tags));
    }
  };
  return [
    createSchema,
    createTag,
    schemaList,
    activeSchema,
    activeTag,
    setActiveSchema,
    setActiveTag,
    tags,
    $tags,
    removeTag,
    $activeSchema,
    active_handler
  ];
}
class Schema extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2s, create_fragment$2v, safe_not_equal, {
      createSchema: 0,
      createTag: 1,
      schemaList: 2,
      activeSchema: 3,
      activeTag: 4,
      setActiveSchema: 5,
      setActiveTag: 6
    });
  }
}
function create_if_block$1q(ctx) {
  let div;
  let iconbtn;
  let current;
  let mounted;
  let dispose;
  iconbtn = new IconBtn({
    props: {
      size: iconSize,
      $$slots: { default: [create_default_slot$10] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(iconbtn.$$.fragment);
      attr(div, "style", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(iconbtn, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "click", function() {
            if (is_function(ctx[0].onDeleteClicked))
              ctx[0].onDeleteClicked.apply(this, arguments);
          }),
          listen(div, "keypress", ctx[5])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const iconbtn_changes = {};
      if (dirty & 64) {
        iconbtn_changes.$$scope = { dirty, ctx };
      }
      iconbtn.$set(iconbtn_changes);
      if (!current || dirty & 2) {
        attr(div, "style", ctx[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(iconbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(iconbtn);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$10(ctx) {
  let cross;
  let current;
  cross = new Cross$1({ props: { strokeColor: "white" } });
  return {
    c() {
      create_component(cross.$$.fragment);
    },
    m(target, anchor) {
      mount_component(cross, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(cross.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(cross.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(cross, detaching);
    }
  };
}
function create_fragment$2u(ctx) {
  var _a;
  let if_block_anchor;
  let current;
  let if_block = ((_a = ctx[0]) == null ? void 0 : _a.onDeleteClicked) && create_if_block$1q(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      if ((_a2 = ctx2[0]) == null ? void 0 : _a2.onDeleteClicked) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1q(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
let iconSize = 14;
function instance$2r($$self, $$props, $$invalidate) {
  let iconBtnStyle;
  let { frame = { top: 0, left: 0, width: 0, height: 0 } } = $$props;
  let { callbacks = {} } = $$props;
  let { exclude } = $$props;
  let { el: el2 } = $$props;
  const keypress_handler = (e) => e.key === "Enter" && callbacks.onDeleteClicked(e);
  $$self.$$set = ($$props2) => {
    if ("frame" in $$props2)
      $$invalidate(2, frame = $$props2.frame);
    if ("callbacks" in $$props2)
      $$invalidate(0, callbacks = $$props2.callbacks);
    if ("exclude" in $$props2)
      $$invalidate(3, exclude = $$props2.exclude);
    if ("el" in $$props2)
      $$invalidate(4, el2 = $$props2.el);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      $$invalidate(1, iconBtnStyle = `
    position: absolute; z-index: 11000000000;
    left: ${frame.left + frame.width - iconSize / 2}px;top: ${frame.top - iconSize / 2}px; height: ${frame.height}px;
    background-color: ${exclude ? "rgba(220, 120, 40, 1)" : "rgba(40, 120, 200, 1)"};
    float: right; width: ${iconSize}px; height: ${iconSize}px;
    border: 0px; display: flex; align-items: center;
    justify-content: center; cursor: pointer;
  `);
    }
  };
  return [callbacks, iconBtnStyle, frame, exclude, el2, keypress_handler];
}
class Target extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2r, create_fragment$2u, safe_not_equal, {
      frame: 2,
      callbacks: 0,
      exclude: 3,
      el: 4
    });
  }
  get frame() {
    return this.$$.ctx[2];
  }
  set frame(frame) {
    this.$$set({ frame });
    flush();
  }
  get callbacks() {
    return this.$$.ctx[0];
  }
  set callbacks(callbacks) {
    this.$$set({ callbacks });
    flush();
  }
  get exclude() {
    return this.$$.ctx[3];
  }
  set exclude(exclude) {
    this.$$set({ exclude });
    flush();
  }
  get el() {
    return this.$$.ctx[4];
  }
  set el(el2) {
    this.$$set({ el: el2 });
    flush();
  }
}
class TagTarget extends Target$1 {
  constructor(el2, selector, overlay, isExcluded) {
    super(el2, overlay);
    this.isExcluded = false;
    this.onDeleteClicked = () => {
      let selector2 = this.selector;
      if (this.isExcluded) {
        this.overlay.excludes.remove(selector2);
      } else {
        this.overlay.includes.remove(selector2);
      }
    };
    this.selector = selector;
    this.isExcluded = isExcluded != null ? isExcluded : false;
    this.overlay = overlay;
  }
  calculateOffsetLeftTopToParent(node) {
    let offsetTop = 0;
    let offsetLeft = 0;
    while (node) {
      if (!isNaN(node.offsetTop) && !isNaN(node.offsetLeft)) {
        offsetTop += node.offsetTop;
        offsetLeft += node.offsetLeft;
      }
      node = node.offsetParent;
    }
    return { offsetTop, offsetLeft };
  }
  create(overlay) {
    let topLeftOffset = this.calculateOffsetLeftTopToParent(this.el);
    let targetFrame = {
      top: topLeftOffset.offsetTop,
      left: topLeftOffset.offsetLeft,
      width: this.el.offsetWidth,
      height: this.el.offsetHeight
    };
    this.targetView = new Target({
      target: overlay.el,
      props: {
        exclude: this.isExcluded,
        frame: targetFrame,
        el: this.el,
        callbacks: this.overlay.pageOverlay.mode !== "edit" ? {
          onDeleteClicked: this.onDeleteClicked
        } : {}
      }
    });
  }
  destroy(_overlay) {
    this.targetView.$destroy();
  }
  update(rect, overlay) {
    this.targetView.frame = {
      top: rect.y,
      left: rect.x,
      width: this.el.offsetWidth,
      height: this.el.offsetHeight
    };
  }
}
class TaggerFrameOverlay extends CanvasFrameOverlay {
  constructor(fv, el2, frameIndex, pageOverlay) {
    super(fv, el2);
    this.frameIndex = frameIndex;
    this.pageOverlay = pageOverlay;
    this.onClick = this.onClick.bind(this);
    this.setTargets();
  }
  get includes() {
    return this.pageOverlay.includes;
  }
  get excludes() {
    return this.pageOverlay.excludes;
  }
  get editSelector() {
    return this.pageOverlay._editSelector;
  }
  get mode() {
    return this.pageOverlay.mode;
  }
  async _setEditModeTargets() {
    if (!this.editSelector)
      return;
    let els = await select(this.editSelector.toJSON(), this.fv.getDoc());
    if (els.length === 0)
      return;
    let target = new TagTarget(els[0], this.editSelector, this);
    this.addTarget(target);
  }
  async _setTagModeTargets() {
    var _a, _b;
    if (this.includes) {
      for (let selector of (_a = this.includes) == null ? void 0 : _a.models) {
        try {
          let els = await select(selector.toJSON(), this.fv.getDoc());
          if (els.length === 0)
            continue;
          let target = new TagTarget(els[0], selector, this);
          this.addTarget(target);
        } catch (e) {
          console.error(e);
        }
      }
    }
    if (this.excludes) {
      for (let selector of (_b = this.excludes) == null ? void 0 : _b.models) {
        try {
          let els = await select(selector.toJSON(), this.fv.getDoc());
          if (els.length === 0)
            continue;
          let target = new TagTarget(els[0], selector, this, true);
          this.addTarget(target);
        } catch (e) {
          console.error(e);
        }
      }
    }
  }
  async setTargets() {
    this.clearTargets();
    if (this.pageOverlay.mode === "tag") {
      await this._setTagModeTargets();
    } else if (this.pageOverlay.mode === "edit") {
      await this._setEditModeTargets();
    } else {
      throw new Error(`Unknown mode ${this.pageOverlay.mode}`);
    }
  }
  async handleClickEditMode(el2, { target }) {
    if ((target == null ? void 0 : target.get()) === el2)
      return;
    if (!this.includes || !this.excludes)
      return;
    let getSelector = this.editSelector.get("type") === "css" ? getCSS$1 : getXPATH$1;
    this.editSelector.set({ value: await getSelector([el2]) });
  }
  async handleClickTagMode(el2, { target, parents, children }) {
    if ((target == null ? void 0 : target.get()) === el2)
      return;
    if (!this.includes || !this.excludes)
      return;
    let selector = new Selector$2({ type: "css", value: await getCSS$1([el2]) });
    let immediateParent = getImmediateParent(el2, parents);
    let isExcluded = immediateParent && !immediateParent.isExcluded;
    let list = isExcluded ? this.excludes : this.includes;
    list.remove(children.map((child) => child.selector));
    list.add(selector);
  }
  async onClick(el2, { target, parents, children }) {
    if (!this.includes || !this.excludes)
      return;
    if (this.frameIndex !== this.pageOverlay.frameIndex) {
      if (this.includes.length === 0 && this.excludes.length === 0) {
        this.pageOverlay.frameIndex = this.frameIndex;
      } else {
        return;
      }
    }
    if (this.mode === "tag") {
      await this.handleClickTagMode(el2, { target, parents, children });
    } else {
      await this.handleClickEditMode(el2, { target });
    }
  }
  onHover(el2, { target }) {
    if (!this.includes || !this.excludes)
      return;
    if (this.frameIndex !== this.pageOverlay.frameIndex && (this.includes.length > 0 || this.excludes.length > 0))
      return;
    if (!this.includes || !this.excludes)
      return;
    this.setHoverTarget(target && target.get() == el2 ? null : el2);
  }
  getTargetStyles(target) {
    let style = super.getTargetStyles(target);
    if (target.isExcluded)
      style.strokeStyle = "rgba(220, 120, 40, 1)";
    return style;
  }
  uninit() {
    this.targets.forEach((target) => target.destroy(this));
    super.uninit();
  }
}
class TaggerPageOverlay extends PageOverlay {
  constructor(page, tag) {
    super(page);
    this.overlays = /* @__PURE__ */ new Map();
    this._mode = "tag";
    this.setTargets = () => {
      for (let overlay of this.overlays.values()) {
        overlay.setTargets();
      }
    };
    this.updateSelectorListeners = () => {
      var _a, _b, _c, _d;
      (_a = this.includes) == null ? void 0 : _a.each((selector) => selector.off("change", this.setTargets));
      (_b = this.includes) == null ? void 0 : _b.each((selector) => selector.on("change", this.setTargets));
      (_c = this.excludes) == null ? void 0 : _c.each((selector) => selector.off("change", this.setTargets));
      (_d = this.excludes) == null ? void 0 : _d.each((selector) => selector.on("change", this.setTargets));
    };
    this._tag = tag;
    this.setSelectorListeners();
    this.setTargets();
  }
  get includes() {
    var _a;
    let selectors = (_a = this.tag) == null ? void 0 : _a.get("selectors");
    if (!selectors)
      return void 0;
    return selectors.get("includes");
  }
  get excludes() {
    var _a;
    let selectors = (_a = this.tag) == null ? void 0 : _a.get("selectors");
    if (!selectors)
      return void 0;
    return selectors.get("excludes");
  }
  get frameIndex() {
    if (!this.tag)
      return void 0;
    let frameLocator = this.tag.get("frame");
    if (typeof frameLocator === "number")
      return frameLocator;
    else
      return frameLocator.index;
  }
  set frameIndex(frameIndex) {
    this.tag.set({ frame: frameIndex });
  }
  get mode() {
    return this._mode;
  }
  get tag() {
    return this._tag;
  }
  set tag(tag) {
    this.removeSelectorListeners();
    this._tag = tag;
    this.setSelectorListeners();
    this.setTargets();
  }
  setMode(mode, selector) {
    var _a, _b, _c, _d;
    if (mode === "edit" && ((_a = this.includes) == null ? void 0 : _a.length) === 0 && ((_b = this.excludes) == null ? void 0 : _b.length) === 0)
      throw new Error("No selectors to edit");
    this._mode = mode;
    if (this._mode === "edit") {
      this._editSelector = selector != null ? selector : ((_c = this.includes) == null ? void 0 : _c.length) > 0 ? this.includes.at(-1) : (_d = this.excludes) == null ? void 0 : _d.at(-1);
    } else {
      this._editSelector = void 0;
    }
    this.setTargets();
  }
  afterInit(fv) {
    super.afterInit(fv);
    this.removeSelectorListeners();
    this.setSelectorListeners();
  }
  createFrameOverlay(fv, el2) {
    let index2 = fv.store.getIndex();
    let taggerFrameOverlay = new TaggerFrameOverlay(fv, el2, index2, this);
    this.overlays.set(fv.store.id, taggerFrameOverlay);
    return taggerFrameOverlay;
  }
  removeSelectorListeners() {
    var _a, _b, _c, _d, _e, _f;
    (_a = this.includes) == null ? void 0 : _a.off("change", this.setTargets);
    (_b = this.excludes) == null ? void 0 : _b.off("change", this.setTargets);
    (_c = this.includes) == null ? void 0 : _c.off("change", this.updateSelectorListeners);
    (_d = this.excludes) == null ? void 0 : _d.off("change", this.updateSelectorListeners);
    (_e = this.includes) == null ? void 0 : _e.each((selector) => selector.off("change", this.setTargets));
    (_f = this.excludes) == null ? void 0 : _f.each((selector) => selector.off("change", this.setTargets));
  }
  setSelectorListeners() {
    var _a, _b, _c, _d, _e, _f;
    (_a = this.includes) == null ? void 0 : _a.on("change", this.setTargets);
    (_b = this.excludes) == null ? void 0 : _b.on("change", this.setTargets);
    (_c = this.includes) == null ? void 0 : _c.on("change", this.updateSelectorListeners);
    (_d = this.excludes) == null ? void 0 : _d.on("change", this.updateSelectorListeners);
    (_e = this.includes) == null ? void 0 : _e.each((selector) => selector.on("change", this.setTargets));
    (_f = this.excludes) == null ? void 0 : _f.each((selector) => selector.on("change", this.setTargets));
  }
  afterUninit(fv) {
    super.afterUninit(fv);
    this.removeSelectorListeners();
  }
}
function getImmediateParent(el2, parents) {
  let immediateParent;
  for (let parent2 of parents) {
    let _el = parent2.get();
    if (_el.contains(el2) && (immediateParent === void 0 || (immediateParent == null ? void 0 : immediateParent.get().contains(_el)))) {
      immediateParent = parent2;
    }
  }
  return immediateParent;
}
function get_each_context$E(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  return child_ctx;
}
function create_each_block$E(ctx) {
  let td;
  let t_value = ctx[5] + "";
  let t;
  let td_colspan_value;
  let td_class_value;
  return {
    c() {
      td = element("td");
      t = text(t_value);
      attr(td, "colspan", td_colspan_value = ctx[1].length === 1 ? 100 : void 0);
      attr(td, "class", td_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx[2] ? "bbx-error" : ""));
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[5] + ""))
        set_data(t, t_value);
      if (dirty & 2 && td_colspan_value !== (td_colspan_value = ctx2[1].length === 1 ? 100 : void 0)) {
        attr(td, "colspan", td_colspan_value);
      }
      if (dirty & 4 && td_class_value !== (td_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx2[2] ? "bbx-error" : ""))) {
        attr(td, "class", td_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_fragment$2t(ctx) {
  var _a;
  let tr;
  let td;
  let t0;
  let t1;
  let each_value = (_a = ctx[1]) != null ? _a : [];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$E(get_each_context$E(ctx, each_value, i2));
  }
  return {
    c() {
      tr = element("tr");
      td = element("td");
      t0 = text(ctx[3]);
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(td, "class", "bbx-collapsed-border bbx-pad-y bbx-pad-x-2 bbx-step__header");
      set_style(td, "width", "10rem");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      append(td, t0);
      append(tr, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tr, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (dirty & 8)
        set_data(t0, ctx2[3]);
      if (dirty & 6) {
        each_value = (_a2 = ctx2[1]) != null ? _a2 : [];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$E(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$E(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(tr, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2q($$self, $$props, $$invalidate) {
  let mapperName;
  let $mapper, $$unsubscribe_mapper = noop$1, $$subscribe_mapper = () => ($$unsubscribe_mapper(), $$unsubscribe_mapper = subscribe(mapper, ($$value) => $$invalidate(4, $mapper = $$value)), mapper);
  $$self.$$.on_destroy.push(() => $$unsubscribe_mapper());
  let { mapper } = $$props;
  $$subscribe_mapper();
  let { data } = $$props;
  let { err } = $$props;
  $$self.$$set = ($$props2) => {
    if ("mapper" in $$props2)
      $$subscribe_mapper($$invalidate(0, mapper = $$props2.mapper));
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
    if ("err" in $$props2)
      $$invalidate(2, err = $$props2.err);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $$invalidate(3, mapperName = $mapper.root.expression.children[1].name);
    }
  };
  return [mapper, data, err, mapperName, $mapper];
}
class Map$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2q, create_fragment$2t, safe_not_equal, { mapper: 0, data: 1, err: 2 });
  }
}
function get_each_context$D(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2];
  return child_ctx;
}
function create_else_block$O(ctx) {
  let td;
  return {
    c() {
      td = element("td");
      attr(td, "class", "bbx-collapsed-border");
    },
    m(target, anchor) {
      insert(target, td, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_each_block$D(ctx) {
  let td;
  let t_value = ctx[2] + "";
  let t;
  let td_class_value;
  return {
    c() {
      td = element("td");
      t = text(t_value);
      attr(td, "class", td_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx[1] ? "bbx-error" : ""));
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[2] + ""))
        set_data(t, t_value);
      if (dirty & 2 && td_class_value !== (td_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx2[1] ? "bbx-error" : ""))) {
        attr(td, "class", td_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_fragment$2s(ctx) {
  let tr;
  let td;
  let t1;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$D(get_each_context$D(ctx, each_value, i2));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$O();
  }
  return {
    c() {
      tr = element("tr");
      td = element("td");
      td.textContent = "Extracted";
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      attr(td, "class", "bbx-collapsed-border bbx-pad-y bbx-pad-x-2 bbx-step__header");
      set_style(td, "width", "10rem");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      append(tr, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tr, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tr, null);
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$D(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$D(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(tr, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$O();
          each_1_else.c();
          each_1_else.m(tr, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_each(each_blocks, detaching);
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$2p($$self, $$props, $$invalidate) {
  let { data } = $$props;
  let { err } = $$props;
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("err" in $$props2)
      $$invalidate(1, err = $$props2.err);
  };
  return [data, err];
}
class Extract extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2p, create_fragment$2s, safe_not_equal, { data: 0, err: 1 });
  }
}
function create_if_block$1p(ctx) {
  let tr;
  let td0;
  let t0;
  let t1;
  let td1;
  let t2;
  let td1_class_value;
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(ctx[3]);
      t1 = space();
      td1 = element("td");
      t2 = text(ctx[1]);
      attr(td0, "class", "bbx-collapsed-border bbx-pad-y bbx-pad-x-2 bbx-step__header");
      set_style(td0, "width", "10rem");
      attr(td1, "colspan", 1e3);
      attr(td1, "class", td1_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx[2] ? "bbx-error" : ""));
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t0, ctx2[3]);
      if (dirty & 2)
        set_data(t2, ctx2[1]);
      if (dirty & 4 && td1_class_value !== (td1_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx2[2] ? "bbx-error" : ""))) {
        attr(td1, "class", td1_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_fragment$2r(ctx) {
  let if_block_anchor;
  let if_block = ctx[0] && create_if_block$1p(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1p(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2o($$self, $$props, $$invalidate) {
  let reducerExpression;
  let separatorNode;
  let reducerTitle;
  let $separatorNode, $$unsubscribe_separatorNode = noop$1, $$subscribe_separatorNode = () => ($$unsubscribe_separatorNode(), $$unsubscribe_separatorNode = subscribe(separatorNode, ($$value) => $$invalidate(6, $separatorNode = $$value)), separatorNode);
  let $reducerExpression, $$unsubscribe_reducerExpression = noop$1, $$subscribe_reducerExpression = () => ($$unsubscribe_reducerExpression(), $$unsubscribe_reducerExpression = subscribe(reducerExpression, ($$value) => $$invalidate(7, $reducerExpression = $$value)), reducerExpression);
  let $reducer, $$unsubscribe_reducer = noop$1, $$subscribe_reducer = () => ($$unsubscribe_reducer(), $$unsubscribe_reducer = subscribe(reducer, ($$value) => $$invalidate(8, $reducer = $$value)), reducer);
  $$self.$$.on_destroy.push(() => $$unsubscribe_separatorNode());
  $$self.$$.on_destroy.push(() => $$unsubscribe_reducerExpression());
  $$self.$$.on_destroy.push(() => $$unsubscribe_reducer());
  let { reducer } = $$props;
  $$subscribe_reducer();
  let { data } = $$props;
  let { err } = $$props;
  $$self.$$set = ($$props2) => {
    if ("reducer" in $$props2)
      $$subscribe_reducer($$invalidate(0, reducer = $$props2.reducer));
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
    if ("err" in $$props2)
      $$invalidate(2, err = $$props2.err);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      $$subscribe_reducerExpression($$invalidate(5, reducerExpression = $reducer == null ? void 0 : $reducer.root.expression.children[1]));
    }
    if ($$self.$$.dirty & 128) {
      $$subscribe_separatorNode($$invalidate(4, separatorNode = $reducerExpression == null ? void 0 : $reducerExpression.argList[1]));
    }
    if ($$self.$$.dirty & 192) {
      $$invalidate(3, reducerTitle = `${$reducerExpression == null ? void 0 : $reducerExpression.name}: ${$separatorNode == null ? void 0 : $separatorNode.value}`);
    }
  };
  return [
    reducer,
    data,
    err,
    reducerTitle,
    separatorNode,
    reducerExpression,
    $separatorNode,
    $reducerExpression,
    $reducer
  ];
}
class Reduce extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2o, create_fragment$2r, safe_not_equal, { reducer: 0, data: 1, err: 2 });
  }
}
function get_each_context_1$6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  child_ctx[6] = i2;
  return child_ctx;
}
function get_each_context$C(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2][0];
  child_ctx[4] = list[i2][1];
  child_ctx[6] = i2;
  return child_ctx;
}
function create_else_block$N(ctx) {
  let div;
  let span;
  let t0_value = `${ctx[3] ? ctx[3] + ": " : ""}`;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4_value = ctx[2] ? "," : "";
  let t4;
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(ctx[0]);
      t3 = space();
      t4 = text(t4_value);
      attr(span, "class", "bbx-semi-bold");
      set_style(div, "margin-left", ctx[1] * 0.5 + "rem");
      set_style(div, "white-space", "nowrap");
      set_style(div, "overflow", "hidden");
      set_style(div, "text-overflow", "ellipsis");
      set_style(div, "width", "fit-content");
      set_style(div, "max-width", "20rem");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t0);
      append(div, t1);
      append(div, t2);
      append(div, t3);
      append(div, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t0_value !== (t0_value = `${ctx2[3] ? ctx2[3] + ": " : ""}`))
        set_data(t0, t0_value);
      if (dirty & 1)
        set_data(t2, ctx2[0]);
      if (dirty & 4 && t4_value !== (t4_value = ctx2[2] ? "," : ""))
        set_data(t4, t4_value);
      if (dirty & 2) {
        set_style(div, "margin-left", ctx2[1] * 0.5 + "rem");
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$$(ctx) {
  let div0;
  let span0;
  let t0_value = `${ctx[3] ? ctx[3] + ": " : ""}`;
  let t0;
  let t1;
  let span1;
  let t3;
  let t4;
  let div1;
  let span2;
  let t5_value = `]${ctx[2] ? "," : ""}`;
  let t5;
  let current;
  let each_value_1 = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div0 = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      span1.textContent = `${"["}`;
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t4 = space();
      div1 = element("div");
      span2 = element("span");
      t5 = text(t5_value);
      set_style(span1, "color", "var(--bs-primary)");
      attr(div0, "class", "bbx-semi-bold");
      set_style(div0, "margin-left", ctx[1] * 0.5 + "rem");
      set_style(span2, "color", "var(--bs-primary)");
      attr(div1, "class", "bbx-semi-bold");
      set_style(div1, "margin-left", ctx[1] * 0.5 + "rem");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, span0);
      append(span0, t0);
      append(div0, t1);
      append(div0, span1);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t4, anchor);
      insert(target, div1, anchor);
      append(div1, span2);
      append(span2, t5);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 8) && t0_value !== (t0_value = `${ctx2[3] ? ctx2[3] + ": " : ""}`))
        set_data(t0, t0_value);
      if (!current || dirty & 2) {
        set_style(div0, "margin-left", ctx2[1] * 0.5 + "rem");
      }
      if (dirty & 3) {
        each_value_1 = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$6(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$6(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t4.parentNode, t4);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if ((!current || dirty & 4) && t5_value !== (t5_value = `]${ctx2[2] ? "," : ""}`))
        set_data(t5, t5_value);
      if (!current || dirty & 2) {
        set_style(div1, "margin-left", ctx2[1] * 0.5 + "rem");
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block$1o(ctx) {
  let div0;
  let span0;
  let t0_value = `${ctx[3] ? ctx[3] + ": " : ""}`;
  let t0;
  let t1;
  let span1;
  let t3;
  let t4;
  let div1;
  let span2;
  let t5_value = `}${ctx[2] ? "," : ""}`;
  let t5;
  let current;
  let each_value = Object.entries(ctx[0]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$C(get_each_context$C(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div0 = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      span1.textContent = `${"{"}`;
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t4 = space();
      div1 = element("div");
      span2 = element("span");
      t5 = text(t5_value);
      set_style(span1, "color", "var(--bbx-color-warn)");
      attr(div0, "class", "bbx-semi-bold");
      set_style(div0, "margin-left", ctx[1] * 0.5 + "rem");
      set_style(span2, "color", "var(--bbx-color-warn)");
      attr(div1, "class", "bbx-semi-bold");
      set_style(div1, "margin-left", ctx[1] * 0.5 + "rem");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, span0);
      append(span0, t0);
      append(div0, t1);
      append(div0, span1);
      insert(target, t3, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, t4, anchor);
      insert(target, div1, anchor);
      append(div1, span2);
      append(span2, t5);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 8) && t0_value !== (t0_value = `${ctx2[3] ? ctx2[3] + ": " : ""}`))
        set_data(t0, t0_value);
      if (!current || dirty & 2) {
        set_style(div0, "margin-left", ctx2[1] * 0.5 + "rem");
      }
      if (dirty & 3) {
        each_value = Object.entries(ctx2[0]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$C(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$C(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(t4.parentNode, t4);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if ((!current || dirty & 4) && t5_value !== (t5_value = `}${ctx2[2] ? "," : ""}`))
        set_data(t5, t5_value);
      if (!current || dirty & 2) {
        set_style(div1, "margin-left", ctx2[1] * 0.5 + "rem");
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(div1);
    }
  };
}
function create_each_block_1$6(ctx) {
  let pojo;
  let current;
  pojo = new POJO({
    props: {
      value: ctx[4],
      level: ctx[1] + 1,
      appendComma: ctx[6] < ctx[0].length - 1
    }
  });
  return {
    c() {
      create_component(pojo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pojo, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pojo_changes = {};
      if (dirty & 1)
        pojo_changes.value = ctx2[4];
      if (dirty & 2)
        pojo_changes.level = ctx2[1] + 1;
      if (dirty & 1)
        pojo_changes.appendComma = ctx2[6] < ctx2[0].length - 1;
      pojo.$set(pojo_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pojo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pojo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pojo, detaching);
    }
  };
}
function create_each_block$C(ctx) {
  let pojo;
  let current;
  pojo = new POJO({
    props: {
      key: ctx[3],
      value: ctx[4],
      level: ctx[1] + 1,
      appendComma: ctx[6] < Object.keys(ctx[0]).length - 1
    }
  });
  return {
    c() {
      create_component(pojo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pojo, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pojo_changes = {};
      if (dirty & 1)
        pojo_changes.key = ctx2[3];
      if (dirty & 1)
        pojo_changes.value = ctx2[4];
      if (dirty & 2)
        pojo_changes.level = ctx2[1] + 1;
      if (dirty & 1)
        pojo_changes.appendComma = ctx2[6] < Object.keys(ctx2[0]).length - 1;
      pojo.$set(pojo_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pojo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pojo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pojo, detaching);
    }
  };
}
function create_fragment$2q(ctx) {
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$1o, create_if_block_1$$, create_else_block$N];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 1)
      show_if = null;
    if (dirty & 1)
      show_if_1 = null;
    if (show_if == null)
      show_if = !!isPojo(ctx2[0]);
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!Array.isArray(ctx2[0]);
    if (show_if_1)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function isPojo(obj) {
  if (obj === null || typeof obj !== "object") {
    return false;
  }
  return Object.getPrototypeOf(obj) === Object.prototype;
}
function instance$2n($$self, $$props, $$invalidate) {
  let { key = null } = $$props;
  let { value } = $$props;
  let { level = 0 } = $$props;
  let { appendComma = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(3, key = $$props2.key);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("level" in $$props2)
      $$invalidate(1, level = $$props2.level);
    if ("appendComma" in $$props2)
      $$invalidate(2, appendComma = $$props2.appendComma);
  };
  return [value, level, appendComma, key];
}
class POJO extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2n, create_fragment$2q, safe_not_equal, {
      key: 3,
      value: 0,
      level: 1,
      appendComma: 2
    });
  }
}
function get_each_context$B(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2];
  return child_ctx;
}
function create_else_block$M(ctx) {
  let t_value = ctx[2] + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[2] + ""))
        set_data(t, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$1n(ctx) {
  let pojo;
  let current;
  pojo = new POJO({ props: { value: ctx[2] } });
  return {
    c() {
      create_component(pojo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pojo, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pojo_changes = {};
      if (dirty & 1)
        pojo_changes.value = ctx2[2];
      pojo.$set(pojo_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pojo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pojo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pojo, detaching);
    }
  };
}
function create_each_block$B(ctx) {
  let td;
  let current_block_type_index;
  let if_block;
  let t;
  let td_colspan_value;
  let td_class_value;
  let current;
  const if_block_creators = [create_if_block$1n, create_else_block$M];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].constructor === {}.constructor)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      td = element("td");
      if_block.c();
      t = space();
      attr(td, "colspan", td_colspan_value = ctx[0].length === 1 ? 1e3 : void 0);
      attr(td, "class", td_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx[1] ? "bbx-error" : ""));
    },
    m(target, anchor) {
      insert(target, td, anchor);
      if_blocks[current_block_type_index].m(td, null);
      append(td, t);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(td, t);
      }
      if (!current || dirty & 1 && td_colspan_value !== (td_colspan_value = ctx2[0].length === 1 ? 1e3 : void 0)) {
        attr(td, "colspan", td_colspan_value);
      }
      if (!current || dirty & 2 && td_class_value !== (td_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx2[1] ? "bbx-error" : ""))) {
        attr(td, "class", td_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(td);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_fragment$2p(ctx) {
  let tr;
  let td;
  let t1;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$B(get_each_context$B(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      tr = element("tr");
      td = element("td");
      td.textContent = "Final Data";
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(td, "class", "bbx-collapsed-border bbx-pad-y bbx-pad-x-2 bbx-step__header");
      set_style(td, "width", "10rem");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      append(tr, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tr, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$B(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$B(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(tr, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$2m($$self, $$props, $$invalidate) {
  let { data } = $$props;
  let { err } = $$props;
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("err" in $$props2)
      $$invalidate(1, err = $$props2.err);
  };
  return [data, err];
}
class Final extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2m, create_fragment$2p, safe_not_equal, { data: 0, err: 1 });
  }
}
function get_each_context$A(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_if_block$1m(ctx) {
  let tr;
  let td;
  let t0;
  let t1;
  let t2;
  let current;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$A(get_each_context$A(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      tr = element("tr");
      td = element("td");
      t0 = text("Parse: ");
      t1 = text(ctx[2]);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(td, "class", "bbx-collapsed-border bbx-pad-y bbx-pad-x-2 bbx-step__header");
      set_style(td, "width", "10rem");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      append(td, t0);
      append(td, t1);
      append(tr, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tr, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 4)
        set_data(t1, ctx2[2]);
      if (dirty & 10) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$A(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$A(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(tr, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block$L(ctx) {
  let t_value = ctx[4] + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[4] + ""))
        set_data(t, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$_(ctx) {
  let pojo;
  let current;
  pojo = new POJO({ props: { value: ctx[4] } });
  return {
    c() {
      create_component(pojo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pojo, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pojo_changes = {};
      if (dirty & 2)
        pojo_changes.value = ctx2[4];
      pojo.$set(pojo_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pojo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pojo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pojo, detaching);
    }
  };
}
function create_each_block$A(ctx) {
  let td;
  let current_block_type_index;
  let if_block;
  let t;
  let td_colspan_value;
  let td_class_value;
  let current;
  const if_block_creators = [create_if_block_1$_, create_else_block$L];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4].constructor === {}.constructor)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      td = element("td");
      if_block.c();
      t = space();
      attr(td, "colspan", td_colspan_value = ctx[1].length === 1 ? 1e3 : void 0);
      attr(td, "class", td_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx[3] ? "bbx-error" : ""));
    },
    m(target, anchor) {
      insert(target, td, anchor);
      if_blocks[current_block_type_index].m(td, null);
      append(td, t);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(td, t);
      }
      if (!current || dirty & 2 && td_colspan_value !== (td_colspan_value = ctx2[1].length === 1 ? 1e3 : void 0)) {
        attr(td, "colspan", td_colspan_value);
      }
      if (!current || dirty & 8 && td_class_value !== (td_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx2[3] ? "bbx-error" : ""))) {
        attr(td, "class", td_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(td);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_fragment$2o(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block$1m(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1m(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2l($$self, $$props, $$invalidate) {
  let { parser } = $$props;
  let { data } = $$props;
  let { dataType } = $$props;
  let { err } = $$props;
  $$self.$$set = ($$props2) => {
    if ("parser" in $$props2)
      $$invalidate(0, parser = $$props2.parser);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
    if ("dataType" in $$props2)
      $$invalidate(2, dataType = $$props2.dataType);
    if ("err" in $$props2)
      $$invalidate(3, err = $$props2.err);
  };
  return [parser, data, dataType, err];
}
class Parse extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2l, create_fragment$2o, safe_not_equal, { parser: 0, data: 1, dataType: 2, err: 3 });
  }
}
function get_each_context$z(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2];
  return child_ctx;
}
function create_if_block$1l(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$z(get_each_context$z(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$z(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$z(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_else_block$K(ctx) {
  let t_value = ctx[2] + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[2] + ""))
        set_data(t, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$Z(ctx) {
  let pojo;
  let current;
  pojo = new POJO({ props: { value: ctx[2] } });
  return {
    c() {
      create_component(pojo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pojo, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pojo_changes = {};
      if (dirty & 1)
        pojo_changes.value = ctx2[2];
      pojo.$set(pojo_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pojo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pojo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pojo, detaching);
    }
  };
}
function create_each_block$z(ctx) {
  let td;
  let current_block_type_index;
  let if_block;
  let t;
  let td_colspan_value;
  let td_class_value;
  let current;
  const if_block_creators = [create_if_block_1$Z, create_else_block$K];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].constructor === {}.constructor)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      td = element("td");
      if_block.c();
      t = space();
      attr(td, "colspan", td_colspan_value = ctx[0].length === 1 ? 1e3 : void 0);
      attr(td, "class", td_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx[1] ? "bbx-error" : ""));
    },
    m(target, anchor) {
      insert(target, td, anchor);
      if_blocks[current_block_type_index].m(td, null);
      append(td, t);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(td, t);
      }
      if (!current || dirty & 1 && td_colspan_value !== (td_colspan_value = ctx2[0].length === 1 ? 1e3 : void 0)) {
        attr(td, "colspan", td_colspan_value);
      }
      if (!current || dirty & 2 && td_class_value !== (td_class_value = "bbx-collapsed-border bbx-pad-x-2 " + (ctx2[1] ? "bbx-error" : ""))) {
        attr(td, "class", td_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(td);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_fragment$2n(ctx) {
  let tr;
  let td;
  let t1;
  let current;
  let if_block = ctx[0] && create_if_block$1l(ctx);
  return {
    c() {
      tr = element("tr");
      td = element("td");
      td.textContent = "Validated";
      t1 = space();
      if (if_block)
        if_block.c();
      attr(td, "class", "bbx-collapsed-border bbx-pad-y bbx-pad-x-2 bbx-step__header");
      set_style(td, "width", "10rem");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      append(tr, t1);
      if (if_block)
        if_block.m(tr, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1l(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(tr, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$2k($$self, $$props, $$invalidate) {
  let { data } = $$props;
  let { err } = $$props;
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("err" in $$props2)
      $$invalidate(1, err = $$props2.err);
  };
  return [data, err];
}
class Validate extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2k, create_fragment$2n, safe_not_equal, { data: 0, err: 1 });
  }
}
function get_each_context$y(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i2];
  child_ctx[26] = i2;
  return child_ctx;
}
function create_if_block$1k(ctx) {
  let div;
  let current;
  let if_block = ctx[0] && create_if_block_1$Y(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      set_style(div, "height", "200px");
      set_style(div, "background-color", "var(--bbx-color-menu-bg)");
      set_style(div, "overflow", "auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$Y(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$Y(ctx) {
  let table;
  let extract;
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let reducer_1;
  let t2;
  let parser_1;
  let t3;
  let validate;
  let t4;
  let final;
  let current;
  extract = new Extract({
    props: {
      data: ctx[3].extract,
      err: ctx[4].extract
    }
  });
  let each_value = ctx[8].models;
  const get_key = (ctx2) => ctx2[24];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$y(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$y(key, child_ctx));
  }
  reducer_1 = new Reduce({
    props: {
      reducer: ctx[6],
      data: ctx[3].reducer,
      err: ctx[4].reducer
    }
  });
  parser_1 = new Parse({
    props: {
      parser: ctx[5],
      dataType: ctx[7].data_type,
      data: ctx[3].parser,
      err: ctx[4].parser
    }
  });
  validate = new Validate({
    props: {
      data: ctx[3].validator,
      err: ctx[4].validator
    }
  });
  final = new Final({
    props: {
      data: ctx[3].final,
      err: ctx[4].final
    }
  });
  return {
    c() {
      table = element("table");
      create_component(extract.$$.fragment);
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      create_component(reducer_1.$$.fragment);
      t2 = space();
      create_component(parser_1.$$.fragment);
      t3 = space();
      create_component(validate.$$.fragment);
      t4 = space();
      create_component(final.$$.fragment);
      attr(table, "class", "bbx-w-full bbx-collapsed-border");
      set_style(table, "height", "fit-content");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      mount_component(extract, table, null);
      append(table, t0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(table, null);
        }
      }
      append(table, t1);
      mount_component(reducer_1, table, null);
      append(table, t2);
      mount_component(parser_1, table, null);
      append(table, t3);
      mount_component(validate, table, null);
      append(table, t4);
      mount_component(final, table, null);
      current = true;
    },
    p(ctx2, dirty) {
      const extract_changes = {};
      if (dirty & 8)
        extract_changes.data = ctx2[3].extract;
      if (dirty & 16)
        extract_changes.err = ctx2[4].extract;
      extract.$set(extract_changes);
      if (dirty & 280) {
        each_value = ctx2[8].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, table, outro_and_destroy_block, create_each_block$y, t1, get_each_context$y);
        check_outros();
      }
      const reducer_1_changes = {};
      if (dirty & 64)
        reducer_1_changes.reducer = ctx2[6];
      if (dirty & 8)
        reducer_1_changes.data = ctx2[3].reducer;
      if (dirty & 16)
        reducer_1_changes.err = ctx2[4].reducer;
      reducer_1.$set(reducer_1_changes);
      const parser_1_changes = {};
      if (dirty & 32)
        parser_1_changes.parser = ctx2[5];
      if (dirty & 128)
        parser_1_changes.dataType = ctx2[7].data_type;
      if (dirty & 8)
        parser_1_changes.data = ctx2[3].parser;
      if (dirty & 16)
        parser_1_changes.err = ctx2[4].parser;
      parser_1.$set(parser_1_changes);
      const validate_changes = {};
      if (dirty & 8)
        validate_changes.data = ctx2[3].validator;
      if (dirty & 16)
        validate_changes.err = ctx2[4].validator;
      validate.$set(validate_changes);
      const final_changes = {};
      if (dirty & 8)
        final_changes.data = ctx2[3].final;
      if (dirty & 16)
        final_changes.err = ctx2[4].final;
      final.$set(final_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(extract.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(reducer_1.$$.fragment, local);
      transition_in(parser_1.$$.fragment, local);
      transition_in(validate.$$.fragment, local);
      transition_in(final.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(extract.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(reducer_1.$$.fragment, local);
      transition_out(parser_1.$$.fragment, local);
      transition_out(validate.$$.fragment, local);
      transition_out(final.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      destroy_component(extract);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      destroy_component(reducer_1);
      destroy_component(parser_1);
      destroy_component(validate);
      destroy_component(final);
    }
  };
}
function create_each_block$y(key_1, ctx) {
  let first2;
  let mapper;
  let current;
  mapper = new Map$1({
    props: {
      mapper: ctx[24],
      data: ctx[3].mappers[ctx[26]],
      err: ctx[4].mappers === ctx[26]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(mapper.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(mapper, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const mapper_changes = {};
      if (dirty & 256)
        mapper_changes.mapper = ctx[24];
      if (dirty & 264)
        mapper_changes.data = ctx[3].mappers[ctx[26]];
      if (dirty & 272)
        mapper_changes.err = ctx[4].mappers === ctx[26];
      mapper.$set(mapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(mapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(mapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(mapper, detaching);
    }
  };
}
function create_fragment$2m(ctx) {
  let div3;
  let div2;
  let div0;
  let angleright;
  let t0;
  let div1;
  let t2;
  let current;
  let mounted;
  let dispose;
  angleright = new AngleRight({
    props: {
      strokeColor: "white",
      class: ctx[2] ? "bbx-rotate-90" : ""
    }
  });
  let if_block = ctx[2] && create_if_block$1k(ctx);
  return {
    c() {
      var _a, _b;
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      create_component(angleright.$$.fragment);
      t0 = space();
      div1 = element("div");
      div1.textContent = "Preview";
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "bbx-flex bbx-center");
      attr(div1, "class", "bbx-header bbx-semi-bold");
      attr(div2, "class", "bbx-pad bbx-pad-x-2 bbx-flex bbx-gap");
      set_style(div2, "background-color", "var(--bbx-color-gray)");
      set_style(div2, "color", "var(--bbx-color-menu-bg)");
      set_style(div2, "cursor", "pointer");
      set_style(div3, "position", "absolute");
      set_style(div3, "bottom", "0");
      set_style(div3, "width", "calc(100% - " + ((_b = (_a = ctx[1]) == null ? void 0 : _a.width) != null ? _b : 0) + "px)");
      set_style(div3, "z-index", "9999999999");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      mount_component(angleright, div0, null);
      append(div2, t0);
      append(div2, div1);
      append(div3, t2);
      if (if_block)
        if_block.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div2, "click", ctx[12]),
          listen(div2, "keypress", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a, _b;
      const angleright_changes = {};
      if (dirty & 4)
        angleright_changes.class = ctx2[2] ? "bbx-rotate-90" : "";
      angleright.$set(angleright_changes);
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1k(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div3, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 2) {
        set_style(div3, "width", "calc(100% - " + ((_b = (_a = ctx2[1]) == null ? void 0 : _a.width) != null ? _b : 0) + "px)");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(angleright.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(angleright.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(angleright);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2j($$self, $$props, $$invalidate) {
  var _a;
  let reducer;
  let parser;
  let $activeTag, $$unsubscribe_activeTag = noop$1, $$subscribe_activeTag = () => ($$unsubscribe_activeTag(), $$unsubscribe_activeTag = subscribe(activeTag, ($$value) => $$invalidate(7, $activeTag = $$value)), activeTag);
  let $mappers;
  let $procs;
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeTag());
  const browserView = getContext("browserView");
  let { activeTag } = $$props;
  $$subscribe_activeTag();
  let { sidebarRect } = $$props;
  const procs = $activeTag == null ? void 0 : $activeTag.procs;
  component_subscribe($$self, procs, (value) => $$invalidate(11, $procs = value));
  const mappers = $procs == null ? void 0 : $procs.mappers;
  component_subscribe($$self, mappers, (value) => $$invalidate(8, $mappers = value));
  let listenerManager;
  let frameView, pageView, open = true;
  let data = {
    extract: [],
    mappers: ((_a = $mappers == null ? void 0 : $mappers.models) != null ? _a : []).map((_2) => [""]),
    reducer: "",
    parser: [],
    final: []
  };
  let err = {
    extract: false,
    mappers: -1,
    reducer: false,
    parser: false,
    final: false
  };
  const _updateData = async () => {
    let res = await getData();
    $$invalidate(3, data = res.data);
    $$invalidate(4, err = res.err);
  };
  const updateData = debounce$1(_updateData, 10);
  async function getData() {
    var _a2, _b, _c, _d;
    let data2 = {
      extract: [],
      mappers: ((_a2 = $mappers == null ? void 0 : $mappers.models) != null ? _a2 : []).map((_2) => [""]),
      reducer: "",
      parser: [],
      validator: "",
      final: []
    };
    let err2 = {
      extract: false,
      mappers: -1,
      reducer: false,
      parser: false,
      validator: false,
      final: false
    };
    if (!activeTag || !frameView) {
      return { data: data2, err: err2 };
    }
    let tagJSON = activeTag.toJSON();
    let newDocument = frameView.getDoc().cloneNode(true);
    try {
      data2.extract = extractData(tagJSON, newDocument);
    } catch (e) {
      data2.extract = [e.message];
      err2.extract = true;
      return { data: data2, err: err2 };
    }
    let prevRes = data2.extract;
    for (let i2 = 0; i2 < ((_b = tagJSON.procs.mappers) == null ? void 0 : _b.length); i2++) {
      let _tagJSON = structuredClone(tagJSON);
      _tagJSON.procs.mappers = tagJSON.procs.mappers.slice(i2, i2 + 1);
      try {
        data2.mappers[i2] = await applyMappers$1(_tagJSON, prevRes);
        prevRes = data2.mappers[i2];
      } catch (e) {
        data2.mappers[i2] = [e.message];
        err2.mappers = i2;
        return { data: data2, err: err2 };
      }
    }
    let reducer2 = (_c = activeTag.get("procs")) == null ? void 0 : _c.get("reducer");
    if (reducer2) {
      try {
        data2.reducer = (await applyReducers$1(tagJSON, prevRes)).toString();
        prevRes = data2.reducer;
      } catch (e) {
        data2.reducer = e.message;
        err2.reducer = true;
        return { data: data2, err: err2 };
      }
    }
    let parser2 = (_d = activeTag.get("procs")) == null ? void 0 : _d.get("parser");
    if (parser2) {
      try {
        data2.parser = await applyParser$1(tagJSON, prevRes);
        if (!Array.isArray(data2.parser))
          data2.parser = [data2.parser];
        prevRes = data2.parser;
      } catch (e) {
        data2.parser = [e.message];
        err2.parser = true;
        return { data: data2, err: err2 };
      }
    }
    let validator = activeTag.get("procs").get("validator");
    if (validator) {
      try {
        await validateTagData$1(tagJSON, prevRes);
        data2.validator = !Array.isArray(prevRes) ? [prevRes] : prevRes;
      } catch (e) {
        data2.validator = [e.message];
        err2.validator = true;
        return { data: data2, err: err2 };
      }
    }
    try {
      data2.final = await processTagData(tagJSON, newDocument);
      if (!Array.isArray(data2.final))
        data2.final = [data2.final];
    } catch (e) {
      data2.final = [e.message];
      err2.final = false;
    }
    return { data: data2, err: err2 };
  }
  function onFrameAdded() {
    var _a2;
    let frameLocator = (_a2 = $activeTag == null ? void 0 : $activeTag.frame) != null ? _a2 : 0;
    let frameIndex = typeof frameLocator === "number" ? frameLocator : frameLocator.index;
    frameView = pageView.getFrame(pageView.store.frames[frameIndex].id);
    if (!frameView)
      return;
    frameView.on("document_ready", updateData);
    updateData();
  }
  function onPageAdded() {
    pageView = browserView.getPage(-1);
    if (!pageView)
      return;
    pageView.on("frameadded", onFrameAdded);
    onFrameAdded();
  }
  onMount(() => {
    listenerManager = ListenerManager(activeTag, updateData);
    listenerManager.set();
    updateData();
  });
  onDestroy(() => {
    listenerManager == null ? void 0 : listenerManager.remove();
    frameView == null ? void 0 : frameView.off("document_ready", updateData);
    pageView == null ? void 0 : pageView.off("frameadded", onFrameAdded);
    browserView == null ? void 0 : browserView.off("pageadded", onPageAdded);
  });
  const click_handler = () => $$invalidate(2, open = !open);
  const keypress_handler = (e) => e.key === "Enter" && $$invalidate(2, open = !open);
  $$self.$$set = ($$props2) => {
    if ("activeTag" in $$props2)
      $$subscribe_activeTag($$invalidate(0, activeTag = $$props2.activeTag));
    if ("sidebarRect" in $$props2)
      $$invalidate(1, sidebarRect = $$props2.sidebarRect);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2048) {
      $$invalidate(6, reducer = $procs == null ? void 0 : $procs.reducer);
    }
    if ($$self.$$.dirty & 2048) {
      $$invalidate(5, parser = $procs == null ? void 0 : $procs.parser);
    }
    if ($$self.$$.dirty & 2048) {
      $procs == null ? void 0 : $procs.validator;
    }
  };
  if (browserView) {
    browserView.on("pageadded", onPageAdded);
    onPageAdded();
  }
  return [
    activeTag,
    sidebarRect,
    open,
    data,
    err,
    parser,
    reducer,
    $activeTag,
    $mappers,
    procs,
    mappers,
    $procs,
    click_handler,
    keypress_handler
  ];
}
class Preview$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2j, create_fragment$2m, safe_not_equal, { activeTag: 0, sidebarRect: 1 });
  }
}
function create_if_block$1j(ctx) {
  let div2;
  let div0;
  let t1;
  let div1;
  let pojo;
  let current;
  pojo = new POJO({ props: { value: ctx[0] } });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "Scrape Data";
      t1 = space();
      div1 = element("div");
      create_component(pojo.$$.fragment);
      attr(div0, "class", "bbx-semi-bold");
      attr(div1, "class", "bbx-pad bbx-bg-light");
      attr(div2, "class", "bbx-flex-col bbx-gap bbx-pad");
      set_style(div2, "border-top", "solid 1px var(--bbx-color-border) ");
      set_style(div2, "height", "30%");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      mount_component(pojo, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const pojo_changes = {};
      if (dirty & 1)
        pojo_changes.value = ctx2[0];
      pojo.$set(pojo_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pojo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pojo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(pojo);
    }
  };
}
function create_fragment$2l(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block$1j(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1j(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2i($$self, $$props, $$invalidate) {
  let { scrapeData } = $$props;
  $$self.$$set = ($$props2) => {
    if ("scrapeData" in $$props2)
      $$invalidate(0, scrapeData = $$props2.scrapeData);
  };
  return [scrapeData];
}
class ScrapeResult extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2i, create_fragment$2l, safe_not_equal, { scrapeData: 0 });
  }
}
function create_else_block$J(ctx) {
  let recordercomponent;
  let t;
  let scraperesult;
  let current;
  recordercomponent = new Recorder$1({
    props: {
      disablePointer: ctx[16],
      expressionTree: ctx[0],
      findSelector: ctx[1],
      getRecorder: ctx[17],
      getPlayer: ctx[18],
      url: ctx[12].url,
      params: ctx[3],
      optInParams: ctx[4]
    }
  });
  recordercomponent.$on("replayEnd", ctx[19]);
  scraperesult = new ScrapeResult({
    props: { scrapeData: ctx[9] }
  });
  return {
    c() {
      create_component(recordercomponent.$$.fragment);
      t = space();
      create_component(scraperesult.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recordercomponent, target, anchor);
      insert(target, t, anchor);
      mount_component(scraperesult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recordercomponent_changes = {};
      if (dirty[0] & 1)
        recordercomponent_changes.expressionTree = ctx2[0];
      if (dirty[0] & 2)
        recordercomponent_changes.findSelector = ctx2[1];
      if (dirty[0] & 4096)
        recordercomponent_changes.url = ctx2[12].url;
      if (dirty[0] & 8)
        recordercomponent_changes.params = ctx2[3];
      if (dirty[0] & 16)
        recordercomponent_changes.optInParams = ctx2[4];
      recordercomponent.$set(recordercomponent_changes);
      const scraperesult_changes = {};
      if (dirty[0] & 512)
        scraperesult_changes.scrapeData = ctx2[9];
      scraperesult.$set(scraperesult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recordercomponent.$$.fragment, local);
      transition_in(scraperesult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recordercomponent.$$.fragment, local);
      transition_out(scraperesult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recordercomponent, detaching);
      if (detaching)
        detach(t);
      destroy_component(scraperesult, detaching);
    }
  };
}
function create_if_block_1$X(ctx) {
  let schemacomponent;
  let current;
  schemacomponent = new Schema({
    props: {
      schemaList: ctx[2],
      activeSchema: ctx[6],
      activeTag: ctx[7],
      createSchema: ctx[14],
      createTag: ctx[15],
      setActiveSchema: ctx[20],
      setActiveTag: ctx[21]
    }
  });
  return {
    c() {
      create_component(schemacomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(schemacomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const schemacomponent_changes = {};
      if (dirty[0] & 4)
        schemacomponent_changes.schemaList = ctx2[2];
      if (dirty[0] & 64)
        schemacomponent_changes.activeSchema = ctx2[6];
      if (dirty[0] & 128)
        schemacomponent_changes.activeTag = ctx2[7];
      schemacomponent.$set(schemacomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(schemacomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(schemacomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(schemacomponent, detaching);
    }
  };
}
function create_if_block$1i(ctx) {
  let previous_key = ctx[7];
  let key_block_anchor;
  let current;
  let key_block = create_key_block$5(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128 && safe_not_equal(previous_key, previous_key = ctx2[7])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$5(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_key_block$5(ctx) {
  let preview;
  let current;
  preview = new Preview$1({
    props: {
      activeTag: ctx[7],
      sidebarRect: ctx[11]
    }
  });
  return {
    c() {
      create_component(preview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(preview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const preview_changes = {};
      if (dirty[0] & 128)
        preview_changes.activeTag = ctx2[7];
      if (dirty[0] & 2048)
        preview_changes.sidebarRect = ctx2[11];
      preview.$set(preview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(preview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(preview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(preview, detaching);
    }
  };
}
function create_fragment$2k(ctx) {
  let div;
  let ul;
  let li0;
  let a0;
  let t0;
  let a0_class_value;
  let t1;
  let li1;
  let a1;
  let t2;
  let a1_class_value;
  let t3;
  let current_block_type_index;
  let if_block0;
  let t4;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$X, create_else_block$J];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[10])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[10] && create_if_block$1i(ctx);
  return {
    c() {
      div = element("div");
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      t0 = text("Tagger");
      t1 = space();
      li1 = element("li");
      a1 = element("a");
      t2 = text("Recorder");
      t3 = space();
      if_block0.c();
      t4 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(a0, "class", a0_class_value = "nav-link " + (ctx[10] ? "active" : ""));
      attr(a0, "href", "#");
      attr(li0, "class", "nav-item");
      attr(a1, "class", a1_class_value = "nav-link " + (!ctx[10] ? "active" : ""));
      attr(a1, "href", "#");
      attr(li1, "class", "nav-item");
      attr(ul, "class", "nav nav-tabs");
      set_style(ul, "background", "var(--bbx-color-menu-bg)");
      attr(div, "class", "bbx-sidebar");
      toggle_class(div, "active", ctx[8]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ul);
      append(ul, li0);
      append(li0, a0);
      append(a0, t0);
      append(ul, t1);
      append(ul, li1);
      append(li1, a1);
      append(a1, t2);
      append(div, t3);
      if_blocks[current_block_type_index].m(div, null);
      ctx[29](div);
      insert(target, t4, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(li0, "click", ctx[25]),
          listen(li0, "keydown", ctx[26]),
          listen(li1, "click", ctx[27]),
          listen(li1, "keydown", ctx[28])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & 1024 && a0_class_value !== (a0_class_value = "nav-link " + (ctx2[10] ? "active" : ""))) {
        attr(a0, "class", a0_class_value);
      }
      if (!current || dirty[0] & 1024 && a1_class_value !== (a1_class_value = "nav-link " + (!ctx2[10] ? "active" : ""))) {
        attr(a1, "class", a1_class_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, null);
      }
      if (!current || dirty[0] & 256) {
        toggle_class(div, "active", ctx2[8]);
      }
      if (ctx2[10]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1i(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      ctx[29](null);
      if (detaching)
        detach(t4);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2h($$self, $$props, $$invalidate) {
  let sidebarRect;
  let $taggerOverlay;
  let $activeSchema, $$unsubscribe_activeSchema = noop$1, $$subscribe_activeSchema = () => ($$unsubscribe_activeSchema(), $$unsubscribe_activeSchema = subscribe(activeSchema, ($$value) => $$invalidate(12, $activeSchema = $$value)), activeSchema);
  let $schemaList, $$unsubscribe_schemaList = noop$1, $$subscribe_schemaList = () => ($$unsubscribe_schemaList(), $$unsubscribe_schemaList = subscribe(schemaList, ($$value) => $$invalidate(31, $schemaList = $$value)), schemaList);
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeSchema());
  $$self.$$.on_destroy.push(() => $$unsubscribe_schemaList());
  let { browserView } = $$props;
  let { expressionTree } = $$props;
  let { findSelector } = $$props;
  let { schemaList } = $$props;
  $$subscribe_schemaList();
  let { params: params2 } = $$props;
  let { url } = $$props;
  let { optInParams: optInParams2 } = $$props;
  if (schemaList.length === 0)
    createSchema();
  if (expressionTree.expression.children.length === 0) {
    expressionTree.expression.insertAt(0, ["wait_doc"]);
    expressionTree.expression.insertAt(1, ["scrape", schemaList.at(0).get("id")]);
  }
  let activeSchema = schemaList.at(0);
  $$subscribe_activeSchema();
  let activeTag;
  let isPointerDisabled = false;
  let scrapeData;
  let sidebarComponent;
  let tagMode = true;
  if ($activeSchema.tags.length > 0) {
    setActiveTag($activeSchema.tags.at(0));
  }
  const taggerOverlay = writable();
  component_subscribe($$self, taggerOverlay, (value) => $$invalidate(30, $taggerOverlay = value));
  setContext("browserView", browserView);
  setContext("expressionCtx", {
    replace: {
      skipControl: false,
      stepNames: [...Object.keys(stepDefs), ...Object.keys(scraperDefs)],
      defaultStep: "click",
      defaultExprs: {
        scrape: ["scrape", activeSchema.get("id")],
        and: ["and", ["element_exists"]],
        or: ["or", ["element_exists"]],
        not: ["not", ["element_exists"]],
        "if..else": ["cond", [["or", ["and", ["element_exists"]]]]],
        "while loop": ["while", ["or", ["and", ["element_exists"]]], []],
        "for loop": ["for", "item", ["range", 10, 0, 1], []]
      }
    }
  });
  setContext("setActiveSchema", setActiveSchema);
  setContext("schemaList", schemaList);
  setContext("setTagMode", setTagMode);
  setContext("taggerOverlay", taggerOverlay);
  setContext("createSchema", createSchema);
  setContext("replaceSchemas", replaceSchemas);
  function createSchema(name = "Default") {
    schemaList.create({ name, url, tags: [] });
    return schemaList.at(-1);
  }
  function replaceSchemas(newSchemas) {
    return schemaList.replaceAll(newSchemas);
  }
  function createTag() {
    $activeSchema.tags.create({
      version: "0",
      name: getNewTagName($activeSchema.tags),
      parent: "",
      data_type: Type.string,
      frame: 0,
      selectors: {
        includes: [],
        excludes: [],
        fields: { type: "text" }
      },
      procs: {
        mappers: [],
        reducer: ["join", "$val", "\\n"],
        validator: { required: false, exprs: [] },
        parsers: {}
      }
    });
    setActiveTag($activeSchema.tags.at(-1));
  }
  function disablePointer(disable = true) {
    $$invalidate(8, isPointerDisabled = disable);
  }
  function getRecorder(bv, findSelector2, tree, params3) {
    return new Base(bv, findSelector2, tree, { optInParams: optInParams2, params: params3 });
  }
  function getPlayer(bv, opts) {
    return new Player(expressionTree, new BrowserImpl(bv), new Scraper$1(bv, $schemaList.models), opts);
  }
  function onBrowserReady() {
    $taggerOverlay == null ? void 0 : $taggerOverlay.setActive(false);
    set_store_value(taggerOverlay, $taggerOverlay = new TaggerPageOverlay(browserView.getPage(-1)), $taggerOverlay);
    $taggerOverlay.setActive(tagMode);
    set_store_value(taggerOverlay, $taggerOverlay.tag = activeTag, $taggerOverlay);
  }
  function replayCallback({ detail }) {
    $$invalidate(9, scrapeData = detail);
  }
  function setActiveSchema(_activeSchema) {
    $$subscribe_activeSchema($$invalidate(6, activeSchema = _activeSchema));
    if ($activeSchema.tags.length > 0) {
      setActiveTag($activeSchema.tags.at(0));
    } else {
      setActiveTag();
    }
  }
  function setActiveTag(_activeTag) {
    $$invalidate(7, activeTag = _activeTag);
    if ($taggerOverlay) {
      set_store_value(taggerOverlay, $taggerOverlay.tag = activeTag, $taggerOverlay);
    }
  }
  function setTagMode(_tagMode) {
    $$invalidate(10, tagMode = _tagMode);
    $taggerOverlay == null ? void 0 : $taggerOverlay.setActive(tagMode);
  }
  onBrowserReady();
  const click_handler = () => setTagMode(true);
  const keydown_handler = (e) => {
    if (e.key === "Enter")
      setTagMode(true);
  };
  const click_handler_1 = () => setTagMode(false);
  const keydown_handler_1 = (e) => {
    if (e.key === "Enter")
      setTagMode(true);
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      sidebarComponent = $$value;
      $$invalidate(5, sidebarComponent);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("browserView" in $$props2)
      $$invalidate(23, browserView = $$props2.browserView);
    if ("expressionTree" in $$props2)
      $$invalidate(0, expressionTree = $$props2.expressionTree);
    if ("findSelector" in $$props2)
      $$invalidate(1, findSelector = $$props2.findSelector);
    if ("schemaList" in $$props2)
      $$subscribe_schemaList($$invalidate(2, schemaList = $$props2.schemaList));
    if ("params" in $$props2)
      $$invalidate(3, params2 = $$props2.params);
    if ("url" in $$props2)
      $$invalidate(24, url = $$props2.url);
    if ("optInParams" in $$props2)
      $$invalidate(4, optInParams2 = $$props2.optInParams);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 32) {
      $$invalidate(11, sidebarRect = sidebarComponent == null ? void 0 : sidebarComponent.getBoundingClientRect());
    }
  };
  return [
    expressionTree,
    findSelector,
    schemaList,
    params2,
    optInParams2,
    sidebarComponent,
    activeSchema,
    activeTag,
    isPointerDisabled,
    scrapeData,
    tagMode,
    sidebarRect,
    $activeSchema,
    taggerOverlay,
    createSchema,
    createTag,
    disablePointer,
    getRecorder,
    getPlayer,
    replayCallback,
    setActiveSchema,
    setActiveTag,
    setTagMode,
    browserView,
    url,
    click_handler,
    keydown_handler,
    click_handler_1,
    keydown_handler_1,
    div_binding
  ];
}
class App$2 extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$2h,
      create_fragment$2k,
      safe_not_equal,
      {
        browserView: 23,
        expressionTree: 0,
        findSelector: 1,
        schemaList: 2,
        params: 3,
        url: 24,
        optInParams: 4
      },
      null,
      [-1, -1]
    );
  }
}
const get_tb_l_slot_changes$1 = (dirty) => ({});
const get_tb_l_slot_context$1 = (ctx) => ({});
const get_tb_url_l_slot_changes$1 = (dirty) => ({});
const get_tb_url_l_slot_context$1 = (ctx) => ({});
const get_tb_url_r_slot_changes$1 = (dirty) => ({});
const get_tb_url_r_slot_context$1 = (ctx) => ({});
const get_tb_r_l_slot_changes$1 = (dirty) => ({});
const get_tb_r_l_slot_context$1 = (ctx) => ({});
const get_tb_r_r_slot_changes$1 = (dirty) => ({});
const get_tb_r_r_slot_context$1 = (ctx) => ({});
const get_tb_save_slot_changes$1 = (dirty) => ({ onSave: dirty & 8192 });
const get_tb_save_slot_context$1 = (ctx) => ({
  slot: "tb-save",
  onSave: ctx[13]
});
function create_tb_l_slot$1(ctx) {
  let current;
  const tb_l_slot_template = ctx[16]["tb-l"];
  const tb_l_slot = create_slot(tb_l_slot_template, ctx, ctx[17], get_tb_l_slot_context$1);
  return {
    c() {
      if (tb_l_slot)
        tb_l_slot.c();
    },
    m(target, anchor) {
      if (tb_l_slot) {
        tb_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_l_slot) {
        if (tb_l_slot.p && (!current || dirty & 131072)) {
          update_slot_base(
            tb_l_slot,
            tb_l_slot_template,
            ctx2,
            ctx2[17],
            !current ? get_all_dirty_from_scope(ctx2[17]) : get_slot_changes(tb_l_slot_template, ctx2[17], dirty, get_tb_l_slot_changes$1),
            get_tb_l_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_l_slot)
        tb_l_slot.d(detaching);
    }
  };
}
function create_tb_url_l_slot$1(ctx) {
  let current;
  const tb_url_l_slot_template = ctx[16]["tb-url-l"];
  const tb_url_l_slot = create_slot(tb_url_l_slot_template, ctx, ctx[17], get_tb_url_l_slot_context$1);
  return {
    c() {
      if (tb_url_l_slot)
        tb_url_l_slot.c();
    },
    m(target, anchor) {
      if (tb_url_l_slot) {
        tb_url_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_url_l_slot) {
        if (tb_url_l_slot.p && (!current || dirty & 131072)) {
          update_slot_base(
            tb_url_l_slot,
            tb_url_l_slot_template,
            ctx2,
            ctx2[17],
            !current ? get_all_dirty_from_scope(ctx2[17]) : get_slot_changes(tb_url_l_slot_template, ctx2[17], dirty, get_tb_url_l_slot_changes$1),
            get_tb_url_l_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_url_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_url_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_url_l_slot)
        tb_url_l_slot.d(detaching);
    }
  };
}
function create_tb_url_r_slot$2(ctx) {
  let current;
  const tb_url_r_slot_template = ctx[16]["tb-url-r"];
  const tb_url_r_slot = create_slot(tb_url_r_slot_template, ctx, ctx[17], get_tb_url_r_slot_context$1);
  return {
    c() {
      if (tb_url_r_slot)
        tb_url_r_slot.c();
    },
    m(target, anchor) {
      if (tb_url_r_slot) {
        tb_url_r_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_url_r_slot) {
        if (tb_url_r_slot.p && (!current || dirty & 131072)) {
          update_slot_base(
            tb_url_r_slot,
            tb_url_r_slot_template,
            ctx2,
            ctx2[17],
            !current ? get_all_dirty_from_scope(ctx2[17]) : get_slot_changes(tb_url_r_slot_template, ctx2[17], dirty, get_tb_url_r_slot_changes$1),
            get_tb_url_r_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_url_r_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_url_r_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_url_r_slot)
        tb_url_r_slot.d(detaching);
    }
  };
}
function create_tb_r_l_slot$1(ctx) {
  let current;
  const tb_r_l_slot_template = ctx[16]["tb-r-l"];
  const tb_r_l_slot = create_slot(tb_r_l_slot_template, ctx, ctx[17], get_tb_r_l_slot_context$1);
  return {
    c() {
      if (tb_r_l_slot)
        tb_r_l_slot.c();
    },
    m(target, anchor) {
      if (tb_r_l_slot) {
        tb_r_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_r_l_slot) {
        if (tb_r_l_slot.p && (!current || dirty & 131072)) {
          update_slot_base(
            tb_r_l_slot,
            tb_r_l_slot_template,
            ctx2,
            ctx2[17],
            !current ? get_all_dirty_from_scope(ctx2[17]) : get_slot_changes(tb_r_l_slot_template, ctx2[17], dirty, get_tb_r_l_slot_changes$1),
            get_tb_r_l_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_r_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_r_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_r_l_slot)
        tb_r_l_slot.d(detaching);
    }
  };
}
function create_tb_r_r_slot$1(ctx) {
  let current;
  const tb_r_r_slot_template = ctx[16]["tb-r-r"];
  const tb_r_r_slot = create_slot(tb_r_r_slot_template, ctx, ctx[17], get_tb_r_r_slot_context$1);
  return {
    c() {
      if (tb_r_r_slot)
        tb_r_r_slot.c();
    },
    m(target, anchor) {
      if (tb_r_r_slot) {
        tb_r_r_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_r_r_slot) {
        if (tb_r_r_slot.p && (!current || dirty & 131072)) {
          update_slot_base(
            tb_r_r_slot,
            tb_r_r_slot_template,
            ctx2,
            ctx2[17],
            !current ? get_all_dirty_from_scope(ctx2[17]) : get_slot_changes(tb_r_r_slot_template, ctx2[17], dirty, get_tb_r_r_slot_changes$1),
            get_tb_r_r_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_r_r_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_r_r_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_r_r_slot)
        tb_r_r_slot.d(detaching);
    }
  };
}
function fallback_block$3(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Save";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-sm btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[13]))
            ctx[13].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_tb_save_slot$1(ctx) {
  let current;
  const tb_save_slot_template = ctx[16]["tb-save"];
  const tb_save_slot = create_slot(tb_save_slot_template, ctx, ctx[17], get_tb_save_slot_context$1);
  const tb_save_slot_or_fallback = tb_save_slot || fallback_block$3(ctx);
  return {
    c() {
      if (tb_save_slot_or_fallback)
        tb_save_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (tb_save_slot_or_fallback) {
        tb_save_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_save_slot) {
        if (tb_save_slot.p && (!current || dirty & 139264)) {
          update_slot_base(
            tb_save_slot,
            tb_save_slot_template,
            ctx2,
            ctx2[17],
            !current ? get_all_dirty_from_scope(ctx2[17]) : get_slot_changes(tb_save_slot_template, ctx2[17], dirty, get_tb_save_slot_changes$1),
            get_tb_save_slot_context$1
          );
        }
      } else {
        if (tb_save_slot_or_fallback && tb_save_slot_or_fallback.p && (!current || dirty & 8192)) {
          tb_save_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_save_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(tb_save_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (tb_save_slot_or_fallback)
        tb_save_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block$1h(ctx) {
  let app;
  let current;
  app = new App$2({
    props: {
      browserView: ctx[8],
      expressionTree: ctx[9],
      findSelector: ctx[2],
      schemaList: ctx[4],
      params: ctx[10],
      url: ctx[6],
      optInParams: ctx[7]
    }
  });
  return {
    c() {
      create_component(app.$$.fragment);
    },
    m(target, anchor) {
      mount_component(app, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const app_changes = {};
      if (dirty & 256)
        app_changes.browserView = ctx2[8];
      if (dirty & 4)
        app_changes.findSelector = ctx2[2];
      if (dirty & 16)
        app_changes.schemaList = ctx2[4];
      if (dirty & 64)
        app_changes.url = ctx2[6];
      if (dirty & 128)
        app_changes.optInParams = ctx2[7];
      app.$set(app_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(app.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(app.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(app, detaching);
    }
  };
}
function create_browser_r_slot$1(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[8] && create_if_block$1h(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1h(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$2j(ctx) {
  let browsercontainer;
  let current;
  browsercontainer = new BrowserContainer({
    props: {
      bbx: ctx[0],
      class: ctx[1],
      onCancel: ctx[12],
      onSave: ctx[13],
      proxy: ctx[3],
      session: ctx[5],
      url: ctx[6],
      $$slots: {
        "browser-r": [create_browser_r_slot$1],
        "tb-save": [
          create_tb_save_slot$1,
          ({ onSave }) => ({ 13: onSave }),
          ({ onSave }) => onSave ? 8192 : 0
        ],
        "tb-r-r": [create_tb_r_r_slot$1],
        "tb-r-l": [create_tb_r_l_slot$1],
        "tb-url-r": [create_tb_url_r_slot$2],
        "tb-url-l": [create_tb_url_l_slot$1],
        "tb-l": [create_tb_l_slot$1]
      },
      $$scope: { ctx }
    }
  });
  browsercontainer.$on("ready", ctx[11]);
  return {
    c() {
      create_component(browsercontainer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(browsercontainer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const browsercontainer_changes = {};
      if (dirty & 1)
        browsercontainer_changes.bbx = ctx2[0];
      if (dirty & 2)
        browsercontainer_changes.class = ctx2[1];
      if (dirty & 8)
        browsercontainer_changes.proxy = ctx2[3];
      if (dirty & 32)
        browsercontainer_changes.session = ctx2[5];
      if (dirty & 64)
        browsercontainer_changes.url = ctx2[6];
      if (dirty & 139732) {
        browsercontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      browsercontainer.$set(browsercontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(browsercontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(browsercontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(browsercontainer, detaching);
    }
  };
}
function instance$2g($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  const _Msg = getContext("Msg");
  const Msg2 = new MsgClass(_Msg);
  setContext("Msg", Msg2);
  let { bbx } = $$props;
  let { class: clazz = "" } = $$props;
  let { findSelector } = $$props;
  let { initialSteps = [] } = $$props;
  let { initialParams = [] } = $$props;
  let { proxy = void 0 } = $$props;
  let { schemaList } = $$props;
  let { session = void 0 } = $$props;
  let { url } = $$props;
  let { optInParams: optInParams2 = false } = $$props;
  const expressionTree = parseSteps(initialSteps, { declarations: initialParams });
  const params2 = new Params$2(expressionTree.declarations);
  let browserView;
  function onBrowserContainerReady(event) {
    $$invalidate(8, browserView = event.detail);
    dispatch("ready", event.detail);
  }
  function onCancel() {
    dispatch("cancel");
  }
  function onSave() {
    let children = expressionTree.expression.children;
    if (children.length === 0 || !hasScrape(children[children.length - 1])) {
      Msg2.error("Can't save: the final step of the macro must be scrape.");
      throw new Error("Can't save: the final step of the macro must be scrape");
    }
    let steps;
    try {
      steps = expressionTree.toJSON();
    } catch (e) {
      Msg2.error("Cannot save steps with errors. Please resolve ");
      throw e;
    }
    dispatch("save", {
      steps,
      schemaList,
      params: params2.toJSON()
    });
  }
  $$self.$$set = ($$props2) => {
    if ("bbx" in $$props2)
      $$invalidate(0, bbx = $$props2.bbx);
    if ("class" in $$props2)
      $$invalidate(1, clazz = $$props2.class);
    if ("findSelector" in $$props2)
      $$invalidate(2, findSelector = $$props2.findSelector);
    if ("initialSteps" in $$props2)
      $$invalidate(14, initialSteps = $$props2.initialSteps);
    if ("initialParams" in $$props2)
      $$invalidate(15, initialParams = $$props2.initialParams);
    if ("proxy" in $$props2)
      $$invalidate(3, proxy = $$props2.proxy);
    if ("schemaList" in $$props2)
      $$invalidate(4, schemaList = $$props2.schemaList);
    if ("session" in $$props2)
      $$invalidate(5, session = $$props2.session);
    if ("url" in $$props2)
      $$invalidate(6, url = $$props2.url);
    if ("optInParams" in $$props2)
      $$invalidate(7, optInParams2 = $$props2.optInParams);
    if ("$$scope" in $$props2)
      $$invalidate(17, $$scope = $$props2.$$scope);
  };
  return [
    bbx,
    clazz,
    findSelector,
    proxy,
    schemaList,
    session,
    url,
    optInParams2,
    browserView,
    expressionTree,
    params2,
    onBrowserContainerReady,
    onCancel,
    onSave,
    initialSteps,
    initialParams,
    slots,
    $$scope
  ];
}
class Index$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2g, create_fragment$2j, safe_not_equal, {
      bbx: 0,
      class: 1,
      findSelector: 2,
      initialSteps: 14,
      initialParams: 15,
      proxy: 3,
      schemaList: 4,
      session: 5,
      url: 6,
      optInParams: 7
    });
  }
}
function create_if_block$1g(ctx) {
  let recordermodal;
  let current;
  recordermodal = new Modal$1({
    props: {
      widthClass: "modal-fullscreen",
      $$slots: { default: [create_default_slot$$] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(recordermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recordermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recordermodal_changes = {};
      if (dirty & 8388831) {
        recordermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      recordermodal.$set(recordermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recordermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recordermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recordermodal, detaching);
    }
  };
}
function create_catch_block$t(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$t(ctx) {
  let previous_key = ctx[6];
  let key_block_anchor;
  let current;
  let key_block = create_key_block$4(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 64 && safe_not_equal(previous_key, previous_key = ctx2[6])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$4(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_key_block$4(ctx) {
  let div;
  let scraper;
  let current;
  scraper = new Index$1({
    props: {
      bbx: ctx[1],
      initialSteps: ctx[3],
      initialParams: ctx[4],
      optInParams,
      schemaList: ctx[2],
      url: ctx[0].fields.uri.get().href,
      findSelector: ctx[11]
    }
  });
  scraper.$on("save", ctx[12]);
  scraper.$on("cancel", ctx[13]);
  return {
    c() {
      div = element("div");
      create_component(scraper.$$.fragment);
      attr(div, "class", "w-100");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(scraper, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const scraper_changes = {};
      if (dirty & 2)
        scraper_changes.bbx = ctx2[1];
      if (dirty & 8)
        scraper_changes.initialSteps = ctx2[3];
      if (dirty & 16)
        scraper_changes.initialParams = ctx2[4];
      if (dirty & 4)
        scraper_changes.schemaList = ctx2[2];
      if (dirty & 1)
        scraper_changes.url = ctx2[0].fields.uri.get().href;
      scraper.$set(scraper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scraper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scraper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(scraper);
    }
  };
}
function create_pending_block$t(ctx) {
  let loader;
  let t0;
  let div;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
      t0 = space();
      div = element("div");
      div.textContent = "Initializing Scraper";
      attr(div, "class", "fs-2 pt-2 text-center");
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$$(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$t,
    then: create_then_block$t,
    catch: create_catch_block$t,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[7], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 128 && promise !== (promise = ctx[7]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$2i(ctx) {
  let selectorurledit;
  let t;
  let if_block_anchor;
  let current;
  selectorurledit = new SelectorUrlEdit({
    props: {
      model: ctx[8],
      uri: ctx[9],
      placeholder: TXT("Enter URL of a webpage"),
      disableGo: false
    }
  });
  selectorurledit.$on("go", ctx[14]);
  let if_block = ctx[5] && create_if_block$1g(ctx);
  return {
    c() {
      create_component(selectorurledit.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(selectorurledit, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1g(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(selectorurledit.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(selectorurledit.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(selectorurledit, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
let optInParams = true;
function composeTagsPayload(newTags, oldTags) {
  const payload = { inserts: [], updates: [], deletes: [] };
  newTags.forEach((tag) => {
    const oldTag = oldTags.find((oldTag2) => oldTag2.id === tag.id);
    if (oldTag) {
      payload.updates.push(tag);
    } else {
      payload.inserts.push(tag);
    }
  });
  oldTags.forEach((oldTag) => {
    const newTag = newTags.find((newTag2) => newTag2.id === oldTag.id);
    if (!newTag) {
      payload.deletes.push(oldTag);
    }
  });
  return payload;
}
function getParamsConfig(params2) {
  const values2 = {};
  params2.forEach((param) => {
    values2[param.name] = param.default || "";
  });
  return values2;
}
function instance$2f($$self, $$props, $$invalidate) {
  let $model;
  const dispatch = createEventDispatcher();
  let { formModel } = $$props;
  setContext("Msg", Msg);
  let bbx;
  let allSchemaList = [];
  let oldSchemaList = getModel([]);
  let initialSteps = [];
  let initialParams = [];
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(16, $model = value));
  const { uri } = formModel.fields;
  let showSelector = false;
  let rerender = false;
  let initPromise;
  async function init2() {
    var _a, _b;
    try {
      Msg.reset();
      if ($model.macro_id) {
        const macroDetails = await getMacro();
        if (macroDetails) {
          $$invalidate(3, initialSteps = macroDetails.steps || []);
          $$invalidate(4, initialParams = macroDetails.spec.params || []);
        }
      }
      if ($model.id) {
        const schemaDetails = await getSchema();
        if (schemaDetails) {
          $$invalidate(2, oldSchemaList = getModel((_a = schemaDetails.data) != null ? _a : []));
          allSchemaList = (_b = schemaDetails.data) != null ? _b : [];
        }
      }
      $$invalidate(1, bbx = await createBBX());
    } catch (e) {
      $$invalidate(5, showSelector = false);
      Msg.error("Failed to initialize scraper. Please try again later.");
    }
  }
  async function findSelector(el2, type = "css") {
    return type === "css" ? new CSSSelector(await getCSS([el2], el2.ownerDocument)) : new XPathSelector(await getXpath([el2], el2.ownerDocument));
  }
  async function createBBX() {
    try {
      let res = await Api.api("/selectors2", "POST");
      window.addEventListener("beforeunload", deleteBBX);
      return res;
    } catch (e) {
      console.error("Failed to create BBX", e);
      Msg.error("Cannot start the Browser right now, please retry in some time");
      throw new Error("Failed to start browser", { cause: e });
    }
  }
  async function deleteBBX() {
    if (bbx) {
      let selectorStopActivateAPI = `/selectors2/${bbx.id}`;
      try {
        await Api.api(selectorStopActivateAPI, "DELETE");
      } catch (e) {
        console.error("Stop Request failed", e);
      } finally {
        window.removeEventListener("beforeunload", deleteBBX);
      }
    }
  }
  async function getSchema() {
    var _a;
    try {
      let sieveSchemas = await Api.api(`/sieve-schemas/sieves/${$model.id}?state.in[0]=${C$1.STATE_DEFAULT}&state.in[1]=${C$1.STATE_READY}`, "GET");
      if (sieveSchemas && ((_a = sieveSchemas.data) == null ? void 0 : _a.length) > 0) {
        const schemaIds = sieveSchemas.data.map((item) => item.schema_id);
        const queryStr = schemaIds.map((id2, index2) => `id.in[${index2}]=${id2}`).join("&");
        let res = await Api.api(`/schemas?${queryStr}`, "GET");
        return res;
      }
      return null;
    } catch (e) {
      console.error("Failed to get schema: ", e);
    }
  }
  async function getMacro() {
    try {
      return await Api.api(`/macros/${$model.macro_id}`, "GET");
    } catch (e) {
      console.error("Failed to get schema: ", e);
    }
  }
  function composeSchemaPayload(schemas) {
    const payload = { inserts: [], updates: [], deletes: [] };
    schemas.forEach((schema) => {
      const oldSchema = allSchemaList.find((oldSchema2) => oldSchema2.id === schema.id);
      if (oldSchema) {
        payload.updates.push({
          ...schema,
          tags: composeTagsPayload(schema.tags, oldSchema.tags)
        });
      } else {
        payload.inserts.push({
          ...schema,
          tags: { inserts: schema.tags }
        });
      }
    });
    allSchemaList.forEach((oldSchema) => {
      const newSchema = schemas.find((newSchema2) => newSchema2.id === oldSchema.id);
      if (!newSchema) {
        payload.deletes.push(oldSchema);
      }
    });
    return payload;
  }
  async function onSave({ detail }) {
    const { steps, params: params2, schemaList } = detail;
    const schemas = schemaList.toJSON();
    const schemasIds = schemas.map((schema) => schema.id);
    model.set("schemas", composeSchemaPayload(schemas));
    model.set("schema_ids", schemasIds);
    model.set("macro", { steps, spec: { params: params2 } });
    $$invalidate(5, showSelector = false);
    $$invalidate(4, initialParams = params2);
    model.set("config", {
      params: getParamsConfig(params2),
      filters: { included: ["."] }
    });
    dispatch("save");
  }
  function onCancel() {
    $$invalidate(5, showSelector = false);
    dispatch("discard");
  }
  onDestroy(async () => {
    await deleteBBX();
  });
  const go_handler = () => {
    $$invalidate(5, showSelector = true);
    $$invalidate(6, rerender = !rerender);
    if (!bbx) {
      $$invalidate(7, initPromise = init2());
    }
  };
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
  };
  return [
    formModel,
    bbx,
    oldSchemaList,
    initialSteps,
    initialParams,
    showSelector,
    rerender,
    initPromise,
    model,
    uri,
    init2,
    findSelector,
    onSave,
    onCancel,
    go_handler
  ];
}
class Visual_tagger extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2f, create_fragment$2i, safe_not_equal, { formModel: 0 });
  }
}
function create_content_slot$2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [{ formModel: ctx[0] }, ctx[4]];
  var switch_value = ctx[3].component;
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props());
    switch_instance.$on("save", ctx[5]);
    switch_instance.$on("discard", ctx[6]);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty & 17 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 1 && { formModel: ctx2[0] },
        dirty & 16 && get_spread_object(ctx2[4])
      ]) : {};
      if (switch_value !== (switch_value = ctx2[3].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props());
          switch_instance.$on("save", ctx2[5]);
          switch_instance.$on("discard", ctx2[6]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_fragment$2h(ctx) {
  let sieveoptionslayout;
  let current;
  sieveoptionslayout = new Layout({
    props: {
      title: !ctx[1] && `${TXT("l_source")} - ${ctx[3].title}`,
      $$slots: { content: [create_content_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(sieveoptionslayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveoptionslayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sieveoptionslayout_changes = {};
      if (dirty & 2)
        sieveoptionslayout_changes.title = !ctx2[1] && `${TXT("l_source")} - ${ctx2[3].title}`;
      if (dirty & 4113) {
        sieveoptionslayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sieveoptionslayout.$set(sieveoptionslayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveoptionslayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveoptionslayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveoptionslayout, detaching);
    }
  };
}
function instance$2e($$self, $$props, $$invalidate) {
  const omit_props_names = ["formModel", "hideTitle"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $model;
  let { formModel } = $$props;
  let { hideTitle = false } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(7, $model = value));
  const type = getType();
  const getJSONSourceComponent = () => {
    if ($model.datasource_id === C$1.DS_ID_SCRAPER) {
      return {
        title: "Scraper",
        component: Visual_tagger
      };
    } else if ($model.datasource_id === C$1.DS_ID_UPTIME) {
      return { title: "Uptime", component: Json };
    } else
      return { title: "JSON", component: Json };
  };
  const sources = {
    [C$1.TYPE_HTML]: {
      title: "Webpage",
      component: Html
    },
    [C$1.TYPE_FEED]: { title: "Feed", component: Feed_1 },
    [C$1.TYPE_XML]: { title: "XML", component: Xml },
    [C$1.TYPE_PDF_HTML]: { title: "PDF", component: Pdf },
    [C$1.TYPE_DOC]: {
      title: "Word Document",
      component: Doc
    },
    [C$1.TYPE_JSON]: getJSONSourceComponent(),
    [C$1.TYPE_SITEMAP]: {
      title: "Sitemap",
      component: Sitemap
    }
  };
  const selected = sources[type];
  function getType() {
    if (!$model.content_type) {
      return C$1.TYPE_HTML;
    }
    if ($model.content_type === C$1.TYPE_JSON && ![C$1.DS_ID_JSON, C$1.DS_ID_UPTIME, C$1.DS_ID_SCRAPER].includes($model.datasource_id)) {
      return C$1.TYPE_HTML;
    }
    return $model.content_type;
  }
  function save_handler(event) {
    bubble.call(this, $$self, event);
  }
  function discard_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("formModel" in $$new_props)
      $$invalidate(0, formModel = $$new_props.formModel);
    if ("hideTitle" in $$new_props)
      $$invalidate(1, hideTitle = $$new_props.hideTitle);
  };
  return [
    formModel,
    hideTitle,
    model,
    selected,
    $$restProps,
    save_handler,
    discard_handler
  ];
}
class SourceSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2e, create_fragment$2h, safe_not_equal, { formModel: 0, hideTitle: 1 });
  }
}
function create_default_slot$_(ctx) {
  let div;
  let ruleeditor;
  let updating_rule;
  let current;
  function ruleeditor_rule_binding(value) {
    ctx[4](value);
  }
  let ruleeditor_props = { global: true };
  if (ctx[1] !== void 0) {
    ruleeditor_props.rule = ctx[1];
  }
  ruleeditor = new RuleEditor({ props: ruleeditor_props });
  binding_callbacks.push(() => bind$1(ruleeditor, "rule", ruleeditor_rule_binding));
  ruleeditor.$on("close", ctx[5]);
  return {
    c() {
      div = element("div");
      create_component(ruleeditor.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(ruleeditor, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleeditor_changes = {};
      if (!updating_rule && dirty & 2) {
        updating_rule = true;
        ruleeditor_changes.rule = ctx2[1];
        add_flush_callback(() => updating_rule = false);
      }
      ruleeditor.$set(ruleeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(ruleeditor);
    }
  };
}
function create_header_slot$i(ctx) {
  let t;
  return {
    c() {
      t = text("Global Conditions");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_sub_header_slot$3(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "used for all monitors and combined with each monitor's conditions";
      attr(small, "class", "text-body-secondary");
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment$2g(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      isDialog: false,
      onSave: ctx[3],
      $$slots: {
        "sub-header": [create_sub_header_slot$3],
        header: [create_header_slot$i],
        default: [create_default_slot$_]
      },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[2]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 514) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$2d($$self, $$props, $$invalidate) {
  let $rule, $$unsubscribe_rule = noop$1, $$subscribe_rule = () => ($$unsubscribe_rule(), $$unsubscribe_rule = subscribe(rule, ($$value) => $$invalidate(6, $rule = $$value)), rule);
  let $user;
  $$self.$$.on_destroy.push(() => $$unsubscribe_rule());
  const dispatch = createEventDispatcher();
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(7, $user = value));
  let rule;
  onMount(() => {
    if (!$user.id) {
      close();
      alert("Please sign in to save global conditions");
    }
  });
  function close() {
    dispatch("close");
  }
  async function save() {
    let version = $rule.version;
    let config = $rule.config.toJSON();
    try {
      await Api.api("/prefs/rule", "PUT", { ...config, version });
      $$invalidate(0, user.attributes.prefs.rule = { ...config, version }, user);
      close();
    } catch (e) {
      console.error(e);
      Msg.error("Failed to save data, please try again later");
    }
  }
  function ruleeditor_rule_binding(value) {
    rule = value;
    $$subscribe_rule($$invalidate(1, rule));
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  return [user, rule, close, save, ruleeditor_rule_binding, close_handler];
}
class GlobalRuleEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2d, create_fragment$2g, safe_not_equal, {});
  }
}
const get_header_right_slot_changes = (dirty) => ({
  globalRuleModel: dirty & 64
});
const get_header_right_slot_context = (ctx) => ({
  globalRuleModel: ctx[6],
  setGlobalCount: ctx[12]
});
function create_catch_block$s(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$s(ctx) {
  let div2;
  let t0;
  let div0;
  let t1;
  let t2;
  let div1;
  let select2;
  let option0;
  let t3;
  let option1;
  let t4;
  let select_value_value;
  let t5;
  let current_block_type_index;
  let if_block1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[2] && create_if_block_3$y(ctx);
  const header_right_slot_template = ctx[14]["header-right"];
  const header_right_slot = create_slot(header_right_slot_template, ctx, ctx[13], get_header_right_slot_context);
  const if_block_creators = [create_if_block_1$W, create_if_block_2$G];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[7].version === ctx2[8])
      return 0;
    if (ctx2[7].version === ctx2[9])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      if (header_right_slot)
        header_right_slot.c();
      t2 = space();
      div1 = element("div");
      select2 = element("select");
      option0 = element("option");
      t3 = text("V1 (classic)");
      option1 = element("option");
      t4 = text("V2 (modern)");
      t5 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(div0, "class", "flex-grow-1");
      option0.__value = ctx[8];
      option0.value = option0.__value;
      option1.__value = ctx[9];
      option1.value = option1.__value;
      attr(select2, "class", "form-select form-select-sm");
      attr(div2, "class", "d-flex align-items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t0);
      append(div2, div0);
      append(div2, t1);
      if (header_right_slot) {
        header_right_slot.m(div2, null);
      }
      append(div2, t2);
      append(div2, div1);
      append(div1, select2);
      append(select2, option0);
      append(option0, t3);
      append(select2, option1);
      append(option1, t4);
      select_option(select2, ctx[7].version);
      insert(target, t5, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(select2, "change", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$y(ctx2);
          if_block0.c();
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (header_right_slot) {
        if (header_right_slot.p && (!current || dirty & 8256)) {
          update_slot_base(
            header_right_slot,
            header_right_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(header_right_slot_template, ctx2[13], dirty, get_header_right_slot_changes),
            get_header_right_slot_context
          );
        }
      }
      if (!current || dirty & 896 && select_value_value !== (select_value_value = ctx2[7].version)) {
        select_option(select2, ctx2[7].version);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        } else {
          if_block1 = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_right_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(header_right_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if (header_right_slot)
        header_right_slot.d(detaching);
      if (detaching)
        detach(t5);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$y(ctx) {
  let div;
  let a;
  let t0;
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      a = element("a");
      t0 = text("Global Conditions: ");
      t1 = text(ctx[5]);
      attr(a, "href", "#");
      attr(div, "class", "p-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[15]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t1, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$G(ctx) {
  let sieveruleseditorv2;
  let current;
  sieveruleseditorv2 = new SieveRulesEditorV2$1({
    props: {
      inputs: ctx[2] ? getGlobalConditionInputs() : ctx[3],
      config: ctx[7].config
    }
  });
  return {
    c() {
      create_component(sieveruleseditorv2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv2_changes = {};
      if (dirty & 12)
        sieveruleseditorv2_changes.inputs = ctx2[2] ? getGlobalConditionInputs() : ctx2[3];
      if (dirty & 128)
        sieveruleseditorv2_changes.config = ctx2[7].config;
      sieveruleseditorv2.$set(sieveruleseditorv2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv2, detaching);
    }
  };
}
function create_if_block_1$W(ctx) {
  let sieveruleseditorv1;
  let current;
  sieveruleseditorv1 = new SieveRulesEditorV1({
    props: { config: ctx[7].config }
  });
  return {
    c() {
      create_component(sieveruleseditorv1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv1_changes = {};
      if (dirty & 128)
        sieveruleseditorv1_changes.config = ctx2[7].config;
      sieveruleseditorv1.$set(sieveruleseditorv1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv1, detaching);
    }
  };
}
function create_pending_block$s(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_if_block$1f(ctx) {
  let globalruleeditormodal;
  let current;
  globalruleeditormodal = new GlobalRuleEditorModal({});
  globalruleeditormodal.$on("close", ctx[16]);
  return {
    c() {
      create_component(globalruleeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalruleeditormodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(globalruleeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalruleeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalruleeditormodal, detaching);
    }
  };
}
function create_fragment$2f(ctx) {
  let t;
  let if_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$s,
    then: create_then_block$s,
    catch: create_catch_block$s,
    value: 21,
    blocks: [, , ,]
  };
  handle_promise(ctx[10], info);
  let if_block = ctx[4] && create_if_block$1f(ctx);
  return {
    c() {
      info.block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      info.block.m(target, info.anchor = anchor);
      info.mount = () => t.parentNode;
      info.anchor = t;
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      if (ctx[4]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1f(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      info.block.d(detaching);
      info.token = null;
      info = null;
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$2c($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop$1, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(18, $sieve = $$value)), sieve);
  let $rule, $$unsubscribe_rule = noop$1, $$subscribe_rule = () => ($$unsubscribe_rule(), $$unsubscribe_rule = subscribe(rule, ($$value) => $$invalidate(7, $rule = $$value)), rule);
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  $$self.$$.on_destroy.push(() => $$unsubscribe_rule());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { sieve = null } = $$props;
  $$subscribe_sieve();
  let { global: global2 = false } = $$props;
  let { sieveConditionInputs } = $$props;
  let { rule } = $$props;
  $$subscribe_rule();
  const { V1: V12, V2: V22 } = Model$2.SieveRule;
  const dispatch = createEventDispatcher();
  let showGlobalEditorModal = false;
  let fetchComplete;
  let pagePromise = new Promise((resolve, reject2) => {
    fetchComplete = resolve;
  });
  let globalCount = 0;
  let globalRuleModel;
  function updateVersion(e) {
    rule.setVersion(e.target.value);
  }
  async function getGlobalRuleModel() {
    try {
      let config = await Api.api("/prefs/rule") || void 0;
      Msg.reset();
      let version = null;
      if (config && !config.version) {
        version = V12;
      } else if (config && config.version) {
        version = config.version;
      } else {
        version = V22;
      }
      return new Model$2.SieveRule({ config, version }, { parse: true });
    } catch (e) {
      console.error(e);
      Msg.error("Please try again later. Failed to fetch global conditions.");
      if (global2) {
        dispatch("close");
      }
    }
  }
  async function setGlobalCount() {
    $$invalidate(6, globalRuleModel = await getGlobalRuleModel());
    if (globalRuleModel) {
      $$invalidate(5, globalCount = globalRuleModel.getCount());
    }
  }
  onMount(async () => {
    if (!rule) {
      if (global2) {
        $$subscribe_rule($$invalidate(0, rule = await getGlobalRuleModel()));
      } else {
        $$subscribe_rule($$invalidate(0, rule = new Model$2.SieveRule({ id: $sieve.rule_id || void 0 }, { parse: true })));
        await rule.fetch();
      }
    }
    fetchComplete(true);
  });
  const click_handler = () => {
    $$invalidate(4, showGlobalEditorModal = true);
  };
  const close_handler = () => {
    $$invalidate(4, showGlobalEditorModal = false);
  };
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(1, sieve = $$props2.sieve));
    if ("global" in $$props2)
      $$invalidate(2, global2 = $$props2.global);
    if ("sieveConditionInputs" in $$props2)
      $$invalidate(3, sieveConditionInputs = $$props2.sieveConditionInputs);
    if ("rule" in $$props2)
      $$subscribe_rule($$invalidate(0, rule = $$props2.rule));
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 20) {
      {
        if (App.user.isLoggedIn() && !global2 && !showGlobalEditorModal) {
          setGlobalCount();
        }
      }
    }
  };
  return [
    rule,
    sieve,
    global2,
    sieveConditionInputs,
    showGlobalEditorModal,
    globalCount,
    globalRuleModel,
    $rule,
    V12,
    V22,
    pagePromise,
    updateVersion,
    setGlobalCount,
    $$scope,
    slots,
    click_handler,
    close_handler
  ];
}
class RuleEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2c, create_fragment$2f, safe_not_equal, {
      sieve: 1,
      global: 2,
      sieveConditionInputs: 3,
      rule: 0
    });
  }
}
const FIELD_TYPES_BUILTIN = "builtin";
const FIELD_TYPES_PROPERTY = "property";
const FIELD_TYPES_ATTRIBUTE = "attribute";
const PROPS_COMMON = ["innerHTML", "innerText", "outerHTML", "outerText", "title", "textContent"];
const ATTRS_COMMON = ["id", "name", "class"];
class ConfigContext {
  constructor() {
    this.allFields = this.createAllFields();
    const allFieldsList = this.allFields;
    this.context = {
      add(frameIndex, op = "INCLUDE", locators) {
        const defaultLocator = {
          expr: "#enter-your-selector-here",
          type: "css"
        };
        if (op === "INCLUDE") {
          defaultLocator.allFields = allFieldsList;
        }
        const frame = locators.frame;
        const includesExcludes = op === "INCLUDE" ? frame.get("includes") : frame.get("excludes");
        includesExcludes.push(defaultLocator);
      },
      setType(locator, type) {
        locator.set("type", type);
      },
      setExpr(locator, expr) {
        locator.set("expr", expr);
      },
      del(locator) {
        locator.destroy();
      }
    };
  }
  getContext() {
    return this.context;
  }
  getFields(frames) {
    frames.models.forEach((locator) => {
      const allFields = this.allFields;
      locator.set("allFields", allFields);
    });
  }
  createAllFields() {
    const allFields = [];
    allFields.push({
      name: "text",
      type: FIELD_TYPES_BUILTIN
    });
    ATTRS_COMMON.forEach((attr2) => {
      allFields.push({
        name: attr2,
        type: FIELD_TYPES_ATTRIBUTE
      });
    });
    PROPS_COMMON.forEach((prop) => {
      allFields.push({
        name: prop,
        type: FIELD_TYPES_PROPERTY
      });
    });
    return allFields;
  }
}
function create_fragment$2e(ctx) {
  let div;
  let sieveconfigpage;
  let t;
  let regexwrapper;
  let current;
  sieveconfigpage = new SieveConfigPage({
    props: {
      model: ctx[1],
      config: ctx[0]
    }
  });
  regexwrapper = new RegexWrapper({
    props: {
      id: "vs-regex",
      show: false,
      config: ctx[0]
    }
  });
  return {
    c() {
      div = element("div");
      create_component(sieveconfigpage.$$.fragment);
      t = space();
      create_component(regexwrapper.$$.fragment);
      attr(div, "class", "flex-auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(sieveconfigpage, div, null);
      append(div, t);
      mount_component(regexwrapper, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sieveconfigpage_changes = {};
      if (dirty & 1)
        sieveconfigpage_changes.config = ctx2[0];
      sieveconfigpage.$set(sieveconfigpage_changes);
      const regexwrapper_changes = {};
      if (dirty & 1)
        regexwrapper_changes.config = ctx2[0];
      regexwrapper.$set(regexwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveconfigpage.$$.fragment, local);
      transition_in(regexwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveconfigpage.$$.fragment, local);
      transition_out(regexwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(sieveconfigpage);
      destroy_component(regexwrapper);
    }
  };
}
function instance$2b($$self, $$props, $$invalidate) {
  var _a;
  let { config } = $$props;
  const page = (_a = config.get("selections")) == null ? void 0 : _a.models[0];
  const configContext = new ConfigContext();
  const CMD = configContext.getContext();
  setContext("CMD", CMD);
  const frames = page.get("frames").models[0].get("includes");
  configContext.getFields(frames);
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(0, config = $$props2.config);
  };
  return [config, page];
}
class VisualConfigEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2b, create_fragment$2e, safe_not_equal, { config: 0 });
  }
}
function create_default_slot$Z(ctx) {
  let textarea;
  let textarea_class_value;
  let mounted;
  let dispose;
  let textarea_levels = [
    {
      class: textarea_class_value = ctx[2] + " mb2 h-[400px]"
    },
    { placeholder: "Selection Config" },
    ctx[1]
  ];
  let textarea_data = {};
  for (let i2 = 0; i2 < textarea_levels.length; i2 += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i2]);
  }
  return {
    c() {
      textarea = element("textarea");
      set_attributes(textarea, textarea_data);
      toggle_class(textarea, "is-invalid", ctx[4]);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      if (!mounted) {
        dispose = action_destroyer(ctx[3].call(null, textarea));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty & 4 && textarea_class_value !== (textarea_class_value = ctx2[2] + " mb2 h-[400px]") && { class: textarea_class_value },
        { placeholder: "Selection Config" },
        dirty & 2 && ctx2[1]
      ]));
      toggle_class(textarea, "is-invalid", ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$2d(ctx) {
  let fieldwrapper;
  let current;
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[0],
      $$slots: {
        default: [
          create_default_slot$Z,
          ({ inputClasses, action, showError }) => ({ 2: inputClasses, 3: action, 4: showError }),
          ({ inputClasses, action, showError }) => (inputClasses ? 4 : 0) | (action ? 8 : 0) | (showError ? 16 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(fieldwrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(fieldwrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 1)
        fieldwrapper_changes.field = ctx2[0];
      if (dirty & 54) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(fieldwrapper, detaching);
    }
  };
}
function instance$2a($$self, $$props, $$invalidate) {
  const omit_props_names = ["config"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { config } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("config" in $$new_props)
      $$invalidate(0, config = $$new_props.config);
  };
  return [config, $$restProps];
}
class JsonConfigEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2a, create_fragment$2d, safe_not_equal, { config: 0 });
  }
}
function create_fragment$2c(ctx) {
  let requesteditor;
  let current;
  requesteditor = new RequestEditor({
    props: {
      formModel: ctx[0],
      configureOptions: true,
      configView: true
    }
  });
  return {
    c() {
      create_component(requesteditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(requesteditor, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const requesteditor_changes = {};
      if (dirty & 1)
        requesteditor_changes.formModel = ctx2[0];
      requesteditor.$set(requesteditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(requesteditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(requesteditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(requesteditor, detaching);
    }
  };
}
function instance$29($$self, $$props, $$invalidate) {
  let { formModel } = $$props;
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
  };
  return [formModel];
}
class RequestConfigEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$29, create_fragment$2c, safe_not_equal, { formModel: 0 });
  }
}
function create_default_slot$Y(ctx) {
  let urledit;
  let current;
  urledit = new UrlEdit({
    props: {
      field: ctx[1],
      placeholder: "URL"
    }
  });
  return {
    c() {
      create_component(urledit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(urledit, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(urledit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urledit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(urledit, detaching);
    }
  };
}
function create_fragment$2b(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: TXT("l_url"),
      onSave: ctx[4],
      disableSave: ctx[0],
      $$slots: { default: [create_default_slot$Y] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[6]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 1)
        savemodal_changes.disableSave = ctx2[0];
      if (dirty & 1024) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$28($$self, $$props, $$invalidate) {
  let $clone;
  let $dirty;
  let $showError;
  let { uri } = $$props;
  const clone2 = uri.clone();
  component_subscribe($$self, clone2, (value) => $$invalidate(7, $clone = value));
  const { showError, dirty } = clone2;
  component_subscribe($$self, showError, (value) => $$invalidate(0, $showError = value));
  component_subscribe($$self, dirty, (value) => $$invalidate(8, $dirty = value));
  const dispatch = createEventDispatcher();
  async function save() {
    try {
      if ($dirty) {
        uri.set($clone);
      }
      dispatch("close");
    } catch (e) {
      throw new Error("Invalid URL");
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("uri" in $$props2)
      $$invalidate(5, uri = $$props2.uri);
  };
  return [$showError, clone2, showError, dirty, save, uri, close_handler];
}
class UrlEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$28, create_fragment$2b, safe_not_equal, { uri: 5 });
  }
}
function create_label_pre_slot$1(ctx) {
  let t;
  return {
    c() {
      t = text("Macro -");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_bottom_slot$4(ctx) {
  let li0;
  let t0;
  let li1;
  let a0;
  let t1;
  let a0_href_value;
  let t2;
  let li2;
  let a1;
  let t3;
  return {
    c() {
      li0 = element("li");
      t0 = space();
      li1 = element("li");
      a0 = element("a");
      t1 = text("Manage Macros");
      t2 = space();
      li2 = element("li");
      a1 = element("a");
      t3 = text("Learn More");
      attr(li0, "class", "dropdown-divider");
      attr(a0, "class", "dropdown-item");
      attr(a0, "href", a0_href_value = "#/w/" + ctx[4].team + "/macros/");
      attr(a0, "target", "_blank");
      attr(a1, "class", "dropdown-item");
      attr(a1, "href", urlCfg.website + "/docs/web-monitor/macro-to-record-replay-actions/");
      attr(a1, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      insert(target, t0, anchor);
      insert(target, li1, anchor);
      append(li1, a0);
      append(a0, t1);
      insert(target, t2, anchor);
      insert(target, li2, anchor);
      append(li2, a1);
      append(a1, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && a0_href_value !== (a0_href_value = "#/w/" + ctx2[4].team + "/macros/")) {
        attr(a0, "href", a0_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(li1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(li2);
    }
  };
}
function create_fragment$2a(ctx) {
  let searchablemacromenu;
  let updating_id;
  let updating_showParamsModal;
  let current;
  const searchablemacromenu_spread_levels = [{ items: ctx[3] }, { title: "Select Macro" }, ctx[8]];
  function searchablemacromenu_id_binding(value) {
    ctx[11](value);
  }
  function searchablemacromenu_showParamsModal_binding(value) {
    ctx[12](value);
  }
  let searchablemacromenu_props = {
    $$slots: {
      bottom: [create_bottom_slot$4],
      "label-pre": [create_label_pre_slot$1]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < searchablemacromenu_spread_levels.length; i2 += 1) {
    searchablemacromenu_props = assign(searchablemacromenu_props, searchablemacromenu_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    searchablemacromenu_props.id = ctx[0];
  }
  if (ctx[1] !== void 0) {
    searchablemacromenu_props.showParamsModal = ctx[1];
  }
  searchablemacromenu = new SearchableMacroMenu({ props: searchablemacromenu_props });
  binding_callbacks.push(() => bind$1(searchablemacromenu, "id", searchablemacromenu_id_binding));
  binding_callbacks.push(() => bind$1(searchablemacromenu, "showParamsModal", searchablemacromenu_showParamsModal_binding));
  searchablemacromenu.$on("close", ctx[7]);
  searchablemacromenu.$on("search", ctx[5]);
  searchablemacromenu.$on("select", ctx[6]);
  return {
    c() {
      create_component(searchablemacromenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemacromenu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const searchablemacromenu_changes = dirty & 264 ? get_spread_update(searchablemacromenu_spread_levels, [
        dirty & 8 && { items: ctx2[3] },
        searchablemacromenu_spread_levels[1],
        dirty & 256 && get_spread_object(ctx2[8])
      ]) : {};
      if (dirty & 65552) {
        searchablemacromenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_id && dirty & 1) {
        updating_id = true;
        searchablemacromenu_changes.id = ctx2[0];
        add_flush_callback(() => updating_id = false);
      }
      if (!updating_showParamsModal && dirty & 2) {
        updating_showParamsModal = true;
        searchablemacromenu_changes.showParamsModal = ctx2[1];
        add_flush_callback(() => updating_showParamsModal = false);
      }
      searchablemacromenu.$set(searchablemacromenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemacromenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemacromenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemacromenu, detaching);
    }
  };
}
function instance$27($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "macro", "uri", "showParamsModal"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $uri, $$unsubscribe_uri = noop$1, $$subscribe_uri = () => ($$unsubscribe_uri(), $$unsubscribe_uri = subscribe(uri, ($$value) => $$invalidate(10, $uri = $$value)), uri);
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(4, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_uri());
  let { id: id2 } = $$props;
  let { macro } = $$props;
  let { uri } = $$props;
  $$subscribe_uri();
  let { showParamsModal } = $$props;
  let initMacros = [];
  let items = [];
  async function init2() {
    initMacros = $$invalidate(3, items = await getMacros());
    await addSelected();
  }
  async function getMacros(phrase = "") {
    var _a;
    if (Supports.agents.local && !await serviceProxy.auth.isLoggedIn()) {
      return [];
    }
    const query = {
      _opt: { only: ["id", "name", "spec", "meta"] },
      "meta:->>'url'.like": `%${(_a = $uri.host) != null ? _a : ""}%`
    };
    if (phrase) {
      query["name.ilike"] = `%${phrase}%`;
    }
    const res = await Api.api("/macros", query);
    return res.data;
  }
  async function onSearch(e) {
    $$invalidate(3, items = await getMacros(e.detail));
  }
  async function addSelected() {
    if (!id2 || initMacros.find((m) => m.id === id2)) {
      return;
    }
    const item = await Api.api(`/macros/${id2}`);
    $$invalidate(3, items = [item, ...initMacros]);
  }
  async function resetMacros() {
    if (!id2 || initMacros.find((m) => m.id === id2)) {
      $$invalidate(3, items = initMacros);
    } else if (id2) {
      const m = items.find((m2) => m2.id === id2);
      $$invalidate(3, items = [m, ...initMacros]);
    }
  }
  function searchablemacromenu_id_binding(value) {
    id2 = value;
    $$invalidate(0, id2);
  }
  function searchablemacromenu_showParamsModal_binding(value) {
    showParamsModal = value;
    $$invalidate(1, showParamsModal);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
    if ("macro" in $$new_props)
      $$invalidate(9, macro = $$new_props.macro);
    if ("uri" in $$new_props)
      $$subscribe_uri($$invalidate(2, uri = $$new_props.uri));
    if ("showParamsModal" in $$new_props)
      $$invalidate(1, showParamsModal = $$new_props.showParamsModal);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      $uri && init2();
    }
    if ($$self.$$.dirty & 9) {
      $$invalidate(9, macro = items.find((item) => item.id === id2));
    }
  };
  return [
    id2,
    showParamsModal,
    uri,
    items,
    $route,
    onSearch,
    addSelected,
    resetMacros,
    $$restProps,
    macro,
    $uri,
    searchablemacromenu_id_binding,
    searchablemacromenu_showParamsModal_binding
  ];
}
class SelectMacro extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$27, create_fragment$2a, safe_not_equal, {
      id: 0,
      macro: 9,
      uri: 2,
      showParamsModal: 1
    });
  }
}
function create_if_block$1e(ctx) {
  let accordion;
  let current;
  accordion = new Accordion({
    props: {
      id: "params",
      show: true,
      class: "mt-2 mb-1",
      $$slots: {
        header: [create_header_slot_1$1],
        default: [create_default_slot_1$g]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(accordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordion_changes = {};
      if (dirty & 16404) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordion, detaching);
    }
  };
}
function create_default_slot_1$g(ctx) {
  let paramseditor;
  let current;
  paramseditor = new ParamsEditor({
    props: {
      spec: ctx[2],
      fields: ctx[4].params,
      onUpdate: ctx[7],
      wrapperClass: "bg-transparent"
    }
  });
  return {
    c() {
      create_component(paramseditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(paramseditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const paramseditor_changes = {};
      if (dirty & 4)
        paramseditor_changes.spec = ctx2[2];
      if (dirty & 16)
        paramseditor_changes.fields = ctx2[4].params;
      paramseditor.$set(paramseditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(paramseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(paramseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(paramseditor, detaching);
    }
  };
}
function create_header_slot_1$1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Input Fields";
      attr(div, "slot", "header");
      attr(div, "class", "d-flex items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$X(ctx) {
  let a;
  let t1;
  let schemakeytree;
  let updating_root;
  let current;
  let mounted;
  let dispose;
  function schemakeytree_root_binding(value) {
    ctx[11](value);
  }
  let schemakeytree_props = {
    includedJson: ctx[6],
    showPreviewNode: false,
    showOuterBorder: false,
    obj: JSON.parse(JSON.stringify(ctx[1].schema)),
    class: "monitored-fields bg-transparent"
  };
  if (ctx[3] !== void 0) {
    schemakeytree_props.root = ctx[3];
  }
  schemakeytree = new SchemaKeyTree({ props: schemakeytree_props });
  binding_callbacks.push(() => bind$1(schemakeytree, "root", schemakeytree_root_binding));
  return {
    c() {
      a = element("a");
      a.textContent = "Select all";
      t1 = space();
      create_component(schemakeytree.$$.fragment);
      attr(a, "href", "#");
      attr(a, "class", "d-block pt-2");
      set_style(a, "font-size", "10px");
      set_style(a, "margin-left", "calc(16px + var(--tv-key-gap))");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      insert(target, t1, anchor);
      mount_component(schemakeytree, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[8]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const schemakeytree_changes = {};
      if (dirty & 2)
        schemakeytree_changes.obj = JSON.parse(JSON.stringify(ctx2[1].schema));
      if (!updating_root && dirty & 8) {
        updating_root = true;
        schemakeytree_changes.root = ctx2[3];
        add_flush_callback(() => updating_root = false);
      }
      schemakeytree.$set(schemakeytree_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(schemakeytree.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(schemakeytree.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (detaching)
        detach(t1);
      destroy_component(schemakeytree, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_header_slot$h(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Monitored Fields";
      attr(div, "slot", "header");
      attr(div, "class", "w-100 d-flex align-items-center justify-content-between gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$29(ctx) {
  let show_if = ctx[4].params && Object.keys(ctx[4].params).length;
  let t;
  let accordion;
  let current;
  let if_block = show_if && create_if_block$1e(ctx);
  accordion = new Accordion({
    props: {
      id: "filter",
      show: true,
      class: "mt-2",
      $$slots: {
        header: [create_header_slot$h],
        default: [create_default_slot$X]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      create_component(accordion.$$.fragment);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 16)
        show_if = ctx2[4].params && Object.keys(ctx2[4].params).length;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1e(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const accordion_changes = {};
      if (dirty & 16394) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      destroy_component(accordion, detaching);
    }
  };
}
function instance$26($$self, $$props, $$invalidate) {
  let $includedJson;
  let $model, $$unsubscribe_model = noop$1, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe(model, ($$value) => $$invalidate(12, $model = $$value)), model);
  let $config;
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  let { model } = $$props;
  $$subscribe_model();
  let { datasource } = $$props;
  let { configFormModel } = $$props;
  let { spec } = $$props;
  let rootNode;
  let config = $model.config;
  component_subscribe($$self, config, (value) => $$invalidate(4, $config = value));
  const includedJson = writable($model.config.get("filters").included);
  component_subscribe($$self, includedJson, (value) => $$invalidate(10, $includedJson = value));
  function updateParams2(newParamsValues) {
    configFormModel.set({
      ...config.toJSON(),
      params: newParamsValues
    });
  }
  function updateFilters() {
    let includedSelectors = $includedJson;
    if (!includedSelectors.length) {
      includedSelectors = ["."];
    }
    configFormModel.set({
      ...config.toJSON(),
      filters: { included: includedSelectors }
    });
  }
  function selectAll() {
    includedJson.set(["."]);
    rootNode.checkAll(true);
  }
  function schemakeytree_root_binding(value) {
    rootNode = value;
    $$invalidate(3, rootNode);
  }
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$subscribe_model($$invalidate(0, model = $$props2.model));
    if ("datasource" in $$props2)
      $$invalidate(1, datasource = $$props2.datasource);
    if ("configFormModel" in $$props2)
      $$invalidate(9, configFormModel = $$props2.configFormModel);
    if ("spec" in $$props2)
      $$invalidate(2, spec = $$props2.spec);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      updateFilters();
    }
  };
  return [
    model,
    datasource,
    spec,
    rootNode,
    $config,
    config,
    includedJson,
    updateParams2,
    selectAll,
    configFormModel,
    $includedJson,
    schemakeytree_root_binding
  ];
}
class ScraperConfigEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$26, create_fragment$29, safe_not_equal, {
      model: 0,
      datasource: 1,
      configFormModel: 9,
      spec: 2
    });
  }
}
function create_if_block_12(ctx) {
  let div;
  let selectmacro;
  let updating_id;
  let updating_macro;
  let updating_showParamsModal;
  let current;
  function selectmacro_id_binding(value) {
    ctx[29](value);
  }
  function selectmacro_macro_binding(value) {
    ctx[30](value);
  }
  function selectmacro_showParamsModal_binding(value) {
    ctx[31](value);
  }
  let selectmacro_props = {
    uri: ctx[17],
    actionClass: "btn btn-default"
  };
  if (ctx[4].macro_id !== void 0) {
    selectmacro_props.id = ctx[4].macro_id;
  }
  if (ctx[3] !== void 0) {
    selectmacro_props.macro = ctx[3];
  }
  if (ctx[13] !== void 0) {
    selectmacro_props.showParamsModal = ctx[13];
  }
  selectmacro = new SelectMacro({ props: selectmacro_props });
  binding_callbacks.push(() => bind$1(selectmacro, "id", selectmacro_id_binding));
  binding_callbacks.push(() => bind$1(selectmacro, "macro", selectmacro_macro_binding));
  binding_callbacks.push(() => bind$1(selectmacro, "showParamsModal", selectmacro_showParamsModal_binding));
  return {
    c() {
      div = element("div");
      create_component(selectmacro.$$.fragment);
      attr(div, "class", "btn-group flex");
      attr(div, "role", "group");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(selectmacro, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const selectmacro_changes = {};
      if (!updating_id && dirty[0] & 16) {
        updating_id = true;
        selectmacro_changes.id = ctx2[4].macro_id;
        add_flush_callback(() => updating_id = false);
      }
      if (!updating_macro && dirty[0] & 8) {
        updating_macro = true;
        selectmacro_changes.macro = ctx2[3];
        add_flush_callback(() => updating_macro = false);
      }
      if (!updating_showParamsModal && dirty[0] & 8192) {
        updating_showParamsModal = true;
        selectmacro_changes.showParamsModal = ctx2[13];
        add_flush_callback(() => updating_showParamsModal = false);
      }
      selectmacro.$set(selectmacro_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectmacro.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectmacro.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(selectmacro);
    }
  };
}
function create_if_block_11$3(ctx) {
  let button;
  let t0;
  let t1_value = ctx[4].uri + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t0 = text("Edit ");
      t1 = text(t1_value);
      attr(button, "class", "btn btn-default truncate mw6");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[32]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16 && t1_value !== (t1_value = ctx2[4].uri + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_10$4(ctx) {
  let sourceselector;
  let current;
  sourceselector = new SourceSelector({
    props: {
      model: ctx[16],
      formModel: ctx[6],
      hideTitle: true
    }
  });
  sourceselector.$on("save", ctx[23]);
  sourceselector.$on("discard", ctx[33]);
  return {
    c() {
      create_component(sourceselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sourceselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sourceselector_changes = {};
      if (dirty[0] & 64)
        sourceselector_changes.formModel = ctx2[6];
      sourceselector.$set(sourceselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sourceselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sourceselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sourceselector, detaching);
    }
  };
}
function create_if_block_3$x(ctx) {
  let div;
  let ul;
  let li0;
  let show_if;
  let t0;
  let li1;
  let a;
  let t2;
  let current_block_type_index;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4].content_type === C$1.TYPE_HTML)
      return create_if_block_8$6;
    if (show_if == null)
      show_if = !!ctx2[16].isScraperDatasource();
    if (show_if)
      return create_if_block_9$5;
    return create_else_block$I;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  const if_block_creators = [create_if_block_4$n, create_if_block_5$h, create_if_block_6$b, create_if_block_7$9];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[8] === "visual")
      return 0;
    if (ctx2[8] === "request")
      return 1;
    if (ctx2[8] === "json")
      return 2;
    if (ctx2[8] === "scraper")
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      ul = element("ul");
      li0 = element("li");
      if_block0.c();
      t0 = space();
      li1 = element("li");
      a = element("a");
      a.textContent = "Config JSON";
      t2 = space();
      if (if_block1)
        if_block1.c();
      attr(li0, "class", "nav-item");
      attr(a, "class", "nav-link");
      attr(a, "href", "#");
      toggle_class(a, "active", ctx[8] === "json");
      attr(li1, "class", "nav-item");
      attr(ul, "class", "nav nav-underline");
      attr(div, "class", "bg-body mt2 px-2 border-gray-100 ba pb-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ul);
      append(ul, li0);
      if_block0.m(li0, null);
      append(ul, t0);
      append(ul, li1);
      append(li1, a);
      append(div, t2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", ctx[37]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(li0, null);
        }
      }
      if (!current || dirty[0] & 256) {
        toggle_class(a, "active", ctx2[8] === "json");
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        } else {
          if_block1 = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$I(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = "Configuration";
      attr(a, "class", "nav-link");
      attr(a, "href", "#");
      toggle_class(a, "active", ctx[8] === "request");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[36]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256) {
        toggle_class(a, "active", ctx2[8] === "request");
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_9$5(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = "Configuration";
      attr(a, "class", "nav-link");
      attr(a, "href", "#");
      toggle_class(a, "active", ctx[8] === "scraper");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[35]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256) {
        toggle_class(a, "active", ctx2[8] === "scraper");
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_8$6(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = "Configuration";
      attr(a, "class", "nav-link");
      attr(a, "href", "#");
      toggle_class(a, "active", ctx[8] === "visual");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", ctx[34]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256) {
        toggle_class(a, "active", ctx2[8] === "visual");
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_7$9(ctx) {
  var _a, _b;
  let scraperconfigeditor;
  let current;
  scraperconfigeditor = new ScraperConfigEditor({
    props: {
      model: ctx[16],
      datasource: ctx[1],
      configFormModel: ctx[18],
      spec: ctx[16].get("datasource_id") === C$1.DS_ID_SCRAPER ? (_a = ctx[12]) == null ? void 0 : _a.spec : (_b = ctx[1]) == null ? void 0 : _b.spec
    }
  });
  return {
    c() {
      create_component(scraperconfigeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scraperconfigeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const scraperconfigeditor_changes = {};
      if (dirty[0] & 2)
        scraperconfigeditor_changes.datasource = ctx2[1];
      if (dirty[0] & 4098)
        scraperconfigeditor_changes.spec = ctx2[16].get("datasource_id") === C$1.DS_ID_SCRAPER ? (_a2 = ctx2[12]) == null ? void 0 : _a2.spec : (_b2 = ctx2[1]) == null ? void 0 : _b2.spec;
      scraperconfigeditor.$set(scraperconfigeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scraperconfigeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scraperconfigeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scraperconfigeditor, detaching);
    }
  };
}
function create_if_block_6$b(ctx) {
  let jsonconfigeditor;
  let current;
  jsonconfigeditor = new JsonConfigEditor({ props: { config: ctx[18] } });
  return {
    c() {
      create_component(jsonconfigeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(jsonconfigeditor, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(jsonconfigeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(jsonconfigeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(jsonconfigeditor, detaching);
    }
  };
}
function create_if_block_5$h(ctx) {
  let requestconfigeditor;
  let current;
  requestconfigeditor = new RequestConfigEditor({
    props: { formModel: ctx[0] }
  });
  return {
    c() {
      create_component(requestconfigeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(requestconfigeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const requestconfigeditor_changes = {};
      if (dirty[0] & 1)
        requestconfigeditor_changes.formModel = ctx2[0];
      requestconfigeditor.$set(requestconfigeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(requestconfigeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(requestconfigeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(requestconfigeditor, detaching);
    }
  };
}
function create_if_block_4$n(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$r,
    then: create_then_block$r,
    catch: create_catch_block$r,
    blocks: [, , ,]
  };
  handle_promise(ctx[19](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block$r(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$r(ctx) {
  let visualconfigeditor;
  let current;
  visualconfigeditor = new VisualConfigEditor({
    props: { config: ctx[5] }
  });
  return {
    c() {
      create_component(visualconfigeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(visualconfigeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const visualconfigeditor_changes = {};
      if (dirty[0] & 32)
        visualconfigeditor_changes.config = ctx2[5];
      visualconfigeditor.$set(visualconfigeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(visualconfigeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(visualconfigeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(visualconfigeditor, detaching);
    }
  };
}
function create_pending_block$r(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_if_block_2$F(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      onSave: ctx[26],
      $$slots: {
        header: [create_header_slot$g],
        default: [create_default_slot$W]
      },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[38]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty[0] & 20480 | dirty[1] & 2097152) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$W(ctx) {
  let paramseditor;
  let current;
  paramseditor = new ParamsEditor({
    props: {
      paramLabelClass: "xoption-label",
      spec: ctx[12].spec,
      fields: ctx[14],
      onUpdate: ctx[25]
    }
  });
  return {
    c() {
      create_component(paramseditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(paramseditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const paramseditor_changes = {};
      if (dirty[0] & 4096)
        paramseditor_changes.spec = ctx2[12].spec;
      if (dirty[0] & 16384)
        paramseditor_changes.fields = ctx2[14];
      paramseditor.$set(paramseditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(paramseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(paramseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(paramseditor, detaching);
    }
  };
}
function create_header_slot$g(ctx) {
  let t;
  return {
    c() {
      t = text("Configure Input Fields");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$V(ctx) {
  let div2;
  let div0;
  let t0_value = TXT("m_xframe_notice1") + "";
  let t0;
  let t1;
  let a0;
  let t2_value = TXT("Download Desktop App") + "";
  let t2;
  let t3;
  let t4;
  let div1;
  let t5_value = TXT("m_xframe_notice2") + "";
  let t5;
  let t6;
  let button;
  let t8;
  let a1;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      a0 = element("a");
      t2 = text(t2_value);
      t3 = text(" to run checks in background.");
      t4 = space();
      div1 = element("div");
      t5 = text(t5_value);
      t6 = space();
      button = element("button");
      button.textContent = `${TXT("a_static_load")}`;
      t8 = space();
      a1 = element("a");
      a1.textContent = `${TXT("Learn More")}`;
      attr(a0, "class", "btn btn-default btn-sm");
      attr(a0, "href", urlCfg.website + "/apps/web-monitor/#desktop");
      attr(button, "class", "btn btn-default btn-sm");
      attr(a1, "href", "https://distill.io/docs/web-monitor/extensions-open-new-tab-for-checks/");
      attr(div2, "class", "alert alert-info pa2 mt2");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div0, t1);
      append(div0, a0);
      append(a0, t2);
      append(div0, t3);
      append(div2, t4);
      append(div2, div1);
      append(div1, t5);
      append(div1, t6);
      append(div1, button);
      append(div1, t8);
      append(div1, a1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[24]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$1d(ctx) {
  let urleditormodal;
  let current;
  urleditormodal = new UrlEditorModal({ props: { uri: ctx[17] } });
  urleditormodal.$on("close", ctx[39]);
  return {
    c() {
      create_component(urleditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(urleditormodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(urleditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urleditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(urleditormodal, detaching);
    }
  };
}
function create_fragment$28(ctx) {
  let div1;
  let div0;
  let button0;
  let t0;
  let t1;
  let button1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let if_block6_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[4].content_type === C$1.TYPE_HTML && create_if_block_12(ctx);
  let if_block1 = ctx[4].content_type !== C$1.TYPE_SITEMAP && create_if_block_11$3(ctx);
  let if_block2 = ctx[2] && ctx[10] && create_if_block_10$4(ctx);
  let if_block3 = ctx[7] && create_if_block_3$x(ctx);
  let if_block4 = ctx[13] && create_if_block_2$F(ctx);
  let if_block5 = ctx[15] && create_if_block_1$V(ctx);
  let if_block6 = ctx[9] && create_if_block$1d(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      t0 = text(ctx[11]);
      t1 = space();
      button1 = element("button");
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      if (if_block3)
        if_block3.c();
      t6 = space();
      if (if_block4)
        if_block4.c();
      t7 = space();
      if (if_block5)
        if_block5.c();
      t8 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      attr(button0, "type", "button");
      attr(button0, "class", "btn btn-default");
      attr(button0, "title", "Select content from a webpage.");
      attr(button1, "class", "btn btn-default fa fa-gear");
      attr(button1, "title", "Show config");
      attr(div0, "class", "btn-group flex");
      attr(div0, "role", "group");
      attr(div1, "class", "flex gap-2");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      append(button0, t0);
      append(div0, t1);
      append(div0, button1);
      append(div1, t2);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t3);
      if (if_block1)
        if_block1.m(div1, null);
      insert(target, t4, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, t6, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert(target, t7, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert(target, t8, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert(target, if_block6_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[20]),
          listen(button1, "click", ctx[21])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & 2048)
        set_data(t0, ctx2[11]);
      if (ctx2[4].content_type === C$1.TYPE_HTML) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[4].content_type !== C$1.TYPE_SITEMAP) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_11$3(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[2] && ctx2[10]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 1028) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_10$4(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t5.parentNode, t5);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[7]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_3$x(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t6.parentNode, t6);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[13]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & 8192) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_2$F(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t7.parentNode, t7);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (ctx2[15]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_1$V(ctx2);
          if_block5.c();
          if_block5.m(t8.parentNode, t8);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (ctx2[9]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block$1d(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block6);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block6);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach(t4);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t5);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(t6);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach(t7);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach(t8);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach(if_block6_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$25($$self, $$props, $$invalidate) {
  let $config;
  let $model;
  let { formModel } = $$props;
  let { mdsDatasource } = $$props;
  const { model } = formModel;
  component_subscribe($$self, model, (value) => $$invalidate(4, $model = value));
  const { uri, config } = formModel.fields;
  component_subscribe($$self, config, (value) => $$invalidate(28, $config = value));
  let vceBBConfig = model.get("config");
  const clients = getContext("clients");
  let formClone;
  let showSelectorPanel = false;
  let showTabs = shouldOpenConfig();
  let activeEditor = $model.content_type == C$1.TYPE_HTML ? "visual" : getEditorType();
  let showUriEditor = false;
  let cloned = false;
  let buttonLabel;
  let macro;
  let showParamsModal = false;
  const intialSelectedMacro = $model.macro_id;
  let configInputfields;
  let previousMacroId;
  let prevMacro = null;
  let currMacro;
  let willOpenTabForChecks = false;
  const fetchParamSpec = async () => {
    $$invalidate(12, macro = await model.fetchMacro());
  };
  onMount(() => {
    vceBBConfig.on("all", onConfigChange);
    return () => {
      vceBBConfig.off("all", onConfigChange);
    };
  });
  function onConfigChange(eventName) {
    if (eventName.endsWith("change") || eventName.endsWith("add") || eventName.endsWith("remove")) {
      config.set(vceBBConfig.toJSON());
    }
  }
  async function initializeAdblockerState() {
    var _a, _b;
    prevMacro = $model.macro_id;
    const sieveConfig = model.get("config");
    const isSieveAdblockerEnabled = sieveConfig.get(EXT_ID_PROPS[ADBLOCKER_ID]);
    if (isSieveAdblockerEnabled !== void 0) {
      return;
    }
    if (prevMacro) {
      const isMacroAdblockerEnabled = (_b = (_a = currMacro == null ? void 0 : currMacro.meta) == null ? void 0 : _a[EXT_ID_PROPS[ADBLOCKER_ID]]) != null ? _b : false;
      setAdblockerState(isMacroAdblockerEnabled);
    } else {
      setAdblockerState(true);
    }
  }
  async function updateAdblockerStateOnMacroChange() {
    var _a, _b;
    if ($model.macro_id === prevMacro || !currMacro)
      return;
    prevMacro = $model.macro_id;
    if (!$model.macro_id) {
      return;
    }
    const isMacroAdblockerEnabled = (_b = (_a = currMacro == null ? void 0 : currMacro.meta) == null ? void 0 : _a[EXT_ID_PROPS[ADBLOCKER_ID]]) != null ? _b : false;
    setAdblockerState(isMacroAdblockerEnabled);
  }
  function setAdblockerState(val) {
    vceBBConfig.setAdblockerEnabled(val);
  }
  function getEditorType() {
    if ($model.content_type === C$1.TYPE_HTML) {
      return "visual";
    } else if (model.isScraperDatasource()) {
      return "scraper";
    } else {
      return "request";
    }
  }
  function shouldOpenConfig() {
    if ($model.content_type === C$1.TYPE_JSON && $model.datasource_id === C$1.DS_ID_SCRAPER && $config.params && Object.entries($config.params).length > 0 && !$model.id) {
      return true;
    }
    return false;
  }
  onDestroy(() => {
    if (formClone) {
      formClone.unsubscribe();
    }
  });
  function getContentTypeDescription() {
    let typeLabel;
    switch ($model.content_type) {
      case C$1.TYPE_HTML:
        typeLabel = "l_webpage";
        break;
      case C$1.TYPE_FEED:
        typeLabel = "l_feed";
        break;
      case C$1.TYPE_XML:
        typeLabel = "l_xml";
        break;
      case C$1.TYPE_PDF_HTML:
        typeLabel = "l_pdf";
        break;
      case C$1.TYPE_DOC:
        typeLabel = "l_doc";
        break;
      case C$1.TYPE_JSON:
        typeLabel = "l_scraper";
        switch ($model.datasource_id) {
          case C$1.DS_ID_UPTIME:
            typeLabel = "l_uptime";
            break;
          case C$1.DS_ID_JSON:
          case null:
            typeLabel = "l_json";
        }
        break;
      case C$1.TYPE_SITEMAP:
        typeLabel = "l_sitemap";
        break;
      default:
        console.warn("getContentTypeDescription", "unknown content type", $model.content_type);
    }
    if (typeLabel) {
      const actionLabel = showSelectorPanel ? "a_close_x_selector" : "a_open_x_selector";
      return SPRINTF(actionLabel, typeLabel);
    } else {
      return TXT(showSelectorPanel ? "a_close_selector" : "a_open_selector");
    }
  }
  function toggleSelectorPanel() {
    $$invalidate(2, showSelectorPanel = !showSelectorPanel);
    $$invalidate(7, showTabs = false);
    if (showSelectorPanel) {
      const eventName = PHEvents.getEventForSieveSelectorPanel($model.content_type, $model.datasource_id);
      trackEvent(eventName, {
        sieve_id: model.id,
        isNew: model.isNew(),
        uri: model.get("uri")
      });
    }
  }
  function toggleTabs() {
    setActiveEditor(getEditorType());
    $$invalidate(7, showTabs = !showTabs);
    $$invalidate(2, showSelectorPanel = false);
  }
  function setActiveEditor(editor) {
    if (activeEditor === "json") {
      model.parseAndSet("config", config.toJSON());
    }
    if (editor === "visual") {
      vceBBConfig.off("all", onConfigChange);
      $$invalidate(5, vceBBConfig = model.get("config"));
      vceBBConfig.on("all", onConfigChange);
    }
    $$invalidate(8, activeEditor = editor);
  }
  function createClone() {
    $$invalidate(6, formClone = formModel.clone());
    if ($model.content_type === C$1.TYPE_FEED) {
      const { uri: uriClone } = formClone.fields;
      uriClone.set($config.uri, { parse: true });
    }
  }
  function onSave() {
    model.parseAndSet(_.omit(formClone.model.toJSON(), "name"));
    formModel.copyForm(formClone);
    $$invalidate(2, showSelectorPanel = false);
  }
  function disableJS() {
    set_store_value(config, $config.selections[0].dynamic = false, $config);
  }
  async function fetchMacroData() {
    $$invalidate(12, macro = await model.fetchMacro());
    if (intialSelectedMacro === $model.macro_id) {
      $$invalidate(14, configInputfields = $config.params);
    } else {
      $$invalidate(14, configInputfields = {});
    }
  }
  function updateParams2(newParamsValues) {
    const modelConfig = $model.config;
    config.set({
      ...modelConfig.toJSON(),
      params: newParamsValues
    });
    $$invalidate(14, configInputfields = $config.params);
  }
  function saveParams() {
    $$invalidate(13, showParamsModal = false);
  }
  function selectmacro_id_binding(value) {
    if ($$self.$$.not_equal($model.macro_id, value)) {
      $model.macro_id = value;
      model.set($model);
    }
  }
  function selectmacro_macro_binding(value) {
    currMacro = value;
    $$invalidate(3, currMacro);
  }
  function selectmacro_showParamsModal_binding(value) {
    showParamsModal = value;
    $$invalidate(13, showParamsModal);
  }
  const click_handler = () => $$invalidate(9, showUriEditor = true);
  const discard_handler = () => $$invalidate(2, showSelectorPanel = false);
  const click_handler_1 = () => setActiveEditor("visual");
  const click_handler_2 = () => setActiveEditor("scraper");
  const click_handler_3 = () => setActiveEditor("request");
  const click_handler_4 = () => setActiveEditor("json");
  const close_handler = () => $$invalidate(13, showParamsModal = false);
  const close_handler_1 = () => $$invalidate(9, showUriEditor = false);
  $$self.$$set = ($$props2) => {
    if ("formModel" in $$props2)
      $$invalidate(0, formModel = $$props2.formModel);
    if ("mdsDatasource" in $$props2)
      $$invalidate(1, mdsDatasource = $$props2.mdsDatasource);
  };
  $$self.$$.update = () => {
    var _a, _b;
    if ($$self.$$.dirty[0] & 268435472) {
      {
        let client = clients.get($model.client_id);
        $$invalidate(15, willOpenTabForChecks = (client == null ? void 0 : client.isExtension()) && ((_b = (_a = $config.selections) == null ? void 0 : _a[0]) == null ? void 0 : _b.dynamic));
      }
    }
    if ($$self.$$.dirty[0] & 16) {
      if (model.isScraperDatasource() && $model.datasource_id === C$1.DS_ID_SCRAPER) {
        fetchParamSpec();
      }
    }
    if ($$self.$$.dirty[0] & 134217744) {
      if ($model.macro_id !== previousMacroId) {
        $$invalidate(27, previousMacroId = $model.macro_id);
        if (previousMacroId) {
          fetchMacroData();
        }
      }
    }
    if ($$self.$$.dirty[0] & 8) {
      updateAdblockerStateOnMacroChange();
    }
    if ($$self.$$.dirty[0] & 4) {
      if (showSelectorPanel) {
        $$invalidate(10, cloned = false);
        createClone();
        $$invalidate(10, cloned = true);
      }
    }
    if ($$self.$$.dirty[0] & 4) {
      $$invalidate(11, buttonLabel = getContentTypeDescription());
    }
  };
  return [
    formModel,
    mdsDatasource,
    showSelectorPanel,
    currMacro,
    $model,
    vceBBConfig,
    formClone,
    showTabs,
    activeEditor,
    showUriEditor,
    cloned,
    buttonLabel,
    macro,
    showParamsModal,
    configInputfields,
    willOpenTabForChecks,
    model,
    uri,
    config,
    initializeAdblockerState,
    toggleSelectorPanel,
    toggleTabs,
    setActiveEditor,
    onSave,
    disableJS,
    updateParams2,
    saveParams,
    previousMacroId,
    $config,
    selectmacro_id_binding,
    selectmacro_macro_binding,
    selectmacro_showParamsModal_binding,
    click_handler,
    discard_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    close_handler,
    close_handler_1
  ];
}
class SourceEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$25, create_fragment$28, safe_not_equal, { formModel: 0, mdsDatasource: 1 }, null, [-1, -1]);
  }
}
function create_if_block$1c(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$U, create_else_block$H];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[4])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$H(ctx) {
  let selectsession;
  let updating_id;
  let t;
  let selectproxy;
  let updating_id_1;
  let current;
  function selectsession_id_binding(value) {
    ctx[11](value);
  }
  let selectsession_props = { actionClass: "btn btn-default" };
  if (ctx[5].session_id !== void 0) {
    selectsession_props.id = ctx[5].session_id;
  }
  selectsession = new SelectSession({ props: selectsession_props });
  binding_callbacks.push(() => bind$1(selectsession, "id", selectsession_id_binding));
  function selectproxy_id_binding(value) {
    ctx[12](value);
  }
  let selectproxy_props = { actionClass: "btn btn-default" };
  if (ctx[5].proxy_id !== void 0) {
    selectproxy_props.id = ctx[5].proxy_id;
  }
  selectproxy = new SelectProxy({ props: selectproxy_props });
  binding_callbacks.push(() => bind$1(selectproxy, "id", selectproxy_id_binding));
  return {
    c() {
      create_component(selectsession.$$.fragment);
      t = space();
      create_component(selectproxy.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectsession, target, anchor);
      insert(target, t, anchor);
      mount_component(selectproxy, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectsession_changes = {};
      if (!updating_id && dirty & 32) {
        updating_id = true;
        selectsession_changes.id = ctx2[5].session_id;
        add_flush_callback(() => updating_id = false);
      }
      selectsession.$set(selectsession_changes);
      const selectproxy_changes = {};
      if (!updating_id_1 && dirty & 32) {
        updating_id_1 = true;
        selectproxy_changes.id = ctx2[5].proxy_id;
        add_flush_callback(() => updating_id_1 = false);
      }
      selectproxy.$set(selectproxy_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectsession.$$.fragment, local);
      transition_in(selectproxy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectsession.$$.fragment, local);
      transition_out(selectproxy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectsession, detaching);
      if (detaching)
        detach(t);
      destroy_component(selectproxy, detaching);
    }
  };
}
function create_if_block_1$U(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      a.textContent = "Options";
      attr(a, "class", "cursor-pointer");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[10]));
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$27(ctx) {
  let div;
  let menu;
  let updating_id;
  let t;
  let show_if = ctx[3] && ctx[3].isWeb() && ctx[5].content_type !== C$1.TYPE_SITEMAP;
  let current;
  const menu_spread_levels = [
    { items: ctx[2] },
    { title: "Select Client" },
    { actionClass: "btn btn-default" },
    { allowNull: false },
    ctx[7]
  ];
  function menu_id_binding(value) {
    ctx[9](value);
  }
  let menu_props = {};
  for (let i2 = 0; i2 < menu_spread_levels.length; i2 += 1) {
    menu_props = assign(menu_props, menu_spread_levels[i2]);
  }
  if (ctx[1] !== void 0) {
    menu_props.id = ctx[1];
  }
  menu = new Menu({ props: menu_props });
  binding_callbacks.push(() => bind$1(menu, "id", menu_id_binding));
  let if_block = show_if && create_if_block$1c(ctx);
  return {
    c() {
      div = element("div");
      create_component(menu.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "flex items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(menu, div, null);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = dirty & 132 ? get_spread_update(menu_spread_levels, [
        dirty & 4 && { items: ctx2[2] },
        menu_spread_levels[1],
        menu_spread_levels[2],
        menu_spread_levels[3],
        dirty & 128 && get_spread_object(ctx2[7])
      ]) : {};
      if (!updating_id && dirty & 2) {
        updating_id = true;
        menu_changes.id = ctx2[1];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
      if (dirty & 40)
        show_if = ctx2[3] && ctx2[3].isWeb() && ctx2[5].content_type !== C$1.TYPE_SITEMAP;
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 40) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(menu);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$24($$self, $$props, $$invalidate) {
  const omit_props_names = ["model", "showAllClients"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $model, $$unsubscribe_model = noop$1, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe(model, ($$value) => $$invalidate(5, $model = $$value)), model);
  let $clients;
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  let { model } = $$props;
  $$subscribe_model();
  let { showAllClients } = $$props;
  const clients = getContext("clients");
  component_subscribe($$self, clients, (value) => $$invalidate(13, $clients = value));
  let items;
  let client_id;
  let client;
  let showOptions = false;
  if (showAllClients) {
    items = $clients.map((client2) => ({ id: client2.id, name: client2.getInfo() }));
    client_id = getDefaultClientId($clients);
  } else {
    const availableClients = model.getAccessibleClients(clients);
    items = availableClients.map((client2) => ({ id: client2.id, name: client2.getInfo() }));
    client_id = getDefaultClientId(availableClients);
  }
  function getDefaultClientId(clientList) {
    var _a;
    const id2 = $model.client_id || clients.defaultId;
    return clientList.find((client2) => id2 === client2.id) ? id2 : (_a = clientList[0]) == null ? void 0 : _a.id;
  }
  function menu_id_binding(value) {
    client_id = value;
    $$invalidate(1, client_id);
  }
  const click_handler = () => $$invalidate(4, showOptions = true);
  function selectsession_id_binding(value) {
    if ($$self.$$.not_equal($model.session_id, value)) {
      $model.session_id = value;
      model.set($model);
    }
  }
  function selectproxy_id_binding(value) {
    if ($$self.$$.not_equal($model.proxy_id, value)) {
      $model.proxy_id = value;
      model.set($model);
    }
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("model" in $$new_props)
      $$subscribe_model($$invalidate(0, model = $$new_props.model));
    if ("showAllClients" in $$new_props)
      $$invalidate(8, showAllClients = $$new_props.showAllClients);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      if (client_id) {
        model.set("client_id", client_id);
        $$invalidate(3, client = clients.get(client_id));
      }
    }
  };
  return [
    model,
    client_id,
    items,
    client,
    showOptions,
    $model,
    clients,
    $$restProps,
    showAllClients,
    menu_id_binding,
    click_handler,
    selectsession_id_binding,
    selectproxy_id_binding
  ];
}
class ClientSelector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$24, create_fragment$27, safe_not_equal, { model: 0, showAllClients: 8 });
  }
}
function get_each_context$x(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_else_block$G(ctx) {
  let t;
  return {
    c() {
      t = text("No label found.");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$1b(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ctx[1].models;
  const get_key = (ctx2) => ctx2[6].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$x(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$x(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "flex flex-wrap");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 11) {
        each_value = ctx2[1].models;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, destroy_block, create_each_block$x, null, get_each_context$x);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_each_block$x(key_1, ctx) {
  let label;
  let input;
  let input_checked_value;
  let t0;
  let t1_value = ctx[6].get("name") + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function change_handler(...args) {
    return ctx[5](ctx[6], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "checkbox");
      set_style(input, "vertical-align", "top");
      set_style(input, "margin", "0 4px");
      input.checked = input_checked_value = ctx[0].includes(ctx[6]);
      attr(label, "class", "flex font-normal mr-2");
      this.first = label;
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input);
      append(label, t0);
      append(label, t1);
      append(label, t2);
      if (!mounted) {
        dispose = listen(input, "change", change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 3 && input_checked_value !== (input_checked_value = ctx[0].includes(ctx[6]))) {
        input.checked = input_checked_value;
      }
      if (dirty & 2 && t1_value !== (t1_value = ctx[6].get("name") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(label);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$26(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].length > 0)
      return create_if_block$1b;
    return create_else_block$G;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$23($$self, $$props, $$invalidate) {
  let $tags;
  let { model } = $$props;
  const tags = getContext("labels");
  component_subscribe($$self, tags, (value) => $$invalidate(1, $tags = value));
  let currTags = model.getTags(tags);
  function onChecked(tag, checked) {
    if (checked) {
      currTags.push(tag);
    } else {
      $$invalidate(0, currTags = _.without(currTags, tag));
    }
    model.set("tags", _.pluck(currTags, "id").join(","));
  }
  const change_handler = (tag, e) => onChecked(tag, e.target.checked);
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(4, model = $$props2.model);
  };
  return [currTags, $tags, tags, onChecked, model, change_handler];
}
class TagsEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$23, create_fragment$26, safe_not_equal, { model: 4 });
  }
}
function create_if_block$1a(ctx) {
  let div;
  let a;
  let t;
  let a_href_value;
  return {
    c() {
      div = element("div");
      a = element("a");
      t = text("Configure in crawler");
      attr(a, "href", a_href_value = urlCfg.crawlerDetail(ctx[1].team || 0, ctx[0]));
      attr(div, "class", "flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 3 && a_href_value !== (a_href_value = urlCfg.crawlerDetail(ctx2[1].team || 0, ctx2[0]))) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$25(ctx) {
  let if_block_anchor;
  let if_block = ctx[0] && create_if_block$1a(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$1a(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$22($$self, $$props, $$invalidate) {
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(1, $params = $$value));
  let { id: id2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
  };
  return [id2, $params];
}
class AutoScheduleMessage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$22, create_fragment$25, safe_not_equal, { id: 0 });
  }
}
function create_header_slot$f(ctx) {
  let t;
  return {
    c() {
      t = text("Global Actions");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_sub_header_slot$2(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "taken on changes for all monitors, merged with monitor's actions";
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_default_slot$V(ctx) {
  let div;
  let actionseditor;
  let updating_actions;
  let current;
  function actionseditor_actions_binding(value) {
    ctx[8](value);
  }
  let actionseditor_props = { sieve: ctx[5], global: true };
  if (ctx[0] !== void 0) {
    actionseditor_props.actions = ctx[0];
  }
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  binding_callbacks.push(() => bind$1(actionseditor, "actions", actionseditor_actions_binding));
  ctx[9](actionseditor);
  actionseditor.$on("close", ctx[10]);
  actionseditor.$on("manage", ctx[6]);
  return {
    c() {
      div = element("div");
      create_component(actionseditor.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(actionseditor, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const actionseditor_changes = {};
      if (!updating_actions && dirty & 1) {
        updating_actions = true;
        actionseditor_changes.actions = ctx2[0];
        add_flush_callback(() => updating_actions = false);
      }
      actionseditor.$set(actionseditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actionseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[9](null);
      destroy_component(actionseditor);
    }
  };
}
function create_if_block_1$T(ctx) {
  let manageemailsmodal;
  let current;
  manageemailsmodal = new ManageEmailModal({});
  manageemailsmodal.$on("close", ctx[12]);
  return {
    c() {
      create_component(manageemailsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(manageemailsmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(manageemailsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(manageemailsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(manageemailsmodal, detaching);
    }
  };
}
function create_if_block$19(ctx) {
  let managephonesmodal;
  let current;
  managephonesmodal = new ManagePhonesModal({});
  managephonesmodal.$on("close", ctx[13]);
  return {
    c() {
      create_component(managephonesmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managephonesmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(managephonesmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managephonesmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managephonesmodal, detaching);
    }
  };
}
function create_fragment$24(ctx) {
  let savemodal;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Global Actions",
      onSave: ctx[7],
      $$slots: {
        default: [create_default_slot$V],
        "sub-header": [create_sub_header_slot$2],
        header: [create_header_slot$f]
      },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[11]);
  let if_block0 = ctx[2] && create_if_block_1$T(ctx);
  let if_block1 = ctx[3] && create_if_block$19(ctx);
  return {
    c() {
      create_component(savemodal.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 262147) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$T(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$19(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$21($$self, $$props, $$invalidate) {
  let $user;
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(15, $route = $$value));
  const dispatch = createEventDispatcher();
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(14, $user = value));
  let actions;
  let sieve = new Model$2.Sieve();
  let actionsEditor;
  let showManageEmailsModal = false;
  let showManagePhonesModal = false;
  onMount(() => {
    if (!$user.id) {
      close();
      alert("Please sign in to save global actions");
    }
  });
  function close() {
    dispatch("close");
  }
  function showModal(e) {
    const type = e.detail;
    if (type === "email") {
      $$invalidate(2, showManageEmailsModal = true);
    } else if (type === "phone") {
      $$invalidate(3, showManagePhonesModal = true);
    }
  }
  async function save() {
    const isValid2 = actions.validateActions();
    if (isValid2) {
      const data = actions.getPosts();
      try {
        await Api.api("/prefs/actions", "PUT", data);
        if ($route.team === "0") {
          set_store_value(user, $user.prefs = { ...$user.prefs, actions: data }, $user);
        } else {
          const groups = $user.groups;
          const group2 = groups.find((g) => g.id === $route.team);
          group2.prefs = { ...group2.prefs, actions: data };
          set_store_value(user, $user.groups = [...groups], $user);
        }
        close();
      } catch (e) {
        console.error(e);
        Msg.error("Failed to save data, please try again later");
      }
    }
  }
  function actionseditor_actions_binding(value) {
    actions = value;
    $$invalidate(0, actions);
  }
  function actionseditor_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      actionsEditor = $$value;
      $$invalidate(1, actionsEditor);
    });
  }
  function close_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  const close_handler_2 = () => $$invalidate(2, showManageEmailsModal = false);
  const close_handler_3 = () => $$invalidate(3, showManagePhonesModal = false);
  return [
    actions,
    actionsEditor,
    showManageEmailsModal,
    showManagePhonesModal,
    user,
    sieve,
    showModal,
    save,
    actionseditor_actions_binding,
    actionseditor_binding,
    close_handler_1,
    close_handler,
    close_handler_2,
    close_handler_3
  ];
}
class GlobalActionsEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$21, create_fragment$24, safe_not_equal, {});
  }
}
function findNetAdditionsAndDeletions(addedText, deletedText) {
  if (!addedText && !deletedText) {
    return {
      netAdditions: "",
      netDeletions: ""
    };
  }
  const addArray = addedText.split(/\s+|\b/);
  const delArray = deletedText.split(/\s+|\b/);
  const addPositions = /* @__PURE__ */ new Map();
  const delPositions = /* @__PURE__ */ new Map();
  addArray.forEach((word, index2) => {
    if (word) {
      if (!addPositions.has(word)) {
        addPositions.set(word, []);
      }
      addPositions.get(word).push(index2);
    }
  });
  delArray.forEach((word, index2) => {
    if (word) {
      if (!delPositions.has(word)) {
        delPositions.set(word, []);
      }
      delPositions.get(word).push(index2);
    }
  });
  let netAdditions = [];
  let netDeletions = [];
  addArray.forEach((word, index2) => {
    if (word && delPositions.has(word)) {
      const positions = delPositions.get(word);
      positions.shift();
      if (positions.length === 0) {
        delPositions.delete(word);
      }
    } else if (word) {
      netAdditions.push({ word, index: index2 });
    }
  });
  delPositions.forEach((positions, word) => {
    positions.forEach((index2) => {
      netDeletions.push({ word, index: index2 });
    });
  });
  const sortedNetAdditions = netAdditions.sort((a, b) => a.index - b.index).map((item) => item.word).join(" ");
  const sortedNetDeletions = netDeletions.sort((a, b) => a.index - b.index).map((item) => item.word).join(" ");
  return {
    netAdditions: sortedNetAdditions,
    netDeletions: sortedNetDeletions
  };
}
async function getDiff(previousText, newText, contentType) {
  await initializeWorker();
  let addedText = "";
  let deletedText = "";
  let context;
  let type = contentType === C$1.TYPE_JSON ? "json" : "text";
  ({ addedText, deletedText } = await worker.diff(previousText, newText, { type }));
  const { netAdditions, netDeletions } = findNetAdditionsAndDeletions(addedText, deletedText);
  context = {
    sieve_data: { text: newText },
    old_sieve_data: { text: previousText },
    inserts: addedText,
    dels: deletedText,
    net_additions: netAdditions,
    net_deletions: netDeletions
  };
  return { addedText, deletedText, netAdditions, netDeletions, context };
}
function create_if_block_11$2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "No conditions were set.";
      attr(div, "class", "mt-3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_6$a(ctx) {
  let h4;
  let t1;
  let accordion;
  let current;
  accordion = new Accordion({
    props: {
      id: "Global",
      show: true,
      $$slots: {
        header: [create_header_slot_1],
        default: [create_default_slot_1$f]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      h4 = element("h4");
      h4.textContent = "Global Conditions";
      t1 = space();
      create_component(accordion.$$.fragment);
      attr(h4, "class", "mt-3");
    },
    m(target, anchor) {
      insert(target, h4, anchor);
      insert(target, t1, anchor);
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordion_changes = {};
      if (dirty[0] & 281 | dirty[1] & 256) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h4);
      if (detaching)
        detach(t1);
      destroy_component(accordion, detaching);
    }
  };
}
function create_if_block_10$3(ctx) {
  let sieveruleseditorv2;
  let updating_config;
  let current;
  function sieveruleseditorv2_config_binding(value) {
    ctx[22](value);
  }
  let sieveruleseditorv2_props = {
    disabled: ctx[0],
    inputs: getGlobalConditionInputs(),
    results: ctx[3].results
  };
  if (ctx[8].config !== void 0) {
    sieveruleseditorv2_props.config = ctx[8].config;
  }
  sieveruleseditorv2 = new SieveRulesEditorV2$1({ props: sieveruleseditorv2_props });
  binding_callbacks.push(() => bind$1(sieveruleseditorv2, "config", sieveruleseditorv2_config_binding));
  sieveruleseditorv2.$on("change", ctx[23]);
  return {
    c() {
      create_component(sieveruleseditorv2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv2_changes = {};
      if (dirty[0] & 1)
        sieveruleseditorv2_changes.disabled = ctx2[0];
      if (dirty[0] & 8)
        sieveruleseditorv2_changes.results = ctx2[3].results;
      if (!updating_config && dirty[0] & 256) {
        updating_config = true;
        sieveruleseditorv2_changes.config = ctx2[8].config;
        add_flush_callback(() => updating_config = false);
      }
      sieveruleseditorv2.$set(sieveruleseditorv2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv2, detaching);
    }
  };
}
function create_if_block_9$4(ctx) {
  let sieveruleseditorv1;
  let updating_config;
  let current;
  function sieveruleseditorv1_config_binding(value) {
    ctx[20](value);
  }
  let sieveruleseditorv1_props = {
    disabled: ctx[0],
    results: ctx[3].results
  };
  if (ctx[8].config !== void 0) {
    sieveruleseditorv1_props.config = ctx[8].config;
  }
  sieveruleseditorv1 = new SieveRulesEditorV1({ props: sieveruleseditorv1_props });
  binding_callbacks.push(() => bind$1(sieveruleseditorv1, "config", sieveruleseditorv1_config_binding));
  sieveruleseditorv1.$on("change", ctx[21]);
  return {
    c() {
      create_component(sieveruleseditorv1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv1_changes = {};
      if (dirty[0] & 1)
        sieveruleseditorv1_changes.disabled = ctx2[0];
      if (dirty[0] & 8)
        sieveruleseditorv1_changes.results = ctx2[3].results;
      if (!updating_config && dirty[0] & 256) {
        updating_config = true;
        sieveruleseditorv1_changes.config = ctx2[8].config;
        add_flush_callback(() => updating_config = false);
      }
      sieveruleseditorv1.$set(sieveruleseditorv1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv1, detaching);
    }
  };
}
function create_default_slot_1$f(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_9$4, create_if_block_10$3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[4] === V1$1)
      return 0;
    if (ctx2[4] === V2$1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "overflow-auto px-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_8$5(ctx) {
  let t;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      result: ctx[3].finalResult
    }
  });
  return {
    c() {
      t = text("(V2) ");
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty[0] & 8)
        ruleresult_changes.result = ctx2[3].finalResult;
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_if_block_7$8(ctx) {
  let t;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      result: ctx[3].finalResult
    }
  });
  return {
    c() {
      t = text("(V1) ");
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty[0] & 8)
        ruleresult_changes.result = ctx2[3].finalResult;
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_header_slot_1(ctx) {
  let div;
  let t;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_7$8, create_if_block_8$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4] === V1$1)
      return 0;
    if (ctx2[4] === V2$1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      t = text("Global\n        ");
      if (if_block)
        if_block.c();
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_1$S(ctx) {
  let h4;
  let t1;
  let accordion;
  let current;
  accordion = new Accordion({
    props: {
      id: "Monitor",
      show: true,
      $$slots: {
        header: [create_header_slot$e],
        default: [create_default_slot$U]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      h4 = element("h4");
      h4.textContent = "Monitor Conditions";
      t1 = space();
      create_component(accordion.$$.fragment);
      attr(h4, "class", "mt-3");
    },
    m(target, anchor) {
      insert(target, h4, anchor);
      insert(target, t1, anchor);
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordion_changes = {};
      if (dirty[0] & 519 | dirty[1] & 256) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h4);
      if (detaching)
        detach(t1);
      destroy_component(accordion, detaching);
    }
  };
}
function create_if_block_5$g(ctx) {
  let sieveruleseditorv2;
  let updating_config;
  let current;
  function sieveruleseditorv2_config_binding_1(value) {
    ctx[26](value);
  }
  let sieveruleseditorv2_props = {
    disabled: ctx[0],
    inputs: ctx[1],
    results: ctx[2].results
  };
  if (ctx[9].config !== void 0) {
    sieveruleseditorv2_props.config = ctx[9].config;
  }
  sieveruleseditorv2 = new SieveRulesEditorV2$1({ props: sieveruleseditorv2_props });
  binding_callbacks.push(() => bind$1(sieveruleseditorv2, "config", sieveruleseditorv2_config_binding_1));
  sieveruleseditorv2.$on("change", ctx[27]);
  return {
    c() {
      create_component(sieveruleseditorv2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv2_changes = {};
      if (dirty[0] & 1)
        sieveruleseditorv2_changes.disabled = ctx2[0];
      if (dirty[0] & 2)
        sieveruleseditorv2_changes.inputs = ctx2[1];
      if (dirty[0] & 4)
        sieveruleseditorv2_changes.results = ctx2[2].results;
      if (!updating_config && dirty[0] & 512) {
        updating_config = true;
        sieveruleseditorv2_changes.config = ctx2[9].config;
        add_flush_callback(() => updating_config = false);
      }
      sieveruleseditorv2.$set(sieveruleseditorv2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv2, detaching);
    }
  };
}
function create_if_block_4$m(ctx) {
  let sieveruleseditorv1;
  let updating_config;
  let current;
  function sieveruleseditorv1_config_binding_1(value) {
    ctx[24](value);
  }
  let sieveruleseditorv1_props = {
    disabled: ctx[0],
    results: ctx[2].results
  };
  if (ctx[9].config !== void 0) {
    sieveruleseditorv1_props.config = ctx[9].config;
  }
  sieveruleseditorv1 = new SieveRulesEditorV1({ props: sieveruleseditorv1_props });
  binding_callbacks.push(() => bind$1(sieveruleseditorv1, "config", sieveruleseditorv1_config_binding_1));
  sieveruleseditorv1.$on("change", ctx[25]);
  return {
    c() {
      create_component(sieveruleseditorv1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruleseditorv1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruleseditorv1_changes = {};
      if (dirty[0] & 1)
        sieveruleseditorv1_changes.disabled = ctx2[0];
      if (dirty[0] & 4)
        sieveruleseditorv1_changes.results = ctx2[2].results;
      if (!updating_config && dirty[0] & 512) {
        updating_config = true;
        sieveruleseditorv1_changes.config = ctx2[9].config;
        add_flush_callback(() => updating_config = false);
      }
      sieveruleseditorv1.$set(sieveruleseditorv1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruleseditorv1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruleseditorv1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruleseditorv1, detaching);
    }
  };
}
function create_default_slot$U(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_4$m, create_if_block_5$g];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (ctx2[13] === V1$1)
      return 0;
    if (ctx2[13] === V2$1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_3(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "overflow-auto px-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_3$w(ctx) {
  let t;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      result: ctx[2].finalResult
    }
  });
  return {
    c() {
      t = text("(V2) ");
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty[0] & 4)
        ruleresult_changes.result = ctx2[2].finalResult;
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_if_block_2$E(ctx) {
  let t;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: {
      result: ctx[2].finalResult
    }
  });
  return {
    c() {
      t = text("(V1) ");
      create_component(ruleresult.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(ruleresult, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty[0] & 4)
        ruleresult_changes.result = ctx2[2].finalResult;
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(ruleresult, detaching);
    }
  };
}
function create_header_slot$e(ctx) {
  let div;
  let t;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_2$E, create_if_block_3$w];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[13] === V1$1)
      return 0;
    if (ctx2[13] === V2$1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_2(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      t = text("Monitor\n        ");
      if (if_block)
        if_block.c();
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block$18(ctx) {
  let h5;
  let t;
  let ruleresult;
  let current;
  ruleresult = new RuleResult({
    props: { result: ctx[7] }
  });
  return {
    c() {
      h5 = element("h5");
      t = text("Final result: ");
      create_component(ruleresult.$$.fragment);
      attr(h5, "class", "mt-4");
    },
    m(target, anchor) {
      insert(target, h5, anchor);
      append(h5, t);
      mount_component(ruleresult, h5, null);
      current = true;
    },
    p(ctx2, dirty) {
      const ruleresult_changes = {};
      if (dirty[0] & 128)
        ruleresult_changes.result = ctx2[7];
      ruleresult.$set(ruleresult_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ruleresult.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ruleresult.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h5);
      destroy_component(ruleresult);
    }
  };
}
function create_fragment$23(ctx) {
  var _a, _b, _c, _d;
  let t0;
  let div;
  let t1;
  let t2;
  let current;
  let if_block0 = !((_a = ctx[8]) == null ? void 0 : _a.config) && !((_b = ctx[9]) == null ? void 0 : _b.config) && create_if_block_11$2();
  let if_block1 = ((_c = ctx[8]) == null ? void 0 : _c.config) && ctx[11] && create_if_block_6$a(ctx);
  let if_block2 = ((_d = ctx[9]) == null ? void 0 : _d.config) && create_if_block_1$S(ctx);
  let if_block3 = !ctx[0] && create_if_block$18(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      attr(div, "class", "col-md-12");
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append(div, t2);
      if (if_block3)
        if_block3.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2, _d2;
      if (!((_a2 = ctx2[8]) == null ? void 0 : _a2.config) && !((_b2 = ctx2[9]) == null ? void 0 : _b2.config)) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_11$2();
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (((_c2 = ctx2[8]) == null ? void 0 : _c2.config) && ctx2[11]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_6$a(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if ((_d2 = ctx2[9]) == null ? void 0 : _d2.config) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$S(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!ctx2[0]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$18(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
}
function instance$20($$self, $$props, $$invalidate) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  let finalResult;
  let $globalRule, $$unsubscribe_globalRule = noop$1, $$subscribe_globalRule = () => ($$unsubscribe_globalRule(), $$unsubscribe_globalRule = subscribe(globalRule, ($$value) => $$invalidate(8, $globalRule = $$value)), globalRule);
  let $sieveRule, $$unsubscribe_sieveRule = noop$1, $$subscribe_sieveRule = () => ($$unsubscribe_sieveRule(), $$unsubscribe_sieveRule = subscribe(sieveRule, ($$value) => $$invalidate(9, $sieveRule = $$value)), sieveRule);
  let $ctxEditorSieveDataInputs;
  let $user;
  $$self.$$.on_destroy.push(() => $$unsubscribe_globalRule());
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieveRule());
  let { meta } = $$props;
  let { context } = $$props;
  let { disabled = false } = $$props;
  let { contentType } = $$props;
  let { sieveConditionInputs } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(29, $user = value));
  const signedIn = !!$user.id;
  const dispatch = createEventDispatcher();
  const ruleData = meta.rule || meta.rules;
  const sieveConfig = (_b = (_a = ruleData == null ? void 0 : ruleData.sieve) == null ? void 0 : _a.rules) != null ? _b : null;
  const sieveVersion = (_d = (_c = ruleData == null ? void 0 : ruleData.sieve) == null ? void 0 : _c.version) != null ? _d : null;
  const globalConfig = (_g = (_f = (_e = ruleData == null ? void 0 : ruleData.global) == null ? void 0 : _e.rules) == null ? void 0 : _f.rule) != null ? _g : null;
  let globalVersion;
  if (globalConfig) {
    globalVersion = (_i = (_h = ruleData == null ? void 0 : ruleData.global) == null ? void 0 : _h.version) != null ? _i : V1$1;
  }
  let sieveRule = null;
  $$subscribe_sieveRule();
  let globalRule = null;
  $$subscribe_globalRule();
  let sieveRuleConfigResults;
  let globalRuleConfigResults;
  const getParsedJSON = (text2) => {
    try {
      return JSON.parse(text2);
    } catch (e) {
      return null;
    }
  };
  const ctxEditorSieveDataInputs = writable();
  component_subscribe($$self, ctxEditorSieveDataInputs, (value) => $$invalidate(28, $ctxEditorSieveDataInputs = value));
  setContext("editorSieveDataInputs", ctxEditorSieveDataInputs);
  const getVars = () => {
    var _a2, _b2;
    const vars = {
      $diff: {
        old: context.dels,
        new: context.inserts,
        net_add: context.net_additions,
        net_del: context.net_deletions
      },
      $new: context.sieve_data.text,
      $old: ((_a2 = context.old_sieve_data) == null ? void 0 : _a2.text) || "",
      $summary: {
        new: context.new_summary,
        old: context.old_summary
      }
    };
    if (contentType === C$1.TYPE_JSON) {
      vars.$new = getParsedJSON(context.sieve_data.text);
      vars.$old = getParsedJSON((_b2 = context.old_sieve_data) == null ? void 0 : _b2.text);
    }
    return vars;
  };
  const getHashedValues = () => {
    return {
      newTextHash: context.newTextHash,
      oldTextHashes: context.oldTextHashes
    };
  };
  const areRulesEmpty = (rules, version) => {
    return version === V1$1 ? rules.length === 0 : rules.length <= 1;
  };
  const evaluateSieveConditions = () => {
    if (!sieveRule)
      return;
    if (sieveVersion === V1$1) {
      $$invalidate(2, sieveRuleConfigResults = $sieveRule.config.evaluate(context, sieveConfig.numberFormat));
    } else if (sieveVersion === V2$1) {
      const vars = getVars();
      set_store_value(ctxEditorSieveDataInputs, $ctxEditorSieveDataInputs = _.pick(vars, ["$new", "$old", "$summary"]), $ctxEditorSieveDataInputs);
      $$invalidate(2, sieveRuleConfigResults = $sieveRule.config.evaluate(vars, getHashedValues(), sieveConfig.numberFormat));
    }
  };
  const initSieveRules = () => {
    if (sieveConfig && sieveVersion) {
      if (disabled && areRulesEmpty(sieveConfig.rules, sieveVersion)) {
        return;
      }
      $$subscribe_sieveRule($$invalidate(5, sieveRule = new Model$2.SieveRule(
        {
          config: sieveConfig,
          version: sieveVersion
        },
        { parse: true }
      )));
      evaluateSieveConditions();
    }
  };
  initSieveRules();
  const evaluateGlobalConditions = () => {
    if (!globalRule)
      return;
    if (globalVersion === V1$1) {
      $$invalidate(3, globalRuleConfigResults = $globalRule.config.evaluate(context, globalConfig.numberFormat));
    } else if (globalVersion === V2$1) {
      $$invalidate(3, globalRuleConfigResults = $globalRule.config.evaluate(getVars(), getHashedValues(), globalConfig.numberFormat));
    }
  };
  const initGlobalRule = () => {
    if (globalConfig && globalVersion) {
      if (disabled && areRulesEmpty(globalConfig.rules, globalVersion)) {
        return;
      }
      $$subscribe_globalRule($$invalidate(6, globalRule = new Model$2.SieveRule(
        {
          config: globalConfig,
          version: globalVersion
        },
        { parse: true }
      )));
      evaluateGlobalConditions();
    }
  };
  initGlobalRule();
  function sieveruleseditorv1_config_binding(value) {
    if ($$self.$$.not_equal($globalRule.config, value)) {
      $globalRule.config = value;
      globalRule.set($globalRule);
    }
  }
  const change_handler = (e) => {
    evaluateGlobalConditions();
    dispatch("globalRulesUpdate", $globalRule);
  };
  function sieveruleseditorv2_config_binding(value) {
    if ($$self.$$.not_equal($globalRule.config, value)) {
      $globalRule.config = value;
      globalRule.set($globalRule);
    }
  }
  const change_handler_1 = (e) => {
    evaluateGlobalConditions();
    dispatch("globalRulesUpdate", $globalRule);
  };
  function sieveruleseditorv1_config_binding_1(value) {
    if ($$self.$$.not_equal($sieveRule.config, value)) {
      $sieveRule.config = value;
      sieveRule.set($sieveRule);
    }
  }
  const change_handler_2 = (e) => {
    evaluateSieveConditions();
    dispatch("sieveRulesUpdate", $sieveRule);
  };
  function sieveruleseditorv2_config_binding_1(value) {
    if ($$self.$$.not_equal($sieveRule.config, value)) {
      $sieveRule.config = value;
      sieveRule.set($sieveRule);
    }
  }
  const change_handler_3 = (e) => {
    evaluateSieveConditions();
    dispatch("sieveRulesUpdate", $sieveRule);
  };
  $$self.$$set = ($$props2) => {
    if ("meta" in $$props2)
      $$invalidate(17, meta = $$props2.meta);
    if ("context" in $$props2)
      $$invalidate(18, context = $$props2.context);
    if ("disabled" in $$props2)
      $$invalidate(0, disabled = $$props2.disabled);
    if ("contentType" in $$props2)
      $$invalidate(19, contentType = $$props2.contentType);
    if ("sieveConditionInputs" in $$props2)
      $$invalidate(1, sieveConditionInputs = $$props2.sieveConditionInputs);
  };
  $$self.$$.update = () => {
    var _a2, _b2;
    if ($$self.$$.dirty[0] & 262144) {
      context && evaluateSieveConditions();
    }
    if ($$self.$$.dirty[0] & 262144) {
      context && evaluateGlobalConditions();
    }
    if ($$self.$$.dirty[0] & 12) {
      $$invalidate(7, finalResult = ((_a2 = sieveRuleConfigResults == null ? void 0 : sieveRuleConfigResults.finalResult) != null ? _a2 : true) && ((_b2 = globalRuleConfigResults == null ? void 0 : globalRuleConfigResults.finalResult) != null ? _b2 : true));
    }
  };
  return [
    disabled,
    sieveConditionInputs,
    sieveRuleConfigResults,
    globalRuleConfigResults,
    globalVersion,
    sieveRule,
    globalRule,
    finalResult,
    $globalRule,
    $sieveRule,
    user,
    signedIn,
    dispatch,
    sieveVersion,
    ctxEditorSieveDataInputs,
    evaluateSieveConditions,
    evaluateGlobalConditions,
    meta,
    context,
    contentType,
    sieveruleseditorv1_config_binding,
    change_handler,
    sieveruleseditorv2_config_binding,
    change_handler_1,
    sieveruleseditorv1_config_binding_1,
    change_handler_2,
    sieveruleseditorv2_config_binding_1,
    change_handler_3
  ];
}
class PreviewEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$20,
      create_fragment$23,
      safe_not_equal,
      {
        meta: 17,
        context: 18,
        disabled: 0,
        contentType: 19,
        sieveConditionInputs: 1
      },
      null,
      [-1, -1]
    );
  }
}
function create_else_block_1$e(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "<Empty>";
      attr(span, "class", "alert alert-light p-0 px-1 code");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block$17(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$R, create_else_block$F];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[2].length > 60)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$F(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[2]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4)
        set_data(t, ctx2[2]);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$R(ctx) {
  let t0_value = ctx[2].substring(0, 60) + "";
  let t0;
  let t1;
  let popover;
  let current;
  popover = new Popover({
    props: {
      header: ctx[1],
      content: ctx[2],
      $$slots: { default: [create_default_slot_1$e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
      create_component(popover.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      mount_component(popover, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 4) && t0_value !== (t0_value = ctx2[2].substring(0, 60) + ""))
        set_data(t0, t0_value);
      const popover_changes = {};
      if (dirty & 2)
        popover_changes.header = ctx2[1];
      if (dirty & 4)
        popover_changes.content = ctx2[2];
      if (dirty & 8) {
        popover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      popover.$set(popover_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(popover.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(popover.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      destroy_component(popover, detaching);
    }
  };
}
function create_default_slot_1$e(ctx) {
  let a;
  return {
    c() {
      a = element("a");
      a.textContent = "Show more";
      attr(a, "href", "#");
      attr(a, "tabindex", "0");
      attr(a, "role", "button");
    },
    m(target, anchor) {
      insert(target, a, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_default_slot$T(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$17, create_else_block_1$e];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "pa1 f6 w-100 overflow-hidden");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_header_slot$d(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[1]);
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$22(ctx) {
  let accordion;
  let current;
  accordion = new Accordion({
    props: {
      id: ctx[0],
      show: true,
      class: "pb-1",
      $$slots: {
        header: [create_header_slot$d],
        default: [create_default_slot$T]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(accordion.$$.fragment);
    },
    m(target, anchor) {
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const accordion_changes = {};
      if (dirty & 1)
        accordion_changes.id = ctx2[0];
      if (dirty & 14) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordion, detaching);
    }
  };
}
function instance$1$($$self, $$props, $$invalidate) {
  let { id: id2 } = $$props;
  let { header } = $$props;
  let { content } = $$props;
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id2 = $$props2.id);
    if ("header" in $$props2)
      $$invalidate(1, header = $$props2.header);
    if ("content" in $$props2)
      $$invalidate(2, content = $$props2.content);
  };
  return [id2, header, content];
}
class SieveVariables extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1$, create_fragment$22, safe_not_equal, { id: 0, header: 1, content: 2 });
  }
}
function create_fragment$21(ctx) {
  let div1;
  let h6;
  let t1;
  let div0;
  let t2;
  let sievevariables0;
  let t3;
  let sievevariables1;
  let t4;
  let sievevariables2;
  let t5;
  let sievevariables3;
  let current;
  sievevariables0 = new SieveVariables({
    props: {
      id: "AddedText",
      header: "Added Text",
      content: ctx[0]
    }
  });
  sievevariables1 = new SieveVariables({
    props: {
      id: "DeletedText",
      header: "Deleted Text",
      content: ctx[1]
    }
  });
  sievevariables2 = new SieveVariables({
    props: {
      id: "NetAdditions",
      header: "Net added text",
      content: ctx[2]
    }
  });
  sievevariables3 = new SieveVariables({
    props: {
      id: "NetDeletions",
      header: "Net deleted text",
      content: ctx[3]
    }
  });
  return {
    c() {
      div1 = element("div");
      h6 = element("h6");
      h6.textContent = "Variables";
      t1 = space();
      div0 = element("div");
      t2 = space();
      create_component(sievevariables0.$$.fragment);
      t3 = space();
      create_component(sievevariables1.$$.fragment);
      t4 = space();
      create_component(sievevariables2.$$.fragment);
      t5 = space();
      create_component(sievevariables3.$$.fragment);
      attr(h6, "class", "f5 px-2 fw-bold");
      attr(div0, "class", "border-top");
      attr(div1, "class", "col-md-4 px-1");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, h6);
      append(div1, t1);
      append(div1, div0);
      append(div1, t2);
      mount_component(sievevariables0, div1, null);
      append(div1, t3);
      mount_component(sievevariables1, div1, null);
      append(div1, t4);
      mount_component(sievevariables2, div1, null);
      append(div1, t5);
      mount_component(sievevariables3, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const sievevariables0_changes = {};
      if (dirty & 1)
        sievevariables0_changes.content = ctx2[0];
      sievevariables0.$set(sievevariables0_changes);
      const sievevariables1_changes = {};
      if (dirty & 2)
        sievevariables1_changes.content = ctx2[1];
      sievevariables1.$set(sievevariables1_changes);
      const sievevariables2_changes = {};
      if (dirty & 4)
        sievevariables2_changes.content = ctx2[2];
      sievevariables2.$set(sievevariables2_changes);
      const sievevariables3_changes = {};
      if (dirty & 8)
        sievevariables3_changes.content = ctx2[3];
      sievevariables3.$set(sievevariables3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sievevariables0.$$.fragment, local);
      transition_in(sievevariables1.$$.fragment, local);
      transition_in(sievevariables2.$$.fragment, local);
      transition_in(sievevariables3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievevariables0.$$.fragment, local);
      transition_out(sievevariables1.$$.fragment, local);
      transition_out(sievevariables2.$$.fragment, local);
      transition_out(sievevariables3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(sievevariables0);
      destroy_component(sievevariables1);
      destroy_component(sievevariables2);
      destroy_component(sievevariables3);
    }
  };
}
function instance$1_($$self, $$props, $$invalidate) {
  let { addedText } = $$props;
  let { deletedText } = $$props;
  let { netAdditions } = $$props;
  let { netDeletions } = $$props;
  $$self.$$set = ($$props2) => {
    if ("addedText" in $$props2)
      $$invalidate(0, addedText = $$props2.addedText);
    if ("deletedText" in $$props2)
      $$invalidate(1, deletedText = $$props2.deletedText);
    if ("netAdditions" in $$props2)
      $$invalidate(2, netAdditions = $$props2.netAdditions);
    if ("netDeletions" in $$props2)
      $$invalidate(3, netDeletions = $$props2.netDeletions);
  };
  return [addedText, deletedText, netAdditions, netDeletions];
}
class Variables extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1_, create_fragment$21, safe_not_equal, {
      addedText: 0,
      deletedText: 1,
      netAdditions: 2,
      netDeletions: 3
    });
  }
}
function create_if_block_1$Q(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[9]);
      attr(div, "class", "alert alert-warning p-2 m-2");
      attr(div, "role", "alert");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 512)
        set_data(t, ctx2[9]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$16(ctx) {
  let sieverules;
  let current;
  sieverules = new PreviewEditor({
    props: {
      meta: ctx[21](),
      context: ctx[16],
      contentType: ctx[2],
      sieveConditionInputs: ctx[3]
    }
  });
  sieverules.$on("sieveRulesUpdate", ctx[29]);
  sieverules.$on("globalRulesUpdate", ctx[30]);
  return {
    c() {
      create_component(sieverules.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieverules, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieverules_changes = {};
      if (dirty[0] & 65536)
        sieverules_changes.context = ctx2[16];
      if (dirty[0] & 4)
        sieverules_changes.contentType = ctx2[2];
      if (dirty[0] & 8)
        sieverules_changes.sieveConditionInputs = ctx2[3];
      sieverules.$set(sieverules_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieverules.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieverules.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieverules, detaching);
    }
  };
}
function create_fragment$20(ctx) {
  let div4;
  let div1;
  let div0;
  let span0;
  let t1;
  let span1;
  let menu0;
  let t2;
  let textarea0;
  let textarea0_disabled_value;
  let t3;
  let div3;
  let div2;
  let span2;
  let t5;
  let span3;
  let menu1;
  let t6;
  let textarea1;
  let textarea1_disabled_value;
  let t7;
  let variables;
  let t8;
  let div5;
  let t9;
  let t10;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  menu0 = new Menu({
    props: {
      allowNull: false,
      id: ctx[10] === void 0 ? "custom" : ctx[10],
      items: [
        { id: "custom", name: "Custom Data" },
        ...ctx[0].map(ctx[25])
      ]
    }
  });
  menu0.$on("select", ctx[26]);
  menu1 = new Menu({
    props: {
      allowNull: false,
      id: ctx[11] === void 0 ? "custom" : ctx[11],
      items: [
        { id: "custom", name: "Custom Data" },
        ...ctx[0].map(ctx[27])
      ]
    }
  });
  menu1.$on("select", ctx[28]);
  variables = new Variables({
    props: {
      addedText: ctx[12],
      deletedText: ctx[13],
      netAdditions: ctx[14],
      netDeletions: ctx[15]
    }
  });
  let if_block0 = ctx[9] && !(ctx[4] || ctx[5] || ctx[6]) && create_if_block_1$Q(ctx);
  let if_block1 = ctx[16] && create_if_block$16(ctx);
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      span0.textContent = "Previous Text";
      t1 = space();
      span1 = element("span");
      create_component(menu0.$$.fragment);
      t2 = space();
      textarea0 = element("textarea");
      t3 = space();
      div3 = element("div");
      div2 = element("div");
      span2 = element("span");
      span2.textContent = "Text";
      t5 = space();
      span3 = element("span");
      create_component(menu1.$$.fragment);
      t6 = space();
      textarea1 = element("textarea");
      t7 = space();
      create_component(variables.$$.fragment);
      t8 = space();
      div5 = element("div");
      t9 = space();
      if (if_block0)
        if_block0.c();
      t10 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(span0, "class", "f5 px-2 fw-bold");
      attr(span1, "class", "f6 px-2");
      attr(div0, "class", "flex pb1 border-bottom justify-content-between");
      attr(textarea0, "class", "pa2 w-100 border-0 f6 h-[300px]");
      textarea0.disabled = textarea0_disabled_value = ctx[10] !== void 0;
      textarea0.value = ctx[7];
      attr(div1, "class", "col-md-4 border-end px-0");
      attr(span2, "class", "f5 px-2 fw-bold");
      attr(span3, "class", "f6 px-2");
      attr(div2, "class", "flex pb1 border-bottom justify-content-between");
      attr(textarea1, "class", "pa2 w-100 border-0 f6 h-[300px]");
      textarea1.disabled = textarea1_disabled_value = ctx[11] !== void 0;
      textarea1.value = ctx[8];
      attr(div3, "class", "col-md-4 border-end px-0");
      attr(div4, "class", "row");
      attr(div5, "class", "border-top");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, div0);
      append(div0, span0);
      append(div0, t1);
      append(div0, span1);
      mount_component(menu0, span1, null);
      append(div1, t2);
      append(div1, textarea0);
      append(div4, t3);
      append(div4, div3);
      append(div3, div2);
      append(div2, span2);
      append(div2, t5);
      append(div2, span3);
      mount_component(menu1, span3, null);
      append(div3, t6);
      append(div3, textarea1);
      append(div4, t7);
      mount_component(variables, div4, null);
      insert(target, t8, anchor);
      insert(target, div5, anchor);
      insert(target, t9, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t10, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(textarea0, "input", ctx[20]),
          listen(textarea1, "input", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const menu0_changes = {};
      if (dirty[0] & 1024)
        menu0_changes.id = ctx2[10] === void 0 ? "custom" : ctx2[10];
      if (dirty[0] & 1)
        menu0_changes.items = [
          { id: "custom", name: "Custom Data" },
          ...ctx2[0].map(ctx2[25])
        ];
      menu0.$set(menu0_changes);
      if (!current || dirty[0] & 1024 && textarea0_disabled_value !== (textarea0_disabled_value = ctx2[10] !== void 0)) {
        textarea0.disabled = textarea0_disabled_value;
      }
      if (!current || dirty[0] & 128) {
        textarea0.value = ctx2[7];
      }
      const menu1_changes = {};
      if (dirty[0] & 2048)
        menu1_changes.id = ctx2[11] === void 0 ? "custom" : ctx2[11];
      if (dirty[0] & 1)
        menu1_changes.items = [
          { id: "custom", name: "Custom Data" },
          ...ctx2[0].map(ctx2[27])
        ];
      menu1.$set(menu1_changes);
      if (!current || dirty[0] & 2048 && textarea1_disabled_value !== (textarea1_disabled_value = ctx2[11] !== void 0)) {
        textarea1.disabled = textarea1_disabled_value;
      }
      if (!current || dirty[0] & 256) {
        textarea1.value = ctx2[8];
      }
      const variables_changes = {};
      if (dirty[0] & 4096)
        variables_changes.addedText = ctx2[12];
      if (dirty[0] & 8192)
        variables_changes.deletedText = ctx2[13];
      if (dirty[0] & 16384)
        variables_changes.netAdditions = ctx2[14];
      if (dirty[0] & 32768)
        variables_changes.netDeletions = ctx2[15];
      variables.$set(variables_changes);
      if (ctx2[9] && !(ctx2[4] || ctx2[5] || ctx2[6])) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$Q(ctx2);
          if_block0.c();
          if_block0.m(t10.parentNode, t10);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[16]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 65536) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$16(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu0.$$.fragment, local);
      transition_in(menu1.$$.fragment, local);
      transition_in(variables.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(menu0.$$.fragment, local);
      transition_out(menu1.$$.fragment, local);
      transition_out(variables.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(menu0);
      destroy_component(menu1);
      destroy_component(variables);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(div5);
      if (detaching)
        detach(t9);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t10);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1Z($$self, $$props, $$invalidate) {
  let $sieveRules, $$unsubscribe_sieveRules = noop$1, $$subscribe_sieveRules = () => ($$unsubscribe_sieveRules(), $$unsubscribe_sieveRules = subscribe(sieveRules, ($$value) => $$invalidate(34, $sieveRules = $$value)), sieveRules);
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieveRules());
  let { sieveData } = $$props;
  let { sieveRules } = $$props;
  $$subscribe_sieveRules();
  let { globalRules } = $$props;
  let { contentType } = $$props;
  let { setLoading } = $$props;
  let { initialIds } = $$props;
  let { sieveConditionInputs } = $$props;
  let diffRequestCounter = 0;
  let previousText = "";
  let newText = "";
  let previousSieveDataLoading;
  let newSieveDataLoading;
  let diffLoading;
  let diffError;
  let previousSieveDataId;
  let nextSieveDataId;
  let nextSieveData = null;
  let previousSeiveData = null;
  if (initialIds) {
    previousSieveDataId = initialIds.previousSieveId;
    nextSieveDataId = initialIds.nextSieveId;
  } else {
    if (sieveData.length >= 2) {
      previousSieveDataId = sieveData.at(1).id;
      nextSieveDataId = sieveData.at(0).id;
    } else if (sieveData.length) {
      nextSieveDataId = sieveData.at(0).id;
    }
  }
  const getSieveData = async (dataId) => {
    const sd = sieveData.find((data) => data.id === dataId);
    await sd.fetch();
    return sd;
  };
  const getSieveDataTextForPreviousSieve = async (dataId) => {
    previousSeiveData = await getSieveData(dataId);
    return previousSeiveData.get("text");
  };
  const getSieveDataTextForNewSieve = async (dataId) => {
    nextSieveData = await getSieveData(dataId);
    return nextSieveData.get("text");
  };
  const init2 = async () => {
    if (previousSieveDataId) {
      $$invalidate(7, previousText = await getSieveDataTextForPreviousSieve(previousSieveDataId));
    }
    if (nextSieveDataId) {
      $$invalidate(8, newText = await getSieveDataTextForNewSieve(nextSieveDataId));
    }
  };
  init2();
  let addedText = "";
  let deletedText = "";
  let netAdditions = "";
  let netDeletions = "";
  let context = void 0;
  const getUrlsForJob = async (sieveDataId) => {
    const { crawler_id: crawlerId, job_id: jobId } = JSON.parse(sieveData.find((data) => data.id === sieveDataId).data);
    let jobData = await Api.api(`/crawlers/data/${crawlerId}/jobs/${jobId}/urls`);
    return jobData.data.filter((url) => [100, 120].includes(url.state)).map((url) => url.url).join("\n");
  };
  const updatePreviousSieveDataId = async (sieveDataId) => {
    if (sieveDataId === "custom") {
      $$invalidate(10, previousSieveDataId = void 0);
    } else {
      $$invalidate(4, previousSieveDataLoading = true);
      if (contentType === C$1.TYPE_SITEMAP) {
        $$invalidate(7, previousText = await getUrlsForJob(sieveDataId));
      } else {
        $$invalidate(7, previousText = await getSieveDataTextForPreviousSieve(sieveDataId));
      }
      $$invalidate(4, previousSieveDataLoading = false);
      $$invalidate(10, previousSieveDataId = sieveDataId);
    }
    loadDiff();
  };
  const updateNewSieveDataId = async (sieveDataId) => {
    if (sieveDataId === "custom") {
      $$invalidate(11, nextSieveDataId = void 0);
    } else {
      $$invalidate(5, newSieveDataLoading = true);
      if (contentType === C$1.TYPE_SITEMAP) {
        $$invalidate(8, newText = await getUrlsForJob(sieveDataId));
      } else {
        $$invalidate(8, newText = await getSieveDataTextForNewSieve(sieveDataId));
      }
      $$invalidate(5, newSieveDataLoading = false);
      $$invalidate(11, nextSieveDataId = sieveDataId);
    }
    loadDiff();
  };
  previousSieveDataId && updatePreviousSieveDataId(previousSieveDataId);
  nextSieveDataId && updateNewSieveDataId(nextSieveDataId);
  const updateContext = () => {
    var _a, _b;
    if (nextSieveDataId) {
      const currentSieveData = sieveData.find((data) => data.id === nextSieveDataId);
      $$invalidate(16, context.new_summary = currentSieveData.get("summary"), context);
    }
    if (previousSieveDataId) {
      const previousSieveData = sieveData.find((data) => data.id === previousSieveDataId);
      $$invalidate(16, context.old_summary = previousSieveData.get("summary"), context);
    }
    if (nextSieveDataId) {
      const currentSieveData = sieveData.find((data) => data.id === nextSieveDataId);
      $$invalidate(16, context.oldTextHashes = ((_a = currentSieveData.get("meta")) == null ? void 0 : _a.oldTextHashes) || [], context);
      $$invalidate(16, context.newTextHash = currentSieveData.get("text_hash"), context);
    } else if (sieveData.length) {
      const currentSieveData = sieveData.at(sieveData.length - 1);
      $$invalidate(16, context.oldTextHashes = ((_b = currentSieveData.get("meta")) == null ? void 0 : _b.oldTextHashes) || [], context);
      $$invalidate(16, context.newTextHash = currentSieveData.get("text_hash"), context);
    } else {
      $$invalidate(16, context.oldTextHashes = [], context);
      $$invalidate(16, context.newTextHash = "", context);
    }
  };
  async function loadDiff() {
    const currentRequest = ++diffRequestCounter;
    try {
      $$invalidate(6, diffLoading = true);
      $$invalidate(9, diffError = false);
      const diffResult = await getDiff(previousText, newText, contentType);
      if (currentRequest !== diffRequestCounter) {
        return;
      }
      $$invalidate(12, addedText = diffResult.addedText);
      $$invalidate(13, deletedText = diffResult.deletedText);
      $$invalidate(14, netAdditions = diffResult.netAdditions);
      $$invalidate(15, netDeletions = diffResult.netDeletions);
      $$invalidate(16, context = diffResult.context);
      updateContext();
      $$invalidate(6, diffLoading = false);
    } catch (e) {
      if (currentRequest !== diffRequestCounter) {
        return;
      }
      $$invalidate(6, diffLoading = false);
      $$invalidate(9, diffError = "Failed to diff data: " + e.message);
      if (contentType === C$1.TYPE_JSON) {
        $$invalidate(9, diffError = "Failed to parse data. Please provide valid JSON data for both inputs.");
      }
      console.error("cannot get the diff ", e);
    }
  }
  const debouncedLoadDiff = debounce(loadDiff, 500);
  const onNextTextChange = (e) => {
    $$invalidate(8, newText = e.target.value);
    debouncedLoadDiff();
  };
  const onPreviousTextChange = (e) => {
    $$invalidate(7, previousText = e.target.value);
    debouncedLoadDiff();
  };
  const getMeta = () => {
    const meta = {
      rule: {
        global: {
          rules: {
            rule: globalRules.config ? JSON.parse(globalRules.config) : {}
          },
          version: globalRules.version
        },
        sieve: {
          rules: $sieveRules.config.toJSON(),
          version: $sieveRules.version
        }
      },
      oldTextHashes: context.oldTextHashes
    };
    return meta;
  };
  loadDiff();
  const func2 = (data) => {
    return {
      id: data.id,
      name: formatLogTime(data.get("ts"))
    };
  };
  const select_handler = (e) => updatePreviousSieveDataId(e.detail);
  const func_12 = (data) => {
    return {
      id: data.id,
      name: formatLogTime(data.get("ts"))
    };
  };
  const select_handler_1 = (e) => updateNewSieveDataId(e.detail);
  function sieveRulesUpdate_handler(event) {
    bubble.call(this, $$self, event);
  }
  function globalRulesUpdate_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieveData" in $$props2)
      $$invalidate(0, sieveData = $$props2.sieveData);
    if ("sieveRules" in $$props2)
      $$subscribe_sieveRules($$invalidate(1, sieveRules = $$props2.sieveRules));
    if ("globalRules" in $$props2)
      $$invalidate(22, globalRules = $$props2.globalRules);
    if ("contentType" in $$props2)
      $$invalidate(2, contentType = $$props2.contentType);
    if ("setLoading" in $$props2)
      $$invalidate(23, setLoading = $$props2.setLoading);
    if ("initialIds" in $$props2)
      $$invalidate(24, initialIds = $$props2.initialIds);
    if ("sieveConditionInputs" in $$props2)
      $$invalidate(3, sieveConditionInputs = $$props2.sieveConditionInputs);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 8388720) {
      setLoading(previousSieveDataLoading || newSieveDataLoading || diffLoading);
    }
  };
  return [
    sieveData,
    sieveRules,
    contentType,
    sieveConditionInputs,
    previousSieveDataLoading,
    newSieveDataLoading,
    diffLoading,
    previousText,
    newText,
    diffError,
    previousSieveDataId,
    nextSieveDataId,
    addedText,
    deletedText,
    netAdditions,
    netDeletions,
    context,
    updatePreviousSieveDataId,
    updateNewSieveDataId,
    onNextTextChange,
    onPreviousTextChange,
    getMeta,
    globalRules,
    setLoading,
    initialIds,
    func2,
    select_handler,
    func_12,
    select_handler_1,
    sieveRulesUpdate_handler,
    globalRulesUpdate_handler
  ];
}
class SieveRuleDebuggerEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$1Z,
      create_fragment$20,
      safe_not_equal,
      {
        sieveData: 0,
        sieveRules: 1,
        globalRules: 22,
        contentType: 2,
        setLoading: 23,
        initialIds: 24,
        sieveConditionInputs: 3
      },
      null,
      [-1, -1]
    );
  }
}
function createPromiseStore(promise) {
  const store2 = writable({
    loading: true,
    error: null,
    value: null
  });
  promise.then((value) => {
    store2.set({ loading: false, error: null, value });
  }).catch((error2) => {
    store2.set({
      loading: false,
      error: error2,
      value: null
    });
  });
  return {
    subscribe: store2.subscribe
  };
}
function create_else_block$E(ctx) {
  let sieveruledebuggereditor;
  let current;
  sieveruledebuggereditor = new SieveRuleDebuggerEditor({
    props: {
      initialIds: ctx[3],
      setLoading: ctx[13],
      sieveConditionInputs: ctx[4],
      sieveRules: ctx[1],
      contentType: ctx[2],
      sieveData: ctx[7],
      globalRules: ctx[0]
    }
  });
  sieveruledebuggereditor.$on("globalRulesUpdate", ctx[12]);
  sieveruledebuggereditor.$on("sieveRulesUpdate", ctx[11]);
  return {
    c() {
      create_component(sieveruledebuggereditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruledebuggereditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruledebuggereditor_changes = {};
      if (dirty & 8)
        sieveruledebuggereditor_changes.initialIds = ctx2[3];
      if (dirty & 16)
        sieveruledebuggereditor_changes.sieveConditionInputs = ctx2[4];
      if (dirty & 2)
        sieveruledebuggereditor_changes.sieveRules = ctx2[1];
      if (dirty & 4)
        sieveruledebuggereditor_changes.contentType = ctx2[2];
      if (dirty & 1)
        sieveruledebuggereditor_changes.globalRules = ctx2[0];
      sieveruledebuggereditor.$set(sieveruledebuggereditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruledebuggereditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruledebuggereditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruledebuggereditor, detaching);
    }
  };
}
function create_if_block_1$P(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_default_slot$S(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$P, create_else_block$E];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6].loading)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$15(ctx) {
  let spinner;
  let current;
  spinner = new Spinner({ props: { class: "text-primary mb-0.5" } });
  return {
    c() {
      create_component(spinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spinner, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spinner, detaching);
    }
  };
}
function create_header_slot$c(ctx) {
  let div;
  let t;
  let current;
  let if_block = ctx[5] && create_if_block$15();
  return {
    c() {
      div = element("div");
      t = text("Test Conditions\n    ");
      if (if_block)
        if_block.c();
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[5]) {
        if (if_block) {
          if (dirty & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$15();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_buttons_slot$5(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = "Save";
      attr(button, "class", "btn btn-primary");
      attr(div, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[9]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1$(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      modalDialogClasses: "modal-xl",
      labelClose: "Cancel",
      scrollable: true,
      $$slots: {
        buttons: [create_buttons_slot$5],
        header: [create_header_slot$c],
        default: [create_default_slot$S]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[17]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 2097279) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$1Y($$self, $$props, $$invalidate) {
  let $sieveDataStore;
  let { sieveId } = $$props;
  let { globalRules } = $$props;
  let { rule } = $$props;
  let { onClose } = $$props;
  let { onSave } = $$props;
  let { contentType } = $$props;
  let { initialIds } = $$props;
  let { sieveConditionInputs } = $$props;
  let finalSieveRules = void 0;
  let finalGlobalRules = void 0;
  let loading2 = false;
  const sieveDataList = new SieveDataCollection([], { sieveId });
  const getSieveDataForSieve = async () => {
    if (!sieveId) {
      sieveDataList.set([]);
      return;
    }
    await sieveDataList.fetch({
      data: {
        _opt: {
          only: ["id", "ts", "meta", "text_hash", "summary"]
        }
      }
    });
  };
  let sieveDataStore = createPromiseStore(getSieveDataForSieve());
  component_subscribe($$self, sieveDataStore, (value) => $$invalidate(6, $sieveDataStore = value));
  const handleSave = () => {
    onSave(finalSieveRules, finalGlobalRules);
  };
  const handleClose = () => {
    onClose(finalSieveRules, finalGlobalRules);
  };
  const sieveRulesUpdate = (e) => {
    finalSieveRules = e.detail;
  };
  const globalRulesUpdate = (e) => {
    finalGlobalRules = e.detail;
  };
  const setLoading = (val) => {
    $$invalidate(5, loading2 = val);
  };
  const close_handler = () => handleClose();
  $$self.$$set = ($$props2) => {
    if ("sieveId" in $$props2)
      $$invalidate(14, sieveId = $$props2.sieveId);
    if ("globalRules" in $$props2)
      $$invalidate(0, globalRules = $$props2.globalRules);
    if ("rule" in $$props2)
      $$invalidate(1, rule = $$props2.rule);
    if ("onClose" in $$props2)
      $$invalidate(15, onClose = $$props2.onClose);
    if ("onSave" in $$props2)
      $$invalidate(16, onSave = $$props2.onSave);
    if ("contentType" in $$props2)
      $$invalidate(2, contentType = $$props2.contentType);
    if ("initialIds" in $$props2)
      $$invalidate(3, initialIds = $$props2.initialIds);
    if ("sieveConditionInputs" in $$props2)
      $$invalidate(4, sieveConditionInputs = $$props2.sieveConditionInputs);
  };
  return [
    globalRules,
    rule,
    contentType,
    initialIds,
    sieveConditionInputs,
    loading2,
    $sieveDataStore,
    sieveDataList,
    sieveDataStore,
    handleSave,
    handleClose,
    sieveRulesUpdate,
    globalRulesUpdate,
    setLoading,
    sieveId,
    onClose,
    onSave,
    close_handler
  ];
}
class SieveRuleDebuggerEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Y, create_fragment$1$, safe_not_equal, {
      sieveId: 14,
      globalRules: 0,
      rule: 1,
      onClose: 15,
      onSave: 16,
      contentType: 2,
      initialIds: 3,
      sieveConditionInputs: 4
    });
  }
}
function get_each_context$w(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_catch_block$q(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$q(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Email",
      onSave: ctx[3],
      saveLabel: "Send",
      $$slots: { default: [create_default_slot$R] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[8]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 131075) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_each_block$w(key_1, ctx) {
  let option;
  let t0_value = ctx[14].value + "";
  let t0;
  let t1;
  let option_value_value;
  return {
    key: key_1,
    first: null,
    c() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      option.__value = option_value_value = ctx[14].value;
      option.value = option.__value;
      this.first = option;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t0);
      append(option, t1);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[14].value + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && option_value_value !== (option_value_value = ctx[14].value)) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_default_slot$R(ctx) {
  let select2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[14].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$w(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$w(key, child_ctx));
  }
  return {
    c() {
      select2 = element("select");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(select2, "class", "w-100");
      if (ctx[1] === void 0)
        add_render_callback(() => ctx[7].call(select2));
    },
    m(target, anchor) {
      insert(target, select2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      select_option(select2, ctx[1], true);
      if (!mounted) {
        dispose = listen(select2, "change", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value = ctx2[0];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, select2, destroy_block, create_each_block$w, null, get_each_context$w);
      }
      if (dirty & 3) {
        select_option(select2, ctx2[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(select2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function create_pending_block$q(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_fragment$1_(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$q,
    then: create_then_block$q,
    catch: create_catch_block$q,
    value: 13,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function setStyle(els, name, value) {
  els.forEach(function(el2) {
    el2.style[name] = value;
  });
}
function setDiffStyle(doc) {
  setStyle(doc.querySelectorAll(".removed"), "background-color", "#ff9494");
  setStyle(doc.querySelectorAll(".inserted"), "background-color", "#b7fdcb");
  setStyle(doc.querySelectorAll("span.inserted, span.removed"), "padding", "1px 4px");
  setStyle(doc.querySelectorAll("a.removed, a .removed"), "color", "#008");
  setStyle(doc.querySelectorAll("img.removed"), "border", "solid 2px red");
  setStyle(doc.querySelectorAll("img.removed"), "background-color", "transparent");
  setStyle(doc.querySelectorAll("img.removed"), "padding", "2px");
  setStyle(doc.querySelectorAll("img.inserted"), "border", "solid 2px green");
  setStyle(doc.querySelectorAll("img.inserted"), "background-color", "transparent");
  setStyle(doc.querySelectorAll("img.inserted"), "padding", "2px");
}
function instance$1X($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { diffView = null } = $$props;
  let { sieve } = $$props;
  let { model } = $$props;
  const type = model.get("data_type");
  let emails = [];
  let selectedEmail;
  function close() {
    dispatch("close");
  }
  async function fetchData() {
    Msg.info("loading");
    const res = await Api.api("/users/attrs", { name: "email", state: 40 });
    $$invalidate(0, emails = res.data);
    Msg.reset();
  }
  function getEmailContent() {
    let content;
    if (type === C$1.TYPE_JSON) {
      content = diffView.innerHTML;
    } else {
      let doc = diffView.contentDocument.cloneNode(true);
      if (type === C$1.TYPE_HTML) {
        setDiffStyle(doc);
      } else if (type === C$1.TYPE_XML) {
        content = `<pre>${content}</pre>`;
      }
      content = doc.body.innerHTML;
    }
    return content;
  }
  async function save() {
    try {
      await Api.api("/agents/actions/email", "POST", {
        action: { config: { email: selectedEmail } },
        sieve: sieve.pick("id", "name", "uri", "ts"),
        sieve_data: model.pick("id", "text", "ts"),
        emailContent: `
          <div id="highlighted-inlined"
            style="padding: 10px; background-color: #fff">
            ${getEmailContent()}
          </div>`,
        hasDiff: true
      });
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function select_change_handler() {
    selectedEmail = select_value(this);
    $$invalidate(1, selectedEmail);
    $$invalidate(0, emails);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("diffView" in $$props2)
      $$invalidate(4, diffView = $$props2.diffView);
    if ("sieve" in $$props2)
      $$invalidate(5, sieve = $$props2.sieve);
    if ("model" in $$props2)
      $$invalidate(6, model = $$props2.model);
  };
  return [
    emails,
    selectedEmail,
    fetchData,
    save,
    diffView,
    sieve,
    model,
    select_change_handler,
    close_handler
  ];
}
class EmailSelectModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1X, create_fragment$1_, safe_not_equal, { diffView: 4, sieve: 5, model: 6 });
  }
}
function create_catch_block$p(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$p(ctx) {
  let explorediffheader;
  let updating_inlined;
  let updating_withStyle;
  let t;
  let div;
  let current;
  function explorediffheader_inlined_binding(value) {
    ctx[9](value);
  }
  function explorediffheader_withStyle_binding(value) {
    ctx[10](value);
  }
  let explorediffheader_props = {
    class: "mb-4",
    promise: ctx[6],
    showStyleMode: ctx[4].type === C$1.TYPE_HTML,
    dataType: ctx[5],
    showCloseButton: true,
    datasourceId: ctx[7],
    sieve: ctx[0].parent
  };
  if (ctx[3] !== void 0) {
    explorediffheader_props.inlined = ctx[3];
  }
  if (ctx[2] !== void 0) {
    explorediffheader_props.withStyle = ctx[2];
  }
  explorediffheader = new ExploreDiffHeader({ props: explorediffheader_props });
  binding_callbacks.push(() => bind$1(explorediffheader, "inlined", explorediffheader_inlined_binding));
  binding_callbacks.push(() => bind$1(explorediffheader, "withStyle", explorediffheader_withStyle_binding));
  explorediffheader.$on("close", ctx[8]);
  let if_block = ctx[4].diff && create_if_block$14(ctx);
  return {
    c() {
      create_component(explorediffheader.$$.fragment);
      t = space();
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "flex-grow overflow-y-auto");
    },
    m(target, anchor) {
      mount_component(explorediffheader, target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const explorediffheader_changes = {};
      if (dirty & 16)
        explorediffheader_changes.showStyleMode = ctx2[4].type === C$1.TYPE_HTML;
      if (dirty & 1)
        explorediffheader_changes.sieve = ctx2[0].parent;
      if (!updating_inlined && dirty & 8) {
        updating_inlined = true;
        explorediffheader_changes.inlined = ctx2[3];
        add_flush_callback(() => updating_inlined = false);
      }
      if (!updating_withStyle && dirty & 4) {
        updating_withStyle = true;
        explorediffheader_changes.withStyle = ctx2[2];
        add_flush_callback(() => updating_withStyle = false);
      }
      explorediffheader.$set(explorediffheader_changes);
      if (ctx2[4].diff) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(explorediffheader.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(explorediffheader.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(explorediffheader, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block$14(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block_1$O,
    create_if_block_2$D,
    create_if_block_4$l,
    create_if_block_5$f,
    create_if_block_6$9
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & 1)
      show_if = null;
    if (show_if == null)
      show_if = !!ctx2[0].parent.isHTML();
    if (show_if)
      return 0;
    if (ctx2[4].type === C$1.TYPE_JSON)
      return 1;
    if (ctx2[4].type === C$1.TYPE_XML)
      return 2;
    if (ctx2[4].type === C$1.TYPE_SITEMAP)
      return 3;
    if (ctx2[4].type === C$1.TYPE_FEED)
      return 4;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_6$9(ctx) {
  let explorefeeddiff;
  let current;
  explorefeeddiff = new ExploreFeedDiff({ props: { inlined: ctx[3] } });
  return {
    c() {
      create_component(explorefeeddiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorefeeddiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorefeeddiff_changes = {};
      if (dirty & 8)
        explorefeeddiff_changes.inlined = ctx2[3];
      explorefeeddiff.$set(explorefeeddiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorefeeddiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorefeeddiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorefeeddiff, detaching);
    }
  };
}
function create_if_block_5$f(ctx) {
  let exploresitemapdiff;
  let current;
  exploresitemapdiff = new ExploreSitemapDiff({ props: { inlined: ctx[3] } });
  return {
    c() {
      create_component(exploresitemapdiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exploresitemapdiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exploresitemapdiff_changes = {};
      if (dirty & 8)
        exploresitemapdiff_changes.inlined = ctx2[3];
      exploresitemapdiff.$set(exploresitemapdiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(exploresitemapdiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exploresitemapdiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exploresitemapdiff, detaching);
    }
  };
}
function create_if_block_4$l(ctx) {
  let explorexmldiff;
  let current;
  explorexmldiff = new ExploreXmlDiff({
    props: {
      inlined: ctx[3],
      selectedDiffContentMode: ctx[4].diffContentMode
    }
  });
  return {
    c() {
      create_component(explorexmldiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorexmldiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorexmldiff_changes = {};
      if (dirty & 8)
        explorexmldiff_changes.inlined = ctx2[3];
      if (dirty & 16)
        explorexmldiff_changes.selectedDiffContentMode = ctx2[4].diffContentMode;
      explorexmldiff.$set(explorexmldiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorexmldiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorexmldiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorexmldiff, detaching);
    }
  };
}
function create_if_block_2$D(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$v, create_else_block$D];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[4].diffContentMode === C$1.DIFF_MODE_DATA)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$O(ctx) {
  let explorehtmldiff;
  let updating_withStyle;
  let current;
  function explorehtmldiff_withStyle_binding(value) {
    ctx[11](value);
  }
  let explorehtmldiff_props = { inlined: ctx[3] };
  if (ctx[2] !== void 0) {
    explorehtmldiff_props.withStyle = ctx[2];
  }
  explorehtmldiff = new ExploreHTMLDiff({ props: explorehtmldiff_props });
  binding_callbacks.push(() => bind$1(explorehtmldiff, "withStyle", explorehtmldiff_withStyle_binding));
  return {
    c() {
      create_component(explorehtmldiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorehtmldiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorehtmldiff_changes = {};
      if (dirty & 8)
        explorehtmldiff_changes.inlined = ctx2[3];
      if (!updating_withStyle && dirty & 4) {
        updating_withStyle = true;
        explorehtmldiff_changes.withStyle = ctx2[2];
        add_flush_callback(() => updating_withStyle = false);
      }
      explorehtmldiff.$set(explorehtmldiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorehtmldiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorehtmldiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorehtmldiff, detaching);
    }
  };
}
function create_else_block$D(ctx) {
  let explorehtmldiff;
  let updating_withStyle;
  let current;
  function explorehtmldiff_withStyle_binding_1(value) {
    ctx[12](value);
  }
  let explorehtmldiff_props = { inlined: ctx[3] };
  if (ctx[2] !== void 0) {
    explorehtmldiff_props.withStyle = ctx[2];
  }
  explorehtmldiff = new ExploreHTMLDiff({ props: explorehtmldiff_props });
  binding_callbacks.push(() => bind$1(explorehtmldiff, "withStyle", explorehtmldiff_withStyle_binding_1));
  return {
    c() {
      create_component(explorehtmldiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorehtmldiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorehtmldiff_changes = {};
      if (dirty & 8)
        explorehtmldiff_changes.inlined = ctx2[3];
      if (!updating_withStyle && dirty & 4) {
        updating_withStyle = true;
        explorehtmldiff_changes.withStyle = ctx2[2];
        add_flush_callback(() => updating_withStyle = false);
      }
      explorehtmldiff.$set(explorehtmldiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorehtmldiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorehtmldiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorehtmldiff, detaching);
    }
  };
}
function create_if_block_3$v(ctx) {
  let explorejsondiff;
  let current;
  explorejsondiff = new ExploreJSONDiff({ props: { inlined: ctx[3] } });
  return {
    c() {
      create_component(explorejsondiff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorejsondiff, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorejsondiff_changes = {};
      if (dirty & 8)
        explorejsondiff_changes.inlined = ctx2[3];
      explorejsondiff.$set(explorejsondiff_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorejsondiff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorejsondiff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorejsondiff, detaching);
    }
  };
}
function create_pending_block$p(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_content_slot$1(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$p,
    then: create_then_block$p,
    catch: create_catch_block$p,
    value: 15,
    blocks: [, , ,]
  };
  handle_promise(ctx[6], info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "xmodal card panel-default flex flex-column h-screen");
      attr(div, "slot", "content");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$1Z(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      $$slots: { content: [create_content_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 65565) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$1W($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop$1, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store2, ($$value) => $$invalidate(4, $store = $$value)), store2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  const dispatch = createEventDispatcher();
  let { model } = $$props;
  let store2;
  let dataType = model.get("data_type");
  let withStyle = true;
  let inlined = false;
  let initPromise = init2();
  let datasourceId = model.parent.get("datasource_id");
  async function init2() {
    $$subscribe_store($$invalidate(1, store2 = initStore()));
    store2.updateStore({
      type: dataType,
      uri: model.parent.get("uri"),
      sieve: model.parent
    });
    await store2.fetchSieveData(model.id);
  }
  function onClose() {
    dispatch("close");
  }
  onDestroy(() => {
    destroyStore();
  });
  function explorediffheader_inlined_binding(value) {
    inlined = value;
    $$invalidate(3, inlined);
  }
  function explorediffheader_withStyle_binding(value) {
    withStyle = value;
    $$invalidate(2, withStyle);
  }
  function explorehtmldiff_withStyle_binding(value) {
    withStyle = value;
    $$invalidate(2, withStyle);
  }
  function explorehtmldiff_withStyle_binding_1(value) {
    withStyle = value;
    $$invalidate(2, withStyle);
  }
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(0, model = $$props2.model);
  };
  return [
    model,
    store2,
    withStyle,
    inlined,
    $store,
    dataType,
    initPromise,
    datasourceId,
    onClose,
    explorediffheader_inlined_binding,
    explorediffheader_withStyle_binding,
    explorehtmldiff_withStyle_binding,
    explorehtmldiff_withStyle_binding_1
  ];
}
class ExploreDiffModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1W, create_fragment$1Z, safe_not_equal, { model: 0 });
  }
}
function create_action_slot$d(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-cog"></i>`;
      attr(button, "class", "btn btn-default btn-sm");
      set_style(button, "--bs-btn-padding-y", ".20rem");
      set_style(button, "--bs-btn-padding-x", ".45rem");
      set_style(button, "--bs-btn-font-size", ".75rem");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[11]))
            ctx[11].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_catch_block$o(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      li.innerHTML = `<div>Couldn&#39;t get prefs.
          <a href="/ui/settings.html#general">Sign in to account.</a></div>`;
      attr(li, "class", "dropdown-item xview error");
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_then_block$o(ctx) {
  let li0;
  let t1;
  let li1;
  let div1;
  let div0;
  let input0;
  let t2;
  let label0;
  let t4;
  let li2;
  let div3;
  let div2;
  let input1;
  let t5;
  let label1;
  let t7;
  let li3;
  let t8;
  let li4;
  let a;
  let t9_value = TXT("l_explore_diff_in_a_new_page") + "";
  let t9;
  let t10;
  let i2;
  let mounted;
  let dispose;
  return {
    c() {
      li0 = element("li");
      li0.innerHTML = `<h6 class="dropdown-header">Defaults</h6>`;
      t1 = space();
      li1 = element("li");
      div1 = element("div");
      div0 = element("div");
      input0 = element("input");
      t2 = space();
      label0 = element("label");
      label0.textContent = "Deleted";
      t4 = space();
      li2 = element("li");
      div3 = element("div");
      div2 = element("div");
      input1 = element("input");
      t5 = space();
      label1 = element("label");
      label1.textContent = "Snipped";
      t7 = space();
      li3 = element("li");
      li3.innerHTML = `<hr class="dropdown-divider"/>`;
      t8 = space();
      li4 = element("li");
      a = element("a");
      t9 = text(t9_value);
      t10 = space();
      i2 = element("i");
      attr(input0, "type", "checkbox");
      attr(input0, "class", "form-check-input");
      attr(input0, "id", "showDeletedID");
      attr(label0, "class", "form-check-label");
      attr(label0, "for", "showDeletedID");
      attr(div0, "class", "form-check");
      attr(div1, "class", "");
      attr(li1, "class", "dropdown-item");
      attr(input1, "type", "checkbox");
      attr(input1, "class", "form-check-input");
      attr(input1, "id", "showSnippedID");
      attr(label1, "class", "form-check-label");
      attr(label1, "for", "showSnippedID");
      attr(div2, "class", "form-check");
      attr(div3, "class", "");
      attr(li2, "class", "dropdown-item");
      attr(i2, "class", "fa fa-external-link");
      attr(a, "href", ctx[0]);
      attr(a, "target", "_blank");
      attr(a, "class", "dropdown-item fw1 f5 lh-copy");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      insert(target, t1, anchor);
      insert(target, li1, anchor);
      append(li1, div1);
      append(div1, div0);
      append(div0, input0);
      input0.checked = ctx[1];
      append(div0, t2);
      append(div0, label0);
      insert(target, t4, anchor);
      insert(target, li2, anchor);
      append(li2, div3);
      append(div3, div2);
      append(div2, input1);
      input1.checked = ctx[2];
      append(div2, t5);
      append(div2, label1);
      insert(target, t7, anchor);
      insert(target, li3, anchor);
      insert(target, t8, anchor);
      insert(target, li4, anchor);
      append(li4, a);
      append(a, t9);
      append(a, t10);
      append(a, i2);
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[6]),
          listen(input0, "change", ctx[4]),
          listen(input1, "change", ctx[7]),
          listen(input1, "change", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        input0.checked = ctx2[1];
      }
      if (dirty & 4) {
        input1.checked = ctx2[2];
      }
      if (dirty & 1) {
        attr(a, "href", ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(li1);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(li2);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(li3);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(li4);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_pending_block$o(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      li.textContent = "Loading...";
      attr(li, "class", "xview text-center dropdown-item");
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_default_slot$Q(ctx) {
  let await_block_anchor;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$o,
    then: create_then_block$o,
    catch: create_catch_block$o,
    value: 10,
    error: 10
  };
  handle_promise(ctx[3](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$1Y(ctx) {
  let menu;
  let current;
  menu = new Menu({
    props: {
      dropDownClass: "dropdown-menu-end",
      toggle: false,
      $$slots: {
        default: [create_default_slot$Q],
        action: [
          create_action_slot$d,
          ({ onClick }) => ({ 11: onClick }),
          ({ onClick }) => onClick ? 2048 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 6151) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$1V($$self, $$props, $$invalidate) {
  let { exploreDiffPath } = $$props;
  let { contentType } = $$props;
  let removed = false;
  let snipped = false;
  const user = getContext("user");
  createEventDispatcher();
  async function fetchDiffPrefs() {
    const res = await Api.api("/users/prefs/ui_diff", "GET");
    if (res) {
      $$invalidate(1, { removed, snipped } = res, removed, $$invalidate(2, snipped));
    }
  }
  async function save() {
    try {
      const diffPrefs = {
        removed: removed ? 1 : 0,
        snipped: snipped ? 1 : 0
      };
      await Api.api("/users/prefs/ui_diff", "PUT", diffPrefs);
      user.setDiffPrefs(diffPrefs);
    } catch (err) {
      Msg.error("e_req");
    }
  }
  function input0_change_handler() {
    removed = this.checked;
    $$invalidate(1, removed);
  }
  function input1_change_handler() {
    snipped = this.checked;
    $$invalidate(2, snipped);
  }
  $$self.$$set = ($$props2) => {
    if ("exploreDiffPath" in $$props2)
      $$invalidate(0, exploreDiffPath = $$props2.exploreDiffPath);
    if ("contentType" in $$props2)
      $$invalidate(5, contentType = $$props2.contentType);
  };
  return [
    exploreDiffPath,
    removed,
    snipped,
    fetchDiffPrefs,
    save,
    contentType,
    input0_change_handler,
    input1_change_handler
  ];
}
class DiffPrefsMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1V, create_fragment$1Y, safe_not_equal, { exploreDiffPath: 0, contentType: 5 });
  }
}
function create_fragment$1X(ctx) {
  let previeweditor;
  let current;
  previeweditor = new PreviewEditor({
    props: {
      contentType: ctx[2],
      meta: ctx[0],
      context: ctx[1],
      disabled: true,
      sieveConditionInputs: ctx[3]
    }
  });
  return {
    c() {
      create_component(previeweditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(previeweditor, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const previeweditor_changes = {};
      if (dirty & 4)
        previeweditor_changes.contentType = ctx2[2];
      if (dirty & 1)
        previeweditor_changes.meta = ctx2[0];
      if (dirty & 2)
        previeweditor_changes.context = ctx2[1];
      previeweditor.$set(previeweditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(previeweditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(previeweditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(previeweditor, detaching);
    }
  };
}
function instance$1U($$self, $$props, $$invalidate) {
  let { meta } = $$props;
  let { context } = $$props;
  let { contentType } = $$props;
  const defaultInputs = getDefaultInputs(contentType);
  $$self.$$set = ($$props2) => {
    if ("meta" in $$props2)
      $$invalidate(0, meta = $$props2.meta);
    if ("context" in $$props2)
      $$invalidate(1, context = $$props2.context);
    if ("contentType" in $$props2)
      $$invalidate(2, contentType = $$props2.contentType);
  };
  return [meta, context, contentType, defaultInputs];
}
class Preview extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1U, create_fragment$1X, safe_not_equal, { meta: 0, context: 1, contentType: 2 });
  }
}
function create_catch_block$n(ctx) {
  let p;
  let t0;
  let t1_value = ctx[18].message + "";
  let t1;
  return {
    c() {
      p = element("p");
      t0 = text("Cannot generate the diff: ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_then_block$n(ctx) {
  let div4;
  let div1;
  let div0;
  let span0;
  let t1;
  let span1;
  let t3;
  let textarea0;
  let t4;
  let div3;
  let div2;
  let span2;
  let t6;
  let span3;
  let t8;
  let textarea1;
  let t9;
  let variables;
  let t10;
  let div5;
  let t11;
  let if_block_anchor;
  let current;
  variables = new Variables({
    props: {
      addedText: ctx[3],
      deletedText: ctx[4],
      netAdditions: ctx[5],
      netDeletions: ctx[6]
    }
  });
  let if_block = ctx[7] && create_if_block$13(ctx);
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      span0.textContent = "Previous Text";
      t1 = space();
      span1 = element("span");
      span1.textContent = `${formatLogTime(ctx[8])}`;
      t3 = space();
      textarea0 = element("textarea");
      t4 = space();
      div3 = element("div");
      div2 = element("div");
      span2 = element("span");
      span2.textContent = "Text";
      t6 = space();
      span3 = element("span");
      span3.textContent = `${formatLogTime(ctx[9])}`;
      t8 = space();
      textarea1 = element("textarea");
      t9 = space();
      create_component(variables.$$.fragment);
      t10 = space();
      div5 = element("div");
      t11 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span0, "class", "f5 px-2 fw-bold");
      attr(span1, "class", "f6 px-2");
      attr(div0, "class", "flex pb1 border-bottom justify-content-between");
      attr(textarea0, "class", "pa2 w-100 border-0 f6 h-[300px]");
      textarea0.disabled = true;
      textarea0.value = ctx[1];
      attr(div1, "class", "col-md-4 border-end px-0");
      attr(span2, "class", "f5 px-2 fw-bold");
      attr(span3, "class", "f6 px-2");
      attr(div2, "class", "flex pb1 border-bottom justify-content-between");
      attr(textarea1, "class", "pa2 w-100 border-0 f6 h-[300px]");
      textarea1.disabled = true;
      textarea1.value = ctx[2];
      attr(div3, "class", "col-md-4 border-end px-0");
      attr(div4, "class", "row");
      attr(div5, "class", "border-top");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, div0);
      append(div0, span0);
      append(div0, t1);
      append(div0, span1);
      append(div1, t3);
      append(div1, textarea0);
      append(div4, t4);
      append(div4, div3);
      append(div3, div2);
      append(div2, span2);
      append(div2, t6);
      append(div2, span3);
      append(div3, t8);
      append(div3, textarea1);
      append(div4, t9);
      mount_component(variables, div4, null);
      insert(target, t10, anchor);
      insert(target, div5, anchor);
      insert(target, t11, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 2) {
        textarea0.value = ctx2[1];
      }
      if (!current || dirty & 4) {
        textarea1.value = ctx2[2];
      }
      const variables_changes = {};
      if (dirty & 8)
        variables_changes.addedText = ctx2[3];
      if (dirty & 16)
        variables_changes.deletedText = ctx2[4];
      if (dirty & 32)
        variables_changes.netAdditions = ctx2[5];
      if (dirty & 64)
        variables_changes.netDeletions = ctx2[6];
      variables.$set(variables_changes);
      if (ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(variables.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(variables.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(variables);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(div5);
      if (detaching)
        detach(t11);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$13(ctx) {
  let sieverules;
  let current;
  sieverules = new Preview({
    props: {
      meta: ctx[0].get("meta"),
      context: ctx[7],
      contentType: ctx[10]
    }
  });
  return {
    c() {
      create_component(sieverules.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieverules, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieverules_changes = {};
      if (dirty & 1)
        sieverules_changes.meta = ctx2[0].get("meta");
      if (dirty & 128)
        sieverules_changes.context = ctx2[7];
      sieverules.$set(sieverules_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieverules.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieverules.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieverules, detaching);
    }
  };
}
function create_pending_block$n(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$1W(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$n,
    then: create_then_block$n,
    catch: create_catch_block$n,
    value: 17,
    error: 18,
    blocks: [, , ,]
  };
  handle_promise(ctx[11], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$1T($$self, $$props, $$invalidate) {
  let { model } = $$props;
  let { oldModel } = $$props;
  let previousText = oldModel.get("text");
  let newText = model.get("text");
  const oldSieveDate = oldModel.get("ts_mod");
  const newSieveDate = model.get("ts_mod");
  const contentType = model.get("data_type");
  let addedText = "";
  let deletedText = "";
  let netAdditions = "";
  let netDeletions = "";
  let context = {};
  let res, rej;
  let diffResponsePromise = new Promise((_res, _rej) => {
    res = _res;
    rej = _rej;
  });
  async function setSitemapTextData() {
    let oldData = JSON.parse(oldModel.get("data"));
    let newData = JSON.parse(model.get("data"));
    let crawlerId = oldData.crawler_id;
    let jobId1 = oldData.job_id;
    let jobId2 = newData.job_id;
    let diffEndpoint = `/crawlers/data/${crawlerId}/diff/${jobId1}`;
    if (jobId2) {
      diffEndpoint += `?id2=${jobId2}`;
    }
    const diffData = await Api.api(diffEndpoint);
    let { diff: diff2 } = diffData;
    let unchangedURLs = diff2.filter((diffData2) => diffData2.diff_type === "unchanged").map((diffData2) => diffData2.url);
    let addedURLs = diff2.filter((diffData2) => diffData2.diff_type === "addition").map((diffData2) => diffData2.url);
    let deletedURLs = diff2.filter((diffData2) => diffData2.diff_type === "deletion").map((diffData2) => diffData2.url);
    let oldURLs = [...unchangedURLs, ...deletedURLs].sort();
    let newURLs = [...unchangedURLs, ...addedURLs].sort();
    $$invalidate(1, previousText = oldURLs.join("\n"));
    $$invalidate(2, newText = newURLs.join("\n"));
  }
  async function loadDiff() {
    try {
      if (contentType === C$1.TYPE_SITEMAP) {
        await setSitemapTextData();
      }
      const diffResult = await getDiff(previousText, newText, contentType);
      $$invalidate(3, addedText = diffResult.addedText);
      $$invalidate(4, deletedText = diffResult.deletedText);
      $$invalidate(5, netAdditions = diffResult.netAdditions);
      $$invalidate(6, netDeletions = diffResult.netDeletions);
      $$invalidate(7, context = diffResult.context);
      $$invalidate(7, context.oldTextHashes = model.get("meta").oldTextHashes || [], context);
      $$invalidate(7, context.newTextHash = model.get("text_hash"), context);
      $$invalidate(7, context.new_summary = model.get("summary"), context);
      $$invalidate(7, context.old_summary = oldModel.get("summary"), context);
      res();
    } catch (e) {
      console.error("cannot get the diff", oldModel.id, model.id, e);
      rej(e);
    }
  }
  loadDiff();
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(0, model = $$props2.model);
    if ("oldModel" in $$props2)
      $$invalidate(12, oldModel = $$props2.oldModel);
  };
  return [
    model,
    previousText,
    newText,
    addedText,
    deletedText,
    netAdditions,
    netDeletions,
    context,
    oldSieveDate,
    newSieveDate,
    contentType,
    diffResponsePromise,
    oldModel
  ];
}
class SieveRuleDebugger extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1T, create_fragment$1W, safe_not_equal, { model: 0, oldModel: 12 });
  }
}
function create_fragment$1V(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { fill: "none" },
    { viewBox: "0 0 24 24" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M9.35442 21C10.0596 21.6224 10.9858 22 12.0002 22C13.0147 22 13.9409 21.6224 14.6461 21M2.29414 5.81989C2.27979 4.36854 3.06227 3.01325 4.32635 2.3M21.7024 5.8199C21.7167 4.36855 20.9342 3.01325 19.6702 2.3M18.0002 8C18.0002 6.4087 17.3681 4.88258 16.2429 3.75736C15.1177 2.63214 13.5915 2 12.0002 2C10.4089 2 8.88283 2.63214 7.75761 3.75736C6.63239 4.88258 6.00025 6.4087 6.00025 8C6.00025 11.0902 5.22072 13.206 4.34991 14.6054C3.61538 15.7859 3.24811 16.3761 3.26157 16.5408C3.27649 16.7231 3.31511 16.7926 3.46203 16.9016C3.59471 17 4.19284 17 5.3891 17H18.6114C19.8077 17 20.4058 17 20.5385 16.9016C20.6854 16.7926 20.724 16.7231 20.7389 16.5408C20.7524 16.3761 20.3851 15.7859 19.6506 14.6054C18.7798 13.206 18.0002 11.0902 18.0002 8Z");
      attr(path, "stroke", "#000000");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        { viewBox: "0 0 24 24" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$1S($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class BellOn extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1S, create_fragment$1V, safe_not_equal, {});
  }
}
function create_fragment$1U(ctx) {
  let svg;
  let path;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 24 24" },
    { fill: "none" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M8.63306 3.03371C9.61959 2.3649 10.791 2 12 2C13.5913 2 15.1174 2.63214 16.2426 3.75736C17.3679 4.88258 18 6.4087 18 8C18 10.1008 18.2702 11.7512 18.6484 13.0324M6.25867 6.25724C6.08866 6.81726 6 7.40406 6 8C6 11.0902 5.22047 13.206 4.34966 14.6054C3.61513 15.7859 3.24786 16.3761 3.26132 16.5408C3.27624 16.7231 3.31486 16.7926 3.46178 16.9016C3.59446 17 4.19259 17 5.38885 17H17M9.35418 21C10.0593 21.6224 10.9856 22 12 22C13.0144 22 13.9407 21.6224 14.6458 21M21 21L3 3");
      attr(path, "stroke", "#000000");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 24 24" },
        { fill: "none" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$1R($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class BellOff extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1R, create_fragment$1U, safe_not_equal, {});
  }
}
function create_default_slot$P(ctx) {
  let sieveruledebugger;
  let current;
  sieveruledebugger = new SieveRuleDebugger({
    props: {
      model: ctx[0],
      oldModel: ctx[1]
    }
  });
  return {
    c() {
      create_component(sieveruledebugger.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruledebugger, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruledebugger_changes = {};
      if (dirty & 1)
        sieveruledebugger_changes.model = ctx2[0];
      if (dirty & 2)
        sieveruledebugger_changes.oldModel = ctx2[1];
      sieveruledebugger.$set(sieveruledebugger_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruledebugger.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruledebugger.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruledebugger, detaching);
    }
  };
}
function create_links_slot(ctx) {
  let div;
  let a;
  let t;
  return {
    c() {
      div = element("div");
      a = element("a");
      t = text("Test Conditions");
      attr(a, "class", "btn btn-default");
      attr(a, "href", ctx[4]());
      attr(div, "slot", "links");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(a, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_else_block$C(ctx) {
  let t;
  let belloff;
  let current;
  belloff = new BellOff({ props: { class: "h-5 w-5" } });
  return {
    c() {
      t = text("Notification not triggered\n        ");
      create_component(belloff.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(belloff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(belloff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(belloff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(belloff, detaching);
    }
  };
}
function create_if_block$12(ctx) {
  let t;
  let bellon;
  let current;
  bellon = new BellOn({ props: { class: "h-5 w-5" } });
  return {
    c() {
      t = text("Notification triggered\n        ");
      create_component(bellon.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(bellon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(bellon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bellon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(bellon, detaching);
    }
  };
}
function create_sub_header_slot$1(ctx) {
  let h4;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$12, create_else_block$C];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      h4 = element("h4");
      if_block.c();
      attr(h4, "class", "mb-0");
    },
    m(target, anchor) {
      insert(target, h4, anchor);
      if_blocks[current_block_type_index].m(h4, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h4);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_fragment$1T(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      modalDialogClasses: "modal-xl",
      labelClose: ctx[2],
      scrollable: true,
      $$slots: {
        "sub-header": [create_sub_header_slot$1],
        links: [create_links_slot],
        default: [create_default_slot$P]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[5]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 67) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$1Q($$self, $$props, $$invalidate) {
  let { model } = $$props;
  let { oldModel } = $$props;
  let labelClose = TXT("a_close");
  const triggered = model.get("triggered");
  const getDebuggerUrl = () => {
    const { team } = get_store_value(route);
    return urlCfg.sieveRuleDebugger(team, model.get("sieve_id"), oldModel.get("id"), model.get("id"));
  };
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(0, model = $$props2.model);
    if ("oldModel" in $$props2)
      $$invalidate(1, oldModel = $$props2.oldModel);
  };
  return [model, oldModel, labelClose, triggered, getDebuggerUrl, close_handler];
}
class SieveRuleDebuggerModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Q, create_fragment$1T, safe_not_equal, { model: 0, oldModel: 1 });
  }
}
var DiffBar_svelte_svelte_type_style_lang = "";
function create_if_block_10$2(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_11$1, create_else_block_2$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[16])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", "btn btn-default btn-sm px-1 py-0");
      attr(button, "title", ctx[16] ? "Notification Triggered" : "Notification Not Triggered");
      toggle_class(button, "disabled", ctx[13]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[20]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & 8192) {
        toggle_class(button, "disabled", ctx2[13]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_2$5(ctx) {
  let belloff;
  let current;
  belloff = new BellOff({ props: { class: "h-4 w-4" } });
  return {
    c() {
      create_component(belloff.$$.fragment);
    },
    m(target, anchor) {
      mount_component(belloff, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(belloff.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(belloff.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(belloff, detaching);
    }
  };
}
function create_if_block_11$1(ctx) {
  let bellon;
  let current;
  bellon = new BellOn({ props: { class: "h-4 w-4" } });
  return {
    c() {
      create_component(bellon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(bellon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(bellon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bellon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(bellon, detaching);
    }
  };
}
function create_else_block_1$d(ctx) {
  let t;
  return {
    c() {
      t = text("+");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_9$3(ctx) {
  let t;
  return {
    c() {
      t = text("new,");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_8$4(ctx) {
  let span;
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(ctx[6]);
      t1 = text(" updated,");
      attr(span, "class", "text-secondary-700 font-bold");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64)
        set_data(t0, ctx2[6]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_else_block$B(ctx) {
  let t;
  return {
    c() {
      t = text("-");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_7$7(ctx) {
  let t;
  return {
    c() {
      t = text("deleted");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3$u(ctx) {
  let div;
  let show_if_2 = ctx[8].get("data_type") === C$1.TYPE_JSON;
  let t0;
  let show_if_1 = ctx[8].get("data_type") !== C$1.TYPE_XML;
  let t1;
  let show_if = ctx[8].get("data_type") !== C$1.TYPE_JSON;
  let t2;
  let button;
  let t3_value = TXT("l_source") + "";
  let t3;
  let button_class_value;
  let mounted;
  let dispose;
  let if_block0 = show_if_2 && create_if_block_6$8(ctx);
  let if_block1 = show_if_1 && create_if_block_5$e(ctx);
  let if_block2 = show_if && create_if_block_4$k(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      button = element("button");
      t3 = text(t3_value);
      attr(button, "class", button_class_value = "btn btn-default btn-sm xpopup py-0 self-center " + (C$1.DIFF_MODE_SOURCE === ctx[10] ? "btn-primary min-w-0 active" : ""));
      toggle_class(button, "active", C$1.DIFF_MODE_SOURCE === ctx[10]);
      attr(div, "class", "btn-group btn-toggle flex");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append(div, t2);
      append(div, button);
      append(button, t3);
      if (!mounted) {
        dispose = listen(button, "click", ctx[25]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256)
        show_if_2 = ctx2[8].get("data_type") === C$1.TYPE_JSON;
      if (show_if_2) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$8(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & 256)
        show_if_1 = ctx2[8].get("data_type") !== C$1.TYPE_XML;
      if (show_if_1) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5$e(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & 256)
        show_if = ctx2[8].get("data_type") !== C$1.TYPE_JSON;
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_4$k(ctx2);
          if_block2.c();
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty[0] & 1024 && button_class_value !== (button_class_value = "btn btn-default btn-sm xpopup py-0 self-center " + (C$1.DIFF_MODE_SOURCE === ctx2[10] ? "btn-primary min-w-0 active" : ""))) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & 1024) {
        toggle_class(button, "active", C$1.DIFF_MODE_SOURCE === ctx2[10]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_6$8(ctx) {
  let button;
  let t_value = TXT("l_data") + "";
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", button_class_value = "btn btn-default btn-sm xpopup py-0 self-center ml1 " + (C$1.DIFF_MODE_DATA === ctx[10] ? "btn-primary min-w-0 active" : ""));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[22]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && button_class_value !== (button_class_value = "btn btn-default btn-sm xpopup py-0 self-center ml1 " + (C$1.DIFF_MODE_DATA === ctx2[10] ? "btn-primary min-w-0 active" : ""))) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$e(ctx) {
  let button;
  let t_value = TXT("l_visual") + "";
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", button_class_value = "btn btn-default btn-sm xpopup py-0 self-center ml1 " + (C$1.DIFF_MODE_VISUAL === ctx[10] ? "btn-primary min-w-0 active" : ""));
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[23]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && button_class_value !== (button_class_value = "btn btn-default btn-sm xpopup py-0 self-center ml1 " + (C$1.DIFF_MODE_VISUAL === ctx2[10] ? "btn-primary min-w-0 active" : ""))) {
        attr(button, "class", button_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$k(ctx) {
  let button;
  let t_value = TXT("l_text") + "";
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      attr(button, "class", button_class_value = "btn btn-default btn-sm xpopup py-0 self-center " + (C$1.DIFF_MODE_TEXT === ctx[10] ? "btn-primary min-w-0 active" : ""));
      toggle_class(button, "active", C$1.DIFF_MODE_TEXT === ctx[10]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[24]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && button_class_value !== (button_class_value = "btn btn-default btn-sm xpopup py-0 self-center " + (C$1.DIFF_MODE_TEXT === ctx2[10] ? "btn-primary min-w-0 active" : ""))) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & 1024) {
        toggle_class(button, "active", C$1.DIFF_MODE_TEXT === ctx2[10]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$C(ctx) {
  let label;
  let input;
  let t0;
  let t1_value = TXT("Styled") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      label = element("label");
      input = element("input");
      t0 = space();
      t1 = text(t1_value);
      set_style(input, "vertical-align", "top");
      attr(input, "type", "checkbox");
      input.disabled = ctx[13];
      attr(label, "class", "text-[0.9em] select-none m-0 flex items-center gap-1");
      attr(label, "data-bs-toggle", "tooltip");
      attr(label, "data-bs-title", "Apply page's styles when available. Styles for monitored pages can be included by enable 'include page styles' in Options page");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, input);
      input.checked = ctx[2];
      append(label, t0);
      append(label, t1);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[26]),
          action_destroyer(tooltip.call(null, label, { placement: "top" }))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8192) {
        input.disabled = ctx2[13];
      }
      if (dirty[0] & 4) {
        input.checked = ctx2[2];
      }
    },
    d(detaching) {
      if (detaching)
        detach(label);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$N(ctx) {
  let explorediffmodal;
  let current;
  explorediffmodal = new ExploreDiffModal({ props: { model: ctx[8] } });
  explorediffmodal.$on("close", ctx[30]);
  return {
    c() {
      create_component(explorediffmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(explorediffmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const explorediffmodal_changes = {};
      if (dirty[0] & 256)
        explorediffmodal_changes.model = ctx2[8];
      explorediffmodal.$set(explorediffmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(explorediffmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(explorediffmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(explorediffmodal, detaching);
    }
  };
}
function create_if_block$11(ctx) {
  let sieveruledebuggermodal;
  let current;
  sieveruledebuggermodal = new SieveRuleDebuggerModal({
    props: {
      model: ctx[8],
      oldModel: ctx[7]
    }
  });
  sieveruledebuggermodal.$on("close", ctx[31]);
  return {
    c() {
      create_component(sieveruledebuggermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruledebuggermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveruledebuggermodal_changes = {};
      if (dirty[0] & 256)
        sieveruledebuggermodal_changes.model = ctx2[8];
      if (dirty[0] & 128)
        sieveruledebuggermodal_changes.oldModel = ctx2[7];
      sieveruledebuggermodal.$set(sieveruledebuggermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruledebuggermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruledebuggermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruledebuggermodal, detaching);
    }
  };
}
function create_fragment$1S(ctx) {
  let div;
  let t0;
  let a;
  let t1;
  let span0;
  let t2;
  let t3;
  let t4;
  let t5;
  let span1;
  let t6;
  let t7;
  let t8;
  let show_if_1 = ctx[19]();
  let t9;
  let show_if = ctx[8].get("data_type") === C$1.TYPE_HTML;
  let t10;
  let label0;
  let input0;
  let t11;
  let t12_value = TXT("Deleted") + "";
  let t12;
  let t13;
  let label1;
  let input1;
  let t14;
  let t15_value = TXT("Snipped") + "";
  let t15;
  let t16;
  let diffprefsmenu;
  let t17;
  let t18;
  let if_block7_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (ctx[17] || ctx[18]) && create_if_block_10$2(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[15])
      return create_if_block_9$3;
    return create_else_block_1$d;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type(ctx);
  let if_block2 = ctx[15] && create_if_block_8$4(ctx);
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[15])
      return create_if_block_7$7;
    return create_else_block$B;
  }
  let current_block_type_1 = select_block_type_2(ctx);
  let if_block3 = current_block_type_1(ctx);
  let if_block4 = show_if_1 && create_if_block_3$u(ctx);
  let if_block5 = show_if && create_if_block_2$C(ctx);
  diffprefsmenu = new DiffPrefsMenu({
    props: {
      selectedDiffContentMode: ctx[10],
      contentType: ctx[8].get("data_type"),
      exploreDiffPath: ctx[9]
    }
  });
  diffprefsmenu.$on("applySelectedDiffContentMode", ctx[29]);
  let if_block6 = ctx[11] && create_if_block_1$N(ctx);
  let if_block7 = ctx[12] && create_if_block$11(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      a = element("a");
      t1 = text("Explore diff\n      ");
      span0 = element("span");
      t2 = text(ctx[4]);
      t3 = space();
      if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      span1 = element("span");
      t6 = text(ctx[5]);
      t7 = space();
      if_block3.c();
      t8 = space();
      if (if_block4)
        if_block4.c();
      t9 = space();
      if (if_block5)
        if_block5.c();
      t10 = space();
      label0 = element("label");
      input0 = element("input");
      t11 = space();
      t12 = text(t12_value);
      t13 = space();
      label1 = element("label");
      input1 = element("input");
      t14 = space();
      t15 = text(t15_value);
      t16 = space();
      create_component(diffprefsmenu.$$.fragment);
      t17 = space();
      if (if_block6)
        if_block6.c();
      t18 = space();
      if (if_block7)
        if_block7.c();
      if_block7_anchor = empty();
      attr(span0, "class", "text-green-700 font-bold");
      attr(span1, "class", "text-red-700 font-bold");
      attr(a, "class", "btn btn-default btn-sm xpopup py-0 self-center px-2");
      attr(a, "target", "_blank");
      attr(a, "aria-disabled", ctx[13]);
      toggle_class(a, "disabled", ctx[13]);
      attr(input0, "class", "xremoved");
      set_style(input0, "vertical-align", "top");
      attr(input0, "type", "checkbox");
      input0.disabled = ctx[13];
      attr(label0, "class", "text-[0.9em] select-none m-0 flex items-center gap-1");
      attr(label0, "data-bs-toggle", "tooltip");
      attr(label0, "data-bs-title", "Show deleted content");
      attr(input1, "class", "xsnipped");
      set_style(input1, "vertical-align", "top");
      attr(input1, "type", "checkbox");
      input1.disabled = ctx[13];
      attr(label1, "class", "text-[0.9em] select-none m-0 flex items-center gap-1");
      attr(label1, "data-bs-toggle", "tooltip");
      attr(label1, "data-bs-title", "Hide unchanged content");
      attr(div, "class", "xDiffBar flex items-center gap-1 h-[24px] br3 z-1 svelte-1ayg2i7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      append(div, a);
      append(a, t1);
      append(a, span0);
      append(span0, t2);
      append(span0, t3);
      if_block1.m(span0, null);
      append(a, t4);
      if (if_block2)
        if_block2.m(a, null);
      append(a, t5);
      append(a, span1);
      append(span1, t6);
      append(span1, t7);
      if_block3.m(span1, null);
      append(div, t8);
      if (if_block4)
        if_block4.m(div, null);
      append(div, t9);
      if (if_block5)
        if_block5.m(div, null);
      append(div, t10);
      append(div, label0);
      append(label0, input0);
      input0.checked = ctx[0];
      append(label0, t11);
      append(label0, t12);
      append(div, t13);
      append(div, label1);
      append(label1, input1);
      input1.checked = ctx[1];
      append(label1, t14);
      append(label1, t15);
      append(div, t16);
      mount_component(diffprefsmenu, div, null);
      insert(target, t17, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert(target, t18, anchor);
      if (if_block7)
        if_block7.m(target, anchor);
      insert(target, if_block7_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a, "click", ctx[21]),
          listen(input0, "change", ctx[27]),
          action_destroyer(tooltip.call(null, label0, { placement: "top" })),
          listen(input1, "change", ctx[28]),
          action_destroyer(tooltip.call(null, label1, { placement: "top" }))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[17] || ctx2[18])
        if_block0.p(ctx2, dirty);
      if (!current || dirty[0] & 16)
        set_data(t2, ctx2[4]);
      if (ctx2[15])
        if_block2.p(ctx2, dirty);
      if (!current || dirty[0] & 32)
        set_data(t6, ctx2[5]);
      if (!current || dirty[0] & 8192) {
        attr(a, "aria-disabled", ctx2[13]);
      }
      if (!current || dirty[0] & 8192) {
        toggle_class(a, "disabled", ctx2[13]);
      }
      if (show_if_1)
        if_block4.p(ctx2, dirty);
      if (dirty[0] & 256)
        show_if = ctx2[8].get("data_type") === C$1.TYPE_HTML;
      if (show_if) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_2$C(ctx2);
          if_block5.c();
          if_block5.m(div, t10);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (!current || dirty[0] & 8192) {
        input0.disabled = ctx2[13];
      }
      if (dirty[0] & 1) {
        input0.checked = ctx2[0];
      }
      if (!current || dirty[0] & 8192) {
        input1.disabled = ctx2[13];
      }
      if (dirty[0] & 2) {
        input1.checked = ctx2[1];
      }
      const diffprefsmenu_changes = {};
      if (dirty[0] & 1024)
        diffprefsmenu_changes.selectedDiffContentMode = ctx2[10];
      if (dirty[0] & 256)
        diffprefsmenu_changes.contentType = ctx2[8].get("data_type");
      if (dirty[0] & 512)
        diffprefsmenu_changes.exploreDiffPath = ctx2[9];
      diffprefsmenu.$set(diffprefsmenu_changes);
      if (ctx2[11]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[0] & 2048) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_1$N(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(t18.parentNode, t18);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (ctx2[12]) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block$11(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(if_block7_anchor.parentNode, if_block7_anchor);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(diffprefsmenu.$$.fragment, local);
      transition_in(if_block6);
      transition_in(if_block7);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(diffprefsmenu.$$.fragment, local);
      transition_out(if_block6);
      transition_out(if_block7);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if_block1.d();
      if (if_block2)
        if_block2.d();
      if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      destroy_component(diffprefsmenu);
      if (detaching)
        detach(t17);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach(t18);
      if (if_block7)
        if_block7.d(detaching);
      if (detaching)
        detach(if_block7_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1P($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop$1, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(32, $sieve = $$value)), sieve);
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { sieve } = $$props;
  $$subscribe_sieve();
  let { additions = 0 } = $$props;
  let { deletions = 0 } = $$props;
  let { updations = 0 } = $$props;
  let { oldModel } = $$props;
  let { model } = $$props;
  let { removed } = $$props;
  let { snipped } = $$props;
  let { exploreDiffPath } = $$props;
  let { selectedDiffContentMode = C$1.DIFF_MODE_VISUAL } = $$props;
  let { withStyle } = $$props;
  getContext("api");
  const dispatch = createEventDispatcher();
  const feed = model.get("data_type") === C$1.TYPE_FEED;
  const triggered = model.get("triggered");
  const hasMeta = !_.isEmpty(model.get("meta"));
  const firstData = model && !oldModel || model.id === (oldModel == null ? void 0 : oldModel.id);
  let showExploreDiff = false;
  let showSieveRuleDebuggerModal = false;
  let disabled = false;
  function showDiffModes() {
    if ([C$1.TYPE_DOC, C$1.TYPE_HTML, C$1.TYPE_PDF_HTML, C$1.TYPE_XML, C$1.TYPE_FEED].includes($sieve.content_type)) {
      return true;
    }
    if ($sieve.content_type === C$1.TYPE_JSON && $sieve.datasource_id && model.get("snapshot") && oldModel.get("snapshot")) {
      return true;
    }
    return false;
  }
  const click_handler = () => $$invalidate(12, showSieveRuleDebuggerModal = true);
  const click_handler_1 = () => $$invalidate(11, showExploreDiff = true);
  const click_handler_2 = () => {
    dispatch("diffContentModeUpdate", { diffContentMode: C$1.DIFF_MODE_DATA });
  };
  const click_handler_3 = () => {
    dispatch("diffContentModeUpdate", { diffContentMode: C$1.DIFF_MODE_VISUAL });
  };
  const click_handler_4 = () => {
    dispatch("diffContentModeUpdate", { diffContentMode: C$1.DIFF_MODE_TEXT });
  };
  const click_handler_5 = () => {
    dispatch("diffContentModeUpdate", { diffContentMode: C$1.DIFF_MODE_SOURCE });
  };
  function input_change_handler() {
    withStyle = this.checked;
    $$invalidate(2, withStyle);
  }
  function input0_change_handler() {
    removed = this.checked;
    $$invalidate(0, removed);
  }
  function input1_change_handler() {
    snipped = this.checked;
    $$invalidate(1, snipped);
  }
  function applySelectedDiffContentMode_handler(event) {
    bubble.call(this, $$self, event);
  }
  const close_handler = () => $$invalidate(11, showExploreDiff = false);
  const close_handler_1 = () => $$invalidate(12, showSieveRuleDebuggerModal = false);
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(3, sieve = $$props2.sieve));
    if ("additions" in $$props2)
      $$invalidate(4, additions = $$props2.additions);
    if ("deletions" in $$props2)
      $$invalidate(5, deletions = $$props2.deletions);
    if ("updations" in $$props2)
      $$invalidate(6, updations = $$props2.updations);
    if ("oldModel" in $$props2)
      $$invalidate(7, oldModel = $$props2.oldModel);
    if ("model" in $$props2)
      $$invalidate(8, model = $$props2.model);
    if ("removed" in $$props2)
      $$invalidate(0, removed = $$props2.removed);
    if ("snipped" in $$props2)
      $$invalidate(1, snipped = $$props2.snipped);
    if ("exploreDiffPath" in $$props2)
      $$invalidate(9, exploreDiffPath = $$props2.exploreDiffPath);
    if ("selectedDiffContentMode" in $$props2)
      $$invalidate(10, selectedDiffContentMode = $$props2.selectedDiffContentMode);
    if ("withStyle" in $$props2)
      $$invalidate(2, withStyle = $$props2.withStyle);
  };
  $$invalidate(13, disabled = firstData);
  return [
    removed,
    snipped,
    withStyle,
    sieve,
    additions,
    deletions,
    updations,
    oldModel,
    model,
    exploreDiffPath,
    selectedDiffContentMode,
    showExploreDiff,
    showSieveRuleDebuggerModal,
    disabled,
    dispatch,
    feed,
    triggered,
    hasMeta,
    firstData,
    showDiffModes,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    input_change_handler,
    input0_change_handler,
    input1_change_handler,
    applySelectedDiffContentMode_handler,
    close_handler,
    close_handler_1
  ];
}
class DiffBar extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$1P,
      create_fragment$1S,
      safe_not_equal,
      {
        sieve: 3,
        additions: 4,
        deletions: 5,
        updations: 6,
        oldModel: 7,
        model: 8,
        removed: 0,
        snipped: 1,
        exploreDiffPath: 9,
        selectedDiffContentMode: 10,
        withStyle: 2
      },
      null,
      [-1, -1]
    );
  }
}
function create_if_block_3$t(ctx) {
  let div;
  let i2;
  return {
    c() {
      div = element("div");
      i2 = element("i");
      attr(i2, "class", "fa fa-exclamation align-middle");
      set_style(i2, "font-size", "1.3em");
      attr(i2, "aria-hidden", "true");
      attr(div, "class", "p-1 pointer py-0");
      attr(div, "title", "$" + (error == null ? void 0 : error.message));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, i2);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$B(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<i class="fa fa-check align-middle" style="font-size: 1.3em" aria-hidden="true"></i>`;
      attr(div, "class", "p-1 pointer py-0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$M(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<i class="fa fa-spinner fa-spin align-middle" style="font-size: 1.3em" aria-hidden="true"></i>`;
      attr(div, "class", "ms-2 ph2 pointer py-0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$10(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const default_slot_or_fallback = default_slot || fallback_block$2();
  return {
    c() {
      a = element("a");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      attr(a, "class", "ph2 pointer btn btn-outline-primary btn-sm background-none border-none shadow-none py-0");
      attr(a, "title", ctx[0]);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1) {
        attr(a, "title", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function fallback_block$2(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-thumbs-o-up align-middle");
      set_style(i2, "font-size", "1.3em");
      attr(i2, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_fragment$1R(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$10, create_if_block_1$M, create_if_block_2$B, create_if_block_3$t];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] === 0)
      return 0;
    if (ctx2[1] === 1)
      return 1;
    if (ctx2[1] === 2)
      return 2;
    if (ctx2[1] === 3)
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
let error = null;
function instance$1O($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { oneTimeFn } = $$props;
  let { args = [] } = $$props;
  let { title = void 0 } = $$props;
  let state = 0;
  async function executeOneTimeFunction() {
    $$invalidate(1, state = 1);
    try {
      if (oneTimeFn) {
        await oneTimeFn(...args);
      }
      $$invalidate(1, state = 2);
    } catch (e) {
      console.error("error while executing the oneTime function", e);
      $$invalidate(1, state = 3);
    }
  }
  const click_handler = () => {
    executeOneTimeFunction();
  };
  $$self.$$set = ($$props2) => {
    if ("oneTimeFn" in $$props2)
      $$invalidate(3, oneTimeFn = $$props2.oneTimeFn);
    if ("args" in $$props2)
      $$invalidate(4, args = $$props2.args);
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [
    title,
    state,
    executeOneTimeFunction,
    oneTimeFn,
    args,
    $$scope,
    slots,
    click_handler
  ];
}
class OneTimeAction extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1O, create_fragment$1R, safe_not_equal, { oneTimeFn: 3, args: 4, title: 0 });
  }
}
const routeModuleList = [
  { id: "/teams/", label: "Teams" },
  { id: "/usage/", label: "Usage" },
  { id: "/crawlers/", label: "Crawlers" },
  { id: "/checks/", label: "Check Logs" },
  { id: "/settings/", label: "Settings" },
  { id: "/w/", label: "Watchlist" }
];
const feedbackOptions = [
  { id: "very positive", label: "Very Positive." },
  { id: "positive", label: "Positive." },
  { id: "neutral", label: "Neutral." },
  { id: "negative", label: "Negative." },
  { id: "very negative", label: "Very Negative." }
];
const suggestProductOptions = [
  { id: "extremely likely", label: "Extremely Likely." },
  { id: "very likely", label: "Very Likely." },
  { id: "neutral", label: "Neutral." },
  { id: "slightly likely", label: "Slightly likely." },
  { id: "not likely", label: "Not likely at all." }
];
const other = {
  other: {
    type: "string",
    other: true,
    label: "Other"
  }
};
const product_recommend = {
  label: "How likely are you to recommend our product to others?",
  fields: {
    selected: {
      type: "enum",
      component: "EnumGroup",
      multi: false,
      dropdown: false,
      options: suggestProductOptions
    }
  },
  required: true
};
const commonfields = {
  didnt_work: {
    type: "boolean",
    label: "Distill failed to perform as anticipated"
  },
  dont_need: {
    type: "boolean",
    label: "I no longer need Distill"
  },
  ...other
};
const optionalFeedback = {
  likes: {
    label: "What did you like about Distill?",
    fields: {
      notes: {
        type: "string"
      }
    }
  }
};
const feedbackforms = {
  [C$1.FORM_DOWNGRADE]: {
    downgrade_reason: {
      label: "We're glad to know that you're staying with us! We'd like to understand why you decided to switch to a lower tier subscription and if there's anything we can do to improve your experience with Distill.",
      fields: {
        ...commonfields
      },
      required: true
    }
  },
  [C$1.FORM_CANCEL]: {
    cancel_reason: {
      label: "We're sorry to hear that you're considering cancelling your subscription. To help us improve our service, could you please let us know the reason for your cancellation by selecting from the options below?",
      fields: {
        ...commonfields
      },
      required: true
    },
    ...optionalFeedback
  },
  [C$1.FORM_ACCOUNT_CLOSE]: {
    close_reason: {
      label: "We're sorry to hear that you're considering closing your account. To help us improve our service, could you please let us know the reason for your decision to close your account?",
      fields: {
        ...commonfields
      },
      required: true
    },
    ...optionalFeedback
  },
  [C$1.FORM_EMAIL_ALERT]: {
    alert_issues: {
      label: "What issue are you facing with this email alert?",
      fields: {
        false_positive: {
          type: "boolean",
          label: "It is a false alert."
        },
        late: {
          type: "boolean",
          label: "Alert is late."
        },
        frequent: {
          type: "boolean",
          label: "Alert is too frequent."
        },
        ...other
      },
      required: true
    },
    improvements: {
      label: "Would you like to make any suggestion that could enhance the dependability of email alerts?",
      fields: {
        notes: {
          type: "string"
        }
      }
    }
  },
  [C$1.FORM_APP_FEEDBACK]: {
    rating: {
      label: "How would you describe your overall satisfaction with Distill?",
      fields: {
        selected: {
          type: "enum",
          component: "EnumGroup",
          name: "rating",
          dropdown: false,
          multi: false,
          options: feedbackOptions
        }
      },
      required: true
    },
    module: {
      label: "My feedback is for:",
      fields: {
        context: {
          type: "enum",
          component: "EnumGroup",
          name: "module",
          dropdown: true,
          multi: false,
          options: routeModuleList,
          default: getCurrentRoute
        }
      }
    },
    improvements: {
      label: "Do you have any other feedback or suggestions for improving Distill?",
      fields: {
        notes: {
          type: "string"
        }
      }
    }
  },
  [C$1.FORM_CHANGELOG]: {
    feature_interest: {
      label: "Which new feature or update are you most excited about?",
      fields: {
        feature: {
          type: "string"
        }
      },
      required: true
    },
    feature_desc: {
      label: "Have you used any of the new features or updates? If so, what did you think of them?",
      fields: {
        feature: {
          type: "string"
        }
      },
      required: true
    },
    feature_suggest: {
      label: "Are there any features that you would like to see added or improved in future releases?",
      fields: {
        feature: {
          type: "string"
        }
      },
      required: true
    },
    feature_help: {
      label: "Were there any features that you found difficult to use or understand, or experienced any issues or bugs with? If so, please describe them",
      fields: {
        feature: {
          type: "string"
        }
      },
      required: true
    }
  },
  [C$1.FORM_DOCS]: {
    doc_help: {
      label: "Are there any areas of our product documentation that you find confusing or difficult to follow?",
      fields: {
        feature: {
          type: "string"
        }
      },
      required: true
    },
    docs_missing: {
      label: "Are there any topics or features that you feel are missing from our product documentation?",
      fields: {
        feature: {
          type: "string"
        }
      },
      required: true
    },
    docs_improvements: {
      label: "How can we improve our product documentation to better meet your needs?",
      fields: {
        feature: {
          type: "string"
        }
      },
      required: true
    },
    product_recommend
  },
  [C$1.FORM_CHANGE_SUMMARY]: ({ scoreOnly, notes } = { scoreOnly: false, notes: void 0 }) => {
    const changeSummaryForm = {
      score: {
        fields: {
          score: {
            label: "Rating",
            type: "int",
            required: false,
            default: 1
          }
        },
        required: false
      },
      ratings: {
        label: "How would you rate the current summary?",
        fields: {
          rating: {
            type: "enum",
            component: "NumberedRange",
            required: true,
            options: [
              { id: 1 },
              { id: 2 },
              { id: 3 },
              { id: 4 },
              { id: 5 },
              { id: 6 },
              { id: 7 },
              { id: 8 },
              { id: 9 },
              { id: 10 }
            ]
          }
        },
        required: false
      },
      notes: {
        label: "What should a better summary be? (You can edit the summary below)",
        fields: {
          notes: {
            type: "string",
            required: true,
            default: notes
          }
        },
        required: false
      }
    };
    if (scoreOnly) {
      delete changeSummaryForm.ratings;
      delete changeSummaryForm.notes;
    } else {
      delete changeSummaryForm.score;
    }
    return changeSummaryForm;
  }
};
const feedbackFormConfig = {
  [C$1.FORM_CHANGE_SUMMARY]: {
    callout: {
      type: "warning",
      header: "Tip",
      message: "Change summary and its fields can be customized and improved using the AI Summary settings."
    }
  }
};
class Model extends FormModel {
  constructor(defs2, required = false) {
    super(defs2);
    this.required = required;
  }
  validate(values2) {
    if (this.required) {
      return !values2.find((val) => !!val) ? { message: "*required" } : null;
    }
    return false;
  }
}
class FormGroupModel {
  constructor(formId, context) {
    this.initModel(formId, context);
  }
  initModel(formId, context) {
    this.formId = formId;
    this.formDef = feedbackforms[this.formId];
    this.formConfig = feedbackFormConfig[this.formId];
    if (_.isFunction(this.formDef)) {
      this.formDef = this.formDef(context);
    }
    this.forms = {};
    for (let formKey in this.formDef) {
      const fieldDefs = this.formDef[formKey].fields;
      this.forms[formKey] = new Model(fieldDefs, !!this.formDef[formKey].required);
    }
  }
  toJSON() {
    const json = {};
    Object.keys(this.formDef).forEach((key) => {
      json[key] = this.forms[key].toJSON();
    });
    return json;
  }
  async submit(_doc = {}) {
    let error2;
    Object.values(this.forms).forEach((model) => {
      model.setTouched();
      error2 = error2 != null ? error2 : get_store_value(model.error);
    });
    if (error2) {
      throw new Error(error2);
    }
    let clientDetails = {
      type: C$1.CLIENT_WEB
    };
    if (Supports.agents.local) {
      clientDetails = {
        type: await Supports.agents.type(),
        clientId: await serviceProxy.clientId
      };
    }
    const doc = {
      params: {
        ..._doc,
        clientDetails,
        ...this.toJSON()
      }
    };
    await Api.api(`/public/forms/${this.formId}/submissions`, "POST", doc);
    trackEvent(`form_submit_${this.formId}`, doc.params, PHEventCategories.FORM_SUBMISSIONS);
  }
}
function get_each_context$v(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  child_ctx[11] = i2;
  return child_ctx;
}
function create_each_block$v(ctx) {
  let div;
  let input;
  let input_id_value;
  let t0;
  let label;
  let t1_value = ctx[11] + 1 + "";
  let t1;
  let label_for_value;
  let t2;
  let mounted;
  let dispose;
  function change_handler() {
    return ctx[8](ctx[11]);
  }
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      label = element("label");
      t1 = text(t1_value);
      t2 = space();
      attr(input, "class", "form-check-input");
      attr(input, "type", "radio");
      attr(input, "id", input_id_value = ctx[1] + "-" + ctx[11]);
      attr(input, "name", ctx[2]);
      input.value = ctx[11] + 1;
      input.disabled = ctx[3];
      attr(label, "for", label_for_value = ctx[1] + "-" + ctx[11]);
      attr(label, "class", "form-check-label");
      attr(div, "class", "form-check form-check-inline");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      append(div, t0);
      append(div, label);
      append(label, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(input, "change", change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && input_id_value !== (input_id_value = ctx[1] + "-" + ctx[11])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & 4) {
        attr(input, "name", ctx[2]);
      }
      if (dirty & 8) {
        input.disabled = ctx[3];
      }
      if (dirty & 2 && label_for_value !== (label_for_value = ctx[1] + "-" + ctx[11])) {
        attr(label, "for", label_for_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1Q(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let each_value = Array(ctx[0]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$v(get_each_context$v(ctx, each_value, i2));
  }
  let div2_levels = [{ class: "" }, ctx[6]];
  let div_data_2 = {};
  for (let i2 = 0; i2 < div2_levels.length; i2 += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<small class="text-muted">WORSE</small> 
    <small class="text-muted">BEST</small>`;
      attr(div0, "class", "d-flex justify-content-between");
      attr(div1, "class", "d-flex justify-content-between");
      set_attributes(div2, div_data_2);
      toggle_class(div2, "is-invalid", ctx[4]);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div2, t0);
      append(div2, div1);
    },
    p(ctx2, [dirty]) {
      if (dirty & 47) {
        each_value = Array(ctx2[0]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$v(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$v(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [{ class: "" }, dirty & 64 && ctx2[6]]));
      toggle_class(div2, "is-invalid", ctx2[4]);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1N($$self, $$props, $$invalidate) {
  const omit_props_names = ["n", "id", "name", "disabled", "showErrors", "field"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { n = 10 } = $$props;
  let { id: id2 = "npr" } = $$props;
  let { name = "npr" } = $$props;
  let { disabled = false } = $$props;
  let { showErrors = false } = $$props;
  let { field } = $$props;
  function set(currentRadioButtonValue) {
    field.set(currentRadioButtonValue);
  }
  const change_handler = (i2) => set(i2 + 1);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("n" in $$new_props)
      $$invalidate(0, n = $$new_props.n);
    if ("id" in $$new_props)
      $$invalidate(1, id2 = $$new_props.id);
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("showErrors" in $$new_props)
      $$invalidate(4, showErrors = $$new_props.showErrors);
    if ("field" in $$new_props)
      $$invalidate(7, field = $$new_props.field);
  };
  return [n, id2, name, disabled, showErrors, set, $$restProps, field, change_handler];
}
class NumberedRange extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1N, create_fragment$1Q, safe_not_equal, {
      n: 0,
      id: 1,
      name: 2,
      disabled: 3,
      showErrors: 4,
      field: 7
    });
  }
}
function create_if_block_7$6(ctx) {
  let t;
  let div;
  let fieldwrapper;
  let current;
  let if_block = ctx[0].label && create_if_block_8$3(ctx);
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[1],
      class: "form-control p-0",
      $$slots: {
        default: [
          create_default_slot_2$9,
          ({ inputClasses, showError }) => ({ 5: inputClasses, 7: showError }),
          ({ inputClasses, showError }) => (inputClasses ? 32 : 0) | (showError ? 128 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      create_component(fieldwrapper.$$.fragment);
      attr(div, "class", "flex flex-grow-1");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      mount_component(fieldwrapper, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0].label) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_8$3(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const fieldwrapper_changes = {};
      if (dirty & 2)
        fieldwrapper_changes.field = ctx2[1];
      if (dirty & 418) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      destroy_component(fieldwrapper);
    }
  };
}
function create_if_block_5$d(ctx) {
  let t;
  let div;
  let fieldwrapper;
  let current;
  let if_block = ctx[0].label && create_if_block_6$7(ctx);
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[1],
      class: "form-control p-0",
      $$slots: {
        default: [
          create_default_slot_1$d,
          ({ inputClasses, action, showError }) => ({ 5: inputClasses, 6: action, 7: showError }),
          ({ inputClasses, action, showError }) => (inputClasses ? 32 : 0) | (action ? 64 : 0) | (showError ? 128 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      create_component(fieldwrapper.$$.fragment);
      attr(div, "class", "flex flex-grow-1");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      mount_component(fieldwrapper, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0].label) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_6$7(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const fieldwrapper_changes = {};
      if (dirty & 2)
        fieldwrapper_changes.field = ctx2[1];
      if (dirty & 418) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      destroy_component(fieldwrapper);
    }
  };
}
function create_if_block_3$s(ctx) {
  let div0;
  let input;
  let input_checked_value;
  let t0;
  let t1;
  let div1;
  let fieldwrapper;
  let current;
  let if_block = ctx[0].label && create_if_block_4$j(ctx);
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[1],
      class: "form-control",
      $$slots: {
        default: [
          create_default_slot$O,
          ({ inputClasses, action, showError }) => ({ 5: inputClasses, 6: action, 7: showError }),
          ({ inputClasses, action, showError }) => (inputClasses ? 32 : 0) | (action ? 64 : 0) | (showError ? 128 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      input = element("input");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      create_component(fieldwrapper.$$.fragment);
      attr(input, "type", "checkbox");
      attr(input, "id", ctx[3]);
      input.checked = input_checked_value = !!ctx[2];
      set_style(input, "border", "3px solid red");
      attr(div0, "class", "flex");
      attr(div1, "class", "flex flex-grow-1");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, input);
      append(div0, t0);
      if (if_block)
        if_block.m(div0, null);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      mount_component(fieldwrapper, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 4 && input_checked_value !== (input_checked_value = !!ctx2[2])) {
        input.checked = input_checked_value;
      }
      if (ctx2[0].label) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$j(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const fieldwrapper_changes = {};
      if (dirty & 2)
        fieldwrapper_changes.field = ctx2[1];
      if (dirty & 416) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (if_block)
        if_block.d();
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      destroy_component(fieldwrapper);
    }
  };
}
function create_if_block_1$L(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[0].label && create_if_block_2$A(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "checkbox");
      attr(input, "id", ctx[3]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      input.checked = ctx[2];
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[4]),
          listen(input, "input", function() {
            if (is_function(ctx[1].setTouched))
              ctx[1].setTouched.apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4) {
        input.checked = ctx[2];
      }
      if (ctx[0].label) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_2$A(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$$(ctx) {
  let enumgroup;
  let current;
  enumgroup = new EnumGroup({
    props: {
      def: ctx[0],
      field: ctx[1]
    }
  });
  return {
    c() {
      create_component(enumgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(enumgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const enumgroup_changes = {};
      if (dirty & 1)
        enumgroup_changes.def = ctx2[0];
      if (dirty & 2)
        enumgroup_changes.field = ctx2[1];
      enumgroup.$set(enumgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(enumgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(enumgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(enumgroup, detaching);
    }
  };
}
function create_if_block_8$3(ctx) {
  let label;
  let t_value = ctx[0].label + "";
  let t;
  return {
    c() {
      label = element("label");
      t = text(t_value);
      attr(label, "class", "feedback-form-field-label");
      set_style(label, "width", "100%");
      attr(label, "for", ctx[3]);
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_default_slot_2$9(ctx) {
  let numberedrange;
  let current;
  numberedrange = new NumberedRange({
    props: {
      id: ctx[3],
      field: ctx[1],
      class: "flex-grow-1 pa-2 " + ctx[5],
      showError: ctx[7],
      disabled: ctx[1].def.disabled
    }
  });
  return {
    c() {
      create_component(numberedrange.$$.fragment);
    },
    m(target, anchor) {
      mount_component(numberedrange, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const numberedrange_changes = {};
      if (dirty & 2)
        numberedrange_changes.field = ctx2[1];
      if (dirty & 32)
        numberedrange_changes.class = "flex-grow-1 pa-2 " + ctx2[5];
      if (dirty & 128)
        numberedrange_changes.showError = ctx2[7];
      if (dirty & 2)
        numberedrange_changes.disabled = ctx2[1].def.disabled;
      numberedrange.$set(numberedrange_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(numberedrange.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(numberedrange.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(numberedrange, detaching);
    }
  };
}
function create_if_block_6$7(ctx) {
  let label;
  let t_value = ctx[0].label + "";
  let t;
  return {
    c() {
      label = element("label");
      t = text(t_value);
      attr(label, "class", "feedback-form-field-label font-normal items-center");
      set_style(label, "width", "100%");
      attr(label, "for", ctx[3]);
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_default_slot_1$d(ctx) {
  let textarea;
  let textarea_class_value;
  let textarea_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "id", ctx[3]);
      attr(textarea, "class", textarea_class_value = "flex-grow-1 " + ctx[5]);
      attr(textarea, "rows", "5");
      textarea.disabled = textarea_disabled_value = ctx[1].def.disabled;
      toggle_class(textarea, "is-invalid", ctx[7]);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (!mounted) {
        dispose = action_destroyer(ctx[6].call(null, textarea));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32 && textarea_class_value !== (textarea_class_value = "flex-grow-1 " + ctx2[5])) {
        attr(textarea, "class", textarea_class_value);
      }
      if (dirty & 2 && textarea_disabled_value !== (textarea_disabled_value = ctx2[1].def.disabled)) {
        textarea.disabled = textarea_disabled_value;
      }
      if (dirty & 160) {
        toggle_class(textarea, "is-invalid", ctx2[7]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$j(ctx) {
  let label;
  let t_value = ctx[0].label + "";
  let t;
  return {
    c() {
      label = element("label");
      t = text(t_value);
      attr(label, "class", "feedback-form-field-label font-normal items-center");
      set_style(label, "width", "100%");
      attr(label, "for", ctx[3]);
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_default_slot$O(ctx) {
  let textarea;
  let textarea_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "class", textarea_class_value = "flex-grow-1 " + ctx[5]);
      attr(textarea, "rows", "2");
      toggle_class(textarea, "is-invalid", ctx[7]);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (!mounted) {
        dispose = action_destroyer(ctx[6].call(null, textarea));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32 && textarea_class_value !== (textarea_class_value = "flex-grow-1 " + ctx2[5])) {
        attr(textarea, "class", textarea_class_value);
      }
      if (dirty & 160) {
        toggle_class(textarea, "is-invalid", ctx2[7]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$A(ctx) {
  let label;
  let t_value = ctx[0].label + "";
  let t;
  return {
    c() {
      label = element("label");
      t = text(t_value);
      attr(label, "class", "feedback-form-field-label font-normal items-center");
      set_style(label, "width", "100%");
      attr(label, "for", ctx[3]);
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_fragment$1P(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [
    create_if_block$$,
    create_if_block_1$L,
    create_if_block_3$s,
    create_if_block_5$d,
    create_if_block_7$6
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].type === "enum" && ctx2[0].component === "EnumGroup")
      return 0;
    if (ctx2[0].type === "boolean")
      return 1;
    if (ctx2[0].type === "string" && ctx2[0].other)
      return 2;
    if (ctx2[0].type === "string")
      return 3;
    if (ctx2[0].type === "enum" && ctx2[0].component === "NumberedRange")
      return 4;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "feedback-form-field");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function instance$1M($$self, $$props, $$invalidate) {
  let $field, $$unsubscribe_field = noop$1, $$subscribe_field = () => ($$unsubscribe_field(), $$unsubscribe_field = subscribe(field, ($$value) => $$invalidate(2, $field = $$value)), field);
  $$self.$$.on_destroy.push(() => $$unsubscribe_field());
  let { def } = $$props;
  let { field } = $$props;
  $$subscribe_field();
  const fieldId = ID() + "";
  if (def.multi && def.dropdown) {
    def.options = def.options.map((el2) => {
      return {
        ...el2,
        selected: def.default === el2.value
      };
    });
  }
  if (!def.label) {
    def.label = "";
  }
  function input_change_handler() {
    $field = this.checked;
    field.set($field);
  }
  $$self.$$set = ($$props2) => {
    if ("def" in $$props2)
      $$invalidate(0, def = $$props2.def);
    if ("field" in $$props2)
      $$subscribe_field($$invalidate(1, field = $$props2.field));
  };
  return [def, field, $field, fieldId, input_change_handler];
}
class Field extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1M, create_fragment$1P, safe_not_equal, { def: 0, field: 1 });
  }
}
function get_each_context$u(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2][0];
  child_ctx[8] = list[i2][1];
  return child_ctx;
}
function create_if_block$_(ctx) {
  let small;
  let t_value = ctx[4].message + "";
  let t;
  return {
    c() {
      small = element("small");
      t = text(t_value);
      attr(small, "class", "error");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = ctx2[4].message + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_each_block$u(ctx) {
  let div;
  let field;
  let t;
  let current;
  field = new Field({
    props: {
      def: ctx[0].fields[ctx[7]],
      field: ctx[8]
    }
  });
  return {
    c() {
      div = element("div");
      create_component(field.$$.fragment);
      t = space();
      attr(div, "class", "mb2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(field, div, null);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty & 3)
        field_changes.def = ctx2[0].fields[ctx2[7]];
      if (dirty & 2)
        field_changes.field = ctx2[8];
      field.$set(field_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(field);
    }
  };
}
function create_fragment$1O(ctx) {
  let div;
  let h6;
  let t0_value = ctx[2] + 1 + "";
  let t0;
  let t1;
  let t2_value = ctx[0].label + "";
  let t2;
  let t3;
  let t4;
  let current;
  let if_block = ctx[3] && ctx[4] && create_if_block$_(ctx);
  let each_value = [...Object.entries(ctx[1].fields)];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$u(get_each_context$u(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      h6 = element("h6");
      t0 = text(t0_value);
      t1 = text(". ");
      t2 = text(t2_value);
      t3 = space();
      if (if_block)
        if_block.c();
      t4 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h6, "class", "d-flex justify-between font-bold leading-relaxed");
      attr(div, "class", "feedback-form ph3 pv2 xbg-2");
      set_style(div, "border-left", "1px solid " + (ctx[3] ? "red" : "transparent"));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h6);
      append(h6, t0);
      append(h6, t1);
      append(h6, t2);
      append(h6, t3);
      if (if_block)
        if_block.m(h6, null);
      append(div, t4);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 4) && t0_value !== (t0_value = ctx2[2] + 1 + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx2[0].label + ""))
        set_data(t2, t2_value);
      if (ctx2[3] && ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$_(ctx2);
          if_block.c();
          if_block.m(h6, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 3) {
        each_value = [...Object.entries(ctx2[1].fields)];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$u(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$u(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty & 8) {
        set_style(div, "border-left", "1px solid " + (ctx2[3] ? "red" : "transparent"));
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$1L($$self, $$props, $$invalidate) {
  let $showError;
  let $error;
  let { def } = $$props;
  let { model } = $$props;
  let { index: index2 } = $$props;
  const showError = model.showError;
  component_subscribe($$self, showError, (value) => $$invalidate(3, $showError = value));
  const error2 = model.error;
  component_subscribe($$self, error2, (value) => $$invalidate(4, $error = value));
  $$self.$$set = ($$props2) => {
    if ("def" in $$props2)
      $$invalidate(0, def = $$props2.def);
    if ("model" in $$props2)
      $$invalidate(1, model = $$props2.model);
    if ("index" in $$props2)
      $$invalidate(2, index2 = $$props2.index);
  };
  return [def, model, index2, $showError, $error, showError, error2];
}
class Form extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1L, create_fragment$1O, safe_not_equal, { def: 0, model: 1, index: 2 });
  }
}
function get_each_context$t(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2][0];
  child_ctx[6] = list[i2][1];
  child_ctx[8] = i2;
  return child_ctx;
}
function create_if_block$Z(ctx) {
  let div;
  let t;
  let current;
  let each_value = [...Object.entries(ctx[0].forms)];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$t(get_each_context$t(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = ctx[1] && create_if_block_1$K(ctx);
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "feedback-form-group flex flex-col");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value = [...Object.entries(ctx2[0].forms)];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$t(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$t(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, t);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$K(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function create_each_block$t(ctx) {
  let form;
  let current;
  form = new Form({
    props: {
      def: ctx[0].formDef[ctx[5]],
      model: ctx[6],
      index: ctx[8]
    }
  });
  return {
    c() {
      create_component(form.$$.fragment);
    },
    m(target, anchor) {
      mount_component(form, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const form_changes = {};
      if (dirty & 1)
        form_changes.def = ctx2[0].formDef[ctx2[5]];
      if (dirty & 1)
        form_changes.model = ctx2[6];
      form.$set(form_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(form.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(form.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(form, detaching);
    }
  };
}
function create_if_block_1$K(ctx) {
  let if_block_anchor;
  let if_block = ctx[1].callout && create_if_block_2$z(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[1].callout) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$z(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_2$z(ctx) {
  let div2;
  let div0;
  let span;
  let t0_value = ctx[1].callout.header + "";
  let t0;
  let t1;
  let div1;
  let t2_value = ctx[1].callout.message + "";
  let t2;
  let div2_class_value;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      attr(span, "class", "fw-lighter ttu");
      set_style(span, "font-size", "0.8rem");
      attr(div0, "class", "d-flex p-1 items-center");
      set_style(div0, "backdrop-filter", "brightness(96%)");
      attr(div1, "class", "p-2 ps-1");
      attr(div2, "class", div2_class_value = "x-callout x-callout-" + ctx[1].callout.type + " m-0 mb-2 p-0");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span);
      append(span, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1].callout.header + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = ctx2[1].callout.message + ""))
        set_data(t2, t2_value);
      if (dirty & 2 && div2_class_value !== (div2_class_value = "x-callout x-callout-" + ctx2[1].callout.type + " m-0 mb-2 p-0")) {
        attr(div2, "class", div2_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
function create_fragment$1N(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block$Z(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$Z(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1K($$self, $$props, $$invalidate) {
  let { id: id2 } = $$props;
  let { model } = $$props;
  let { context } = $$props;
  let { formConfig = void 0 } = $$props;
  const isFormEnabled = async () => {
    return await Api.api(`/public/forms/${id2}`, "GET");
  };
  model = null;
  isFormEnabled().then((res) => {
    $$invalidate(0, model = new FormGroupModel(id2, context));
    $$invalidate(0, model.formName = res.name, model);
    $$invalidate(1, formConfig = model.formConfig);
  }).catch((err) => {
    console.error("Cannot fetch form:", id2, err);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(2, id2 = $$props2.id);
    if ("model" in $$props2)
      $$invalidate(0, model = $$props2.model);
    if ("context" in $$props2)
      $$invalidate(3, context = $$props2.context);
    if ("formConfig" in $$props2)
      $$invalidate(1, formConfig = $$props2.formConfig);
  };
  return [model, formConfig, id2, context];
}
class FormGroup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1K, create_fragment$1N, safe_not_equal, {
      id: 2,
      model: 0,
      context: 3,
      formConfig: 1
    });
  }
}
const _SummaryParamFormModel = class extends FormModel {
  constructor(json) {
    super((json == null ? void 0 : json.name) === "change_summary" ? _SummaryParamFormModel.summaryFields : _SummaryParamFormModel.fields, json);
  }
  isDisabled() {
    return ["change_summary", "important"].includes(this.fields.name.get());
  }
  static getDefaultValue() {
    return {
      name: "change_summary",
      type: "string",
      description: void 0
    };
  }
  toJSON(dirty = false) {
    return super.toJSON(dirty);
  }
  validate(values2) {
  }
};
let SummaryParamFormModel = _SummaryParamFormModel;
__publicField(SummaryParamFormModel, "fields", Object.freeze({
  name: {
    required: true,
    type: "string",
    validators: [mustMatchRegex({
      expr: /^[a-zA-Z_][a-zA-Z0-9_]*$/,
      message: "Invalid name: must only contain letters, numbers, and underscores"
    })]
  },
  type: {
    required: true,
    type: "enum",
    dropdown: true,
    options: [
      { id: "number", label: "Number" },
      { id: "string", label: "String" },
      { id: "boolean", label: "Boolean" }
    ],
    default: "string",
    validators: [verifyEnum]
  },
  description: {
    required: true,
    type: "string"
  }
}));
__publicField(SummaryParamFormModel, "summaryFields", Object.freeze({
  ..._SummaryParamFormModel.fields,
  description: {
    type: "string"
  }
}));
class SummaryParamFormModelList extends FieldList {
  constructor(values2) {
    super({ type: "summaryParam" }, values2);
  }
  getDef() {
    return {
      type: "summaryParam"
    };
  }
  getDefaultValue() {
    return SummaryParamFormModel.getDefaultValue();
  }
}
const _SummaryConfigurationFormModel = class extends FormModel {
  constructor(json) {
    super(_SummaryConfigurationFormModel.fields, json);
    __publicField(this, "disabled", false);
  }
  static getDefaultValue() {
    return {
      enabled: false,
      params: [{
        name: "change_summary",
        type: "string",
        description: void 0
      }, {
        name: "important",
        type: "boolean",
        description: void 0
      }]
    };
  }
  toJSON(dirty = false) {
    return super.toJSON(dirty);
  }
  initFields(defs2, attrs) {
    return super.initFields(defs2, attrs);
  }
};
let SummaryConfigurationFormModel = _SummaryConfigurationFormModel;
__publicField(SummaryConfigurationFormModel, "fields", Object.freeze({
  enabled: {
    required: true,
    type: "boolean"
  },
  params: {
    required: true,
    type: "summaryParamList"
  }
}));
class SummaryParamFieldType extends TYPES.base {
  static toJSON(obj) {
    return obj.toJSON();
  }
  static parse(json) {
    return new SummaryParamFormModel(json);
  }
}
register("summaryParam", SummaryParamFieldType);
class SummaryParamListFieldType extends TYPES.base {
  static toJSON(obj) {
    return obj.toJSON();
  }
  static parse(json) {
    return new SummaryParamFormModelList(json);
  }
}
register("summaryParamList", SummaryParamListFieldType);
function create_if_block_1$J(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = "Remove";
      attr(button, "class", "btn btn-sm btn-outline-secondary");
      attr(div, "class", "align-self-end mb-1 pb-1 ms-auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[7]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$A(ctx) {
  let multilineinputedit;
  let current;
  multilineinputedit = new MultilineInputEdit({
    props: {
      id: "param-description-" + ctx[2],
      field: ctx[1].fields.description,
      rows: "3",
      placeholder: ctx[0],
      classes: "me-2"
    }
  });
  return {
    c() {
      create_component(multilineinputedit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(multilineinputedit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const multilineinputedit_changes = {};
      if (dirty & 4)
        multilineinputedit_changes.id = "param-description-" + ctx2[2];
      if (dirty & 2)
        multilineinputedit_changes.field = ctx2[1].fields.description;
      if (dirty & 1)
        multilineinputedit_changes.placeholder = ctx2[0];
      multilineinputedit.$set(multilineinputedit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(multilineinputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(multilineinputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(multilineinputedit, detaching);
    }
  };
}
function create_if_block$Y(ctx) {
  let multilineinputedit;
  let current;
  multilineinputedit = new MultilineInputEdit({
    props: {
      id: "param-description-" + ctx[2],
      field: ctx[1].fields.description,
      rows: "3",
      autofocus: ctx[3],
      placeholder: ctx[0],
      classes: "me-2"
    }
  });
  return {
    c() {
      create_component(multilineinputedit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(multilineinputedit, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const multilineinputedit_changes = {};
      if (dirty & 4)
        multilineinputedit_changes.id = "param-description-" + ctx2[2];
      if (dirty & 2)
        multilineinputedit_changes.field = ctx2[1].fields.description;
      if (dirty & 1)
        multilineinputedit_changes.placeholder = ctx2[0];
      multilineinputedit.$set(multilineinputedit_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(multilineinputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(multilineinputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(multilineinputedit, detaching);
    }
  };
}
function create_fragment$1M(ctx) {
  let div4;
  let div2;
  let div0;
  let label0;
  let t0;
  let inputedit;
  let label0_for_value;
  let t1;
  let div1;
  let label1;
  let t2;
  let enumgroup;
  let label1_for_value;
  let t3;
  let show_if = !ctx[1].isDisabled();
  let t4;
  let div3;
  let current_block_type_index;
  let if_block1;
  let current;
  inputedit = new InputEdit({
    props: {
      id: "param-name-" + ctx[2],
      field: ctx[1].fields.name,
      classes: "me-2",
      disabled: ctx[1].isDisabled()
    }
  });
  enumgroup = new EnumGroup({
    props: {
      id: "param-type-" + ctx[2],
      def: ctx[1].defs.type,
      field: ctx[1].fields.type,
      classes: "me-2",
      disabled: ctx[1].isDisabled()
    }
  });
  let if_block0 = show_if && create_if_block_1$J(ctx);
  const if_block_creators = [create_if_block$Y, create_else_block$A];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div4_levels = [
    {
      class: "d-flex flex-column gap-1 p-2 mt-3"
    },
    ctx[5]
  ];
  let div_data_4 = {};
  for (let i2 = 0; i2 < div4_levels.length; i2 += 1) {
    div_data_4 = assign(div_data_4, div4_levels[i2]);
  }
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      label0 = element("label");
      t0 = text("Name\n\n        ");
      create_component(inputedit.$$.fragment);
      t1 = space();
      div1 = element("div");
      label1 = element("label");
      t2 = text("Type\n\n        ");
      create_component(enumgroup.$$.fragment);
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      div3 = element("div");
      if_block1.c();
      attr(label0, "class", "font-normal form-label");
      attr(label0, "for", label0_for_value = "param-name-" + ctx[2]);
      attr(div0, "class", "d-flex flex-column");
      attr(label1, "class", "font-normal form-label");
      attr(label1, "for", label1_for_value = "param-type-" + ctx[2]);
      attr(div1, "class", "d-flex flex-column");
      attr(div2, "class", "d-flex gap-1");
      attr(div3, "class", "d-flex flex-column");
      set_attributes(div4, div_data_4);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, label0);
      append(label0, t0);
      mount_component(inputedit, label0, null);
      append(div2, t1);
      append(div2, div1);
      append(div1, label1);
      append(label1, t2);
      mount_component(enumgroup, label1, null);
      append(div2, t3);
      if (if_block0)
        if_block0.m(div2, null);
      append(div4, t4);
      append(div4, div3);
      if_blocks[current_block_type_index].m(div3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const inputedit_changes = {};
      if (dirty & 4)
        inputedit_changes.id = "param-name-" + ctx2[2];
      if (dirty & 2)
        inputedit_changes.field = ctx2[1].fields.name;
      if (dirty & 2)
        inputedit_changes.disabled = ctx2[1].isDisabled();
      inputedit.$set(inputedit_changes);
      if (!current || dirty & 4 && label0_for_value !== (label0_for_value = "param-name-" + ctx2[2])) {
        attr(label0, "for", label0_for_value);
      }
      const enumgroup_changes = {};
      if (dirty & 4)
        enumgroup_changes.id = "param-type-" + ctx2[2];
      if (dirty & 2)
        enumgroup_changes.def = ctx2[1].defs.type;
      if (dirty & 2)
        enumgroup_changes.field = ctx2[1].fields.type;
      if (dirty & 2)
        enumgroup_changes.disabled = ctx2[1].isDisabled();
      enumgroup.$set(enumgroup_changes);
      if (!current || dirty & 4 && label1_for_value !== (label1_for_value = "param-type-" + ctx2[2])) {
        attr(label1, "for", label1_for_value);
      }
      if (dirty & 2)
        show_if = !ctx2[1].isDisabled();
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$J(ctx2);
          if_block0.c();
          if_block0.m(div2, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if_block1.p(ctx2, dirty);
      set_attributes(div4, div_data_4 = get_spread_update(div4_levels, [
        {
          class: "d-flex flex-column gap-1 p-2 mt-3"
        },
        dirty & 32 && ctx2[5]
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      transition_in(enumgroup.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      transition_out(enumgroup.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(inputedit);
      destroy_component(enumgroup);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$1J($$self, $$props, $$invalidate) {
  const omit_props_names = ["summaryParamFormModel", "index", "placeholder", "params"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  const dispatch = createEventDispatcher();
  let { summaryParamFormModel } = $$props;
  let { index: index2 = 0 } = $$props;
  let { placeholder = "Enter the field's description and the prompt used by the AI model to get the value out from the highlighted changes" } = $$props;
  let { params: params2 } = $$props;
  let autofocus2 = summaryParamFormModel.fields.name.get() === "change_summary";
  if (summaryParamFormModel.fields.name.get() === "change_summary") {
    placeholder = "Provide the prompt to summarize the changes.\nNote: Keep it blank if you want to use Distill's default summary prompt.";
  }
  function onRemove() {
    dispatch("remove", { index: index2 });
  }
  const click_handler = () => onRemove();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("summaryParamFormModel" in $$new_props)
      $$invalidate(1, summaryParamFormModel = $$new_props.summaryParamFormModel);
    if ("index" in $$new_props)
      $$invalidate(2, index2 = $$new_props.index);
    if ("placeholder" in $$new_props)
      $$invalidate(0, placeholder = $$new_props.placeholder);
    if ("params" in $$new_props)
      $$invalidate(6, params2 = $$new_props.params);
  };
  return [
    placeholder,
    summaryParamFormModel,
    index2,
    autofocus2,
    onRemove,
    $$restProps,
    params2,
    click_handler
  ];
}
class Param extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1J, create_fragment$1M, safe_not_equal, {
      summaryParamFormModel: 1,
      index: 2,
      placeholder: 0,
      params: 6
    });
  }
}
function create_catch_block$m(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Failed to fetch the monitors";
      attr(p, "class", "text-danger");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_then_block$m(ctx) {
  let searchablemenu;
  let current;
  const searchablemenu_spread_levels = [
    { id: ctx[0] },
    { items: ctx[1] },
    {
      actionClass: "btn btn-sm border rounded max-w-[250px] text-truncate"
    },
    { title: "Select Monitor" },
    ctx[6]
  ];
  let searchablemenu_props = {
    $$slots: {
      bottom: [create_bottom_slot$3],
      "label-pre": [create_label_pre_slot]
    },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < searchablemenu_spread_levels.length; i2 += 1) {
    searchablemenu_props = assign(searchablemenu_props, searchablemenu_spread_levels[i2]);
  }
  searchablemenu = new SearchableMenu({ props: searchablemenu_props });
  searchablemenu.$on("search", ctx[3]);
  searchablemenu.$on("select", ctx[4]);
  searchablemenu.$on("open", ctx[7]);
  searchablemenu.$on("close", ctx[5]);
  return {
    c() {
      create_component(searchablemenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemenu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const searchablemenu_changes = dirty & 67 ? get_spread_update(searchablemenu_spread_levels, [
        dirty & 1 && { id: ctx2[0] },
        dirty & 2 && { items: ctx2[1] },
        searchablemenu_spread_levels[2],
        searchablemenu_spread_levels[3],
        dirty & 64 && get_spread_object(ctx2[6])
      ]) : {};
      if (dirty & 65536) {
        searchablemenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      searchablemenu.$set(searchablemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemenu, detaching);
    }
  };
}
function create_label_pre_slot(ctx) {
  let t;
  return {
    c() {
      t = text("Monitor -");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_bottom_slot$3(ctx) {
  let li0;
  let t0;
  let li1;
  let a;
  let t1;
  return {
    c() {
      li0 = element("li");
      t0 = space();
      li1 = element("li");
      a = element("a");
      t1 = text("Learn\n          More");
      attr(li0, "class", "dropdown-divider");
      attr(a, "class", "dropdown-item");
      attr(a, "href", urlCfg.website + "/docs/web-monitor/ai-change-summary/");
      attr(a, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      insert(target, t0, anchor);
      insert(target, li1, anchor);
      append(li1, a);
      append(a, t1);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(li1);
    }
  };
}
function create_pending_block$m(ctx) {
  let spinner;
  let current;
  spinner = new Spinner({});
  return {
    c() {
      create_component(spinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spinner, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spinner, detaching);
    }
  };
}
function create_fragment$1L(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$m,
    then: create_then_block$m,
    catch: create_catch_block$m,
    value: 14,
    error: 15,
    blocks: [, , ,]
  };
  handle_promise(ctx[2], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$1I($$self, $$props, $$invalidate) {
  const omit_props_names = ["id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  const dispatcher = createEventDispatcher();
  let { id: id2 } = $$props;
  let initSieves = [];
  let items = [];
  let initPromiseResolve = null;
  let initPromiseReject = null;
  let initPromise = new Promise((res, rej) => {
    initPromiseResolve = res;
    initPromiseReject = rej;
  });
  init2();
  async function init2() {
    try {
      initSieves = $$invalidate(1, items = await findSieves());
      initPromiseResolve();
      if (id2) {
        const sieve = items.find((sieve2) => sieve2.id === id2);
        if (sieve) {
          addSelected({ detail: id2 });
        }
      }
    } catch (e) {
      console.error("error while fetching the sieves", e);
      Msg.error("Failed to fetch the monitors");
      initPromiseReject(e);
    }
  }
  async function findSieves(phrase = "") {
    var _a;
    if (Supports.agents.local && !await serviceProxy.auth.isLoggedIn()) {
      return [];
    }
    let query = {
      _opt: { only: ["id", "name"], limit: 20 },
      "content_type.in": [C$1.TYPE_PDF_HTML, C$1.TYPE_DOC, C$1.TYPE_HTML],
      "state.in": [40, 45]
    };
    if (phrase) {
      query = {
        ...query,
        "$or": {
          "uri.ilike": `%${phrase}%`,
          "name.ilike": `%${phrase}%`
        }
      };
    }
    const fetchPromises = [Api.api("/sieves", query)];
    if (id2) {
      fetchPromises.push(Api.api(`/sieves`, {
        _opt: { only: ["id", "name"], limit: 1 },
        id: id2
      }));
    }
    const res = await Promise.all(fetchPromises);
    const data = res[0].data;
    if (res.length > 1 && ((_a = res[1].data) == null ? void 0 : _a.length) > 0) {
      for (let i2 = 0; i2 < res[1].data.length; i2++) {
        if (!data.find((sieve) => sieve.id === res[1].data[i2].id)) {
          data.push(res[1].data[i2]);
        }
      }
    }
    return data;
  }
  async function onSearch(e) {
    $$invalidate(1, items = await findSieves(e.detail));
  }
  function addSelected(e) {
    dispatcher("select", e.detail);
  }
  function resetSieves() {
    $$invalidate(1, items = initSieves);
  }
  function open_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
  };
  return [
    id2,
    items,
    initPromise,
    onSearch,
    addSelected,
    resetSieves,
    $$restProps,
    open_handler
  ];
}
class SelectMonitor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1I, create_fragment$1L, safe_not_equal, { id: 0 });
  }
}
function create_catch_block$l(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Failed to fetch the Sieve data";
      attr(p, "class", "text-danger");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_then_block$l(ctx) {
  let searchablemenu;
  let current;
  const searchablemenu_spread_levels = [
    { id: ctx[0] },
    { items: ctx[1] },
    { actionClass: "btn btn-sm border rounded" },
    { title: "Select From Change History" },
    ctx[6]
  ];
  let searchablemenu_props = {
    $$slots: { bottom: [create_bottom_slot$2] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < searchablemenu_spread_levels.length; i2 += 1) {
    searchablemenu_props = assign(searchablemenu_props, searchablemenu_spread_levels[i2]);
  }
  searchablemenu = new SearchableMenu({ props: searchablemenu_props });
  searchablemenu.$on("search", ctx[3]);
  searchablemenu.$on("select", ctx[4]);
  searchablemenu.$on("open", ctx[8]);
  searchablemenu.$on("close", ctx[5]);
  return {
    c() {
      create_component(searchablemenu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(searchablemenu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const searchablemenu_changes = dirty & 67 ? get_spread_update(searchablemenu_spread_levels, [
        dirty & 1 && { id: ctx2[0] },
        dirty & 2 && { items: ctx2[1] },
        searchablemenu_spread_levels[2],
        searchablemenu_spread_levels[3],
        dirty & 64 && get_spread_object(ctx2[6])
      ]) : {};
      if (dirty & 131072) {
        searchablemenu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      searchablemenu.$set(searchablemenu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchablemenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchablemenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(searchablemenu, detaching);
    }
  };
}
function create_bottom_slot$2(ctx) {
  let li0;
  let t0;
  let li1;
  let a;
  let t1;
  return {
    c() {
      li0 = element("li");
      t0 = space();
      li1 = element("li");
      a = element("a");
      t1 = text("Learn\n          More");
      attr(li0, "class", "dropdown-divider");
      attr(a, "class", "dropdown-item");
      attr(a, "href", urlCfg.website + "/docs/web-monitor/ai-change-summary/");
      attr(a, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      insert(target, t0, anchor);
      insert(target, li1, anchor);
      append(li1, a);
      append(a, t1);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(li1);
    }
  };
}
function create_pending_block$l(ctx) {
  let spinner;
  let current;
  spinner = new Spinner({
    props: { class: "text-primary ml-3 mt-1.5" }
  });
  return {
    c() {
      create_component(spinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spinner, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spinner, detaching);
    }
  };
}
function create_fragment$1K(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$l,
    then: create_then_block$l,
    catch: create_catch_block$l,
    value: 15,
    error: 16,
    blocks: [, , ,]
  };
  handle_promise(ctx[2], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$1H($$self, $$props, $$invalidate) {
  const omit_props_names = ["sieveId", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  const dispatcher = createEventDispatcher();
  let { sieveId = null } = $$props;
  let initSieveData = [];
  let items = [];
  let initPromiseResolve = null;
  let initPromiseReject = null;
  let initPromise = new Promise((res, rej) => {
    initPromiseResolve = res;
    initPromiseReject = rej;
  });
  let { id: id2 = null } = $$props;
  init2();
  async function init2() {
    try {
      const sieveDataList = await fetchSieveDataList();
      if (sieveDataList.length === 0) {
        return;
      }
      $$invalidate(1, items = sieveDataList.map((sieveData) => {
        return {
          id: sieveData.id,
          ts: sieveData.ts,
          name: new Date(sieveData.ts).toLocaleString()
        };
      }));
      initSieveData = items;
      if (!id2) {
        $$invalidate(0, id2 = items[0].id);
      }
      initPromiseResolve();
      addSelected({ detail: id2 });
    } catch (e) {
      console.error("error while fetching the sieve data", e);
      Msg.error("Failed to fetch the monitor data");
      initPromiseReject(e);
    }
  }
  async function fetchSieveDataList() {
    if (Supports.agents.local && !await serviceProxy.auth.isLoggedIn()) {
      return [];
    }
    const query = {
      _opt: { only: ["id", "ts"], order: ["-ts"] },
      "sieve_id.eq": sieveId
    };
    const res = await Api.api(`/sieves/${sieveId}/data`, query);
    return res.data;
  }
  async function onSearch(e) {
    $$invalidate(1, items = initSieveData.filter((sieveData) => sieveData.name.toLowerCase().includes(e.detail)));
  }
  function addSelected(e) {
    const selectedSieveData = initSieveData.find((sieveData) => sieveData.id === e.detail);
    dispatcher("select", {
      selectedSieveData,
      allSieveData: initSieveData
    });
  }
  function resetSieves() {
    $$invalidate(1, items = initSieveData);
  }
  function open_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("sieveId" in $$new_props)
      $$invalidate(7, sieveId = $$new_props.sieveId);
    if ("id" in $$new_props)
      $$invalidate(0, id2 = $$new_props.id);
  };
  return [
    id2,
    items,
    initPromise,
    onSearch,
    addSelected,
    resetSieves,
    $$restProps,
    sieveId,
    open_handler
  ];
}
class SelectSieveData extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1H, create_fragment$1K, safe_not_equal, { sieveId: 7, id: 0 });
  }
}
function get_each_context$s(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2][0];
  child_ctx[7] = list[i2][1];
  return child_ctx;
}
function create_if_block$X(ctx) {
  let table;
  let tbody;
  let if_block = ctx[0] && create_if_block_1$I(ctx);
  return {
    c() {
      table = element("table");
      tbody = element("tbody");
      if (if_block)
        if_block.c();
      attr(table, "class", "table table-sm mb-0");
      set_style(table, "--bs-table-bg", "var(--bs-info-bg-subtle)");
      set_style(table, "--bs-border-width", "0px");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, tbody);
      if (if_block)
        if_block.m(tbody, null);
    },
    p(ctx2, dirty) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$I(ctx2);
          if_block.c();
          if_block.m(tbody, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(table);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$I(ctx) {
  let each_1_anchor;
  let each_value = Object.entries(ctx[0]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$s(get_each_context$s(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 9) {
        each_value = Object.entries(ctx2[0]);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$s(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$s(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_2$y(ctx) {
  let tr;
  let td;
  let code;
  let t0_value = ctx[6] + "";
  let t0;
  let t1;
  let show_if;
  let t2;
  function select_block_type(ctx2, dirty) {
    if (dirty & 1)
      show_if = null;
    if (show_if == null)
      show_if = !!ctx2[3].includes(ctx2[6]);
    if (show_if)
      return create_if_block_3$r;
    return create_else_block$z;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      tr = element("tr");
      td = element("td");
      code = element("code");
      t0 = text(t0_value);
      t1 = space();
      if_block.c();
      t2 = space();
      attr(code, "class", "pe-2 fw-bold");
      set_style(code, "font-size", "0.9rem");
      set_style(td, "width", "10px");
      attr(td, "class", "ps-0");
      attr(tr, "class", "border-none");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      append(td, code);
      append(code, t0);
      append(tr, t1);
      if_block.m(tr, null);
      append(tr, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[6] + ""))
        set_data(t0, t0_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(tr, t2);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block.d();
    }
  };
}
function create_else_block$z(ctx) {
  let td;
  let t_value = ctx[7] + "";
  let t;
  return {
    c() {
      td = element("td");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[7] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_if_block_3$r(ctx) {
  let td;
  let span;
  let t_value = ctx[7] === true || ctx[7] === "true" ? "True" : "False";
  let t;
  let span_class_value;
  return {
    c() {
      td = element("td");
      span = element("span");
      t = text(t_value);
      attr(span, "class", span_class_value = "badge text-bg-" + (ctx[7] === true || ctx[7] === "true" ? "success" : "secondary"));
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, span);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[7] === true || ctx2[7] === "true" ? "True" : "False"))
        set_data(t, t_value);
      if (dirty & 1 && span_class_value !== (span_class_value = "badge text-bg-" + (ctx2[7] === true || ctx2[7] === "true" ? "success" : "secondary"))) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_each_block$s(ctx) {
  let if_block_anchor;
  let if_block = ctx[6] !== "change_summary" && create_if_block_2$y(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[6] !== "change_summary") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$y(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$1J(ctx) {
  let div;
  let pre;
  let t1;
  let if_block = ctx[2] > 1 && create_if_block$X(ctx);
  return {
    c() {
      div = element("div");
      pre = element("pre");
      pre.textContent = `${ctx[1]}`;
      t1 = space();
      if (if_block)
        if_block.c();
      attr(pre, "class", "mb-1 whitespace-pre-wrap");
      set_style(pre, "font-family", "var(--bs-body-font-family)");
      set_style(pre, "font-size", "1rem");
      set_style(div, "background-color", "var(--bs-info-bg-subtle)");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, pre);
      append(div, t1);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (ctx2[2] > 1)
        if_block.p(ctx2, dirty);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$1G($$self, $$props, $$invalidate) {
  var _a;
  let { root: root2 } = $$props;
  let { summaryConfiguration } = $$props;
  const change_summary = (_a = root2 == null ? void 0 : root2.change_summary) == null ? void 0 : _a.trim();
  const rowCount = Object.keys(root2).length;
  const params2 = (summaryConfiguration == null ? void 0 : summaryConfiguration.params) || [];
  const booleanParamNames = params2.filter((p) => p.type === "boolean").map((p) => p.name);
  booleanParamNames.push("important");
  $$self.$$set = ($$props2) => {
    if ("root" in $$props2)
      $$invalidate(0, root2 = $$props2.root);
    if ("summaryConfiguration" in $$props2)
      $$invalidate(4, summaryConfiguration = $$props2.summaryConfiguration);
  };
  return [root2, change_summary, rowCount, booleanParamNames, summaryConfiguration];
}
class SummaryResponseTable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1G, create_fragment$1J, safe_not_equal, { root: 0, summaryConfiguration: 4 });
  }
}
function create_fragment$1I(ctx) {
  let label;
  let div;
  let input;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  return {
    c() {
      label = element("label");
      div = element("div");
      input = element("input");
      t = space();
      if (default_slot)
        default_slot.c();
      attr(input, "class", "me-2 form-check-input");
      attr(input, "type", "checkbox");
      attr(input, "role", "switch");
      attr(div, "class", "form-check form-switch");
      attr(label, "class", "d-flex align-items-center");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append(label, div);
      append(div, input);
      input.checked = ctx[1];
      append(label, t);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        input.checked = ctx2[1];
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(label);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$1F($$self, $$props, $$invalidate) {
  let $field, $$unsubscribe_field = noop$1, $$subscribe_field = () => ($$unsubscribe_field(), $$unsubscribe_field = subscribe(field, ($$value) => $$invalidate(1, $field = $$value)), field);
  $$self.$$.on_destroy.push(() => $$unsubscribe_field());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { field } = $$props;
  $$subscribe_field();
  function input_change_handler() {
    $field = this.checked;
    field.set($field);
  }
  $$self.$$set = ($$props2) => {
    if ("field" in $$props2)
      $$subscribe_field($$invalidate(0, field = $$props2.field));
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [field, $field, $$scope, slots, input_change_handler];
}
class Switch extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1F, create_fragment$1I, safe_not_equal, { field: 0 });
  }
}
function get_each_context$r(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2];
  return child_ctx;
}
function get_each_context_1$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i2];
  child_ctx[30] = i2;
  return child_ctx;
}
function create_default_slot$N(ctx) {
  let t;
  return {
    c() {
      t = text("Summarize Changes");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block_1$5(ctx) {
  let param;
  let current;
  param = new Param({
    props: {
      params: ctx[2].fields.params,
      summaryParamFormModel: ctx[28],
      index: ctx[30]
    }
  });
  param.$on("remove", ctx[21]);
  return {
    c() {
      create_component(param.$$.fragment);
    },
    m(target, anchor) {
      mount_component(param, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const param_changes = {};
      if (dirty[0] & 4)
        param_changes.params = ctx2[2].fields.params;
      if (dirty[0] & 4096)
        param_changes.summaryParamFormModel = ctx2[28];
      param.$set(param_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(param.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(param.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(param, detaching);
    }
  };
}
function create_if_block_11(ctx) {
  let div;
  let p;
  let t1;
  let selectsievedata;
  let current;
  selectsievedata = new SelectSieveData({
    props: {
      id: ctx[1],
      sieveId: ctx[0],
      strategy: "fixed"
    }
  });
  selectsievedata.$on("select", ctx[18]);
  return {
    c() {
      div = element("div");
      p = element("p");
      p.textContent = "Select Change";
      t1 = space();
      create_component(selectsievedata.$$.fragment);
      attr(p, "class", "help ms-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(div, t1);
      mount_component(selectsievedata, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const selectsievedata_changes = {};
      if (dirty[0] & 2)
        selectsievedata_changes.id = ctx2[1];
      if (dirty[0] & 1)
        selectsievedata_changes.sieveId = ctx2[0];
      selectsievedata.$set(selectsievedata_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectsievedata.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectsievedata.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(selectsievedata);
    }
  };
}
function create_key_block$3(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block_11(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_11(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_10$1(ctx) {
  let spinner;
  let current;
  spinner = new Spinner({ props: { class: "text-white" } });
  return {
    c() {
      create_component(spinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spinner, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spinner, detaching);
    }
  };
}
function create_if_block_9$2(ctx) {
  let div;
  let p;
  let t_value = ctx[8].message + "";
  let t;
  return {
    c() {
      div = element("div");
      p = element("p");
      t = text(t_value);
      attr(p, "class", "text-danger");
      attr(div, "class", "mt-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256 && t_value !== (t_value = ctx2[8].message + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$W(ctx) {
  let div;
  let t;
  let current_block_type_index;
  let if_block1;
  let current;
  let if_block0 = ctx[7] && create_if_block_8$2();
  const if_block_creators = [create_if_block_1$H, create_if_block_2$x, create_if_block_3$q];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[7] && ctx2[5].length === 0)
      return 0;
    if (!ctx2[7] && ctx2[5].length === 1)
      return 1;
    if (!ctx2[7])
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "mt-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[7]) {
        if (if_block0) {
          if (dirty[0] & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8$2();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        } else {
          if_block1 = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_8$2(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_if_block_3$q(ctx) {
  let div1;
  let div0;
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let current_block_type_index;
  let if_block1;
  let t2;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[10] && create_if_block_6$6(ctx);
  let each_value = ctx[11];
  const get_key = (ctx2) => ctx2[25].time;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$r(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$r(key, child_ctx));
  }
  const if_block_creators = [create_if_block_5$c, create_else_block$y];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    var _a, _b, _c;
    if ((_c = (_b = (_a = ctx2[5][0]) == null ? void 0 : _a.summary) == null ? void 0 : _b.change) == null ? void 0 : _c.text)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = !ctx[7] && ctx[5].length === 2 && ctx[14].content_type && create_if_block_4$i(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      attr(div1, "class", "");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      insert(target, t1, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[10]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_6$6(ctx2);
          if_block0.c();
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & 2048) {
        each_value = ctx2[11];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$r, null, get_each_context$r);
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(t2.parentNode, t2);
      }
      if (!ctx2[7] && ctx2[5].length === 2 && ctx2[14].content_type) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 16544) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4$i(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (detaching)
        detach(t1);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function create_if_block_2$x(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Only one item found. Select an item from Change History having previous data\n              as\n              well.";
      attr(p, "class", "text-danger-emphasis");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_1$H(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "No data found. Select the monitor and an item from change history for\n              comparison.";
      attr(p, "class", "text-danger-emphasis");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_if_block_6$6(ctx) {
  let div;
  let p;
  let t0_value = (ctx[10].message || ctx[10].msg) + "";
  let t0;
  let t1;
  let if_block = ctx[10].reason && create_if_block_7$5(ctx);
  return {
    c() {
      div = element("div");
      p = element("p");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      attr(p, "class", "text-danger");
      attr(div, "class", "mt-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t0);
      append(div, t1);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t0_value !== (t0_value = (ctx2[10].message || ctx2[10].msg) + ""))
        set_data(t0, t0_value);
      if (ctx2[10].reason) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_7$5(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_7$5(ctx) {
  let p;
  let t_value = ctx[10].reason + "";
  let t;
  return {
    c() {
      p = element("p");
      t = text(t_value);
      attr(p, "class", "text-danger");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && t_value !== (t_value = ctx2[10].reason + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_each_block$r(key_1, ctx) {
  let div2;
  let div0;
  let span0;
  let t1;
  let span1;
  let t3;
  let span2;
  let t4_value = ctx[25].time.toLocaleString() + "";
  let t4;
  let t5;
  let div1;
  let summaryresponsetable;
  let t6;
  let current;
  summaryresponsetable = new SummaryResponseTable({
    props: {
      root: ctx[25].result.summaryResponse
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      div2 = element("div");
      div0 = element("div");
      span0 = element("span");
      span0.textContent = "Change Summary Result";
      t1 = space();
      span1 = element("span");
      span1.textContent = "-";
      t3 = space();
      span2 = element("span");
      t4 = text(t4_value);
      t5 = space();
      div1 = element("div");
      create_component(summaryresponsetable.$$.fragment);
      t6 = space();
      attr(span0, "class", "fw-lighter ttu");
      set_style(span0, "font-size", "0.8rem");
      attr(span1, "class", "mx-1");
      attr(span2, "class", "fw-lighter ttu");
      set_style(span2, "font-size", "0.75rem");
      attr(div0, "class", "d-flex p-1 items-center");
      set_style(div0, "backdrop-filter", "brightness(96%)");
      attr(div1, "class", "p-1");
      attr(div2, "class", "x-callout x-callout-info mt-2 p-0");
      this.first = div2;
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span0);
      append(div0, t1);
      append(div0, span1);
      append(div0, t3);
      append(div0, span2);
      append(span2, t4);
      append(div2, t5);
      append(div2, div1);
      mount_component(summaryresponsetable, div1, null);
      append(div2, t6);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & 2048) && t4_value !== (t4_value = ctx[25].time.toLocaleString() + ""))
        set_data(t4, t4_value);
      const summaryresponsetable_changes = {};
      if (dirty[0] & 2048)
        summaryresponsetable_changes.root = ctx[25].result.summaryResponse;
      summaryresponsetable.$set(summaryresponsetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(summaryresponsetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(summaryresponsetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(summaryresponsetable);
    }
  };
}
function create_else_block$y(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "No change summary found for the selected data.";
      attr(div, "class", "x-callout x-callout-warning p-2 mt-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_5$c(ctx) {
  let div2;
  let div0;
  let t1;
  let div1;
  let summaryresponsetable;
  let current;
  summaryresponsetable = new SummaryResponseTable({
    props: {
      root: _.omit(ctx[5][0].summary, "change")
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<span class="fw-lighter ttu" style="font-size: 0.8rem; ">Current Change Summary</span>`;
      t1 = space();
      div1 = element("div");
      create_component(summaryresponsetable.$$.fragment);
      attr(div0, "class", "d-flex p-1 items-center");
      set_style(div0, "backdrop-filter", "brightness(96%)");
      attr(div1, "class", "p-1");
      attr(div2, "class", "x-callout x-callout-info mt-2 p-0");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      mount_component(summaryresponsetable, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const summaryresponsetable_changes = {};
      if (dirty[0] & 32)
        summaryresponsetable_changes.root = _.omit(ctx2[5][0].summary, "change");
      summaryresponsetable.$set(summaryresponsetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(summaryresponsetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(summaryresponsetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(summaryresponsetable);
    }
  };
}
function create_if_block_4$i(ctx) {
  let sievedata;
  let current;
  sievedata = new SieveData({
    props: {
      selectedDiffContentMode: C$1.DIFF_MODE_TEXT,
      showSummary: false,
      iframeStyle: "",
      showDiffStats: true,
      showDiffOptions: false,
      sieve: ctx[3],
      oldData: ctx[5][1],
      data: ctx[5][0]
    }
  });
  return {
    c() {
      create_component(sievedata.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sievedata, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sievedata_changes = {};
      if (dirty[0] & 8)
        sievedata_changes.sieve = ctx2[3];
      if (dirty[0] & 32)
        sievedata_changes.oldData = ctx2[5][1];
      if (dirty[0] & 32)
        sievedata_changes.data = ctx2[5][0];
      sievedata.$set(sievedata_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sievedata.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievedata.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sievedata, detaching);
    }
  };
}
function create_fragment$1H(ctx) {
  let div0;
  let switch_1;
  let t0;
  let div12;
  let div6;
  let h50;
  let t2;
  let div3;
  let t3;
  let div2;
  let div1;
  let t4;
  let button0;
  let t6;
  let div5;
  let t13;
  let div11;
  let h51;
  let t15;
  let div10;
  let div9;
  let div7;
  let p0;
  let t17;
  let selectmonitor;
  let t18;
  let previous_key = ctx[0];
  let t19;
  let div8;
  let p1;
  let t21;
  let button1;
  let span;
  let t23;
  let button1_disabled_value;
  let t24;
  let t25;
  let current;
  let mounted;
  let dispose;
  switch_1 = new Switch({
    props: {
      field: ctx[2].fields.enabled,
      $$slots: { default: [create_default_slot$N] },
      $$scope: { ctx }
    }
  });
  let each_value_1 = ctx[12];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  selectmonitor = new SelectMonitor({
    props: {
      id: ctx[0],
      strategy: "fixed"
    }
  });
  selectmonitor.$on("select", ctx[17]);
  let key_block = create_key_block$3(ctx);
  let if_block0 = ctx[9] && create_if_block_10$1();
  let if_block1 = ctx[8] && create_if_block_9$2(ctx);
  let if_block2 = ctx[6] && create_if_block$W(ctx);
  return {
    c() {
      div0 = element("div");
      create_component(switch_1.$$.fragment);
      t0 = space();
      div12 = element("div");
      div6 = element("div");
      h50 = element("h5");
      h50.textContent = "Fields";
      t2 = space();
      div3 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      t4 = space();
      button0 = element("button");
      button0.innerHTML = `<i class="fa fa-plus" aria-hidden="true"></i>
          New Field`;
      t6 = space();
      div5 = element("div");
      div5.innerHTML = `Fields can be created to extract specific information from the changes. Summary is one of the default field
      created
      by Distill. You can add more fields with custom names and types. The prompt from the fields is used by the model
      to
      extract information. The prompt should be as specific as possible to guide the model to get accurate results.
      <div class="mt-2">For example, you can create fields such as <code>important</code> to figure if it is an important change or
        <code>price</code>
        to get the price from the content.</div>`;
      t13 = space();
      div11 = element("div");
      h51 = element("h5");
      h51.textContent = "Test";
      t15 = space();
      div10 = element("div");
      div9 = element("div");
      div7 = element("div");
      p0 = element("p");
      p0.textContent = "Select Monitor";
      t17 = space();
      create_component(selectmonitor.$$.fragment);
      t18 = space();
      key_block.c();
      t19 = space();
      div8 = element("div");
      p1 = element("p");
      p1.textContent = "\xA0";
      t21 = space();
      button1 = element("button");
      span = element("span");
      span.textContent = "Test";
      t23 = space();
      if (if_block0)
        if_block0.c();
      t24 = space();
      if (if_block1)
        if_block1.c();
      t25 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "d-flex align-items-center gap-2 mb-2");
      attr(h50, "class", "ps-2");
      attr(div1, "class", "ms-auto");
      attr(button0, "class", "ms-auto btn btn-outline-secondary btn-sm");
      attr(div2, "class", "mt-1 d-flex");
      attr(div3, "class", "");
      toggle_class(div3, "opacity-25", !ctx[13]);
      toggle_class(div3, "pe-none", !ctx[13]);
      attr(div5, "class", "x-callout");
      attr(div6, "class", "col-5 p-1 overflow-auto h-100");
      attr(p0, "class", "help ms-1");
      attr(p1, "class", "help ms-1");
      attr(button1, "class", "btn btn-sm btn-success d-flex gap-1 align-items-center align-self-baseline");
      button1.disabled = button1_disabled_value = ctx[9] || !ctx[4];
      toggle_class(button1, "disabled", ctx[9] || !ctx[4]);
      toggle_class(button1, "cursor-not-allowed", ctx[9] || !ctx[4]);
      attr(div8, "class", "d-flex flex-column");
      attr(div9, "class", "d-flex gap-1");
      attr(div10, "class", "");
      attr(div11, "class", "col-7 pe-1 overflow-auto h-100");
      toggle_class(div11, "opacity-25", !ctx[13]);
      toggle_class(div11, "pe-none", !ctx[13]);
      attr(div12, "class", "d-flex position-absolute");
      set_style(div12, "top", "60px");
      set_style(div12, "bottom", "0");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(switch_1, div0, null);
      insert(target, t0, anchor);
      insert(target, div12, anchor);
      append(div12, div6);
      append(div6, h50);
      append(div6, t2);
      append(div6, div3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div3, null);
        }
      }
      append(div3, t3);
      append(div3, div2);
      append(div2, div1);
      append(div2, t4);
      append(div2, button0);
      append(div6, t6);
      append(div6, div5);
      append(div12, t13);
      append(div12, div11);
      append(div11, h51);
      append(div11, t15);
      append(div11, div10);
      append(div10, div9);
      append(div9, div7);
      append(div7, p0);
      append(div7, t17);
      mount_component(selectmonitor, div7, null);
      append(div9, t18);
      key_block.m(div9, null);
      append(div9, t19);
      append(div9, div8);
      append(div8, p1);
      append(div8, t21);
      append(div8, button1);
      append(button1, span);
      append(button1, t23);
      if (if_block0)
        if_block0.m(button1, null);
      append(div10, t24);
      if (if_block1)
        if_block1.m(div10, null);
      append(div10, t25);
      if (if_block2)
        if_block2.m(div10, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[22]),
          listen(button1, "click", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const switch_1_changes = {};
      if (dirty[0] & 4)
        switch_1_changes.field = ctx2[2].fields.enabled;
      if (dirty[1] & 1) {
        switch_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      switch_1.$set(switch_1_changes);
      if (dirty[0] & 69636) {
        each_value_1 = ctx2[12];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$5(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div3, t3);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!current || dirty[0] & 8192) {
        toggle_class(div3, "opacity-25", !ctx2[13]);
      }
      if (!current || dirty[0] & 8192) {
        toggle_class(div3, "pe-none", !ctx2[13]);
      }
      const selectmonitor_changes = {};
      if (dirty[0] & 1)
        selectmonitor_changes.id = ctx2[0];
      selectmonitor.$set(selectmonitor_changes);
      if (dirty[0] & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$3(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div9, t19);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (ctx2[9]) {
        if (if_block0) {
          if (dirty[0] & 512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_10$1();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(button1, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 528 && button1_disabled_value !== (button1_disabled_value = ctx2[9] || !ctx2[4])) {
        button1.disabled = button1_disabled_value;
      }
      if (!current || dirty[0] & 528) {
        toggle_class(button1, "disabled", ctx2[9] || !ctx2[4]);
      }
      if (!current || dirty[0] & 528) {
        toggle_class(button1, "cursor-not-allowed", ctx2[9] || !ctx2[4]);
      }
      if (ctx2[8]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_9$2(ctx2);
          if_block1.c();
          if_block1.m(div10, t25);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[6]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$W(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div10, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 8192) {
        toggle_class(div11, "opacity-25", !ctx2[13]);
      }
      if (!current || dirty[0] & 8192) {
        toggle_class(div11, "pe-none", !ctx2[13]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(switch_1.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(selectmonitor.$$.fragment, local);
      transition_in(key_block);
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(switch_1.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(selectmonitor.$$.fragment, local);
      transition_out(key_block);
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(switch_1);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div12);
      destroy_each(each_blocks, detaching);
      destroy_component(selectmonitor);
      key_block.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1E($$self, $$props, $$invalidate) {
  let $summaryEnabledField;
  let $sieveModel, $$unsubscribe_sieveModel = noop$1, $$subscribe_sieveModel = () => ($$unsubscribe_sieveModel(), $$unsubscribe_sieveModel = subscribe(sieveModel, ($$value) => $$invalidate(14, $sieveModel = $$value)), sieveModel);
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieveModel());
  let { sieveId = void 0 } = $$props;
  let { sieveDataId = void 0 } = $$props;
  let sieveModel = void 0;
  $$subscribe_sieveModel();
  let selectedSieveData = void 0;
  let sieveDataToCompareAgainst = void 0;
  let sieveDataList = [];
  let isFirstSieveDataFetchDone = false;
  let isFetchingSieveData = false;
  let errorWhileFetchingSieveData = void 0;
  let isSummarizing = false;
  let errorWhileSummarizing = void 0;
  let summaryResults = [];
  let { summaryConfigurationFormModel } = $$props;
  if (!summaryConfigurationFormModel.fields.params || summaryConfigurationFormModel.fields.params.fields.length === 0) {
    summaryConfigurationFormModel.fields.params.add();
  }
  let allParams = summaryConfigurationFormModel.fields.params.fields;
  function addParam() {
    summaryConfigurationFormModel.fields.params.add({
      name: "",
      type: "string",
      description: void 0
    });
    $$invalidate(12, allParams = summaryConfigurationFormModel.fields.params.fields);
  }
  function removeParam(e) {
    const index2 = e.detail.index;
    summaryConfigurationFormModel.fields.params.remove(index2);
    $$invalidate(12, allParams = summaryConfigurationFormModel.fields.params.fields);
  }
  async function onSieveSelection(e) {
    if (e.detail !== sieveId) {
      $$invalidate(1, sieveDataId = void 0);
    }
    $$invalidate(0, sieveId = e.detail);
    $$invalidate(11, summaryResults = []);
    $$subscribe_sieveModel($$invalidate(3, sieveModel = new Model$2.Sieve({ id: sieveId })));
    await sieveModel.fetch();
  }
  function onSieveDataSelection(e) {
    selectedSieveData = e.detail.selectedSieveData;
    const allSieveData = e.detail.allSieveData;
    const index2 = allSieveData.findIndex((sieveData) => sieveData.id === selectedSieveData.id);
    if (index2 !== -1) {
      $$invalidate(4, sieveDataToCompareAgainst = allSieveData[index2 + 1]);
    } else {
      $$invalidate(4, sieveDataToCompareAgainst = void 0);
    }
    fetchSieveDataList();
  }
  async function fetchSieveDataList() {
    $$invalidate(6, isFirstSieveDataFetchDone = true);
    $$invalidate(7, isFetchingSieveData = true);
    $$invalidate(8, errorWhileFetchingSieveData = void 0);
    try {
      if (!sieveId) {
        return;
      }
      const selectedIds = [];
      if (selectedSieveData) {
        selectedIds.push(selectedSieveData.id);
      } else {
        throw new Error("No selected data from change history");
      }
      if (sieveDataToCompareAgainst) {
        selectedIds.push(sieveDataToCompareAgainst.id);
      } else {
        throw new Error("No data to compare against. Please select an item from change history having previous data as well.");
      }
      const query = {
        _opt: { limit: 2, order: ["-ts"] },
        "id.in": selectedIds
      };
      let res = await Api.api(`/sieves/${sieveId}/data`, "GET", query);
      $$invalidate(5, sieveDataList = res.data);
      for (let i2 = 0; i2 < sieveDataList.length; i2++) {
        const sieveData = sieveDataList[i2];
        if (!sieveData.summary) {
          sieveData.summary = {};
        }
        if (!sieveData.summary.change) {
          sieveData.summary.change = {};
        }
        if (sieveData.summary.change.text) {
          sieveData.summary.change_summary = sieveData.summary.change.text;
        }
      }
    } catch (e) {
      console.error("error while fetching the sieve data", e);
      $$invalidate(8, errorWhileFetchingSieveData = e);
    } finally {
      $$invalidate(7, isFetchingSieveData = false);
    }
  }
  async function summarizeNow() {
    var _a;
    $$invalidate(9, isSummarizing = true);
    $$invalidate(10, errorWhileSummarizing = null);
    try {
      Msg.reset();
      const res = await Api.utils(`/summary/${sieveId}/change-summary`, "POST", {
        newSieveDataId: selectedSieveData.id,
        oldSieveDataId: sieveDataToCompareAgainst.id,
        summaryParams: ((_a = summaryConfigurationFormModel.toJSON()) == null ? void 0 : _a.params) || []
      });
      summaryResults.unshift({ time: new Date(), result: res });
      $$invalidate(11, summaryResults = [...summaryResults]);
    } catch (e) {
      console.error("error while summarizing", e);
      $$invalidate(10, errorWhileSummarizing = e);
      Msg.error(e.msg || e.message);
    } finally {
      $$invalidate(9, isSummarizing = false);
    }
  }
  const summaryEnabledField = summaryConfigurationFormModel.fields.enabled;
  component_subscribe($$self, summaryEnabledField, (value) => $$invalidate(13, $summaryEnabledField = value));
  const remove_handler = (e) => removeParam(e);
  const click_handler = () => addParam();
  $$self.$$set = ($$props2) => {
    if ("sieveId" in $$props2)
      $$invalidate(0, sieveId = $$props2.sieveId);
    if ("sieveDataId" in $$props2)
      $$invalidate(1, sieveDataId = $$props2.sieveDataId);
    if ("summaryConfigurationFormModel" in $$props2)
      $$invalidate(2, summaryConfigurationFormModel = $$props2.summaryConfigurationFormModel);
  };
  return [
    sieveId,
    sieveDataId,
    summaryConfigurationFormModel,
    sieveModel,
    sieveDataToCompareAgainst,
    sieveDataList,
    isFirstSieveDataFetchDone,
    isFetchingSieveData,
    errorWhileFetchingSieveData,
    isSummarizing,
    errorWhileSummarizing,
    summaryResults,
    allParams,
    $summaryEnabledField,
    $sieveModel,
    addParam,
    removeParam,
    onSieveSelection,
    onSieveDataSelection,
    summarizeNow,
    summaryEnabledField,
    remove_handler,
    click_handler
  ];
}
class Params extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$1E,
      create_fragment$1H,
      safe_not_equal,
      {
        sieveId: 0,
        sieveDataId: 1,
        summaryConfigurationFormModel: 2
      },
      null,
      [-1, -1]
    );
  }
}
function create_catch_block$k(ctx) {
  let p;
  let t0;
  let t1_value = ctx[14].message + "";
  let t1;
  return {
    c() {
      p = element("p");
      t0 = text("Cannot fetch the summary configurations: ");
      t1 = text(t1_value);
      attr(p, "class", "text-danger");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_then_block$k(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "AI Summary Settings",
      bodyStyle: "position: relative",
      disableSave: ctx[2],
      onSave: ctx[5],
      modalDialogClasses: "modal-fullscreen",
      $$slots: {
        default: [create_default_slot$M],
        "sub-header": [create_sub_header_slot],
        header: [create_header_slot$b]
      },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[6]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 4)
        savemodal_changes.disableSave = ctx2[2];
      if (dirty & 32779) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_header_slot$b(ctx) {
  let t;
  return {
    c() {
      t = text("AI Summary Settings");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_sub_header_slot(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `Distill uses LLMs to summarize the monitored content. The summary is a set of fields that are shown in change
        history and alerts. <a href="https://distill.io/docs/web-monitor/ai-change-summary/">Learn More</a>`;
      attr(div, "class", "help");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$M(ctx) {
  let params2;
  let current;
  params2 = new Params({
    props: {
      sieveId: ctx[0],
      sieveDataId: ctx[1],
      summaryConfigurationFormModel: ctx[3]
    }
  });
  return {
    c() {
      create_component(params2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(params2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const params_changes = {};
      if (dirty & 1)
        params_changes.sieveId = ctx2[0];
      if (dirty & 2)
        params_changes.sieveDataId = ctx2[1];
      if (dirty & 8)
        params_changes.summaryConfigurationFormModel = ctx2[3];
      params2.$set(params_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(params2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(params2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(params2, detaching);
    }
  };
}
function create_pending_block$k(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$1G(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$k,
    then: create_then_block$k,
    catch: create_catch_block$k,
    value: 13,
    error: 14,
    blocks: [, , ,]
  };
  handle_promise(ctx[4](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$1D($$self, $$props, $$invalidate) {
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(8, $route = $$value));
  let { sieveId } = $$props;
  let { sieveDataId } = $$props;
  const team = $route.team;
  const dispatch = createEventDispatcher();
  let disableSave = false;
  const user = getContext("user");
  let summaryConfiguration = void 0;
  let summaryConfigurationFormModel;
  async function fetchSummaryConfigurations() {
    var _a;
    try {
      summaryConfiguration = user.getPref("summary", { groupId: team });
      if (!summaryConfiguration) {
        summaryConfiguration = { enabled: false, params: [] };
      }
      if (!summaryConfiguration.params) {
        summaryConfiguration.params = [];
      }
      if (!summaryConfiguration.params.find((p) => p.name === "change_summary")) {
        summaryConfiguration.params.unshift({
          name: "change_summary",
          type: "string",
          description: void 0
        });
      }
      if (!summaryConfiguration.params.find((p) => p.name === "important")) {
        let paramImportant;
        try {
          const defaultParamsResponse = await Api.utils("/summary/params");
          paramImportant = (_a = defaultParamsResponse == null ? void 0 : defaultParamsResponse.params) == null ? void 0 : _a.find((p) => p.name === "important");
        } catch (e) {
          console.error("error while fetching the default summary params", e);
          paramImportant = void 0;
        }
        summaryConfiguration.params.push({
          name: "important",
          type: "boolean",
          description: paramImportant == null ? void 0 : paramImportant.description
        });
      }
      $$invalidate(3, summaryConfigurationFormModel = new SummaryConfigurationFormModel(structuredClone(summaryConfiguration)));
      const outerFormError = summaryConfigurationFormModel.error;
      outerFormError.subscribe((err) => {
        $$invalidate(2, disableSave = !!err);
      });
    } catch (e) {
      console.error("error while fetching the summary configurations", e);
      Msg.error("Failed to fetch the summary configurations");
      throw e;
    }
  }
  onMount(() => {
  });
  function close() {
    dispatch("close");
  }
  async function save() {
    let allParamsAreValid = true;
    outer:
      for (let i2 = 0; i2 < summaryConfigurationFormModel.fields.params.fields.length; i2++) {
        const summaryParamFormModel = summaryConfigurationFormModel.fields.params.fields[i2];
        const value = summaryParamFormModel.toJSON();
        let err = summaryParamFormModel.fields.name.validate(value.name);
        if (err) {
          allParamsAreValid = false;
          break outer;
        }
        err = summaryParamFormModel.fields.type.validate(value.type);
        if (err) {
          allParamsAreValid = false;
          break outer;
        }
        err = summaryParamFormModel.fields.description.validate(value.description);
        if (err) {
          allParamsAreValid = false;
          break outer;
        }
      }
    if (allParamsAreValid) {
      try {
        const data = summaryConfigurationFormModel.toJSON();
        Msg.info("Saving");
        user.setSummaryPrefs(data, { groupId: team || "0" });
        let currentSummaryPrefs = user.getPref("summary", { groupId: team }) || { enabled: false };
        await Api.api("/prefs/summary", "PUT", currentSummaryPrefs);
        close();
        Msg.reset();
      } catch (e) {
        console.error("error while saving the summary configurations", e);
        Msg.error("Failed to update the summary configurations");
      }
    } else {
      Msg.error("Please fill all the required fields");
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieveId" in $$props2)
      $$invalidate(0, sieveId = $$props2.sieveId);
    if ("sieveDataId" in $$props2)
      $$invalidate(1, sieveDataId = $$props2.sieveDataId);
  };
  return [
    sieveId,
    sieveDataId,
    disableSave,
    summaryConfigurationFormModel,
    fetchSummaryConfigurations,
    save,
    close_handler
  ];
}
class SummaryConfigurationModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1D, create_fragment$1G, safe_not_equal, { sieveId: 0, sieveDataId: 1 });
  }
}
var SummaryContainer_svelte_svelte_type_style_lang = "";
function create_if_block_10(ctx) {
  let div3;
  let div1;
  let div0;
  let span;
  let t0;
  let t1;
  let div2;
  let t2;
  let a;
  let t4;
  let button;
  let div3_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text(ctx[3]);
      t1 = space();
      div2 = element("div");
      t2 = text("Summary can be generated.\n      ");
      a = element("a");
      a.textContent = "Learn More";
      t4 = space();
      button = element("button");
      button.textContent = "Dismiss";
      attr(span, "class", "fw-lighter ttu");
      set_style(span, "font-size", "0.8rem");
      attr(div0, "class", "flex align-items-center");
      attr(div1, "class", "d-flex w-full p-1");
      set_style(div1, "backdrop-filter", "brightness(96%)");
      attr(a, "href", "https://distill.io/docs/web-monitor/ai-change-summary/");
      attr(a, "class", "link link-secondary link-underline link-underline-secondary");
      attr(a, "target", "_blank");
      attr(button, "class", "ms-1 btn btn-sm btn-default px-1 py-1 bg-body");
      set_style(button, "font-size", "0.80rem");
      attr(div2, "class", "mt-1 p-1");
      attr(div3, "class", div3_class_value = "summary-container x-callout " + ctx[4]);
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      append(div0, span);
      append(span, t0);
      append(div3, t1);
      append(div3, div2);
      append(div2, t2);
      append(div2, a);
      append(div2, t4);
      append(div2, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[19]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8)
        set_data(t0, ctx2[3]);
      if (dirty[0] & 16 && div3_class_value !== (div3_class_value = "summary-container x-callout " + ctx2[4])) {
        attr(div3, "class", div3_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div3);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$b(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_6$5, create_if_block_9$1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (show_if == null)
      show_if = !!ctx2[14]();
    if (show_if)
      return 0;
    if (ctx2[5])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1$G(ctx) {
  let div3;
  let div1;
  let div0;
  let span;
  let t0;
  let t1;
  let t2;
  let t3;
  let div2;
  let previous_key = ctx[0];
  let div3_class_value;
  let t4;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[2] && create_if_block_4$h();
  let if_block1 = ctx[1] && create_if_block_3$p(ctx);
  let key_block = create_key_block$2(ctx);
  let if_block2 = ctx[8] && create_if_block_2$w(ctx);
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text(ctx[3]);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      div2 = element("div");
      key_block.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      attr(span, "class", "fw-lighter ttu");
      set_style(span, "font-size", "0.8rem");
      attr(div0, "class", "flex align-items-center");
      attr(div1, "class", "d-flex w-full p-1");
      set_style(div1, "backdrop-filter", "brightness(96%)");
      attr(div2, "class", "whitespace-pre-line mt-1 p-1");
      attr(div3, "class", div3_class_value = "summary-container x-callout x-callout-info " + ctx[4] + " svelte-1gguxlz");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      append(div0, span);
      append(span, t0);
      append(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      append(div3, t3);
      append(div3, div2);
      key_block.m(div2, null);
      insert(target, t4, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & 8)
        set_data(t0, ctx2[3]);
      if (ctx2[2]) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_4$h();
          if_block0.c();
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$p(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty[0] & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$2(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div2, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (!current || dirty[0] & 16 && div3_class_value !== (div3_class_value = "summary-container x-callout x-callout-info " + ctx2[4] + " svelte-1gguxlz")) {
        attr(div3, "class", div3_class_value);
      }
      if (ctx2[8]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$w(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(key_block);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      transition_out(key_block);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      key_block.d(detaching);
      if (detaching)
        detach(t4);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function create_if_block_9$1(ctx) {
  let div3;
  let div1;
  let div0;
  let span;
  let t0;
  let t1;
  let div2;
  let t2;
  let a;
  let t4;
  let button;
  let div3_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text(ctx[3]);
      t1 = space();
      div2 = element("div");
      t2 = text("Summary cannot be generated for this change.\n        ");
      a = element("a");
      a.textContent = "Learn More";
      t4 = space();
      button = element("button");
      button.textContent = "Dismiss";
      attr(span, "class", "fw-lighter ttu");
      set_style(span, "font-size", "0.8rem");
      attr(div0, "class", "flex align-items-center");
      attr(div1, "class", "d-flex w-full p-1");
      set_style(div1, "backdrop-filter", "brightness(96%)");
      attr(a, "href", "https://distill.io/docs/web-monitor/ai-change-summary/#when-do-monitors-record-ai-summaries");
      attr(a, "class", "link link-secondary link-underline link-underline-secondary");
      attr(a, "target", "_blank");
      attr(button, "class", "ms-1 btn btn-sm btn-default px-1 py-1 bg-body");
      set_style(button, "font-size", "0.80rem");
      attr(div2, "class", "mt-1 p-1");
      attr(div3, "class", div3_class_value = "summary-container x-callout " + ctx[4]);
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      append(div0, span);
      append(span, t0);
      append(div3, t1);
      append(div3, div2);
      append(div2, t2);
      append(div2, a);
      append(div2, t4);
      append(div2, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[18]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8)
        set_data(t0, ctx2[3]);
      if (dirty[0] & 16 && div3_class_value !== (div3_class_value = "summary-container x-callout " + ctx2[4])) {
        attr(div3, "class", div3_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div3);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_6$5(ctx) {
  let div4;
  let div1;
  let div0;
  let span;
  let t0;
  let t1;
  let div3;
  let div2;
  let t3;
  let button;
  let t4;
  let t5;
  let div4_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[10] && create_if_block_8$1();
  let if_block1 = ctx[11] && create_if_block_7$4(ctx);
  return {
    c() {
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text(ctx[3]);
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      div2.textContent = "This change has not been summarized yet.";
      t3 = space();
      button = element("button");
      t4 = text("Summarize\n          ");
      if (if_block0)
        if_block0.c();
      t5 = space();
      if (if_block1)
        if_block1.c();
      attr(span, "class", "fw-lighter ttu");
      set_style(span, "font-size", "0.8rem");
      attr(div0, "class", "flex align-items-center");
      attr(div1, "class", "d-flex w-full p-1");
      set_style(div1, "backdrop-filter", "brightness(96%)");
      attr(div2, "class", "");
      attr(button, "class", "ms-2 btn btn-sm btn-default py-1 px-1 bg-body");
      button.disabled = ctx[10];
      toggle_class(button, "disabled", ctx[10]);
      attr(div3, "class", "d-flex w-full align-items-center mt-1 p-1");
      attr(div4, "class", div4_class_value = "summary-container x-callout x-callout-warning " + ctx[4]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div1);
      append(div1, div0);
      append(div0, span);
      append(span, t0);
      append(div4, t1);
      append(div4, div3);
      append(div3, div2);
      append(div3, t3);
      append(div3, button);
      append(button, t4);
      if (if_block0)
        if_block0.m(button, null);
      append(div4, t5);
      if (if_block1)
        if_block1.m(div4, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[15]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & 8)
        set_data(t0, ctx2[3]);
      if (ctx2[10]) {
        if (if_block0) {
          if (dirty[0] & 1024) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8$1();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(button, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 1024) {
        button.disabled = ctx2[10];
      }
      if (!current || dirty[0] & 1024) {
        toggle_class(button, "disabled", ctx2[10]);
      }
      if (ctx2[11]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7$4(ctx2);
          if_block1.c();
          if_block1.m(div4, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty[0] & 16 && div4_class_value !== (div4_class_value = "summary-container x-callout x-callout-warning " + ctx2[4])) {
        attr(div4, "class", div4_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_8$1(ctx) {
  let spinner;
  let current;
  spinner = new Spinner({
    props: { class: "ms-2 align-self-center" }
  });
  return {
    c() {
      create_component(spinner.$$.fragment);
    },
    m(target, anchor) {
      mount_component(spinner, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(spinner, detaching);
    }
  };
}
function create_if_block_7$4(ctx) {
  let div;
  let t_value = (ctx[11].message || ctx[11].msg || "Could not summarize the change") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "text-danger mt-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048 && t_value !== (t_value = (ctx2[11].message || ctx2[11].msg || "Could not summarize the change") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4$h(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-question-circle text-secondary"></i>`;
      attr(button, "class", "ms-1 btn btn-sm btn-link p-0");
      attr(button, "tabindex", "0");
      attr(button, "role", "button");
      attr(button, "data-bs-toggle", "popover");
      attr(button, "data-bs-trigger", "focus");
      attr(button, "data-bs-html", "true");
      attr(button, "data-bs-content", "\n                  <div>This is a preview feature.</div>\n                  <a href='https://distill.io/docs/web-monitor/ai-change-summary' target='_blank'>Learn More</a>\n                ");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = action_destroyer(initPopover.call(null, button));
        mounted = true;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3$p(ctx) {
  let div;
  let button;
  let t1;
  let span;
  let onetimeaction0;
  let t2;
  let a;
  let t4;
  let onetimeaction1;
  let t5;
  let onetimeaction2;
  let current;
  let mounted;
  let dispose;
  onetimeaction0 = new OneTimeAction({
    props: {
      oneTimeFn: ctx[15],
      title: "Regenerate",
      $$slots: { default: [create_default_slot_2$8] },
      $$scope: { ctx }
    }
  });
  onetimeaction1 = new OneTimeAction({
    props: {
      oneTimeFn: ctx[16],
      args: [1]
    }
  });
  onetimeaction2 = new OneTimeAction({
    props: {
      oneTimeFn: ctx[16],
      args: [-1],
      $$slots: { default: [create_default_slot_1$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = "Improve";
      t1 = space();
      span = element("span");
      create_component(onetimeaction0.$$.fragment);
      t2 = space();
      a = element("a");
      a.textContent = "Tell us more";
      t4 = space();
      create_component(onetimeaction1.$$.fragment);
      t5 = space();
      create_component(onetimeaction2.$$.fragment);
      attr(button, "class", "btn btn-sm btn-link p-0");
      attr(a, "href", "#");
      attr(a, "class", "btn btn-sm btn-link p-0");
      toggle_class(a, "d-none", !ctx[7]);
      attr(span, "class", "summary-feedback-links d-none svelte-1gguxlz");
      attr(div, "class", "d-flex ms-2 mt-0 gap-2 align-self-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(div, t1);
      append(div, span);
      mount_component(onetimeaction0, span, null);
      append(span, t2);
      append(span, a);
      append(span, t4);
      mount_component(onetimeaction1, span, null);
      append(span, t5);
      mount_component(onetimeaction2, span, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", ctx[23]),
          listen(a, "click", ctx[24])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const onetimeaction0_changes = {};
      if (dirty[1] & 8) {
        onetimeaction0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      onetimeaction0.$set(onetimeaction0_changes);
      if (!current || dirty[0] & 128) {
        toggle_class(a, "d-none", !ctx2[7]);
      }
      const onetimeaction2_changes = {};
      if (dirty[1] & 8) {
        onetimeaction2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      onetimeaction2.$set(onetimeaction2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(onetimeaction0.$$.fragment, local);
      transition_in(onetimeaction1.$$.fragment, local);
      transition_in(onetimeaction2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(onetimeaction0.$$.fragment, local);
      transition_out(onetimeaction1.$$.fragment, local);
      transition_out(onetimeaction2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(onetimeaction0);
      destroy_component(onetimeaction1);
      destroy_component(onetimeaction2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_2$8(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-refresh");
      attr(i2, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_default_slot_1$c(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-thumbs-o-down align-middle");
      set_style(i2, "font-size", "1.3em");
      attr(i2, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_key_block$2(ctx) {
  let summaryresponsetable;
  let current;
  summaryresponsetable = new SummaryResponseTable({
    props: {
      root: _$2.omit(ctx[0].summary, "change")
    }
  });
  return {
    c() {
      create_component(summaryresponsetable.$$.fragment);
    },
    m(target, anchor) {
      mount_component(summaryresponsetable, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const summaryresponsetable_changes = {};
      if (dirty[0] & 1)
        summaryresponsetable_changes.root = _$2.omit(ctx2[0].summary, "change");
      summaryresponsetable.$set(summaryresponsetable_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(summaryresponsetable.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(summaryresponsetable.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(summaryresponsetable, detaching);
    }
  };
}
function create_if_block_2$w(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      isDialog: true,
      title: TXT("l_feedback_form"),
      onSave: ctx[26],
      saveLabel: "Submit",
      $$slots: { default: [create_default_slot$L] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[27]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty[0] & 4097 | dirty[1] & 8) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$L(ctx) {
  var _a, _b;
  let formgroup;
  let updating_model;
  let current;
  function formgroup_model_binding(value) {
    ctx[25](value);
  }
  let formgroup_props = {
    context: {
      scoreOnly: false,
      notes: (_b = (_a = ctx[0]) == null ? void 0 : _a.summary) == null ? void 0 : _b.change_summary
    },
    id: C$1.FORM_CHANGE_SUMMARY
  };
  if (ctx[12] !== void 0) {
    formgroup_props.model = ctx[12];
  }
  formgroup = new FormGroup({ props: formgroup_props });
  binding_callbacks.push(() => bind$1(formgroup, "model", formgroup_model_binding));
  return {
    c() {
      create_component(formgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const formgroup_changes = {};
      if (dirty[0] & 1)
        formgroup_changes.context = {
          scoreOnly: false,
          notes: (_b2 = (_a2 = ctx2[0]) == null ? void 0 : _a2.summary) == null ? void 0 : _b2.change_summary
        };
      if (!updating_model && dirty[0] & 4096) {
        updating_model = true;
        formgroup_changes.model = ctx2[12];
        add_flush_callback(() => updating_model = false);
      }
      formgroup.$set(formgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formgroup, detaching);
    }
  };
}
function create_if_block$V(ctx) {
  let summaryconfigurationmodal;
  let current;
  summaryconfigurationmodal = new SummaryConfigurationModal({
    props: {
      sieveId: ctx[0].sieve_id,
      sieveDataId: ctx[0].id
    }
  });
  summaryconfigurationmodal.$on("close", ctx[28]);
  return {
    c() {
      create_component(summaryconfigurationmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(summaryconfigurationmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const summaryconfigurationmodal_changes = {};
      if (dirty[0] & 1)
        summaryconfigurationmodal_changes.sieveId = ctx2[0].sieve_id;
      if (dirty[0] & 1)
        summaryconfigurationmodal_changes.sieveDataId = ctx2[0].id;
      summaryconfigurationmodal.$set(summaryconfigurationmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(summaryconfigurationmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(summaryconfigurationmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(summaryconfigurationmodal, detaching);
    }
  };
}
function create_fragment$1F(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_1$G, create_if_block_5$b, create_if_block_10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (dirty[0] & 64)
      show_if = null;
    if (((_c = (_b = (_a = ctx2[0]) == null ? void 0 : _a.summary) == null ? void 0 : _b.change) == null ? void 0 : _c.text) || ((_e = (_d = ctx2[0]) == null ? void 0 : _d.summary) == null ? void 0 : _e.change_summary))
      return 0;
    if ((_f = ctx2[13]) == null ? void 0 : _f.enabled)
      return 1;
    if (show_if == null)
      show_if = !!(!((_g = ctx2[13]) == null ? void 0 : _g.enabled) && ctx2[14]() && ctx2[6]);
    if (show_if)
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = ctx[9] && create_if_block$V(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        } else {
          if_block0 = null;
        }
      }
      if (ctx2[9]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$V(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
const LS_DISMISS_CANNOT_SUMMARIZE = "dismiss-cannot-summarize";
const LS_DISMISS_SUMMARY_SUGGESTION = "dismiss-summary-suggestion";
function initPopover(el2) {
  new bootstrap.Popover(el2);
}
function instance$1C($$self, $$props, $$invalidate) {
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(29, $route = $$value));
  const Store2 = window.App.store;
  let showCannotSummarizeMessage = !Store2.get(LS_DISMISS_CANNOT_SUMMARIZE);
  let showSummarySuggestion = !Store2.get(LS_DISMISS_SUMMARY_SUGGESTION);
  let { sieve } = $$props;
  let { content_type } = $$props;
  let { data } = $$props;
  let { oldData } = $$props;
  let { showFeedbackOptions = true } = $$props;
  let { showPreviewNotice = true } = $$props;
  let { title = "AI Change Summary" } = $$props;
  let { class: clazz = "mt-0 mb-1 p-0" } = $$props;
  let showTellUsMore = false;
  let showFeedbackModal = false;
  let showAISummaryConfigModal = false;
  let isSummarizing = false;
  let errorWhileSummarizing = null;
  const user = getContext("user");
  const team = $route.team;
  const summaryConfiguration = user.getPref("summary", { groupId: team });
  let feedbackModel;
  function setupSummaryResult() {
    var _a, _b;
    if (!((_b = (_a = data.summary) == null ? void 0 : _a.change) == null ? void 0 : _b.text)) {
      return;
    }
    if (data.summary.change_summary) {
      return;
    }
    $$invalidate(0, data.summary.change_summary = data.summary.change.text, data);
  }
  function canSummaryBeGenerated() {
    var _a;
    if (!data.text || data.text.length < 200) {
      return false;
    }
    if (![C$1.TYPE_HTML, C$1.TYPE_PDF_HTML, C$1.TYPE_DOC].includes(content_type)) {
      return false;
    }
    if (user.get("constraint") && ((_a = user.get("constraint")) == null ? void 0 : _a.tokens) < 1) {
      return false;
    }
    if (!user.isFlexi()) {
      return false;
    }
    return oldData.id !== data.id;
  }
  async function summarizeNow() {
    $$invalidate(10, isSummarizing = true);
    $$invalidate(11, errorWhileSummarizing = null);
    try {
      const res = await Api.utils(`/summary/${sieve.id}/change-summary`, "POST", {
        newSieveDataId: data.id,
        oldSieveDataId: oldData.id,
        save: true
      });
      $$invalidate(0, data.summary = res.summaryResponse, data);
      setupSummaryResult();
      $$invalidate(0, data);
    } catch (e) {
      console.error("error while summarizing", e);
      $$invalidate(11, errorWhileSummarizing = e);
    } finally {
      $$invalidate(10, isSummarizing = false);
    }
  }
  async function submitFeedbackWithOnlyScore(score) {
    $$invalidate(7, showTellUsMore = true);
    const feedbackFormModel = new FormGroupModel(C$1.FORM_CHANGE_SUMMARY, { scoreOnly: true });
    feedbackFormModel.forms["score"].fields["score"].set(score);
    try {
      await feedbackFormModel.submit({ sieve_data_id: data.id });
    } catch (e) {
      console.error("error while validating/submitting the form", e);
    }
    if (score === -1) {
      $$invalidate(8, showFeedbackModal = true);
    }
  }
  async function onFeedbackFormSave() {
    let doc = { sieve_data_id: data.id };
    try {
      await feedbackModel.submit(doc);
      $$invalidate(8, showFeedbackModal = false);
    } catch (e) {
      console.error("error while validating/submitting the form", e);
    }
  }
  function dismissCannotSummarize() {
    Store2.set(LS_DISMISS_CANNOT_SUMMARIZE, true);
    $$invalidate(5, showCannotSummarizeMessage = false);
  }
  function dismissSummarySuggestion() {
    Store2.set(LS_DISMISS_SUMMARY_SUGGESTION, true);
    $$invalidate(6, showSummarySuggestion = false);
  }
  setupSummaryResult();
  const click_handler = () => {
    $$invalidate(9, showAISummaryConfigModal = true);
  };
  const click_handler_1 = (e) => {
    $$invalidate(8, showFeedbackModal = true);
  };
  function formgroup_model_binding(value) {
    feedbackModel = value;
    $$invalidate(12, feedbackModel);
  }
  const func2 = () => onFeedbackFormSave();
  const close_handler = () => {
    $$invalidate(8, showFeedbackModal = false);
  };
  const close_handler_1 = () => $$invalidate(9, showAISummaryConfigModal = false);
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$invalidate(20, sieve = $$props2.sieve);
    if ("content_type" in $$props2)
      $$invalidate(21, content_type = $$props2.content_type);
    if ("data" in $$props2)
      $$invalidate(0, data = $$props2.data);
    if ("oldData" in $$props2)
      $$invalidate(22, oldData = $$props2.oldData);
    if ("showFeedbackOptions" in $$props2)
      $$invalidate(1, showFeedbackOptions = $$props2.showFeedbackOptions);
    if ("showPreviewNotice" in $$props2)
      $$invalidate(2, showPreviewNotice = $$props2.showPreviewNotice);
    if ("title" in $$props2)
      $$invalidate(3, title = $$props2.title);
    if ("class" in $$props2)
      $$invalidate(4, clazz = $$props2.class);
  };
  return [
    data,
    showFeedbackOptions,
    showPreviewNotice,
    title,
    clazz,
    showCannotSummarizeMessage,
    showSummarySuggestion,
    showTellUsMore,
    showFeedbackModal,
    showAISummaryConfigModal,
    isSummarizing,
    errorWhileSummarizing,
    feedbackModel,
    summaryConfiguration,
    canSummaryBeGenerated,
    summarizeNow,
    submitFeedbackWithOnlyScore,
    onFeedbackFormSave,
    dismissCannotSummarize,
    dismissSummarySuggestion,
    sieve,
    content_type,
    oldData,
    click_handler,
    click_handler_1,
    formgroup_model_binding,
    func2,
    close_handler,
    close_handler_1
  ];
}
class SummaryContainer extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$1C,
      create_fragment$1F,
      safe_not_equal,
      {
        sieve: 20,
        content_type: 21,
        data: 0,
        oldData: 22,
        showFeedbackOptions: 1,
        showPreviewNotice: 2,
        title: 3,
        class: 4
      },
      null,
      [-1, -1]
    );
  }
}
function create_if_block_9(ctx) {
  let div;
  let a;
  let i2;
  let t0;
  let t1_value = ctx[22].format("hh:mm A") + "";
  let t1;
  let t2;
  let menu;
  let current;
  let mounted;
  let dispose;
  menu = new Menu({
    props: {
      $$slots: {
        default: [create_default_slot$K],
        action: [
          create_action_slot$c,
          ({ onClick }) => ({ 63: onClick }),
          ({ onClick }) => [0, 0, onClick ? 2 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      a = element("a");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      create_component(menu.$$.fragment);
      attr(i2, "class", "fa f4");
      toggle_class(i2, "fa-caret-down", ctx[16]);
      toggle_class(i2, "fa-caret-right", !ctx[16]);
      attr(a, "href", "#");
      attr(div, "class", "mr-[10px]");
      attr(div, "title", ctx[22].format());
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(a, i2);
      append(a, t0);
      append(a, t1);
      append(div, t2);
      mount_component(menu, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[24]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & 65536) {
        toggle_class(i2, "fa-caret-down", ctx2[16]);
      }
      if (!current || dirty[0] & 65536) {
        toggle_class(i2, "fa-caret-right", !ctx2[16]);
      }
      const menu_changes = {};
      if (dirty[0] & 4096 | dirty[2] & 6) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(menu);
      mounted = false;
      dispose();
    }
  };
}
function create_action_slot$c(ctx) {
  let a;
  let i2;
  let t0;
  let t1_value = ctx[22].format("MMM DD") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fa fa-caret-down f4");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i2);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", function() {
          if (is_function(ctx[63]))
            ctx[63].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$K(ctx) {
  let li;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      li.textContent = `${TXT("Email")}`;
      attr(li, "class", "dropdown-item");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (!mounted) {
        dispose = listen(li, "click", ctx[25]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_7$3(ctx) {
  let diffbar;
  let updating_additions;
  let updating_deletions;
  let updating_updations;
  let updating_removed;
  let updating_snipped;
  let updating_withStyle;
  let t;
  let if_block_anchor;
  let current;
  function diffbar_additions_binding(value) {
    ctx[26](value);
  }
  function diffbar_deletions_binding(value) {
    ctx[27](value);
  }
  function diffbar_updations_binding(value) {
    ctx[28](value);
  }
  function diffbar_removed_binding(value) {
    ctx[29](value);
  }
  function diffbar_snipped_binding(value) {
    ctx[30](value);
  }
  function diffbar_withStyle_binding(value) {
    ctx[31](value);
  }
  let diffbar_props = {
    sieve: ctx[3],
    exploreDiffPath: ctx[20],
    model: ctx[14],
    oldModel: ctx[15],
    selectedDiffContentMode: ctx[0]
  };
  if (ctx[8] !== void 0) {
    diffbar_props.additions = ctx[8];
  }
  if (ctx[9] !== void 0) {
    diffbar_props.deletions = ctx[9];
  }
  if (ctx[10] !== void 0) {
    diffbar_props.updations = ctx[10];
  }
  if (ctx[17] !== void 0) {
    diffbar_props.removed = ctx[17];
  }
  if (ctx[18] !== void 0) {
    diffbar_props.snipped = ctx[18];
  }
  if (ctx[13] !== void 0) {
    diffbar_props.withStyle = ctx[13];
  }
  diffbar = new DiffBar({ props: diffbar_props });
  binding_callbacks.push(() => bind$1(diffbar, "additions", diffbar_additions_binding));
  binding_callbacks.push(() => bind$1(diffbar, "deletions", diffbar_deletions_binding));
  binding_callbacks.push(() => bind$1(diffbar, "updations", diffbar_updations_binding));
  binding_callbacks.push(() => bind$1(diffbar, "removed", diffbar_removed_binding));
  binding_callbacks.push(() => bind$1(diffbar, "snipped", diffbar_snipped_binding));
  binding_callbacks.push(() => bind$1(diffbar, "withStyle", diffbar_withStyle_binding));
  diffbar.$on("diffContentModeUpdate", ctx[32]);
  diffbar.$on("applySelectedDiffContentMode", ctx[33]);
  let if_block = ctx[7] && create_if_block_8(ctx);
  return {
    c() {
      create_component(diffbar.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(diffbar, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffbar_changes = {};
      if (dirty[0] & 8)
        diffbar_changes.sieve = ctx2[3];
      if (dirty[0] & 16384)
        diffbar_changes.model = ctx2[14];
      if (dirty[0] & 32768)
        diffbar_changes.oldModel = ctx2[15];
      if (dirty[0] & 1)
        diffbar_changes.selectedDiffContentMode = ctx2[0];
      if (!updating_additions && dirty[0] & 256) {
        updating_additions = true;
        diffbar_changes.additions = ctx2[8];
        add_flush_callback(() => updating_additions = false);
      }
      if (!updating_deletions && dirty[0] & 512) {
        updating_deletions = true;
        diffbar_changes.deletions = ctx2[9];
        add_flush_callback(() => updating_deletions = false);
      }
      if (!updating_updations && dirty[0] & 1024) {
        updating_updations = true;
        diffbar_changes.updations = ctx2[10];
        add_flush_callback(() => updating_updations = false);
      }
      if (!updating_removed && dirty[0] & 131072) {
        updating_removed = true;
        diffbar_changes.removed = ctx2[17];
        add_flush_callback(() => updating_removed = false);
      }
      if (!updating_snipped && dirty[0] & 262144) {
        updating_snipped = true;
        diffbar_changes.snipped = ctx2[18];
        add_flush_callback(() => updating_snipped = false);
      }
      if (!updating_withStyle && dirty[0] & 8192) {
        updating_withStyle = true;
        diffbar_changes.withStyle = ctx2[13];
        add_flush_callback(() => updating_withStyle = false);
      }
      diffbar.$set(diffbar_changes);
      if (ctx2[7]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(diffbar.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(diffbar.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(diffbar, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_8(ctx) {
  let summarycontainer;
  let current;
  summarycontainer = new SummaryContainer({
    props: {
      content_type: ctx[3].get("content_type"),
      sieve: ctx[3],
      oldData: ctx[2],
      data: ctx[1]
    }
  });
  return {
    c() {
      create_component(summarycontainer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(summarycontainer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const summarycontainer_changes = {};
      if (dirty[0] & 8)
        summarycontainer_changes.content_type = ctx2[3].get("content_type");
      if (dirty[0] & 8)
        summarycontainer_changes.sieve = ctx2[3];
      if (dirty[0] & 4)
        summarycontainer_changes.oldData = ctx2[2];
      if (dirty[0] & 2)
        summarycontainer_changes.data = ctx2[1];
      summarycontainer.$set(summarycontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(summarycontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(summarycontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(summarycontainer, detaching);
    }
  };
}
function create_else_block_1$c(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `ERR! Unknown data type - ${ctx[21]}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_6$4(ctx) {
  let diffsitemapview;
  let updating_additions;
  let updating_deletions;
  let updating_diffView;
  let current;
  function diffsitemapview_additions_binding(value) {
    ctx[55](value);
  }
  function diffsitemapview_deletions_binding(value) {
    ctx[56](value);
  }
  function diffsitemapview_diffView_binding(value) {
    ctx[57](value);
  }
  let diffsitemapview_props = {
    oldModel: ctx[15],
    model: ctx[14],
    newData: ctx[1].data,
    oldData: ctx[2].data,
    class: "max-h-[40vh] overflow-scroll max-w-[100%]",
    urlClass: "truncate max-w-[20vw]",
    pruneDeletions: !ctx[17],
    snipped: ctx[18]
  };
  if (ctx[8] !== void 0) {
    diffsitemapview_props.additions = ctx[8];
  }
  if (ctx[9] !== void 0) {
    diffsitemapview_props.deletions = ctx[9];
  }
  if (ctx[11] !== void 0) {
    diffsitemapview_props.diffView = ctx[11];
  }
  diffsitemapview = new DiffSitemapView({ props: diffsitemapview_props });
  binding_callbacks.push(() => bind$1(diffsitemapview, "additions", diffsitemapview_additions_binding));
  binding_callbacks.push(() => bind$1(diffsitemapview, "deletions", diffsitemapview_deletions_binding));
  binding_callbacks.push(() => bind$1(diffsitemapview, "diffView", diffsitemapview_diffView_binding));
  diffsitemapview.$on("load", ctx[58]);
  return {
    c() {
      create_component(diffsitemapview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffsitemapview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffsitemapview_changes = {};
      if (dirty[0] & 32768)
        diffsitemapview_changes.oldModel = ctx2[15];
      if (dirty[0] & 16384)
        diffsitemapview_changes.model = ctx2[14];
      if (dirty[0] & 2)
        diffsitemapview_changes.newData = ctx2[1].data;
      if (dirty[0] & 4)
        diffsitemapview_changes.oldData = ctx2[2].data;
      if (dirty[0] & 131072)
        diffsitemapview_changes.pruneDeletions = !ctx2[17];
      if (dirty[0] & 262144)
        diffsitemapview_changes.snipped = ctx2[18];
      if (!updating_additions && dirty[0] & 256) {
        updating_additions = true;
        diffsitemapview_changes.additions = ctx2[8];
        add_flush_callback(() => updating_additions = false);
      }
      if (!updating_deletions && dirty[0] & 512) {
        updating_deletions = true;
        diffsitemapview_changes.deletions = ctx2[9];
        add_flush_callback(() => updating_deletions = false);
      }
      if (!updating_diffView && dirty[0] & 2048) {
        updating_diffView = true;
        diffsitemapview_changes.diffView = ctx2[11];
        add_flush_callback(() => updating_diffView = false);
      }
      diffsitemapview.$set(diffsitemapview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffsitemapview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffsitemapview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffsitemapview, detaching);
    }
  };
}
function create_if_block_4$g(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5$a, create_else_block$x];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty[0] & 7)
      show_if = null;
    if (show_if == null)
      show_if = !!([C$1.DIFF_MODE_VISUAL, C$1.DIFF_MODE_SOURCE].includes(ctx2[0]) && ctx2[1].snapshot && ctx2[2].snapshot);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3$o(ctx) {
  let diffxmlview;
  let updating_additions;
  let updating_deletions;
  let updating_iframe;
  let current;
  function diffxmlview_additions_binding(value) {
    ctx[43](value);
  }
  function diffxmlview_deletions_binding(value) {
    ctx[44](value);
  }
  function diffxmlview_iframe_binding(value) {
    ctx[45](value);
  }
  let diffxmlview_props = {
    selectedDiffContentMode: ctx[0],
    newData: ctx[1],
    oldData: ctx[2],
    showRemoved: ctx[17],
    showScrollBar: true,
    snipped: ctx[18],
    iframeStyle: ctx[6]
  };
  if (ctx[8] !== void 0) {
    diffxmlview_props.additions = ctx[8];
  }
  if (ctx[9] !== void 0) {
    diffxmlview_props.deletions = ctx[9];
  }
  if (ctx[11] !== void 0) {
    diffxmlview_props.iframe = ctx[11];
  }
  diffxmlview = new DiffXmlView({ props: diffxmlview_props });
  binding_callbacks.push(() => bind$1(diffxmlview, "additions", diffxmlview_additions_binding));
  binding_callbacks.push(() => bind$1(diffxmlview, "deletions", diffxmlview_deletions_binding));
  binding_callbacks.push(() => bind$1(diffxmlview, "iframe", diffxmlview_iframe_binding));
  diffxmlview.$on("load", ctx[46]);
  return {
    c() {
      create_component(diffxmlview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffxmlview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffxmlview_changes = {};
      if (dirty[0] & 1)
        diffxmlview_changes.selectedDiffContentMode = ctx2[0];
      if (dirty[0] & 2)
        diffxmlview_changes.newData = ctx2[1];
      if (dirty[0] & 4)
        diffxmlview_changes.oldData = ctx2[2];
      if (dirty[0] & 131072)
        diffxmlview_changes.showRemoved = ctx2[17];
      if (dirty[0] & 262144)
        diffxmlview_changes.snipped = ctx2[18];
      if (dirty[0] & 64)
        diffxmlview_changes.iframeStyle = ctx2[6];
      if (!updating_additions && dirty[0] & 256) {
        updating_additions = true;
        diffxmlview_changes.additions = ctx2[8];
        add_flush_callback(() => updating_additions = false);
      }
      if (!updating_deletions && dirty[0] & 512) {
        updating_deletions = true;
        diffxmlview_changes.deletions = ctx2[9];
        add_flush_callback(() => updating_deletions = false);
      }
      if (!updating_iframe && dirty[0] & 2048) {
        updating_iframe = true;
        diffxmlview_changes.iframe = ctx2[11];
        add_flush_callback(() => updating_iframe = false);
      }
      diffxmlview.$set(diffxmlview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffxmlview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffxmlview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffxmlview, detaching);
    }
  };
}
function create_if_block_2$v(ctx) {
  let difffeedview;
  let updating_iframe;
  let updating_newFeedCount;
  let updating_updatedFeedCount;
  let updating_deletedFeedCount;
  let current;
  function difffeedview_iframe_binding(value) {
    ctx[38](value);
  }
  function difffeedview_newFeedCount_binding(value) {
    ctx[39](value);
  }
  function difffeedview_updatedFeedCount_binding(value) {
    ctx[40](value);
  }
  function difffeedview_deletedFeedCount_binding(value) {
    ctx[41](value);
  }
  let difffeedview_props = {
    selectedDiffContentMode: ctx[0],
    newData: ctx[1],
    oldData: ctx[2],
    showRemoved: ctx[17],
    showDeletedEntries: ctx[17],
    showScrollBar: true,
    iframeStyle: ctx[6],
    snipped: ctx[18]
  };
  if (ctx[11] !== void 0) {
    difffeedview_props.iframe = ctx[11];
  }
  if (ctx[8] !== void 0) {
    difffeedview_props.newFeedCount = ctx[8];
  }
  if (ctx[10] !== void 0) {
    difffeedview_props.updatedFeedCount = ctx[10];
  }
  if (ctx[9] !== void 0) {
    difffeedview_props.deletedFeedCount = ctx[9];
  }
  difffeedview = new DiffFeedView({ props: difffeedview_props });
  binding_callbacks.push(() => bind$1(difffeedview, "iframe", difffeedview_iframe_binding));
  binding_callbacks.push(() => bind$1(difffeedview, "newFeedCount", difffeedview_newFeedCount_binding));
  binding_callbacks.push(() => bind$1(difffeedview, "updatedFeedCount", difffeedview_updatedFeedCount_binding));
  binding_callbacks.push(() => bind$1(difffeedview, "deletedFeedCount", difffeedview_deletedFeedCount_binding));
  difffeedview.$on("load", ctx[42]);
  return {
    c() {
      create_component(difffeedview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(difffeedview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const difffeedview_changes = {};
      if (dirty[0] & 1)
        difffeedview_changes.selectedDiffContentMode = ctx2[0];
      if (dirty[0] & 2)
        difffeedview_changes.newData = ctx2[1];
      if (dirty[0] & 4)
        difffeedview_changes.oldData = ctx2[2];
      if (dirty[0] & 131072)
        difffeedview_changes.showRemoved = ctx2[17];
      if (dirty[0] & 131072)
        difffeedview_changes.showDeletedEntries = ctx2[17];
      if (dirty[0] & 64)
        difffeedview_changes.iframeStyle = ctx2[6];
      if (dirty[0] & 262144)
        difffeedview_changes.snipped = ctx2[18];
      if (!updating_iframe && dirty[0] & 2048) {
        updating_iframe = true;
        difffeedview_changes.iframe = ctx2[11];
        add_flush_callback(() => updating_iframe = false);
      }
      if (!updating_newFeedCount && dirty[0] & 256) {
        updating_newFeedCount = true;
        difffeedview_changes.newFeedCount = ctx2[8];
        add_flush_callback(() => updating_newFeedCount = false);
      }
      if (!updating_updatedFeedCount && dirty[0] & 1024) {
        updating_updatedFeedCount = true;
        difffeedview_changes.updatedFeedCount = ctx2[10];
        add_flush_callback(() => updating_updatedFeedCount = false);
      }
      if (!updating_deletedFeedCount && dirty[0] & 512) {
        updating_deletedFeedCount = true;
        difffeedview_changes.deletedFeedCount = ctx2[9];
        add_flush_callback(() => updating_deletedFeedCount = false);
      }
      difffeedview.$set(difffeedview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(difffeedview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(difffeedview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(difffeedview, detaching);
    }
  };
}
function create_if_block_1$F(ctx) {
  let diffhtmlview;
  let updating_additions;
  let updating_deletions;
  let updating_iframe;
  let current;
  function diffhtmlview_additions_binding(value) {
    ctx[34](value);
  }
  function diffhtmlview_deletions_binding(value) {
    ctx[35](value);
  }
  function diffhtmlview_iframe_binding(value) {
    ctx[36](value);
  }
  let diffhtmlview_props = {
    selectedDiffContentMode: ctx[0],
    newData: ctx[1],
    oldData: ctx[2],
    showRemoved: ctx[17],
    dynamicHeight: false,
    showScrollBar: true,
    uri: ctx[19].uri,
    iframeStyle: ctx[6],
    snipped: ctx[18],
    withStyle: ctx[13]
  };
  if (ctx[8] !== void 0) {
    diffhtmlview_props.additions = ctx[8];
  }
  if (ctx[9] !== void 0) {
    diffhtmlview_props.deletions = ctx[9];
  }
  if (ctx[11] !== void 0) {
    diffhtmlview_props.iframe = ctx[11];
  }
  diffhtmlview = new DiffHtmlView({ props: diffhtmlview_props });
  binding_callbacks.push(() => bind$1(diffhtmlview, "additions", diffhtmlview_additions_binding));
  binding_callbacks.push(() => bind$1(diffhtmlview, "deletions", diffhtmlview_deletions_binding));
  binding_callbacks.push(() => bind$1(diffhtmlview, "iframe", diffhtmlview_iframe_binding));
  diffhtmlview.$on("load", ctx[37]);
  return {
    c() {
      create_component(diffhtmlview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffhtmlview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffhtmlview_changes = {};
      if (dirty[0] & 1)
        diffhtmlview_changes.selectedDiffContentMode = ctx2[0];
      if (dirty[0] & 2)
        diffhtmlview_changes.newData = ctx2[1];
      if (dirty[0] & 4)
        diffhtmlview_changes.oldData = ctx2[2];
      if (dirty[0] & 131072)
        diffhtmlview_changes.showRemoved = ctx2[17];
      if (dirty[0] & 524288)
        diffhtmlview_changes.uri = ctx2[19].uri;
      if (dirty[0] & 64)
        diffhtmlview_changes.iframeStyle = ctx2[6];
      if (dirty[0] & 262144)
        diffhtmlview_changes.snipped = ctx2[18];
      if (dirty[0] & 8192)
        diffhtmlview_changes.withStyle = ctx2[13];
      if (!updating_additions && dirty[0] & 256) {
        updating_additions = true;
        diffhtmlview_changes.additions = ctx2[8];
        add_flush_callback(() => updating_additions = false);
      }
      if (!updating_deletions && dirty[0] & 512) {
        updating_deletions = true;
        diffhtmlview_changes.deletions = ctx2[9];
        add_flush_callback(() => updating_deletions = false);
      }
      if (!updating_iframe && dirty[0] & 2048) {
        updating_iframe = true;
        diffhtmlview_changes.iframe = ctx2[11];
        add_flush_callback(() => updating_iframe = false);
      }
      diffhtmlview.$set(diffhtmlview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffhtmlview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffhtmlview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffhtmlview, detaching);
    }
  };
}
function create_else_block$x(ctx) {
  let diffjsonview;
  let updating_additions;
  let updating_deletions;
  let updating_diffView;
  let current;
  function diffjsonview_additions_binding(value) {
    ctx[51](value);
  }
  function diffjsonview_deletions_binding(value) {
    ctx[52](value);
  }
  function diffjsonview_diffView_binding(value) {
    ctx[53](value);
  }
  let diffjsonview_props = {
    newData: ctx[1].data,
    oldData: ctx[2].data,
    diffNavigation: false,
    full: !ctx[18],
    pruneDeletions: !ctx[17],
    showDirty: !ctx[18],
    showViewJSONButton: true,
    class: "ml-20 pr-10 my-10 w-auto max-h-[40vh] overflow-scroll"
  };
  if (ctx[8] !== void 0) {
    diffjsonview_props.additions = ctx[8];
  }
  if (ctx[9] !== void 0) {
    diffjsonview_props.deletions = ctx[9];
  }
  if (ctx[11] !== void 0) {
    diffjsonview_props.diffView = ctx[11];
  }
  diffjsonview = new DiffJsonView({ props: diffjsonview_props });
  binding_callbacks.push(() => bind$1(diffjsonview, "additions", diffjsonview_additions_binding));
  binding_callbacks.push(() => bind$1(diffjsonview, "deletions", diffjsonview_deletions_binding));
  binding_callbacks.push(() => bind$1(diffjsonview, "diffView", diffjsonview_diffView_binding));
  diffjsonview.$on("load", ctx[54]);
  return {
    c() {
      create_component(diffjsonview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffjsonview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffjsonview_changes = {};
      if (dirty[0] & 2)
        diffjsonview_changes.newData = ctx2[1].data;
      if (dirty[0] & 4)
        diffjsonview_changes.oldData = ctx2[2].data;
      if (dirty[0] & 262144)
        diffjsonview_changes.full = !ctx2[18];
      if (dirty[0] & 131072)
        diffjsonview_changes.pruneDeletions = !ctx2[17];
      if (dirty[0] & 262144)
        diffjsonview_changes.showDirty = !ctx2[18];
      if (!updating_additions && dirty[0] & 256) {
        updating_additions = true;
        diffjsonview_changes.additions = ctx2[8];
        add_flush_callback(() => updating_additions = false);
      }
      if (!updating_deletions && dirty[0] & 512) {
        updating_deletions = true;
        diffjsonview_changes.deletions = ctx2[9];
        add_flush_callback(() => updating_deletions = false);
      }
      if (!updating_diffView && dirty[0] & 2048) {
        updating_diffView = true;
        diffjsonview_changes.diffView = ctx2[11];
        add_flush_callback(() => updating_diffView = false);
      }
      diffjsonview.$set(diffjsonview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffjsonview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffjsonview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffjsonview, detaching);
    }
  };
}
function create_if_block_5$a(ctx) {
  let diffhtmlview;
  let updating_additions;
  let updating_deletions;
  let updating_iframe;
  let current;
  function diffhtmlview_additions_binding_1(value) {
    ctx[47](value);
  }
  function diffhtmlview_deletions_binding_1(value) {
    ctx[48](value);
  }
  function diffhtmlview_iframe_binding_1(value) {
    ctx[49](value);
  }
  let diffhtmlview_props = {
    selectedDiffContentMode: ctx[0],
    newData: { data: ctx[1].snapshot },
    oldData: { data: ctx[2].snapshot },
    showRemoved: ctx[17],
    dynamicHeight: false,
    showScrollBar: true,
    uri: ctx[19].uri,
    iframeStyle: ctx[6],
    snipped: ctx[18],
    withStyle: ctx[13]
  };
  if (ctx[8] !== void 0) {
    diffhtmlview_props.additions = ctx[8];
  }
  if (ctx[9] !== void 0) {
    diffhtmlview_props.deletions = ctx[9];
  }
  if (ctx[11] !== void 0) {
    diffhtmlview_props.iframe = ctx[11];
  }
  diffhtmlview = new DiffHtmlView({ props: diffhtmlview_props });
  binding_callbacks.push(() => bind$1(diffhtmlview, "additions", diffhtmlview_additions_binding_1));
  binding_callbacks.push(() => bind$1(diffhtmlview, "deletions", diffhtmlview_deletions_binding_1));
  binding_callbacks.push(() => bind$1(diffhtmlview, "iframe", diffhtmlview_iframe_binding_1));
  diffhtmlview.$on("load", ctx[50]);
  return {
    c() {
      create_component(diffhtmlview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(diffhtmlview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const diffhtmlview_changes = {};
      if (dirty[0] & 1)
        diffhtmlview_changes.selectedDiffContentMode = ctx2[0];
      if (dirty[0] & 2)
        diffhtmlview_changes.newData = { data: ctx2[1].snapshot };
      if (dirty[0] & 4)
        diffhtmlview_changes.oldData = { data: ctx2[2].snapshot };
      if (dirty[0] & 131072)
        diffhtmlview_changes.showRemoved = ctx2[17];
      if (dirty[0] & 524288)
        diffhtmlview_changes.uri = ctx2[19].uri;
      if (dirty[0] & 64)
        diffhtmlview_changes.iframeStyle = ctx2[6];
      if (dirty[0] & 262144)
        diffhtmlview_changes.snipped = ctx2[18];
      if (dirty[0] & 8192)
        diffhtmlview_changes.withStyle = ctx2[13];
      if (!updating_additions && dirty[0] & 256) {
        updating_additions = true;
        diffhtmlview_changes.additions = ctx2[8];
        add_flush_callback(() => updating_additions = false);
      }
      if (!updating_deletions && dirty[0] & 512) {
        updating_deletions = true;
        diffhtmlview_changes.deletions = ctx2[9];
        add_flush_callback(() => updating_deletions = false);
      }
      if (!updating_iframe && dirty[0] & 2048) {
        updating_iframe = true;
        diffhtmlview_changes.iframe = ctx2[11];
        add_flush_callback(() => updating_iframe = false);
      }
      diffhtmlview.$set(diffhtmlview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffhtmlview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffhtmlview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(diffhtmlview, detaching);
    }
  };
}
function create_if_block$U(ctx) {
  let emailselectmodal;
  let current;
  emailselectmodal = new EmailSelectModal({
    props: {
      sieve: ctx[3],
      model: ctx[14],
      diffView: ctx[11]
    }
  });
  emailselectmodal.$on("close", ctx[59]);
  return {
    c() {
      create_component(emailselectmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(emailselectmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const emailselectmodal_changes = {};
      if (dirty[0] & 8)
        emailselectmodal_changes.sieve = ctx2[3];
      if (dirty[0] & 16384)
        emailselectmodal_changes.model = ctx2[14];
      if (dirty[0] & 2048)
        emailselectmodal_changes.diffView = ctx2[11];
      emailselectmodal.$set(emailselectmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(emailselectmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(emailselectmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(emailselectmodal, detaching);
    }
  };
}
function create_fragment$1E(ctx) {
  let div2;
  let t0;
  let div1;
  let t1;
  let div0;
  let show_if;
  let current_block_type_index;
  let if_block2;
  let t2;
  let if_block3_anchor;
  let current;
  let if_block0 = ctx[5] && create_if_block_9(ctx);
  let if_block1 = ctx[4] && create_if_block_7$3(ctx);
  const if_block_creators = [
    create_if_block_1$F,
    create_if_block_2$v,
    create_if_block_3$o,
    create_if_block_4$g,
    create_if_block_6$4,
    create_else_block_1$c
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & 8)
      show_if = null;
    if (show_if == null)
      show_if = !!ctx2[3].isHTML();
    if (show_if)
      return 0;
    if (ctx2[21] === C$1.TYPE_FEED)
      return 1;
    if (ctx2[21] === C$1.TYPE_XML)
      return 2;
    if (ctx2[21] === C$1.TYPE_JSON)
      return 3;
    if (ctx2[21] === C$1.TYPE_SITEMAP)
      return 4;
    return 5;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block3 = ctx[12] && create_if_block$U(ctx);
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      attr(div0, "class", "mt3");
      toggle_class(div0, "hidden", !ctx[16]);
      attr(div1, "class", "flex-1 bg-white");
      set_style(div1, "border-bottom", "solid 1px #ccc");
      attr(div2, "class", "relative flex");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t0);
      append(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t1);
      append(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      insert(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_9(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_7$3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div0, null);
      }
      if (!current || dirty[0] & 65536) {
        toggle_class(div0, "hidden", !ctx2[16]);
      }
      if (ctx2[12]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$U(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_blocks[current_block_type_index].d();
      if (detaching)
        detach(t2);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(if_block3_anchor);
    }
  };
}
function instance$1B($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop$1, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(19, $sieve = $$value)), sieve);
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { data } = $$props;
  let { oldData } = $$props;
  let { sieve } = $$props;
  $$subscribe_sieve();
  let { showDiffStats = true } = $$props;
  let { showDiffOptions = true } = $$props;
  let { iframeStyle = "max-height: calc(100vh - 200px);" } = $$props;
  let { showSummary = true } = $$props;
  const Backbone2 = window.Backbone;
  const user = getContext("user");
  const exploreDiffPath = urlCfg.diffPage(sieve.id, data == null ? void 0 : data.id, oldData == null ? void 0 : oldData.id);
  let additions;
  let deletions;
  let updations;
  let diffView;
  let showEmailModal = false;
  let withStyle = true;
  const model = new Backbone2.Model(data);
  model.parent = sieve;
  let oldModel;
  if (oldData) {
    oldModel = new Backbone2.Model(oldData);
  }
  let { selectedDiffContentMode = sieve.getDiffMode() } = $$props;
  let type = model.get("data_type");
  let sieveDataTS = window.moment(model.get("ts"));
  let showDiff = true;
  let { removed, snipped } = user.getPref("ui_diff");
  sieve.on("applySelectedDiffContentMode", () => {
    $$invalidate(0, selectedDiffContentMode = sieve.getDiffMode());
  });
  onMount(() => {
    user.on("change:ui_diff", (diffPrefs) => {
      $$invalidate(17, { removed, snipped } = diffPrefs, removed, $$invalidate(18, snipped));
    });
    return () => {
      user.off("change:ui_diff");
      sieve.off("applySelectedDiffContentMode");
    };
  });
  function onDiffContentModeUpdate(e) {
    const newDiffContentMode = e.detail.diffContentMode;
    if (sieve.getDiffMode() !== newDiffContentMode) {
      sieve.setDiffMode(newDiffContentMode);
    }
    $$invalidate(0, selectedDiffContentMode = sieve.getDiffMode());
  }
  const click_handler = () => $$invalidate(16, showDiff = !showDiff);
  const click_handler_1 = () => $$invalidate(12, showEmailModal = true);
  function diffbar_additions_binding(value) {
    additions = value;
    $$invalidate(8, additions);
  }
  function diffbar_deletions_binding(value) {
    deletions = value;
    $$invalidate(9, deletions);
  }
  function diffbar_updations_binding(value) {
    updations = value;
    $$invalidate(10, updations);
  }
  function diffbar_removed_binding(value) {
    removed = value;
    $$invalidate(17, removed);
  }
  function diffbar_snipped_binding(value) {
    snipped = value;
    $$invalidate(18, snipped);
  }
  function diffbar_withStyle_binding(value) {
    withStyle = value;
    $$invalidate(13, withStyle);
  }
  const diffContentModeUpdate_handler = (e) => onDiffContentModeUpdate(e);
  const applySelectedDiffContentMode_handler = () => {
    sieve.trigger("applySelectedDiffContentMode");
  };
  function diffhtmlview_additions_binding(value) {
    additions = value;
    $$invalidate(8, additions);
  }
  function diffhtmlview_deletions_binding(value) {
    deletions = value;
    $$invalidate(9, deletions);
  }
  function diffhtmlview_iframe_binding(value) {
    diffView = value;
    $$invalidate(11, diffView);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function difffeedview_iframe_binding(value) {
    diffView = value;
    $$invalidate(11, diffView);
  }
  function difffeedview_newFeedCount_binding(value) {
    additions = value;
    $$invalidate(8, additions);
  }
  function difffeedview_updatedFeedCount_binding(value) {
    updations = value;
    $$invalidate(10, updations);
  }
  function difffeedview_deletedFeedCount_binding(value) {
    deletions = value;
    $$invalidate(9, deletions);
  }
  function load_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function diffxmlview_additions_binding(value) {
    additions = value;
    $$invalidate(8, additions);
  }
  function diffxmlview_deletions_binding(value) {
    deletions = value;
    $$invalidate(9, deletions);
  }
  function diffxmlview_iframe_binding(value) {
    diffView = value;
    $$invalidate(11, diffView);
  }
  function load_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function diffhtmlview_additions_binding_1(value) {
    additions = value;
    $$invalidate(8, additions);
  }
  function diffhtmlview_deletions_binding_1(value) {
    deletions = value;
    $$invalidate(9, deletions);
  }
  function diffhtmlview_iframe_binding_1(value) {
    diffView = value;
    $$invalidate(11, diffView);
  }
  function load_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function diffjsonview_additions_binding(value) {
    additions = value;
    $$invalidate(8, additions);
  }
  function diffjsonview_deletions_binding(value) {
    deletions = value;
    $$invalidate(9, deletions);
  }
  function diffjsonview_diffView_binding(value) {
    diffView = value;
    $$invalidate(11, diffView);
  }
  function load_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function diffsitemapview_additions_binding(value) {
    additions = value;
    $$invalidate(8, additions);
  }
  function diffsitemapview_deletions_binding(value) {
    deletions = value;
    $$invalidate(9, deletions);
  }
  function diffsitemapview_diffView_binding(value) {
    diffView = value;
    $$invalidate(11, diffView);
  }
  function load_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  const close_handler = () => $$invalidate(12, showEmailModal = false);
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
    if ("oldData" in $$props2)
      $$invalidate(2, oldData = $$props2.oldData);
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(3, sieve = $$props2.sieve));
    if ("showDiffStats" in $$props2)
      $$invalidate(4, showDiffStats = $$props2.showDiffStats);
    if ("showDiffOptions" in $$props2)
      $$invalidate(5, showDiffOptions = $$props2.showDiffOptions);
    if ("iframeStyle" in $$props2)
      $$invalidate(6, iframeStyle = $$props2.iframeStyle);
    if ("showSummary" in $$props2)
      $$invalidate(7, showSummary = $$props2.showSummary);
    if ("selectedDiffContentMode" in $$props2)
      $$invalidate(0, selectedDiffContentMode = $$props2.selectedDiffContentMode);
  };
  return [
    selectedDiffContentMode,
    data,
    oldData,
    sieve,
    showDiffStats,
    showDiffOptions,
    iframeStyle,
    showSummary,
    additions,
    deletions,
    updations,
    diffView,
    showEmailModal,
    withStyle,
    model,
    oldModel,
    showDiff,
    removed,
    snipped,
    $sieve,
    exploreDiffPath,
    type,
    sieveDataTS,
    onDiffContentModeUpdate,
    click_handler,
    click_handler_1,
    diffbar_additions_binding,
    diffbar_deletions_binding,
    diffbar_updations_binding,
    diffbar_removed_binding,
    diffbar_snipped_binding,
    diffbar_withStyle_binding,
    diffContentModeUpdate_handler,
    applySelectedDiffContentMode_handler,
    diffhtmlview_additions_binding,
    diffhtmlview_deletions_binding,
    diffhtmlview_iframe_binding,
    load_handler,
    difffeedview_iframe_binding,
    difffeedview_newFeedCount_binding,
    difffeedview_updatedFeedCount_binding,
    difffeedview_deletedFeedCount_binding,
    load_handler_1,
    diffxmlview_additions_binding,
    diffxmlview_deletions_binding,
    diffxmlview_iframe_binding,
    load_handler_2,
    diffhtmlview_additions_binding_1,
    diffhtmlview_deletions_binding_1,
    diffhtmlview_iframe_binding_1,
    load_handler_3,
    diffjsonview_additions_binding,
    diffjsonview_deletions_binding,
    diffjsonview_diffView_binding,
    load_handler_4,
    diffsitemapview_additions_binding,
    diffsitemapview_deletions_binding,
    diffsitemapview_diffView_binding,
    load_handler_5,
    close_handler
  ];
}
class SieveData extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$1B,
      create_fragment$1E,
      safe_not_equal,
      {
        data: 1,
        oldData: 2,
        sieve: 3,
        showDiffStats: 4,
        showDiffOptions: 5,
        iframeStyle: 6,
        showSummary: 7,
        selectedDiffContentMode: 0
      },
      null,
      [-1, -1, -1]
    );
  }
}
function create_key_block$1(ctx) {
  let scheduleeditor;
  let current;
  const scheduleeditor_spread_levels = [{ formModel: ctx[1] }, ctx[19]];
  let scheduleeditor_props = {};
  for (let i2 = 0; i2 < scheduleeditor_spread_levels.length; i2 += 1) {
    scheduleeditor_props = assign(scheduleeditor_props, scheduleeditor_spread_levels[i2]);
  }
  scheduleeditor = new ScheduleEditor({ props: scheduleeditor_props });
  return {
    c() {
      create_component(scheduleeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scheduleeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const scheduleeditor_changes = dirty[0] & 524290 ? get_spread_update(scheduleeditor_spread_levels, [
        dirty[0] & 2 && { formModel: ctx2[1] },
        dirty[0] & 524288 && get_spread_object(ctx2[19])
      ]) : {};
      scheduleeditor.$set(scheduleeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scheduleeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scheduleeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scheduleeditor, detaching);
    }
  };
}
function create_if_block_3$n(ctx) {
  let globalactionseditormodal;
  let current;
  globalactionseditormodal = new GlobalActionsEditorModal({});
  globalactionseditormodal.$on("close", ctx[29]);
  return {
    c() {
      create_component(globalactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalactionseditormodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(globalactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalactionseditormodal, detaching);
    }
  };
}
function create_if_block_2$u(ctx) {
  let manageemailsmodal;
  let current;
  manageemailsmodal = new ManageEmailModal({});
  manageemailsmodal.$on("close", ctx[30]);
  return {
    c() {
      create_component(manageemailsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(manageemailsmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(manageemailsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(manageemailsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(manageemailsmodal, detaching);
    }
  };
}
function create_if_block_1$E(ctx) {
  let managephonesmodal;
  let current;
  managephonesmodal = new ManagePhonesModal({});
  managephonesmodal.$on("close", ctx[31]);
  return {
    c() {
      create_component(managephonesmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managephonesmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(managephonesmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managephonesmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managephonesmodal, detaching);
    }
  };
}
function create_if_block$T(ctx) {
  let sieveruledebuggereditormodal;
  let current;
  function func_12(...args) {
    return ctx[34](ctx[52], ...args);
  }
  sieveruledebuggereditormodal = new SieveRuleDebuggerEditorModal({
    props: {
      rule: ctx[5],
      sieveConditionInputs: ctx[2],
      initialIds: ctx[14],
      contentType: ctx[16].content_type,
      sieveId: ctx[16].id,
      globalRules: ctx[53] ? ctx[53].toJSON() : {},
      onClose: ctx[33],
      onSave: func_12
    }
  });
  return {
    c() {
      create_component(sieveruledebuggereditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveruledebuggereditormodal, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const sieveruledebuggereditormodal_changes = {};
      if (dirty[0] & 32)
        sieveruledebuggereditormodal_changes.rule = ctx[5];
      if (dirty[0] & 4)
        sieveruledebuggereditormodal_changes.sieveConditionInputs = ctx[2];
      if (dirty[0] & 16384)
        sieveruledebuggereditormodal_changes.initialIds = ctx[14];
      if (dirty[0] & 65536)
        sieveruledebuggereditormodal_changes.contentType = ctx[16].content_type;
      if (dirty[0] & 65536)
        sieveruledebuggereditormodal_changes.sieveId = ctx[16].id;
      if (dirty[1] & 4194304)
        sieveruledebuggereditormodal_changes.globalRules = ctx[53] ? ctx[53].toJSON() : {};
      if (dirty[0] & 8192)
        sieveruledebuggereditormodal_changes.onClose = ctx[33];
      if (dirty[1] & 2097152)
        sieveruledebuggereditormodal_changes.onSave = func_12;
      sieveruledebuggereditormodal.$set(sieveruledebuggereditormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveruledebuggereditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveruledebuggereditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveruledebuggereditormodal, detaching);
    }
  };
}
function create_header_right_slot(ctx) {
  var _a;
  let div;
  let button;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[13] && ((_a = ctx[15]) == null ? void 0 : _a.config) && create_if_block$T(ctx);
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = "Test conditions";
      t1 = space();
      if (if_block)
        if_block.c();
      attr(button, "class", "btn btn-default btn-sm w-36");
      attr(div, "slot", "header-right");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[32]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2;
      if (ctx2[13] && ((_a2 = ctx2[15]) == null ? void 0 : _a2.config)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 40960) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$T(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_content_slot(ctx) {
  let div17;
  let div1;
  let label0;
  let t1;
  let div0;
  let sourceeditor;
  let t2;
  let p0;
  let t4;
  let div3;
  let label1;
  let t6;
  let div2;
  let clientselector;
  let t7;
  let p1;
  let t9;
  let div5;
  let label2;
  let t11;
  let div4;
  let input;
  let t12;
  let div7;
  let label3;
  let t14;
  let div6;
  let previous_key = ctx[11];
  let t15;
  let div9;
  let label4;
  let t17;
  let div8;
  let actionseditor;
  let updating_actions;
  let t18;
  let p2;
  let t20;
  let t21;
  let t22;
  let t23;
  let div11;
  let label5;
  let t25;
  let div10;
  let ruleeditor;
  let updating_rule;
  let t26;
  let p3;
  let t28;
  let div13;
  let label6;
  let t30;
  let div12;
  let tagseditor;
  let t31;
  let div16;
  let div14;
  let t32;
  let div15;
  let button0;
  let t33_value = (ctx[4] ? TXT("l_loading") : TXT("a_save")) + "";
  let t33;
  let button0_data_ph_sieve_id_value;
  let button0_data_ph_isnew_value;
  let button0_disabled_value;
  let t34;
  let button1;
  let t35_value = TXT("a_discard") + "";
  let t35;
  let button1_data_ph_sieve_id_value;
  let button1_data_ph_isnew_value;
  let current;
  let mounted;
  let dispose;
  sourceeditor = new SourceEditor({
    props: {
      formModel: ctx[1],
      mdsDatasource: ctx[3]
    }
  });
  clientselector = new ClientSelector({ props: { model: ctx[0] } });
  let key_block = create_key_block$1(ctx);
  function actionseditor_actions_binding(value) {
    ctx[26](value);
  }
  let actionseditor_props = { sieve: ctx[0] };
  if (ctx[6] !== void 0) {
    actionseditor_props.actions = ctx[6];
  }
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  binding_callbacks.push(() => bind$1(actionseditor, "actions", actionseditor_actions_binding));
  ctx[27](actionseditor);
  actionseditor.$on("globalaction", ctx[28]);
  actionseditor.$on("manage", ctx[20]);
  let if_block0 = ctx[8] && create_if_block_3$n(ctx);
  let if_block1 = ctx[9] && create_if_block_2$u(ctx);
  let if_block2 = ctx[10] && create_if_block_1$E(ctx);
  function ruleeditor_rule_binding(value) {
    ctx[35](value);
  }
  let ruleeditor_props = {
    sieve: ctx[0],
    sieveConditionInputs: ctx[2],
    $$slots: {
      "header-right": [
        create_header_right_slot,
        ({ setGlobalCount, globalRuleModel }) => ({ 52: setGlobalCount, 53: globalRuleModel }),
        ({ setGlobalCount, globalRuleModel }) => [0, (setGlobalCount ? 2097152 : 0) | (globalRuleModel ? 4194304 : 0)]
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[5] !== void 0) {
    ruleeditor_props.rule = ctx[5];
  }
  ruleeditor = new RuleEditor({ props: ruleeditor_props });
  binding_callbacks.push(() => bind$1(ruleeditor, "rule", ruleeditor_rule_binding));
  tagseditor = new TagsEditor({ props: { model: ctx[0] } });
  return {
    c() {
      div17 = element("div");
      div1 = element("div");
      label0 = element("label");
      label0.textContent = `${TXT("l_source")}`;
      t1 = space();
      div0 = element("div");
      create_component(sourceeditor.$$.fragment);
      t2 = space();
      p0 = element("p");
      p0.textContent = `${TXT("h_sieve_source")}`;
      t4 = space();
      div3 = element("div");
      label1 = element("label");
      label1.textContent = `${TXT("l_device")}`;
      t6 = space();
      div2 = element("div");
      create_component(clientselector.$$.fragment);
      t7 = space();
      p1 = element("p");
      p1.textContent = `${TXT("h_sieve_device")}`;
      t9 = space();
      div5 = element("div");
      label2 = element("label");
      label2.textContent = `${TXT("l_name")}`;
      t11 = space();
      div4 = element("div");
      input = element("input");
      t12 = space();
      div7 = element("div");
      label3 = element("label");
      label3.textContent = `${TXT("l_schedule")}`;
      t14 = space();
      div6 = element("div");
      key_block.c();
      t15 = space();
      div9 = element("div");
      label4 = element("label");
      label4.textContent = `${TXT("l_actions")}`;
      t17 = space();
      div8 = element("div");
      create_component(actionseditor.$$.fragment);
      t18 = space();
      p2 = element("p");
      p2.textContent = `${TXT("h_sieve_actions")}`;
      t20 = space();
      if (if_block0)
        if_block0.c();
      t21 = space();
      if (if_block1)
        if_block1.c();
      t22 = space();
      if (if_block2)
        if_block2.c();
      t23 = space();
      div11 = element("div");
      label5 = element("label");
      label5.textContent = `${TXT("l_conditions")}`;
      t25 = space();
      div10 = element("div");
      create_component(ruleeditor.$$.fragment);
      t26 = space();
      p3 = element("p");
      p3.textContent = `${TXT("h_sieve_rules")}`;
      t28 = space();
      div13 = element("div");
      label6 = element("label");
      label6.textContent = `${TXT("l_label")}`;
      t30 = space();
      div12 = element("div");
      create_component(tagseditor.$$.fragment);
      t31 = space();
      div16 = element("div");
      div14 = element("div");
      t32 = space();
      div15 = element("div");
      button0 = element("button");
      t33 = text(t33_value);
      t34 = space();
      button1 = element("button");
      t35 = text(t35_value);
      attr(label0, "class", "xoption-label form-label");
      attr(p0, "class", "help");
      attr(div0, "class", "flex-1");
      attr(div1, "class", "flex gap-x-6");
      attr(label1, "class", "xoption-label form-label");
      attr(p1, "class", "help");
      attr(div2, "class", "flex-1");
      attr(div3, "class", "flex gap-x-6");
      attr(label2, "class", "xoption-label form-label");
      attr(input, "type", "text");
      attr(input, "class", "form-control xform-control-sm inline");
      attr(div4, "class", "flex-1");
      attr(div5, "class", "flex gap-x-6");
      attr(label3, "class", "xoption-label form-label");
      attr(div6, "class", "flex-1");
      attr(div7, "class", "flex gap-x-6");
      attr(label4, "class", "xoption-label form-label");
      attr(p2, "class", "help");
      attr(div8, "class", "flex-1");
      set_style(div8, "position", "relative");
      attr(div9, "class", "flex gap-x-6");
      attr(label5, "class", "xoption-label form-label");
      attr(p3, "class", "help");
      attr(div10, "class", "flex-1");
      attr(div11, "class", "flex gap-x-6");
      attr(label6, "class", "xoption-label form-label");
      attr(div12, "class", "flex-1");
      attr(div13, "class", "flex gap-x-6");
      attr(div14, "class", "xoption-label form-label");
      attr(button0, "class", "btn btn-primary xbtn-default");
      attr(button0, "ph-event", PHEvents.SIEVE_EDIT_OPTIONS_SAVED);
      attr(button0, "data-ph-sieve_id", button0_data_ph_sieve_id_value = ctx[0].id);
      attr(button0, "data-ph-isnew", button0_data_ph_isnew_value = ctx[0].isNew());
      button0.disabled = button0_disabled_value = ctx[4] || ctx[17].readOnly;
      attr(button1, "class", "btn btn-default");
      attr(button1, "data-action", "go_back");
      attr(button1, "ph-event", PHEvents.SIEVE_EDIT_OPTIONS_CANCELLED);
      attr(button1, "data-ph-sieve_id", button1_data_ph_sieve_id_value = ctx[0].id);
      attr(button1, "data-ph-isnew", button1_data_ph_isnew_value = ctx[0].isNew());
      attr(div15, "class", "flex-1 mt-2 pt-2");
      set_style(div15, "border-top", "solid 1px #ddd");
      attr(div16, "class", "flex gap-x-6 mb-[30px]");
      attr(div17, "class", "flex flex-col gap-y-6 p-[10px]");
    },
    m(target, anchor) {
      insert(target, div17, anchor);
      append(div17, div1);
      append(div1, label0);
      append(div1, t1);
      append(div1, div0);
      mount_component(sourceeditor, div0, null);
      append(div0, t2);
      append(div0, p0);
      append(div17, t4);
      append(div17, div3);
      append(div3, label1);
      append(div3, t6);
      append(div3, div2);
      mount_component(clientselector, div2, null);
      append(div2, t7);
      append(div2, p1);
      append(div17, t9);
      append(div17, div5);
      append(div5, label2);
      append(div5, t11);
      append(div5, div4);
      append(div4, input);
      set_input_value(input, ctx[16].name);
      append(div17, t12);
      append(div17, div7);
      append(div7, label3);
      append(div7, t14);
      append(div7, div6);
      key_block.m(div6, null);
      append(div17, t15);
      append(div17, div9);
      append(div9, label4);
      append(div9, t17);
      append(div9, div8);
      mount_component(actionseditor, div8, null);
      append(div8, t18);
      append(div8, p2);
      append(div8, t20);
      if (if_block0)
        if_block0.m(div8, null);
      append(div8, t21);
      if (if_block1)
        if_block1.m(div8, null);
      append(div8, t22);
      if (if_block2)
        if_block2.m(div8, null);
      append(div17, t23);
      append(div17, div11);
      append(div11, label5);
      append(div11, t25);
      append(div11, div10);
      mount_component(ruleeditor, div10, null);
      append(div10, t26);
      append(div10, p3);
      append(div17, t28);
      append(div17, div13);
      append(div13, label6);
      append(div13, t30);
      append(div13, div12);
      mount_component(tagseditor, div12, null);
      append(div17, t31);
      append(div17, div16);
      append(div16, div14);
      append(div16, t32);
      append(div16, div15);
      append(div15, button0);
      append(button0, t33);
      append(div15, t34);
      append(div15, button1);
      append(button1, t35);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[24]),
          listen(input, "input", ctx[25], { once: true }),
          listen(button0, "click", ctx[21])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const sourceeditor_changes = {};
      if (dirty[0] & 2)
        sourceeditor_changes.formModel = ctx2[1];
      if (dirty[0] & 8)
        sourceeditor_changes.mdsDatasource = ctx2[3];
      sourceeditor.$set(sourceeditor_changes);
      const clientselector_changes = {};
      if (dirty[0] & 1)
        clientselector_changes.model = ctx2[0];
      clientselector.$set(clientselector_changes);
      if (dirty[0] & 65536 && input.value !== ctx2[16].name) {
        set_input_value(input, ctx2[16].name);
      }
      if (dirty[0] & 2048 && safe_not_equal(previous_key, previous_key = ctx2[11])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div6, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      const actionseditor_changes = {};
      if (dirty[0] & 1)
        actionseditor_changes.sieve = ctx2[0];
      if (!updating_actions && dirty[0] & 64) {
        updating_actions = true;
        actionseditor_changes.actions = ctx2[6];
        add_flush_callback(() => updating_actions = false);
      }
      actionseditor.$set(actionseditor_changes);
      if (ctx2[8]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$n(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div8, t21);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[9]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$u(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div8, t22);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[10]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 1024) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$E(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div8, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const ruleeditor_changes = {};
      if (dirty[0] & 1)
        ruleeditor_changes.sieve = ctx2[0];
      if (dirty[0] & 4)
        ruleeditor_changes.sieveConditionInputs = ctx2[2];
      if (dirty[0] & 122916 | dirty[1] & 14680064) {
        ruleeditor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_rule && dirty[0] & 32) {
        updating_rule = true;
        ruleeditor_changes.rule = ctx2[5];
        add_flush_callback(() => updating_rule = false);
      }
      ruleeditor.$set(ruleeditor_changes);
      const tagseditor_changes = {};
      if (dirty[0] & 1)
        tagseditor_changes.model = ctx2[0];
      tagseditor.$set(tagseditor_changes);
      if ((!current || dirty[0] & 16) && t33_value !== (t33_value = (ctx2[4] ? TXT("l_loading") : TXT("a_save")) + ""))
        set_data(t33, t33_value);
      if (!current || dirty[0] & 1 && button0_data_ph_sieve_id_value !== (button0_data_ph_sieve_id_value = ctx2[0].id)) {
        attr(button0, "data-ph-sieve_id", button0_data_ph_sieve_id_value);
      }
      if (!current || dirty[0] & 1 && button0_data_ph_isnew_value !== (button0_data_ph_isnew_value = ctx2[0].isNew())) {
        attr(button0, "data-ph-isnew", button0_data_ph_isnew_value);
      }
      if (!current || dirty[0] & 131088 && button0_disabled_value !== (button0_disabled_value = ctx2[4] || ctx2[17].readOnly)) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty[0] & 1 && button1_data_ph_sieve_id_value !== (button1_data_ph_sieve_id_value = ctx2[0].id)) {
        attr(button1, "data-ph-sieve_id", button1_data_ph_sieve_id_value);
      }
      if (!current || dirty[0] & 1 && button1_data_ph_isnew_value !== (button1_data_ph_isnew_value = ctx2[0].isNew())) {
        attr(button1, "data-ph-isnew", button1_data_ph_isnew_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sourceeditor.$$.fragment, local);
      transition_in(clientselector.$$.fragment, local);
      transition_in(key_block);
      transition_in(actionseditor.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(ruleeditor.$$.fragment, local);
      transition_in(tagseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sourceeditor.$$.fragment, local);
      transition_out(clientselector.$$.fragment, local);
      transition_out(key_block);
      transition_out(actionseditor.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(ruleeditor.$$.fragment, local);
      transition_out(tagseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div17);
      destroy_component(sourceeditor);
      destroy_component(clientselector);
      key_block.d(detaching);
      ctx[27](null);
      destroy_component(actionseditor);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(ruleeditor);
      destroy_component(tagseditor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$1D(ctx) {
  let sieveoptionslayout;
  let current;
  sieveoptionslayout = new Layout({
    props: {
      title: TXT("l_options") + " - " + (ctx[0].isNew() ? TXT("l_add_monitor") : ctx[0].get("name")),
      $$slots: { content: [create_content_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(sieveoptionslayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveoptionslayout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveoptionslayout_changes = {};
      if (dirty[0] & 1)
        sieveoptionslayout_changes.title = TXT("l_options") + " - " + (ctx2[0].isNew() ? TXT("l_add_monitor") : ctx2[0].get("name"));
      if (dirty[0] & 262143 | dirty[1] & 8388608) {
        sieveoptionslayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      sieveoptionslayout.$set(sieveoptionslayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveoptionslayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveoptionslayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveoptionslayout, detaching);
    }
  };
}
function instance$1A($$self, $$props, $$invalidate) {
  let $rule, $$unsubscribe_rule = noop$1, $$subscribe_rule = () => ($$unsubscribe_rule(), $$unsubscribe_rule = subscribe(rule, ($$value) => $$invalidate(15, $rule = $$value)), rule);
  let $model, $$unsubscribe_model = noop$1, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe(model, ($$value) => $$invalidate(16, $model = $$value)), model);
  let $querystring;
  let $permissionsModel;
  component_subscribe($$self, querystring, ($$value) => $$invalidate(36, $querystring = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_rule());
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  let { model } = $$props;
  $$subscribe_model();
  let { formModel } = $$props;
  let { defaultModel = null } = $$props;
  setContext("bbModel", model);
  let sieveConditionInputs = getSieveConditionInputs($model);
  let mdsDatasource;
  const fetchConditionsSchema = async () => {
    var _a;
    const convertToJsonSchema = (schema2) => {
      schema2.type = schema2.type.toLowerCase();
      if (schema2.type === "object") {
        schema2.properties = schema2.schema;
        delete schema2.schema;
        Object.keys(schema2.properties).forEach((key) => {
          convertToJsonSchema(schema2.properties[key]);
        });
      }
    };
    let schema = void 0;
    if (model.isScraperDatasource() && $model.datasource_id !== C$1.DS_ID_SCRAPER) {
      $$invalidate(3, mdsDatasource = await Api.api(`/datasources/${$model.datasource_id}`, "GET"));
      schema = JSON.parse(JSON.stringify(mdsDatasource.schema));
      convertToJsonSchema(schema);
    } else if (model.get("datasource_id") === C$1.DS_ID_UPTIME) {
      schema = UPTIME_JSON_SCHEMA;
    } else if (model.get("datasource_id") === C$1.DS_ID_JSON) {
      if ($model.prefs.schema) {
        schema = (_a = $model.prefs) == null ? void 0 : _a.schema;
      } else {
        const sieveDataList = new SieveDataCollection([], { sieveId: model.id });
        await sieveDataList.fetch({
          data: { _opt: { limit: 1, order: ["-ts"] } }
        });
        schema = generateSchemaFromJSON(JSON.parse(sieveDataList.at(0).get("data")));
      }
    }
    $$invalidate(2, sieveConditionInputs = sieveConditionInputs.map((inp) => {
      if (["$new", "$old"].includes(inp.id)) {
        return { ...inp, schema };
      }
      return inp;
    }));
  };
  fetchConditionsSchema().catch((e) => console.error("Failed to fetch conditions schema ", e));
  let query = qs.parse($querystring);
  const user = App.user;
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(17, $permissionsModel = value));
  const intialSelectedMacro = $model.macro_id;
  const initialParams = model.get("config").get("params");
  let saving = false;
  let rule;
  let actions;
  let actionEditor;
  let sitemapAttributes = $model.content_type === C$1.TYPE_SITEMAP ? {
    editors: {
      AUTO: {
        name: "Auto",
        component: AutoScheduleMessage
      }
    },
    id: $model.crawler_id
  } : {};
  let showGlobalActionEditor2 = false;
  let showManageEmailsModal = false;
  let showManagePhonesModal = false;
  let rerenderSchedule = false;
  let nameInputReject;
  let showTestConditionsV2Modal = false;
  let conditionsDebuggerSieveDataIds = void 0;
  if (query.debug_conditions) {
    try {
      const [previousSieveId, nextSieveId] = query.debug_conditions.split("..");
      showTestConditionsV2Modal = true;
      conditionsDebuggerSieveDataIds = { previousSieveId, nextSieveId };
    } catch (e) {
      console.error("Invalid format for sieveDataIds ", query.debug_conditions, e);
    }
  }
  if (model.isNew() || $model.state === C$1.STATE_INIT) {
    createDefaults();
  }
  function showModal(e) {
    const type = e.detail;
    if (type === "email") {
      $$invalidate(9, showManageEmailsModal = true);
    } else if (type === "phone") {
      $$invalidate(10, showManagePhonesModal = true);
    }
  }
  async function createDefaults() {
    $$invalidate(6, actions = new Model$2.SieveActions(null, { parent: model }));
    $$subscribe_rule($$invalidate(5, rule = new Model$2.SieveRule()));
    if (defaultModel) {
      return copyRef(defaultModel, true);
    }
    const uri = $model.uri;
    const hostname = uri && new URL(uri).hostname;
    const colln = new Model$2.Sieves();
    if (!$model.name && uri) {
      setDefaultName();
    }
    await colln.fetch({
      data: {
        "uri.like": `%${hostname}%`,
        "state.in": [C$1.STATE_READY, C$1.STATE_PAUSED],
        content_type: $model.content_type,
        _opt: {
          limit: 1,
          order: ["-ts"],
          only: ["id", "schedule", "tags"]
        }
      }
    });
    if (colln.length > 0) {
      return copyRef(colln.at(0), false);
    }
    await colln.fetch({
      data: {
        "state.in": [C$1.STATE_READY, C$1.STATE_PAUSED],
        content_type: $model.content_type,
        _opt: {
          limit: 1,
          order: ["-ts"],
          only: ["id", "schedule", "tags"]
        }
      }
    });
    if (colln.length > 0) {
      return copyRef(colln.at(0), false);
    }
    Model$2.SieveActionDescList.forEach((desc) => {
      if (desc.addByDefault(Supports)) {
        actions.add(new Model$2.SieveAction[desc.type](null, { parse: true }));
      }
    });
  }
  async function getWebpageTitle() {
    try {
      const response = await Api.utils("/sieve/on-demand/run", "POST", {
        uri: $model.uri,
        config: JSON.stringify({
          selections: [
            {
              frames: [
                {
                  index: 0,
                  excludes: [],
                  includes: [{ expr: "head > title", type: "css" }]
                }
              ],
              dynamic: false,
              delay: 0
            }
          ],
          regexp: null,
          ignoreEmptyText: true,
          includeStyle: true,
          viewport: {},
          dataAttr: "text"
        }),
        content_type: C$1.TYPE_HTML
      });
      return response.text;
    } catch (e) {
      console.log("Failed to fetch title", e);
    }
  }
  async function setDefaultName() {
    let title;
    if ($model.content_type === C$1.TYPE_HTML) {
      set_store_value(model, $model.name = TXT("l_loading"), $model);
      const nameInputPromise = new Promise((_2, rej) => $$invalidate(12, nameInputReject = rej));
      title = await Promise.race([
        getWebpageTitle(),
        nameInputPromise,
        new Promise((res) => setTimeout(() => res(), 1e4))
      ]);
    }
    set_store_value(model, $model.name = title || getNameFromURL(formModel.fields.uri.get()), $model);
  }
  async function copyRef(ref, defaultRules) {
    const refActions = new Model$2.SieveActions(null, { parent: ref });
    try {
      await refActions.fetch({ data: { state: 0 } });
      refActions.forEach((action) => {
        actions.add(action.clone({ omit: ["id", "sieve_id", "ts", "ts_mod"] }));
      });
    } catch (e) {
    }
    let refSchedule = ref.get("schedule");
    if (refSchedule.get("type") !== "LIVE") {
      formModel.fields.schedule.set(refSchedule.toJSON());
      $$invalidate(11, rerenderSchedule = true);
    }
    const rule_id = ref.get("rule_id");
    if (defaultRules && rule_id) {
      const refRule = new Model$2.SieveRule({ id: rule_id });
      await refRule.fetch();
      rule.set(refRule.pick("config", "version"));
    }
  }
  async function save() {
    $$invalidate(4, saving = true);
    Msg.start("sieve:save", { info: "saving" });
    try {
      const schemas = model.get("schemas");
      const schemaIds = model.get("schema_ids");
      const macro = model.get("macro");
      if (schemas && schemaIds && macro) {
        await saveSchemaList(schemas);
        const macroRes = await saveMacro(macro, { scraper: true });
        model.set("macro_id", macroRes.id);
      }
      const { config, macro_id } = model.attributes;
      if (macro_id !== intialSelectedMacro && $model.content_type === C$1.TYPE_HTML) {
        const configParams = config.get("params");
        if (configParams && initialParams) {
          if (JSON.stringify(initialParams) === JSON.stringify(configParams)) {
            config.unset("params");
          }
        }
      }
      await saveRules();
      let crawler = model.get("crawler");
      if (crawler) {
        if (crawler.isNew()) {
          crawler.set({ name: model.get("name") + " | Crawler" });
        }
        await crawler.save();
        model.set("crawler_id", crawler.id);
      }
      const attrs = _.omit(model.toJSON(), "err", "text", "ts", "ts_data", "ts_mod", "ts_view", "user_id");
      if (attrs.state == C$1.STATE_INIT) {
        attrs.state = C$1.STATE_READY;
      }
      try {
        const res = await model.save(null, {
          data: attrs,
          patch: true,
          silent: true,
          wait: true
        });
        Msg.stop("sieve:save");
        await saveSieveSchema(res);
      } catch (e) {
        Msg.stop("sieve:save", {
          error: "Failed to save changes to server"
        });
      }
      const isValid2 = actions.validateActions();
      if (isValid2) {
        await saveActions();
        App.navBack();
      }
    } catch (e) {
      Msg.error("Failed to save data. Please check console for more info.");
      console.error(e);
    }
    $$invalidate(4, saving = false);
  }
  async function saveActions() {
    const changes = actionEditor.getChanges();
    await base.syncBatch(changes);
  }
  async function saveRules() {
    if (rule.isNew() && rule.isEmpty()) {
      return;
    }
    Msg.start("sieve:rule:save", { info: "l_loading" });
    try {
      await rule.save();
      if ($model.rule_id != rule.id) {
        model.set({ rule_id: rule.id }, { silent: true });
      }
      Msg.stop("sieve:rule:save");
    } catch (e) {
      Msg.stop("sieve:rule:save", { error: "e_req" });
      Msg.error("Failed to save conditions");
      throw new Error("Failed to save conditions", { cause: e });
    }
  }
  async function saveMacro(macro, meta = {}) {
    const macro_id = model.get("macro_id");
    const payload = { ...macro, meta, version: 2 };
    if (macro_id) {
      return await Api.api(`/macros/${macro_id}`, "PATCH", payload);
    } else {
      return await Api.api("/macros", "POST", payload);
    }
  }
  async function saveSchemaList(schemas) {
    return await Api.api("/schemas/save", "POST", schemas);
  }
  async function saveSieveSchema(sieve) {
    try {
      const { id: sieve_id, schema_ids } = model.toJSON();
      if (schema_ids && sieve_id) {
        let res = await Api.api(`/sieve-schemas/sieves/${sieve_id}`, "POST", { schema_ids });
        if (res && res.msg == "error") {
          throw new Error("Failed to save sieve schema");
        }
      }
    } catch (e) {
      Msg.error("Failed to save sieve schema");
      throw new Error("Failed to save sieve schema", { cause: e });
    }
  }
  const saveGlobalRules = async (globalRules) => {
    if (!globalRules)
      return;
    let version = globalRules.version;
    let config = globalRules.config.toJSON();
    try {
      await Api.api("/prefs/rule", "PUT", { ...config, version });
    } catch (e) {
      console.error("failed to update global conditions", e);
      Msg.error("Failed to save data, please try again later");
    }
  };
  const onSaveRules = async (sieveRules, globalRules) => {
    $$invalidate(13, showTestConditionsV2Modal = false);
    await saveGlobalRules(globalRules);
    set_store_value(rule, $rule = sieveRules, $rule);
  };
  onMount(() => {
    trackEvent(PHEvents.SIEVE_EDIT_OPTIONS_OPEN, { sieve_id: model.id, isNew: model.isNew() });
  });
  function input_input_handler() {
    $model.name = this.value;
    model.set($model);
  }
  const input_handler = () => {
    nameInputReject == null ? void 0 : nameInputReject("User started typing name, cancelling title fetch");
  };
  function actionseditor_actions_binding(value) {
    actions = value;
    $$invalidate(6, actions);
  }
  function actionseditor_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      actionEditor = $$value;
      $$invalidate(7, actionEditor);
    });
  }
  const globalaction_handler = () => {
    $$invalidate(8, showGlobalActionEditor2 = true);
  };
  const close_handler = () => $$invalidate(8, showGlobalActionEditor2 = false);
  const close_handler_1 = () => $$invalidate(9, showManageEmailsModal = false);
  const close_handler_2 = () => $$invalidate(10, showManagePhonesModal = false);
  const click_handler = () => $$invalidate(13, showTestConditionsV2Modal = true);
  const func2 = () => {
    $$invalidate(13, showTestConditionsV2Modal = false);
  };
  const func_12 = async (setGlobalCount, sieveRules, globalRules) => {
    await onSaveRules(sieveRules, globalRules);
    await setGlobalCount();
  };
  function ruleeditor_rule_binding(value) {
    rule = value;
    $$subscribe_rule($$invalidate(5, rule));
  }
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$subscribe_model($$invalidate(0, model = $$props2.model));
    if ("formModel" in $$props2)
      $$invalidate(1, formModel = $$props2.formModel);
    if ("defaultModel" in $$props2)
      $$invalidate(23, defaultModel = $$props2.defaultModel);
  };
  return [
    model,
    formModel,
    sieveConditionInputs,
    mdsDatasource,
    saving,
    rule,
    actions,
    actionEditor,
    showGlobalActionEditor2,
    showManageEmailsModal,
    showManagePhonesModal,
    rerenderSchedule,
    nameInputReject,
    showTestConditionsV2Modal,
    conditionsDebuggerSieveDataIds,
    $rule,
    $model,
    $permissionsModel,
    permissionsModel,
    sitemapAttributes,
    showModal,
    save,
    onSaveRules,
    defaultModel,
    input_input_handler,
    input_handler,
    actionseditor_actions_binding,
    actionseditor_binding,
    globalaction_handler,
    close_handler,
    close_handler_1,
    close_handler_2,
    click_handler,
    func2,
    func_12,
    ruleeditor_rule_binding
  ];
}
class SieveOptions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1A, create_fragment$1D, safe_not_equal, { model: 0, formModel: 1, defaultModel: 23 }, null, [-1, -1]);
  }
}
function create_if_block_5$9(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_catch_block$j(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$j(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] && create_if_block$S(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$S(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$S(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_1$D, create_if_block_2$t, create_if_block_3$m, create_if_block_4$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6] === ctx2[8].UPGRADE_ACCOUNT)
      return 0;
    if (ctx2[6] === ctx2[8].OVERLIMIT)
      return 1;
    if (ctx2[6] === ctx2[8].SOURCE_SELECTOR)
      return 2;
    if (ctx2[6] === ctx2[8].SIEVE_OPTIONS)
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "flex flex-col items-stretch");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_4$f(ctx) {
  let sieveoptions;
  let current;
  sieveoptions = new SieveOptions({
    props: {
      model: ctx[0],
      formModel: ctx[1],
      defaultModel: ctx[3]
    }
  });
  return {
    c() {
      create_component(sieveoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveoptions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveoptions_changes = {};
      if (dirty & 1)
        sieveoptions_changes.model = ctx2[0];
      if (dirty & 2)
        sieveoptions_changes.formModel = ctx2[1];
      if (dirty & 8)
        sieveoptions_changes.defaultModel = ctx2[3];
      sieveoptions.$set(sieveoptions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveoptions, detaching);
    }
  };
}
function create_if_block_3$m(ctx) {
  let sourceselector;
  let current;
  sourceselector = new SourceSelector({
    props: {
      model: ctx[0],
      formModel: ctx[1]
    }
  });
  sourceselector.$on("save", ctx[11]);
  sourceselector.$on("discard", ctx[10]);
  return {
    c() {
      create_component(sourceselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sourceselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sourceselector_changes = {};
      if (dirty & 1)
        sourceselector_changes.model = ctx2[0];
      if (dirty & 2)
        sourceselector_changes.formModel = ctx2[1];
      sourceselector.$set(sourceselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sourceselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sourceselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sourceselector, detaching);
    }
  };
}
function create_if_block_2$t(ctx) {
  let sieveconstraint;
  let current;
  sieveconstraint = new SieveConstraint({
    props: { constraint: ctx[5] }
  });
  return {
    c() {
      create_component(sieveconstraint.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sieveconstraint, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sieveconstraint_changes = {};
      if (dirty & 32)
        sieveconstraint_changes.constraint = ctx2[5];
      sieveconstraint.$set(sieveconstraint_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveconstraint.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveconstraint.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sieveconstraint, detaching);
    }
  };
}
function create_if_block_1$D(ctx) {
  let upgradeaccount;
  let current;
  upgradeaccount = new UpgradeAccount({
    props: {
      type: ctx[0].getTypeName(),
      minPlan: ctx[4].minPlan
    }
  });
  return {
    c() {
      create_component(upgradeaccount.$$.fragment);
    },
    m(target, anchor) {
      mount_component(upgradeaccount, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const upgradeaccount_changes = {};
      if (dirty & 1)
        upgradeaccount_changes.type = ctx2[0].getTypeName();
      if (dirty & 16)
        upgradeaccount_changes.minPlan = ctx2[4].minPlan;
      upgradeaccount.$set(upgradeaccount_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(upgradeaccount.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(upgradeaccount.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(upgradeaccount, detaching);
    }
  };
}
function create_pending_block$j(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_fragment$1C(ctx) {
  let div;
  let button;
  let i2;
  let t0;
  let t1_value = TXT("a_discard") + "";
  let t1;
  let t2;
  let t3;
  let await_block_anchor;
  let promise_1;
  let current;
  let if_block = ctx[2] && create_if_block_5$9();
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$j,
    then: create_then_block$j,
    catch: create_catch_block$j,
    value: 23,
    blocks: [, , ,]
  };
  handle_promise(promise_1 = ctx[7], info);
  return {
    c() {
      div = element("div");
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      await_block_anchor = empty();
      info.block.c();
      attr(i2, "class", "fa fa-chevron-left");
      attr(button, "class", "btn btn-default");
      attr(button, "data-action", "go_back");
      attr(div, "class", "xtbar xvbar-margin mb-4 ml-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, i2);
      append(button, t0);
      append(button, t1);
      append(div, t2);
      if (if_block)
        if_block.m(div, null);
      insert(target, t3, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (ctx[2]) {
        if (if_block) {
          if (dirty & 4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$9();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      info.ctx = ctx;
      if (dirty & 128 && promise_1 !== (promise_1 = ctx[7]) && handle_promise(promise_1, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      for (let i3 = 0; i3 < 3; i3 += 1) {
        const block = info.blocks[i3];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      if (detaching)
        detach(t3);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$1z($$self, $$props, $$invalidate) {
  let $model, $$unsubscribe_model = noop$1, $$subscribe_model = () => ($$unsubscribe_model(), $$unsubscribe_model = subscribe(model, ($$value) => $$invalidate(17, $model = $$value)), model);
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(18, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_model());
  const user = getContext("user");
  const views = {
    UPGRADE_ACCOUNT: "upgrade_account",
    OVERLIMIT: "overlimit",
    SOURCE_SELECTOR: "source_selector",
    SIEVE_OPTIONS: "sieve_options"
  };
  let model;
  let formModel;
  let { id: id2, data: type, query } = $route;
  let loading2 = true;
  let defaultModel;
  let accessInfo;
  let sieveConstraint = {};
  let view;
  let newSieve;
  let promise;
  let prevRouteProperties = void 0;
  const routeUnsubscribe = route.subscribe((newRoute) => {
    if ((prevRouteProperties == null ? void 0 : prevRouteProperties.prefix) === newRoute.prefix && (prevRouteProperties == null ? void 0 : prevRouteProperties.wild) === newRoute.wild) {
      if (JSON.stringify(prevRouteProperties == null ? void 0 : prevRouteProperties.query) === JSON.stringify(newRoute.query)) {
        prevRouteProperties = newRoute;
        return;
      }
    }
    prevRouteProperties = newRoute;
    if (newRoute.prefix == "dup" || newRoute.prefix == "add" || newRoute.prefix == "edit") {
      ({ id: id2, data: type, query } = newRoute);
      $$subscribe_model($$invalidate(0, model = void 0));
      $$invalidate(7, promise = setModel());
    }
  });
  onDestroy(() => {
    if (formModel) {
      formModel.unsubscribe();
    }
    if (routeUnsubscribe) {
      routeUnsubscribe();
    }
  });
  async function fetch2(id3) {
    let model2 = new Model$2.Sieve({ id: id3 });
    await model2.fetch();
    return model2;
  }
  async function setModel() {
    $$invalidate(2, loading2 = true);
    newSieve = false;
    if (formModel) {
      formModel.unsubscribe();
    }
    if (id2) {
      $$subscribe_model($$invalidate(0, model = await fetch2(id2)));
      if ($route.prefix === "dup") {
        const json = _.pick(model.toJSON(), "name", "uri", "config", "client_id", "content_type", "schedule", "tags", "datasource_id", "macro_id", "proxy_id", "session_id", "meta", "prefs");
        json.name = "Copy of " + json.name;
        $$invalidate(3, defaultModel = model);
        $$subscribe_model($$invalidate(0, model = new Model$2.Sieve(json, { parse: true })));
        await model.setMeta({ action: "duplicate" });
      }
    } else if (!model) {
      let content_type = 0;
      let attrs = {};
      switch (type) {
        case "page":
          break;
        case "feed":
          content_type = C$1.TYPE_FEED;
          break;
        case "xml":
          content_type = C$1.TYPE_XML;
          break;
        case "pdf":
          content_type = C$1.TYPE_PDF_HTML;
          break;
        case "doc":
          content_type = C$1.TYPE_DOC;
          break;
        case "json":
          content_type = C$1.TYPE_JSON;
          switch (query.type) {
            case C$1.DS_TYPE_UPTIME:
              attrs.datasource_id = C$1.DS_ID_UPTIME;
              break;
            case C$1.DS_TYPE_SCRAPER:
              attrs.datasource_id = C$1.DS_ID_SCRAPER;
              break;
            case C$1.DS_TYPE_JSON:
            default:
              attrs.datasource_id = C$1.DS_ID_JSON;
          }
          break;
        case "sitemap":
          content_type = C$1.TYPE_SITEMAP;
          break;
        default:
          Msg.error("Unknown monitor type: " + type);
      }
      $$subscribe_model($$invalidate(0, model = new Model$2.Sieve(
        {
          uri: query.url,
          content_type,
          version: 1,
          config: {},
          ...attrs
        },
        { parse: true }
      )));
      await model.setMeta({ action: "add" });
      newSieve = true;
    }
    $$invalidate(1, formModel = new SieveFormModel(model));
    await setView();
    $$invalidate(2, loading2 = false);
  }
  async function setView() {
    $$invalidate(6, view = "");
    try {
      $$invalidate(5, sieveConstraint = await checkSieveConstraint(1));
    } catch (e) {
      console.error(e);
      $$invalidate(5, sieveConstraint = { isOverLimit: false });
    }
    $$invalidate(4, accessInfo = await model.getAccess(user));
    if (model.isNew() && !accessInfo.hasAccess) {
      $$invalidate(6, view = views.UPGRADE_ACCOUNT);
    } else if (model.isNew() && sieveConstraint.isOverLimit) {
      $$invalidate(6, view = views.OVERLIMIT);
    } else if (newSieve) {
      $$invalidate(6, view = views.SOURCE_SELECTOR);
    } else {
      $$invalidate(6, view = views.SIEVE_OPTIONS);
    }
  }
  function onDiscard() {
    if ($model.content_type === C$1.TYPE_HTML || $model.content_type === C$1.TYPE_SITEMAP) {
      App.navBack();
    }
  }
  const save_handler = () => setModel();
  return [
    model,
    formModel,
    loading2,
    defaultModel,
    accessInfo,
    sieveConstraint,
    view,
    promise,
    views,
    setModel,
    onDiscard,
    save_handler
  ];
}
class Sieve_options extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1z, create_fragment$1C, safe_not_equal, {});
  }
}
function create_fragment$1B(ctx) {
  let div;
  let input;
  let t0;
  let button;
  let t1;
  let button_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      button = element("button");
      t1 = text(ctx[1]);
      attr(input, "class", "d-none");
      attr(input, "type", "file");
      attr(input, "accept", ctx[0]);
      attr(button, "class", button_class_value = "btn btn-primary btn-lg " + ctx[3]);
      attr(div, "class", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      ctx[7](input);
      append(div, t0);
      append(div, button);
      append(button, t1);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[5]),
          listen(button, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(input, "accept", ctx2[0]);
      }
      if (dirty & 2)
        set_data(t1, ctx2[1]);
      if (dirty & 8 && button_class_value !== (button_class_value = "btn btn-primary btn-lg " + ctx2[3])) {
        attr(button, "class", button_class_value);
      }
      if (dirty & 4) {
        attr(div, "class", ctx2[2]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1y($$self, $$props, $$invalidate) {
  let { accept } = $$props;
  let { label } = $$props;
  let { wrapperClasses = "" } = $$props;
  const dispatch = createEventDispatcher();
  let fileInputEl;
  let { class: classes } = $$props;
  function onFileChange(e) {
    const file = e.target.files[0];
    const reader = new FileReader();
    let filename = file.name;
    reader.readAsText(file, "utf-8");
    reader.onload = (e2) => {
      dispatch("read", { filename, data: e2.target.result });
    };
    reader.onerror = (e2) => {
      console.error("error reading file", e2);
      dispatch("error", { error: e2.message });
    };
  }
  function onFileSelect() {
    fileInputEl.click();
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fileInputEl = $$value;
      $$invalidate(4, fileInputEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("accept" in $$props2)
      $$invalidate(0, accept = $$props2.accept);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("wrapperClasses" in $$props2)
      $$invalidate(2, wrapperClasses = $$props2.wrapperClasses);
    if ("class" in $$props2)
      $$invalidate(3, classes = $$props2.class);
  };
  return [
    accept,
    label,
    wrapperClasses,
    classes,
    fileInputEl,
    onFileChange,
    onFileSelect,
    input_binding
  ];
}
class FilePicker extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1y, create_fragment$1B, safe_not_equal, {
      accept: 0,
      label: 1,
      wrapperClasses: 2,
      class: 3
    });
  }
}
function create_default_slot$J(ctx) {
  let textarea;
  let textarea_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "id", "json");
      attr(textarea, "class", textarea_class_value = ctx[10] + " h-[400px] w-100");
      toggle_class(textarea, "is-invalid", ctx[12]);
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      if (!mounted) {
        dispose = action_destroyer(ctx[11].call(null, textarea));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && textarea_class_value !== (textarea_class_value = ctx2[10] + " h-[400px] w-100")) {
        attr(textarea, "class", textarea_class_value);
      }
      if (dirty & 5120) {
        toggle_class(textarea, "is-invalid", ctx2[12]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$R(ctx) {
  let div;
  let t0;
  let t1;
  return {
    c() {
      div = element("div");
      t0 = text("Error Occurred : ");
      t1 = text(ctx[0]);
      attr(div, "class", "text-danger");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t1, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1A(ctx) {
  let div1;
  let filepicker;
  let t0;
  let h4;
  let t2;
  let label;
  let t4;
  let fieldwrapper;
  let t5;
  let div0;
  let button;
  let t6;
  let t7;
  let current;
  let mounted;
  let dispose;
  filepicker = new FilePicker({
    props: {
      label: "Select JSON file",
      accept: ".json"
    }
  });
  filepicker.$on("read", ctx[4]);
  filepicker.$on("error", ctx[6]);
  fieldwrapper = new FieldWrapper({
    props: {
      field: ctx[2],
      formatOptions: { showEmpty: false },
      $$slots: {
        default: [
          create_default_slot$J,
          ({ inputClasses, action, showError }) => ({
            10: inputClasses,
            11: action,
            12: showError
          }),
          ({ inputClasses, action, showError }) => (inputClasses ? 1024 : 0) | (action ? 2048 : 0) | (showError ? 4096 : 0)
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[0] && create_if_block$R(ctx);
  return {
    c() {
      div1 = element("div");
      create_component(filepicker.$$.fragment);
      t0 = space();
      h4 = element("h4");
      h4.textContent = "OR";
      t2 = space();
      label = element("label");
      label.textContent = "Paste JSON here";
      t4 = space();
      create_component(fieldwrapper.$$.fragment);
      t5 = space();
      div0 = element("div");
      button = element("button");
      t6 = text("Next");
      t7 = space();
      if (if_block)
        if_block.c();
      attr(h4, "class", "my-3 ms-4");
      attr(label, "class", "form-label fs-5");
      attr(label, "for", "json");
      attr(button, "class", "btn btn-primary");
      button.disabled = ctx[1];
      attr(div0, "class", "mt-4 ms-2");
      attr(div1, "class", "mt-4 ms-4");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(filepicker, div1, null);
      append(div1, t0);
      append(div1, h4);
      append(div1, t2);
      append(div1, label);
      append(div1, t4);
      mount_component(fieldwrapper, div1, null);
      append(div1, t5);
      append(div1, div0);
      append(div0, button);
      append(button, t6);
      append(div1, t7);
      if (if_block)
        if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const fieldwrapper_changes = {};
      if (dirty & 13312) {
        fieldwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      fieldwrapper.$set(fieldwrapper_changes);
      if (!current || dirty & 2) {
        button.disabled = ctx2[1];
      }
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$R(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(filepicker.$$.fragment, local);
      transition_in(fieldwrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filepicker.$$.fragment, local);
      transition_out(fieldwrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(filepicker);
      destroy_component(fieldwrapper);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$1x($$self, $$props, $$invalidate) {
  let $jsonField;
  let $error;
  const jsonField = createFieldStore({ type: "jsonStr", required: true }, null);
  component_subscribe($$self, jsonField, (value) => $$invalidate(8, $jsonField = value));
  const { error: error2 } = jsonField;
  component_subscribe($$self, error2, (value) => $$invalidate(1, $error = value));
  const dispatch = createEventDispatcher();
  let data;
  let err;
  function onRead(e) {
    ({ data } = e.detail);
    jsonField.set(data, { parse: true });
  }
  function onClick() {
    dispatch("next", { rows: $jsonField });
  }
  function onError(e) {
    $$invalidate(0, { error: err } = e.detail, err);
  }
  return [err, $error, jsonField, error2, onRead, onClick, onError];
}
class PickFileStage$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1x, create_fragment$1A, safe_not_equal, {});
  }
}
function create_if_block_5$8(ctx) {
  let globalactionseditormodal;
  let current;
  globalactionseditormodal = new GlobalActionsEditorModal({});
  globalactionseditormodal.$on("close", ctx[17]);
  return {
    c() {
      create_component(globalactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalactionseditormodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(globalactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalactionseditormodal, detaching);
    }
  };
}
function create_if_block_4$e(ctx) {
  let manageemailsmodal;
  let current;
  manageemailsmodal = new ManageEmailModal({});
  manageemailsmodal.$on("close", ctx[18]);
  return {
    c() {
      create_component(manageemailsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(manageemailsmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(manageemailsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(manageemailsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(manageemailsmodal, detaching);
    }
  };
}
function create_if_block_3$l(ctx) {
  let managephonesmodal;
  let current;
  managephonesmodal = new ManagePhonesModal({});
  managephonesmodal.$on("close", ctx[19]);
  return {
    c() {
      create_component(managephonesmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managephonesmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(managephonesmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managephonesmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managephonesmodal, detaching);
    }
  };
}
function create_if_block_2$s(ctx) {
  let div;
  let t0;
  let span0;
  let t1;
  let t2;
  let span1;
  let t3;
  return {
    c() {
      div = element("div");
      t0 = text("Importing Monitors: ");
      span0 = element("span");
      t1 = text(ctx[5]);
      t2 = text(" of ");
      span1 = element("span");
      t3 = text(ctx[6]);
      attr(div, "class", "text-lg");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, span0);
      append(span0, t1);
      append(div, t2);
      append(div, span1);
      append(span1, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t1, ctx2[5]);
      if (dirty & 64)
        set_data(t3, ctx2[6]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$C(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.textContent = "Back";
      t1 = space();
      button1 = element("button");
      button1.textContent = `${TXT("a_import")}`;
      attr(button0, "class", "btn btn-default");
      attr(button1, "class", "btn btn-primary");
      attr(div, "class", "d-flex gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[20]),
          listen(button1, "click", ctx[12])
        ];
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$Q(ctx) {
  let div;
  let t_value = (ctx[7] || "") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "text-lg ps-2");
      toggle_class(div, "text-success", ctx[1] === ctx[10].COMPLETE);
      toggle_class(div, "text-danger", ctx[1] === ctx[10].ERROR);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 128 && t_value !== (t_value = (ctx2[7] || "") + ""))
        set_data(t, t_value);
      if (dirty & 1026) {
        toggle_class(div, "text-success", ctx2[1] === ctx2[10].COMPLETE);
      }
      if (dirty & 1026) {
        toggle_class(div, "text-danger", ctx2[1] === ctx2[10].ERROR);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1z(ctx) {
  let div0;
  let t1;
  let div5;
  let div2;
  let label0;
  let t3;
  let div1;
  let clientselector;
  let t4;
  let div4;
  let label1;
  let t6;
  let div3;
  let actionseditor;
  let updating_actions;
  let t7;
  let t8;
  let t9;
  let t10;
  let div6;
  let t11;
  let current;
  clientselector = new ClientSelector({
    props: {
      model: ctx[9],
      showAllClients: true
    }
  });
  function actionseditor_actions_binding(value) {
    ctx[15](value);
  }
  let actionseditor_props = {};
  if (ctx[0] !== void 0) {
    actionseditor_props.actions = ctx[0];
  }
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  binding_callbacks.push(() => bind$1(actionseditor, "actions", actionseditor_actions_binding));
  actionseditor.$on("manage", ctx[13]);
  actionseditor.$on("globalaction", ctx[16]);
  let if_block0 = ctx[2] && create_if_block_5$8(ctx);
  let if_block1 = ctx[3] && create_if_block_4$e(ctx);
  let if_block2 = ctx[4] && create_if_block_3$l(ctx);
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] !== ctx2[10].COMPLETE)
      return create_if_block_1$C;
    if (ctx2[1] === ctx2[10].IMPORTING)
      return create_if_block_2$s;
  }
  let current_block_type = select_block_type(ctx);
  let if_block3 = current_block_type && current_block_type(ctx);
  let if_block4 = ctx[7] && create_if_block$Q(ctx);
  return {
    c() {
      div0 = element("div");
      div0.innerHTML = `<h3>Options</h3>`;
      t1 = space();
      div5 = element("div");
      div2 = element("div");
      label0 = element("label");
      label0.textContent = "Device";
      t3 = space();
      div1 = element("div");
      create_component(clientselector.$$.fragment);
      t4 = space();
      div4 = element("div");
      label1 = element("label");
      label1.textContent = "Actions";
      t6 = space();
      div3 = element("div");
      create_component(actionseditor.$$.fragment);
      t7 = space();
      if (if_block0)
        if_block0.c();
      t8 = space();
      if (if_block1)
        if_block1.c();
      t9 = space();
      if (if_block2)
        if_block2.c();
      t10 = space();
      div6 = element("div");
      if (if_block3)
        if_block3.c();
      t11 = space();
      if (if_block4)
        if_block4.c();
      attr(div0, "class", "py-2 border-bottom");
      attr(label0, "class", "xoption-label");
      attr(div1, "class", "flex-1");
      attr(div2, "class", "flex gap-x-6");
      attr(label1, "class", "xoption-label");
      attr(div3, "class", "flex-1");
      attr(div4, "class", "flex gap-x-6");
      attr(div5, "class", "flex flex-col gap-y-6 p-[10px]");
      attr(div6, "class", "mt-4 ms-4");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div5, anchor);
      append(div5, div2);
      append(div2, label0);
      append(div2, t3);
      append(div2, div1);
      mount_component(clientselector, div1, null);
      append(div5, t4);
      append(div5, div4);
      append(div4, label1);
      append(div4, t6);
      append(div4, div3);
      mount_component(actionseditor, div3, null);
      append(div4, t7);
      if (if_block0)
        if_block0.m(div4, null);
      append(div4, t8);
      if (if_block1)
        if_block1.m(div4, null);
      append(div4, t9);
      if (if_block2)
        if_block2.m(div4, null);
      insert(target, t10, anchor);
      insert(target, div6, anchor);
      if (if_block3)
        if_block3.m(div6, null);
      append(div6, t11);
      if (if_block4)
        if_block4.m(div6, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const actionseditor_changes = {};
      if (!updating_actions && dirty & 1) {
        updating_actions = true;
        actionseditor_changes.actions = ctx2[0];
        add_flush_callback(() => updating_actions = false);
      }
      actionseditor.$set(actionseditor_changes);
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div4, t8);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$e(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div4, t9);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_3$l(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div4, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block3) {
        if_block3.p(ctx2, dirty);
      } else {
        if (if_block3)
          if_block3.d(1);
        if_block3 = current_block_type && current_block_type(ctx2);
        if (if_block3) {
          if_block3.c();
          if_block3.m(div6, t11);
        }
      }
      if (ctx2[7]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block$Q(ctx2);
          if_block4.c();
          if_block4.m(div6, null);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(clientselector.$$.fragment, local);
      transition_in(actionseditor.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(clientselector.$$.fragment, local);
      transition_out(actionseditor.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div5);
      destroy_component(clientselector);
      destroy_component(actionseditor);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach(t10);
      if (detaching)
        detach(div6);
      if (if_block3) {
        if_block3.d();
      }
      if (if_block4)
        if_block4.d();
    }
  };
}
function instance$1w($$self, $$props, $$invalidate) {
  let $clients;
  let $model;
  let { rows } = $$props;
  const labels = getContext("labels");
  const clients = getContext("clients");
  component_subscribe($$self, clients, (value) => $$invalidate(22, $clients = value));
  const model = new Model$2.Sieve();
  component_subscribe($$self, model, (value) => $$invalidate(23, $model = value));
  const IMPORT_STATUS = {
    INIT: 0,
    IMPORTING: 1,
    COMPLETE: 2,
    ERROR: 3
  };
  const dispatch = createEventDispatcher();
  let actions;
  let status = IMPORT_STATUS.INIT;
  let labelMap;
  let showGlobalActionEditor2 = false;
  let showManageEmailsModal = false;
  let showManagePhonesModal = false;
  let index2 = 0;
  let total;
  let message = "";
  async function populateLabelMap(sieves) {
    Msg.info("Importing labels...");
    const names = _.uniq(_.flatten(_.pluck(sieves, "tags"))).filter((tag) => tag);
    const labelList = await labels.getOrCreateLabels(names);
    labelMap = labelList.reduce((acc, { id: id2, name }) => (acc[name] = id2, acc), {});
    Msg.reset();
  }
  async function checkConstraint(numRows) {
    let constraint;
    try {
      constraint = await checkSieveConstraint(numRows);
    } catch (e) {
      console.error(e);
      constraint = { isOverLimit: false };
    }
    return constraint;
  }
  async function importAll() {
    try {
      $$invalidate(1, status = IMPORT_STATUS.IMPORTING);
      let sieves = rows.data;
      $$invalidate(6, total = sieves.length);
      const constraint = await checkConstraint(total);
      if (constraint.isOverLimit) {
        throw new Error("Monitor limit exceeded");
      }
      const isValidActions = actions.validateActions();
      if (!isValidActions) {
        throw new Error("Action fields required");
      }
      await populateLabelMap(sieves);
      const importedTime = new Date().getTime();
      for (let i2 = 0; i2 < sieves.length; i2 += 1) {
        const sieve = sieves[i2];
        await importOne(sieve, importedTime);
        $$invalidate(5, index2 += 1);
      }
      $$invalidate(1, status = IMPORT_STATUS.COMPLETE);
      $$invalidate(7, message = `Imported ${total} monitors`);
    } catch (e) {
      console.error("failed to import data:", e);
      $$invalidate(7, message = `Import failed: ${e.message || e.msg}`);
      $$invalidate(1, status = IMPORT_STATUS.ERROR);
    }
  }
  async function importOne(sieve, importedTime) {
    var _a;
    if ((_a = sieve.rule) == null ? void 0 : _a.config) {
      const config = sieve.rule.config || JSON.parse(sieve.rule);
      const version = sieve.rule.version || (config.hasOwnProperty("type") ? "1.0.0" : "2.0.0");
      const rule = await Api.api("/rules", "POST", { config, version });
      sieve.rule_id = rule.id;
    }
    if (sieve.tags) {
      sieve.tags = sieve.tags.map((name) => labelMap[name]).join(",");
    }
    let client_id = $model.client_id;
    if (!validateClient(client_id, sieve)) {
      client_id = C$1.CLIENT_ID_WEB;
    }
    delete sieve.ts;
    await model.setMeta({
      action: "import",
      type: "json",
      import_id: importedTime
    });
    let res = await Api.api("/sieves", "POST", {
      ...sieve,
      meta: model.get("meta"),
      client_id
    });
    const sieveId = res.id;
    await saveActions(sieveId);
  }
  function validateClient(selectedClientId, { content_type }) {
    const currSieve = new Model$2.Sieve({ content_type });
    const accessibleClients = currSieve.getAccessibleClients($clients);
    return !!accessibleClients.find((client) => selectedClientId === client.id);
  }
  async function saveActions(sieve_id) {
    const actionsList = actions.getPosts();
    for (let i2 = 0; i2 < actionsList.length; i2 += 1) {
      const doc = actionsList[i2].toJSON();
      await Api.api(`/sieves/${sieve_id}/actions`, "POST", { sieve_id, ...doc });
    }
  }
  function showModal(e) {
    const type = e.detail;
    if (type === "email") {
      $$invalidate(3, showManageEmailsModal = true);
    } else if (type === "phone") {
      $$invalidate(4, showManagePhonesModal = true);
    }
  }
  function actionseditor_actions_binding(value) {
    actions = value;
    $$invalidate(0, actions);
  }
  const globalaction_handler = () => {
    $$invalidate(2, showGlobalActionEditor2 = true);
  };
  const close_handler = () => $$invalidate(2, showGlobalActionEditor2 = false);
  const close_handler_1 = () => $$invalidate(3, showManageEmailsModal = false);
  const close_handler_2 = () => $$invalidate(4, showManagePhonesModal = false);
  const click_handler = () => dispatch("back");
  $$self.$$set = ($$props2) => {
    if ("rows" in $$props2)
      $$invalidate(14, rows = $$props2.rows);
  };
  return [
    actions,
    status,
    showGlobalActionEditor2,
    showManageEmailsModal,
    showManagePhonesModal,
    index2,
    total,
    message,
    clients,
    model,
    IMPORT_STATUS,
    dispatch,
    importAll,
    showModal,
    rows,
    actionseditor_actions_binding,
    globalaction_handler,
    close_handler,
    close_handler_1,
    close_handler_2,
    click_handler
  ];
}
class OptionsStage$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1w, create_fragment$1z, safe_not_equal, { rows: 14 });
  }
}
function create_if_block_1$B(ctx) {
  let optionsstage;
  let current;
  optionsstage = new OptionsStage$1({ props: { rows: ctx[1] } });
  optionsstage.$on("back", ctx[4]);
  return {
    c() {
      create_component(optionsstage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(optionsstage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const optionsstage_changes = {};
      if (dirty & 2)
        optionsstage_changes.rows = ctx2[1];
      optionsstage.$set(optionsstage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(optionsstage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(optionsstage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(optionsstage, detaching);
    }
  };
}
function create_if_block$P(ctx) {
  let pickfilestage;
  let current;
  pickfilestage = new PickFileStage$1({});
  pickfilestage.$on("next", ctx[5]);
  return {
    c() {
      create_component(pickfilestage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pickfilestage, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(pickfilestage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pickfilestage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pickfilestage, detaching);
    }
  };
}
function create_fragment$1y(ctx) {
  let div0;
  let h2;
  let t2;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$P, create_if_block_1$B];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === ctx2[2].PICK_FILE)
      return 0;
    if (ctx2[0] === ctx2[2].OPTIONS)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = `${TXT("a_import")} - JSON`;
      t2 = space();
      div1 = element("div");
      if (if_block)
        if_block.c();
      attr(div0, "class", "xpage-header");
      attr(div1, "class", "p-2 bg-white");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, h2);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div1, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function instance$1v($$self, $$props, $$invalidate) {
  const STAGE = { PICK_FILE: 1, OPTIONS: 2 };
  function nextStage() {
    $$invalidate(0, stage += 1);
  }
  function prevStage() {
    $$invalidate(0, stage -= 1);
  }
  let stage = STAGE.PICK_FILE;
  let rows;
  const next_handler = (e) => {
    $$invalidate(1, { rows } = e.detail, rows);
    nextStage();
  };
  return [stage, rows, STAGE, nextStage, prevStage, next_handler];
}
class Import_json extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1v, create_fragment$1y, safe_not_equal, {});
  }
}
function create_fragment$1x(ctx) {
  let div2;
  let div0;
  let filepicker;
  let t0;
  let div1;
  let current;
  filepicker = new FilePicker({
    props: {
      label: "Select CSV file to import monitors",
      accept: ".csv"
    }
  });
  filepicker.$on("read", ctx[0]);
  filepicker.$on("error", ctx[1]);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      create_component(filepicker.$$.fragment);
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `Please note that the file should have columns with following headers:
    <ul><li>Name</li> 
      <li>URL</li> 
      <li>Content Type (Optional)</li> 
      <li>Labels (Optional)</li> 
      <li>DatasourceID (Optional)</li></ul>`;
      attr(div0, "class", "col-md-4 d-flex justify-content-center order-1 order-md-0");
      attr(div1, "class", "col-md-4 fs-5 order-0 order-md-1");
      attr(div2, "class", "row align-items-center justify-content-center");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      mount_component(filepicker, div0, null);
      append(div2, t0);
      append(div2, div1);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(filepicker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filepicker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(filepicker);
    }
  };
}
function instance$1u($$self) {
  const dispatch = createEventDispatcher();
  let filename;
  function onFileRead(e) {
    const text2 = e.detail.data;
    Papa.parse(text2, {
      header: true,
      skipEmptyLines: true,
      complete: (result2) => dispatch("next", { filename, csv: result2 })
    });
  }
  function error_handler(event) {
    bubble.call(this, $$self, event);
  }
  return [onFileRead, error_handler];
}
class PickFileStage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1u, create_fragment$1x, safe_not_equal, {});
  }
}
function get_each_context$q(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2];
  child_ctx[22] = i2;
  return child_ctx;
}
function get_each_context_1$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2];
  return child_ctx;
}
function get_each_context_2$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  child_ctx[27] = list;
  child_ctx[28] = i2;
  return child_ctx;
}
function get_each_context_3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i2];
  return child_ctx;
}
function create_each_block_3(ctx) {
  let option;
  let t_value = ctx[29] + "";
  let t;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = ctx[29];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block_2$1(ctx) {
  let th;
  let div;
  let select2;
  let option;
  let t;
  let mounted;
  let dispose;
  let each_value_3 = Object.values(ctx[7]);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks[i2] = create_each_block_3(get_each_context_3(ctx, each_value_3, i2));
  }
  function select_change_handler() {
    ctx[14].call(select2, ctx[28]);
  }
  return {
    c() {
      th = element("th");
      div = element("div");
      select2 = element("select");
      option = element("option");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      option.__value = "";
      option.value = option.__value;
      if (ctx[1][ctx[28]] === void 0)
        add_render_callback(select_change_handler);
      attr(th, "class", "max-w-[150px] p-[5px]");
      set_style(th, "border", "solid 1px #ccc");
    },
    m(target, anchor) {
      insert(target, th, anchor);
      append(th, div);
      append(div, select2);
      append(select2, option);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      select_option(select2, ctx[1][ctx[28]], true);
      append(th, t);
      if (!mounted) {
        dispose = listen(select2, "change", select_change_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 128) {
        each_value_3 = Object.values(ctx[7]);
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3(ctx, each_value_3, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_3.length;
      }
      if (dirty[0] & 130) {
        select_option(select2, ctx[1][ctx[28]]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(th);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1$4(ctx) {
  let td;
  let t_value = ctx[20][ctx[23]] + "";
  let t;
  let td_title_value;
  return {
    c() {
      td = element("td");
      t = text(t_value);
      attr(td, "class", "max-w-[200px] p-[5px] overflow-x-scroll");
      set_style(td, "border", "solid 1px #ccc");
      set_style(td, "scrollbar-width", "thin");
      attr(td, "title", td_title_value = ctx[20][ctx[23]]);
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t_value !== (t_value = ctx2[20][ctx2[23]] + ""))
        set_data(t, t_value);
      if (dirty[0] & 1 && td_title_value !== (td_title_value = ctx2[20][ctx2[23]])) {
        attr(td, "title", td_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_each_block$q(ctx) {
  let tr;
  let td;
  let t0_value = ctx[22] + 1 + "";
  let t0;
  let t1;
  let t2;
  let each_value_1 = ctx[8];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i2));
  }
  return {
    c() {
      tr = element("tr");
      td = element("td");
      t0 = text(t0_value);
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      attr(td, "class", "max-w-[200px] p-[5px] overflow-x-scroll");
      set_style(td, "border", "solid 1px #ccc");
      set_style(td, "scrollbar-width", "thin");
      attr(tr, "class", "whitespace-nowrap");
      set_style(tr, "border-bottom", "solid 1px #ccc");
      toggle_class(tr, "bg-danger-subtle", ctx[3].has(ctx[22]));
      toggle_class(tr, "bg-secondary-subtle", ctx[5].has(ctx[22]));
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      append(td, t0);
      append(tr, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tr, null);
        }
      }
      append(tr, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 257) {
        each_value_1 = ctx2[8];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$4(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(tr, t2);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & 8) {
        toggle_class(tr, "bg-danger-subtle", ctx2[3].has(ctx2[22]));
      }
      if (dirty[0] & 32) {
        toggle_class(tr, "bg-secondary-subtle", ctx2[5].has(ctx2[22]));
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1$A(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].key === "url-validation")
      return create_if_block_2$r;
    return create_else_block$w;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "error mt-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_else_block$w(ctx) {
  let t_value = ctx[2].msg + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4 && t_value !== (t_value = ctx2[2].msg + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$r(ctx) {
  let t0_value = ctx[2].msg + "";
  let t0;
  let t1;
  let br0;
  let t2;
  let br1;
  let t3;
  let small;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" (highlighted in red)");
      br0 = element("br");
      t2 = text("Please check these rows and ensure the URLs conform to the expected\n        structure ");
      br1 = element("br");
      t3 = space();
      small = element("small");
      small.innerHTML = `<kbd title="protocol">https://</kbd>  <kbd title="host">example.com</kbd> 
          <kbd title="path">/path/to/resource</kbd>  <kbd title="queries">?param1=value1&amp;param2=value2</kbd> 
          <kbd title="hash">#fragment</kbd>`;
      set_style(small, "--bs-body-color", "#eee");
      set_style(small, "--bs-body-bg", "#333");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, br0, anchor);
      insert(target, t2, anchor);
      insert(target, br1, anchor);
      insert(target, t3, anchor);
      insert(target, small, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4 && t0_value !== (t0_value = ctx2[2].msg + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(br0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(br1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(small);
    }
  };
}
function create_if_block$O(ctx) {
  let small;
  let t0;
  let t1_value = getIndexesStr(Array.from(ctx[5]).slice(0, 10)) + "";
  let t1;
  let t2_value = ctx[5].size > 10 ? "... " : "";
  let t2;
  let t3;
  return {
    c() {
      small = element("small");
      t0 = text("Currently feed monitors are not supported via CSV rows: ");
      t1 = text(t1_value);
      t2 = text(t2_value);
      t3 = text(" (highlighted in gray)");
      attr(small, "class", "text-dark-emphasis mt-2");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t0);
      append(small, t1);
      append(small, t2);
      append(small, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32 && t1_value !== (t1_value = getIndexesStr(Array.from(ctx2[5]).slice(0, 10)) + ""))
        set_data(t1, t1_value);
      if (dirty[0] & 32 && t2_value !== (t2_value = ctx2[5].size > 10 ? "... " : ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_fragment$1w(ctx) {
  let div0;
  let t2;
  let div3;
  let div1;
  let table;
  let thead;
  let tr;
  let th;
  let t4;
  let t5;
  let tbody;
  let t6;
  let div2;
  let button0;
  let t8;
  let button1;
  let t9;
  let button1_disabled_value;
  let t10;
  let t11;
  let mounted;
  let dispose;
  let each_value_2 = ctx[1];
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i2));
  }
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$q(get_each_context$q(ctx, each_value, i2));
  }
  let if_block0 = ctx[2] && create_if_block_1$A(ctx);
  let if_block1 = ctx[5] && ctx[5].size > 0 && create_if_block$O(ctx);
  return {
    c() {
      div0 = element("div");
      div0.innerHTML = `<h3 class="ms-2">Data
    <small class="text-muted fs-5">Column headers show identified column attributes. You can edit them to manually specify or correct them.</small></h3>`;
      t2 = space();
      div3 = element("div");
      div1 = element("div");
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      th = element("th");
      th.textContent = "index";
      t4 = space();
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t5 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t6 = space();
      div2 = element("div");
      button0 = element("button");
      button0.textContent = "Back";
      t8 = space();
      button1 = element("button");
      t9 = text("Next - configure options and actions");
      t10 = space();
      if (if_block0)
        if_block0.c();
      t11 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "py-2");
      attr(th, "class", "max-w-[150px] p-[5px]");
      set_style(th, "border", "solid 1px #ccc");
      set_style(tr, "border-top", "solid 1px #ccc");
      attr(div1, "class", "max-h-[500px] overflow-scroll");
      attr(button0, "class", "btn btn-default");
      attr(button1, "class", "btn btn-primary");
      button1.disabled = button1_disabled_value = !!ctx[4];
      attr(div2, "class", "actions");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t2, anchor);
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, table);
      append(table, thead);
      append(thead, tr);
      append(tr, th);
      append(tr, t4);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(tr, null);
        }
      }
      append(table, t5);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      ctx[15](tbody);
      append(div3, t6);
      append(div3, div2);
      append(div2, button0);
      append(div2, t8);
      append(div2, button1);
      append(button1, t9);
      append(div3, t10);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t11);
      if (if_block1)
        if_block1.m(div3, null);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[9]),
          listen(button1, "click", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 130) {
        each_value_2 = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$1(ctx2, each_value_2, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
          } else {
            each_blocks_1[i2] = create_each_block_2$1(child_ctx);
            each_blocks_1[i2].c();
            each_blocks_1[i2].m(tr, null);
          }
        }
        for (; i2 < each_blocks_1.length; i2 += 1) {
          each_blocks_1[i2].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty[0] & 297) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$q(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$q(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(tbody, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty[0] & 16 && button1_disabled_value !== (button1_disabled_value = !!ctx2[4])) {
        button1.disabled = button1_disabled_value;
      }
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$A(ctx2);
          if_block0.c();
          if_block0.m(div3, t11);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[5] && ctx2[5].size > 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$O(ctx2);
          if_block1.c();
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div3);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      ctx[15](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function getIndexesStr(indexes) {
  return indexes.map((idx) => idx + 1).join(", ");
}
function instance$1t($$self, $$props, $$invalidate) {
  let { csv } = $$props;
  const dispatch = createEventDispatcher();
  const KNOWN_COLUMNS = {
    name: "name",
    url: "url",
    labels: "labels",
    "content type": "content_type",
    "datasourceid?": "datasource_id"
  };
  const fields = csv.meta.fields;
  const normalizedFields = fields.map((field) => KNOWN_COLUMNS[field.toLowerCase()]);
  let rows = csv.data;
  const selectFields = structuredClone(normalizedFields);
  let inputFields;
  let errorMap;
  let contentTypeHeader;
  let errRowIdxs = /* @__PURE__ */ new Set();
  let errLen = 0;
  let feedRowIdxs = /* @__PURE__ */ new Set();
  let tbodyEl;
  function createHeaderMap() {
    $$invalidate(12, inputFields = selectFields.reduce((acc, field, index2) => (field && (acc[field] = fields[index2]), acc), {}));
  }
  function onBack() {
    dispatch("back");
  }
  function updateRowHeader() {
    return rows.map((row) => {
      if (row[contentTypeHeader] == C$1.TYPE_FEED) {
        return;
      }
      return Object.entries(inputFields).reduce(
        (newRow, [field, header]) => {
          newRow[field] = row[header];
          return newRow;
        },
        {}
      );
    }).filter((row) => row);
  }
  function onNext() {
    $$invalidate(2, errorMap = null);
    $$invalidate(3, errRowIdxs = /* @__PURE__ */ new Set());
    $$invalidate(4, errLen = 0);
    if (!inputFields.name) {
      $$invalidate(2, errorMap = { key: "name", msg: "Missing column: Name" });
    } else if (!inputFields.url) {
      $$invalidate(2, errorMap = { key: "url", msg: "Missing column: URL" });
    } else {
      $$invalidate(0, rows = rows.filter((row) => !Object.values(row).every((v) => !v)));
      let firstUrlErrEl;
      const urlColumnName = inputFields.url;
      rows.forEach((row, idx) => {
        try {
          if (!feedRowIdxs.has(idx)) {
            new URL(row[urlColumnName]);
          }
        } catch (e) {
          if (!firstUrlErrEl) {
            firstUrlErrEl = tbodyEl.querySelector(`tr:nth-child(${idx})`);
          }
          errRowIdxs.add(idx);
        }
      });
      $$invalidate(4, errLen = errRowIdxs.size);
      if (errLen) {
        console.error(urlColumnName);
        const errMsg = `${errLen} Malformed URL${errLen > 1 ? "s" : ""} at rows: ${getIndexesStr(Array.from(errRowIdxs).slice(0, 10))}${errLen > 10 ? "... " : ""}.`;
        $$invalidate(2, errorMap = { key: "url-validation", msg: errMsg });
        firstUrlErrEl.scrollIntoView();
      }
    }
    if (errorMap) {
      return;
    }
    dispatch("next", { rows: updateRowHeader() });
  }
  function select_change_handler(i2) {
    selectFields[i2] = select_value(this);
    $$invalidate(1, selectFields);
    $$invalidate(7, KNOWN_COLUMNS);
  }
  function tbody_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tbodyEl = $$value;
      $$invalidate(6, tbodyEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("csv" in $$props2)
      $$invalidate(11, csv = $$props2.csv);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 12291) {
      if (selectFields) {
        createHeaderMap();
        $$invalidate(13, contentTypeHeader = inputFields.content_type);
        if (contentTypeHeader) {
          $$invalidate(5, feedRowIdxs = rows.reduce(
            (acc, row, idx) => {
              if (row[contentTypeHeader] == C$1.TYPE_FEED) {
                acc.add(idx);
              }
              return acc;
            },
            /* @__PURE__ */ new Set()
          ));
        }
      }
    }
  };
  return [
    rows,
    selectFields,
    errorMap,
    errRowIdxs,
    errLen,
    feedRowIdxs,
    tbodyEl,
    KNOWN_COLUMNS,
    fields,
    onBack,
    onNext,
    csv,
    inputFields,
    contentTypeHeader,
    select_change_handler,
    tbody_binding
  ];
}
class MarkDataStage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1t, create_fragment$1w, safe_not_equal, { csv: 11 }, null, [-1, -1]);
  }
}
function create_if_block_5$7(ctx) {
  let globalactionseditormodal;
  let current;
  globalactionseditormodal = new GlobalActionsEditorModal({});
  globalactionseditormodal.$on("close", ctx[19]);
  return {
    c() {
      create_component(globalactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalactionseditormodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(globalactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalactionseditormodal, detaching);
    }
  };
}
function create_if_block_4$d(ctx) {
  let manageemailsmodal;
  let current;
  manageemailsmodal = new ManageEmailModal({});
  manageemailsmodal.$on("close", ctx[20]);
  return {
    c() {
      create_component(manageemailsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(manageemailsmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(manageemailsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(manageemailsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(manageemailsmodal, detaching);
    }
  };
}
function create_if_block_3$k(ctx) {
  let managephonesmodal;
  let current;
  managephonesmodal = new ManagePhonesModal({});
  managephonesmodal.$on("close", ctx[21]);
  return {
    c() {
      create_component(managephonesmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managephonesmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(managephonesmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managephonesmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managephonesmodal, detaching);
    }
  };
}
function create_if_block_2$q(ctx) {
  let div;
  let button0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      button0.textContent = "Back";
      t1 = space();
      button1 = element("button");
      button1.textContent = `${TXT("a_import")}`;
      attr(button0, "class", "btn btn-default");
      attr(button1, "class", "btn btn-primary");
      attr(div, "class", "d-flex gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[22]),
          listen(button1, "click", ctx[13])
        ];
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$z(ctx) {
  let div;
  let t0;
  let span0;
  let t1;
  let t2;
  let span1;
  let t3;
  return {
    c() {
      div = element("div");
      t0 = text("Imported: ");
      span0 = element("span");
      t1 = text(ctx[5]);
      t2 = text(" of ");
      span1 = element("span");
      t3 = text(ctx[6]);
      attr(div, "class", "text-success text-lg ps-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, span0);
      append(span0, t1);
      append(div, t2);
      append(div, span1);
      append(span1, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32)
        set_data(t1, ctx2[5]);
      if (dirty[0] & 64)
        set_data(t3, ctx2[6]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$N(ctx) {
  let div;
  let t_value = (ctx[7] || "") + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "text-lg ps-2");
      toggle_class(div, "text-success", ctx[0] === ctx[8].COMPLETE);
      toggle_class(div, "text-danger", ctx[0] === ctx[8].ERROR);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 128 && t_value !== (t_value = (ctx2[7] || "") + ""))
        set_data(t, t_value);
      if (dirty[0] & 257) {
        toggle_class(div, "text-success", ctx2[0] === ctx2[8].COMPLETE);
      }
      if (dirty[0] & 257) {
        toggle_class(div, "text-danger", ctx2[0] === ctx2[8].ERROR);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1v(ctx) {
  let div0;
  let t1;
  let div10;
  let div2;
  let label0;
  let t3;
  let div1;
  let clientselector;
  let t4;
  let div4;
  let label1;
  let t6;
  let div3;
  let scheduleeditor;
  let t7;
  let div6;
  let label2;
  let t9;
  let div5;
  let actionseditor;
  let updating_actions;
  let t10;
  let t11;
  let t12;
  let t13;
  let div8;
  let label3;
  let t15;
  let div7;
  let tagseditor;
  let t16;
  let t17;
  let div9;
  let t18;
  let current;
  clientselector = new ClientSelector({
    props: {
      model: ctx[11],
      showAllClients: true
    }
  });
  scheduleeditor = new ScheduleEditor({
    props: { formModel: ctx[12] }
  });
  function actionseditor_actions_binding(value) {
    ctx[17](value);
  }
  let actionseditor_props = {};
  if (ctx[1] !== void 0) {
    actionseditor_props.actions = ctx[1];
  }
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  binding_callbacks.push(() => bind$1(actionseditor, "actions", actionseditor_actions_binding));
  actionseditor.$on("globalaction", ctx[18]);
  actionseditor.$on("manage", ctx[14]);
  let if_block0 = ctx[2] && create_if_block_5$7(ctx);
  let if_block1 = ctx[3] && create_if_block_4$d(ctx);
  let if_block2 = ctx[4] && create_if_block_3$k(ctx);
  tagseditor = new TagsEditor({ props: { model: ctx[11] } });
  let if_block3 = ctx[0] !== ctx[8].COMPLETE && create_if_block_2$q(ctx);
  let if_block4 = ctx[5] && create_if_block_1$z(ctx);
  let if_block5 = ctx[7] && create_if_block$N(ctx);
  return {
    c() {
      div0 = element("div");
      div0.innerHTML = `<h3>Options</h3>`;
      t1 = space();
      div10 = element("div");
      div2 = element("div");
      label0 = element("label");
      label0.textContent = "Device";
      t3 = space();
      div1 = element("div");
      create_component(clientselector.$$.fragment);
      t4 = space();
      div4 = element("div");
      label1 = element("label");
      label1.textContent = "Schedule";
      t6 = space();
      div3 = element("div");
      create_component(scheduleeditor.$$.fragment);
      t7 = space();
      div6 = element("div");
      label2 = element("label");
      label2.textContent = "Actions";
      t9 = space();
      div5 = element("div");
      create_component(actionseditor.$$.fragment);
      t10 = space();
      if (if_block0)
        if_block0.c();
      t11 = space();
      if (if_block1)
        if_block1.c();
      t12 = space();
      if (if_block2)
        if_block2.c();
      t13 = space();
      div8 = element("div");
      label3 = element("label");
      label3.textContent = "Labels";
      t15 = space();
      div7 = element("div");
      create_component(tagseditor.$$.fragment);
      t16 = space();
      if (if_block3)
        if_block3.c();
      t17 = space();
      div9 = element("div");
      if (if_block4)
        if_block4.c();
      t18 = space();
      if (if_block5)
        if_block5.c();
      attr(div0, "class", "py-2 border-bottom");
      attr(label0, "class", "xoption-label");
      attr(div1, "class", "flex-1");
      attr(div2, "class", "flex gap-x-6");
      attr(label1, "class", "xoption-label");
      attr(div3, "class", "flex-1");
      attr(div4, "class", "flex gap-x-6");
      attr(label2, "class", "xoption-label");
      attr(div5, "class", "flex-1");
      attr(div6, "class", "flex gap-x-6");
      attr(label3, "class", "xoption-label");
      attr(div7, "class", "flex-1");
      attr(div8, "class", "flex gap-x-6");
      attr(div10, "class", "flex flex-col gap-y-6 p-[10px]");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div10, anchor);
      append(div10, div2);
      append(div2, label0);
      append(div2, t3);
      append(div2, div1);
      mount_component(clientselector, div1, null);
      append(div10, t4);
      append(div10, div4);
      append(div4, label1);
      append(div4, t6);
      append(div4, div3);
      mount_component(scheduleeditor, div3, null);
      append(div10, t7);
      append(div10, div6);
      append(div6, label2);
      append(div6, t9);
      append(div6, div5);
      mount_component(actionseditor, div5, null);
      append(div6, t10);
      if (if_block0)
        if_block0.m(div6, null);
      append(div6, t11);
      if (if_block1)
        if_block1.m(div6, null);
      append(div6, t12);
      if (if_block2)
        if_block2.m(div6, null);
      append(div10, t13);
      append(div10, div8);
      append(div8, label3);
      append(div8, t15);
      append(div8, div7);
      mount_component(tagseditor, div7, null);
      append(div10, t16);
      if (if_block3)
        if_block3.m(div10, null);
      append(div10, t17);
      append(div10, div9);
      if (if_block4)
        if_block4.m(div9, null);
      append(div9, t18);
      if (if_block5)
        if_block5.m(div9, null);
      current = true;
    },
    p(ctx2, dirty) {
      const actionseditor_changes = {};
      if (!updating_actions && dirty[0] & 2) {
        updating_actions = true;
        actionseditor_changes.actions = ctx2[1];
        add_flush_callback(() => updating_actions = false);
      }
      actionseditor.$set(actionseditor_changes);
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div6, t11);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$d(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div6, t12);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_3$k(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div6, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[0] !== ctx2[8].COMPLETE) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_2$q(ctx2);
          if_block3.c();
          if_block3.m(div10, t17);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (ctx2[5]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_1$z(ctx2);
          if_block4.c();
          if_block4.m(div9, t18);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (ctx2[7]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block$N(ctx2);
          if_block5.c();
          if_block5.m(div9, null);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(clientselector.$$.fragment, local);
      transition_in(scheduleeditor.$$.fragment, local);
      transition_in(actionseditor.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(tagseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientselector.$$.fragment, local);
      transition_out(scheduleeditor.$$.fragment, local);
      transition_out(actionseditor.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(tagseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div10);
      destroy_component(clientselector);
      destroy_component(scheduleeditor);
      destroy_component(actionseditor);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(tagseditor);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
    }
  };
}
function createCustomError(msg, e) {
  const err = new Error(msg);
  err.cause = e;
  return err;
}
function sanitizeCSVFields(sieveRequest) {
  if (sieveRequest.datasource_id === "") {
    sieveRequest.datasource_id = null;
  }
}
function instance$1s($$self, $$props, $$invalidate) {
  let $clients;
  let { rows } = $$props;
  let { importType = "csv" } = $$props;
  const IMPORT_STATUS = {
    INIT: 0,
    IMPORTING: 1,
    COMPLETE: 2,
    ERROR: 3
  };
  const labels = getContext("labels");
  const clients = getContext("clients");
  component_subscribe($$self, clients, (value) => $$invalidate(24, $clients = value));
  const dispatch = createEventDispatcher();
  let status = IMPORT_STATUS.INIT;
  let actions;
  let labelMap;
  let showGlobalActionEditor2;
  let showManageEmailsModal;
  let showManagePhonesModal;
  let index2 = 0;
  let total;
  let message = "";
  const model = new Model$2.Sieve({ content_type: C$1.TYPE_HTML });
  const formModel = new SieveFormModel(model);
  async function checkConstraint() {
    let constraint;
    try {
      constraint = await checkSieveConstraint(rows.length);
    } catch (e) {
      console.error("error while checking constraints", e);
      constraint = { isOverLimit: false };
    }
    return constraint;
  }
  async function onImport() {
    try {
      const options = model.toJSON();
      const constraint = await checkConstraint();
      if (constraint.isOverLimit) {
        throw new Error("Monitor limit exceeded");
      }
      const isValidActions = actions.validateActions();
      if (!isValidActions) {
        throw new Error("Action fields required");
      }
      await importAll(rows, _.omit(options, "content_type"));
    } catch (e) {
      console.error(e);
      $$invalidate(0, status = IMPORT_STATUS.ERROR);
      $$invalidate(7, message = e.message || e.msg);
    }
  }
  async function importAll(sieves, options) {
    $$invalidate(5, index2 = 0);
    $$invalidate(0, status = IMPORT_STATUS.IMPORTING);
    $$invalidate(6, total = sieves.length);
    await populateLabelMap(sieves);
    const importedTime = new Date().getTime();
    for (let i2 = 0; i2 < sieves.length; i2 += 1) {
      const sieve = sieves[i2];
      $$invalidate(7, message = `Importing ${sieve.url}`);
      await importOne(sieve, options, i2, importedTime);
      $$invalidate(5, index2 += 1);
    }
    $$invalidate(7, message = "Import Complete");
    $$invalidate(0, status = IMPORT_STATUS.COMPLETE);
  }
  async function populateLabelMap(sieves) {
    try {
      let names = sieves.reduce(
        (acc, { labels: labels2 }) => {
          if ((labels2 == null ? void 0 : labels2.length) > 0) {
            acc = [...acc, ...labels2.split(",")];
          }
          return acc;
        },
        []
      );
      names = Array.from(new Set(names));
      const labelList = await labels.getOrCreateLabels(names);
      labelMap = labelList.reduce((acc, { id: id2, name }) => (acc[name] = id2, acc), {});
    } catch (e) {
      throw createCustomError("Import failed: Error while creating labels", e);
    }
  }
  async function importOne(sieve, { tags, client_id, ...sieveOptions }, idx, importedTime) {
    try {
      if (sieve.rule) {
        try {
          const rule = await Api.api("/rules", "POST", { config: sieve.rule });
          sieve.rule_id = rule.id;
        } catch (e) {
          throw createCustomError("Error while saving rules", e);
        }
      }
      let labelIds = [];
      const labelsStr = sieve.labels || "";
      delete sieve.label;
      if (labelsStr.length > 0) {
        const labelNames = labelsStr.split(",");
        labelIds = labelNames.map((name) => labelMap[name]);
      }
      if (tags && tags.length > 0) {
        labelIds = [...labelIds, ...tags.split(",")];
      }
      sieve.tags = Array.from(new Set(labelIds)).join(",");
      sieve.content_type = parseInt(sieve.content_type || C$1.TYPE_HTML);
      switch (sieve.content_type) {
        case C$1.TYPE_SITEMAP:
          sieveOptions = _.omit(sieveOptions, "schedule");
          break;
        case C$1.TYPE_XML:
          sieveOptions = _.omit(sieveOptions, "prefs");
      }
      const doc = {
        client_id: client_id || clients.defaultId,
        ...sieve,
        ...sieveOptions
      };
      importType === "csv" && sanitizeCSVFields(doc);
      const sieveModel = new Model$2.Sieve({ ...doc, uri: sieve.url, config: {} }, { parse: true });
      sieveModel.setMeta({
        action: "import",
        type: importType,
        import_id: importedTime
      });
      sieveModel.applyConfigDefaults();
      if (!validateClient(sieveModel)) {
        sieveModel.set("client_id", C$1.CLIENT_ID_WEB);
      }
      try {
        await sieveModel.save();
      } catch (e) {
        throw createCustomError("Error while saving sieve", e);
      }
      const sieveId = sieveModel.get("id");
      await saveActions(sieveId);
    } catch (e) {
      e.message = `Import failed at row ${idx + 1} : ${e.message} for url - ${sieve.url}`;
      throw e;
    }
  }
  function validateClient(sieve) {
    const selectedClientId = sieve.get("client_id");
    const accessibleClients = sieve.getAccessibleClients($clients);
    return !!accessibleClients.find((client) => selectedClientId === client.id);
  }
  async function saveActions(sieve_id) {
    try {
      const actionList = actions.getPosts();
      for (let i2 = 0; i2 < actionList.length; i2 += 1) {
        const doc = actionList[i2].toJSON();
        await Api.api(`/sieves/${sieve_id}/actions`, "POST", { sieve_id, ...doc });
      }
    } catch (e) {
      throw createCustomError("Error while saving actions", e);
    }
  }
  function showModal(e) {
    const type = e.detail;
    if (type === "email") {
      $$invalidate(3, showManageEmailsModal = true);
    } else if (type === "phone") {
      $$invalidate(4, showManagePhonesModal = true);
    }
  }
  function actionseditor_actions_binding(value) {
    actions = value;
    $$invalidate(1, actions);
  }
  const globalaction_handler = () => {
    $$invalidate(2, showGlobalActionEditor2 = true);
  };
  const close_handler = () => $$invalidate(2, showGlobalActionEditor2 = false);
  const close_handler_1 = () => $$invalidate(3, showManageEmailsModal = false);
  const close_handler_2 = () => $$invalidate(4, showManagePhonesModal = false);
  const click_handler = () => dispatch("back");
  $$self.$$set = ($$props2) => {
    if ("rows" in $$props2)
      $$invalidate(15, rows = $$props2.rows);
    if ("importType" in $$props2)
      $$invalidate(16, importType = $$props2.importType);
  };
  return [
    status,
    actions,
    showGlobalActionEditor2,
    showManageEmailsModal,
    showManagePhonesModal,
    index2,
    total,
    message,
    IMPORT_STATUS,
    clients,
    dispatch,
    model,
    formModel,
    onImport,
    showModal,
    rows,
    importType,
    actionseditor_actions_binding,
    globalaction_handler,
    close_handler,
    close_handler_1,
    close_handler_2,
    click_handler
  ];
}
class OptionsStage extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1s, create_fragment$1v, safe_not_equal, { rows: 15, importType: 16 }, null, [-1, -1]);
  }
}
function create_if_block_2$p(ctx) {
  let optionsstage;
  let current;
  optionsstage = new OptionsStage({ props: { rows: ctx[3] } });
  optionsstage.$on("back", ctx[6]);
  return {
    c() {
      create_component(optionsstage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(optionsstage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const optionsstage_changes = {};
      if (dirty & 8)
        optionsstage_changes.rows = ctx2[3];
      optionsstage.$set(optionsstage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(optionsstage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(optionsstage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(optionsstage, detaching);
    }
  };
}
function create_if_block_1$y(ctx) {
  let markdatastage;
  let current;
  markdatastage = new MarkDataStage({ props: { csv: ctx[2] } });
  markdatastage.$on("back", ctx[6]);
  markdatastage.$on("next", ctx[9]);
  return {
    c() {
      create_component(markdatastage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(markdatastage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const markdatastage_changes = {};
      if (dirty & 4)
        markdatastage_changes.csv = ctx2[2];
      markdatastage.$set(markdatastage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(markdatastage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(markdatastage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(markdatastage, detaching);
    }
  };
}
function create_if_block$M(ctx) {
  let pickfilestage;
  let current;
  pickfilestage = new PickFileStage({});
  pickfilestage.$on("next", ctx[7]);
  pickfilestage.$on("error", ctx[8]);
  return {
    c() {
      create_component(pickfilestage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pickfilestage, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(pickfilestage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pickfilestage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pickfilestage, detaching);
    }
  };
}
function create_fragment$1u(ctx) {
  let div0;
  let h2;
  let t2;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$M, create_if_block_1$y, create_if_block_2$p];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === ctx2[4].PICK_FILE)
      return 0;
    if (ctx2[0] === ctx2[4].MARK_DATA)
      return 1;
    if (ctx2[0] === ctx2[4].OPTIONS)
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = `${TXT("a_import")} - CSV`;
      t2 = space();
      div1 = element("div");
      if (if_block)
        if_block.c();
      attr(div0, "class", "xpage-header");
      attr(div1, "class", "p-2 bg-white");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, h2);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div1, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function instance$1r($$self, $$props, $$invalidate) {
  const STAGE = { PICK_FILE: 1, MARK_DATA: 2, OPTIONS: 3 };
  function nextStage() {
    $$invalidate(0, stage += 1);
  }
  function prevStage() {
    $$invalidate(0, stage -= 1);
  }
  let stage = STAGE.PICK_FILE;
  let errMsg;
  let csv;
  let updatedRows;
  const next_handler = (e) => {
    $$invalidate(2, { csv } = e.detail, csv);
    nextStage();
  };
  const error_handler = (e) => {
    $$invalidate(1, errMsg = e.detail.error);
  };
  const next_handler_1 = (e) => {
    $$invalidate(3, { rows: updatedRows } = e.detail, updatedRows);
    nextStage();
  };
  return [
    stage,
    errMsg,
    csv,
    updatedRows,
    STAGE,
    nextStage,
    prevStage,
    next_handler,
    error_handler,
    next_handler_1
  ];
}
class Import_csv extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1r, create_fragment$1u, safe_not_equal, {});
  }
}
function create_if_block$L(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span class="badge rounded-pill text-bg-primary">New</span>`;
      attr(div, "class", "ms-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1t(ctx) {
  let tr;
  let td0;
  let div0;
  let input;
  let input_checked_value;
  let t0;
  let td1;
  let div2;
  let div1;
  let t1_value = ctx[1].url + "";
  let t1;
  let div1_title_value;
  let t2;
  let t3;
  let td2;
  let t5;
  let td3;
  let t6_value = new Date(ctx[1].first_seen_on).toLocaleString() + "";
  let t6;
  let t7;
  let td4;
  let span;
  let i2;
  let i_class_value;
  let mounted;
  let dispose;
  let if_block = ctx[3] && create_if_block$L();
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      div0 = element("div");
      input = element("input");
      t0 = space();
      td1 = element("td");
      div2 = element("div");
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      t3 = space();
      td2 = element("td");
      td2.textContent = `${ctx[2]}`;
      t5 = space();
      td3 = element("td");
      t6 = text(t6_value);
      t7 = space();
      td4 = element("td");
      span = element("span");
      i2 = element("i");
      attr(input, "class", "form-check-input");
      attr(input, "type", "checkbox");
      input.value = "";
      input.checked = input_checked_value = ctx[1].checked;
      attr(input, "id", "flexCheckDefault");
      attr(div0, "class", "form-check");
      attr(td0, "class", "ps-3");
      attr(div1, "title", div1_title_value = ctx[1].url);
      attr(div1, "class", "text-truncate");
      attr(div2, "class", "d-flex");
      set_style(td1, "max-width", "25vw");
      set_style(td2, "max-width", "calc(100vw - 50vw - 30rem)");
      attr(td2, "class", "text-truncate");
      attr(td3, "class", "text-start");
      attr(i2, "class", i_class_value = "fa " + (ctx[1].monitored ? "text-success fa-check" : "fa-minus"));
      attr(i2, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, div0);
      append(div0, input);
      append(tr, t0);
      append(tr, td1);
      append(td1, div2);
      append(div2, div1);
      append(div1, t1);
      append(div2, t2);
      if (if_block)
        if_block.m(div2, null);
      append(tr, t3);
      append(tr, td2);
      append(tr, t5);
      append(tr, td3);
      append(td3, t6);
      append(tr, t7);
      append(tr, td4);
      append(td4, span);
      append(span, i2);
      if (!mounted) {
        dispose = listen(input, "click", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && input_checked_value !== (input_checked_value = ctx2[1].checked)) {
        input.checked = input_checked_value;
      }
      if (dirty & 2 && t1_value !== (t1_value = ctx2[1].url + ""))
        set_data(t1, t1_value);
      if (dirty & 2 && div1_title_value !== (div1_title_value = ctx2[1].url)) {
        attr(div1, "title", div1_title_value);
      }
      if (dirty & 2 && t6_value !== (t6_value = new Date(ctx2[1].first_seen_on).toLocaleString() + ""))
        set_data(t6, t6_value);
      if (dirty & 2 && i_class_value !== (i_class_value = "fa " + (ctx2[1].monitored ? "text-success fa-check" : "fa-minus"))) {
        attr(i2, "class", i_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$1q($$self, $$props, $$invalidate) {
  var _a;
  let $diffData, $$unsubscribe_diffData = noop$1, $$subscribe_diffData = () => ($$unsubscribe_diffData(), $$unsubscribe_diffData = subscribe(diffData, ($$value) => $$invalidate(1, $diffData = $$value)), diffData);
  $$self.$$.on_destroy.push(() => $$unsubscribe_diffData());
  let { diffData } = $$props;
  $$subscribe_diffData();
  let title = ((_a = $diffData.meta) == null ? void 0 : _a.title) || getNameFromURL($diffData.url);
  let isAdded = $diffData.diff_type === "addition";
  async function selectURL(event) {
    diffData.set("checked", event.target.checked);
  }
  $$self.$$set = ($$props2) => {
    if ("diffData" in $$props2)
      $$subscribe_diffData($$invalidate(0, diffData = $$props2.diffData));
  };
  return [diffData, $diffData, title, isAdded, selectURL];
}
class DiffDataRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1q, create_fragment$1t, safe_not_equal, { diffData: 0 });
  }
}
class Url extends base.Model {
}
class Urls extends base.PagedCollection {
  constructor(attrs, options) {
    super(attrs, options);
    __publicField(this, "model", Url);
    __publicField(this, "limit", 20);
    this.crawler_id = options.crawler_id;
    this.jobId = options.id;
    this.url = `/crawlers/data/${options.crawler_id}/jobs/${options.id}/urls`;
  }
}
class FieldFilter extends base.Model {
  constructor(attrs, options) {
    super(attrs, options);
    this.fields = qs.stringify(options.fields);
    this.url = `/crawlers/data/${options.crawler_id}/jobs/${options.jobId}/filter?${this.fields}`;
  }
}
class UrlChain extends base.Model {
  constructor(attrs, options) {
    super(attrs, options);
    this.urlId = options.urlId;
    this.jobId = options.jobId;
    this.crawlerId = options.crawlerId;
    this.url = `/crawlers/data/${options.crawlerId}/jobs/${options.jobId}/${options.urlId}/`;
  }
}
class UrlDiff extends base.Model {
  constructor() {
    super(...arguments);
    __publicField(this, "checked", false);
  }
}
class UrlDiffs extends base.Collection {
  constructor(attrs, options) {
    super(attrs, options);
    __publicField(this, "model", UrlDiff);
    __publicField(this, "comparator", function(model) {
      return model.get("monitored");
    });
    this.crawlerID = options.crawlerID;
    this.jobID1 = options.jobID1;
    this.jobID2 = options.jobID2;
  }
  getSelected() {
    let selectedModels = [];
    this.models.forEach((model) => {
      if (model.get("checked")) {
        selectedModels.push(model);
      }
    });
    return selectedModels;
  }
  getSummary() {
    let monitored = this.models.filter((model) => model.get("monitored"));
    return {
      total: this.length,
      monitored: monitored.length
    };
  }
}
function get_each_context$p(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[46] = list[i2];
  return child_ctx;
}
function create_if_block_2$o(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Excluded Query Params",
      labelClose: "Close",
      onSave: ctx[32],
      saveLabel: "Apply",
      $$slots: { default: [create_default_slot$I] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[33]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty[0] & 128)
        savemodal_changes.onSave = ctx2[32];
      if (dirty[0] & 256 | dirty[1] & 262144) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$I(ctx) {
  let div;
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      attr(textarea, "class", "w-100");
      set_style(textarea, "height", "10vh");
      attr(div, "class", "overflow-y-auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      set_input_value(textarea, ctx[8]);
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[31]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256) {
        set_input_value(textarea, ctx2[8]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$v(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$i,
    then: create_then_block$i,
    catch: create_catch_block$i,
    value: 45,
    blocks: [, , ,]
  };
  handle_promise(ctx[18], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block$K(ctx) {
  let div;
  let optionsstage;
  let current;
  optionsstage = new OptionsStage({
    props: {
      importType: "sitemap_import",
      rows: ctx[10]
    }
  });
  optionsstage.$on("back", ctx[34]);
  return {
    c() {
      div = element("div");
      create_component(optionsstage.$$.fragment);
      attr(div, "class", "p-2 bg-white");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(optionsstage, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const optionsstage_changes = {};
      if (dirty[0] & 1024)
        optionsstage_changes.rows = ctx2[10];
      optionsstage.$set(optionsstage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(optionsstage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(optionsstage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(optionsstage);
    }
  };
}
function create_catch_block$i(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$i(ctx) {
  let div5;
  let div0;
  let p;
  let t0_value = ctx[9].total + "";
  let t0;
  let t1;
  let a0;
  let t2_value = ctx[13].ts + "";
  let t2;
  let t3;
  let a1;
  let t4_value = ctx[12].name + "";
  let t4;
  let t5;
  let div4;
  let div3;
  let label;
  let div1;
  let t7;
  let div2;
  let input0;
  let t8;
  let button0;
  let t9;
  let div14;
  let div10;
  let div6;
  let h3;
  let t11;
  let t12;
  let div7;
  let t13;
  let div8;
  let t14;
  let div9;
  let searchbar;
  let t15;
  let menu;
  let updating_id;
  let t16;
  let sortby;
  let t17;
  let div13;
  let table;
  let thead;
  let tr;
  let th0;
  let div12;
  let div11;
  let input1;
  let t18;
  let span;
  let t19;
  let ul;
  let li;
  let a2;
  let t21;
  let th1;
  let t23;
  let th2;
  let t25;
  let th3;
  let t27;
  let th4;
  let t29;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t30;
  let div16;
  let div15;
  let button1;
  let t31;
  let button1_disabled_value;
  let current;
  let mounted;
  let dispose;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[9].total)
      return create_if_block_1$x;
    return create_else_block_2$4;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[26]);
  function menu_id_binding(value) {
    ctx[36](value);
  }
  let menu_props = {
    items: ctx[17],
    title: "Select Proxy",
    class: "me-2",
    defaultActionLabel: ctx[17][ctx[4]].title,
    actionClass: "btn btn-sm btn-default",
    allowNull: false,
    toggle: false
  };
  if (ctx[4] !== void 0) {
    menu_props.id = ctx[4];
  }
  menu = new Menu({ props: menu_props });
  binding_callbacks.push(() => bind$1(menu, "id", menu_id_binding));
  menu.$on("select", ctx[27]);
  sortby = new SortBy({
    props: {
      onSort: ctx[28],
      sortingFields: ctx[16],
      currentFieldName: ctx[3]
    }
  });
  let each_value = ctx[5];
  const get_key = (ctx2) => ctx2[46].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$p(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$p(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$b();
  }
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      p = element("p");
      t0 = text(t0_value);
      t1 = text(" URLs found in job started on ");
      a0 = element("a");
      t2 = text(t2_value);
      t3 = text(" in ");
      a1 = element("a");
      t4 = text(t4_value);
      t5 = space();
      div4 = element("div");
      div3 = element("div");
      label = element("label");
      div1 = element("div");
      div1.textContent = "Clean URLs";
      t7 = space();
      div2 = element("div");
      input0 = element("input");
      t8 = space();
      button0 = element("button");
      button0.innerHTML = `<i style="margin-top: -5px;" class="fa fa-filter" aria-hidden="true"></i>`;
      t9 = space();
      div14 = element("div");
      div10 = element("div");
      div6 = element("div");
      h3 = element("h3");
      h3.textContent = "Import Monitors";
      t11 = space();
      if_block.c();
      t12 = space();
      div7 = element("div");
      t13 = space();
      div8 = element("div");
      t14 = space();
      div9 = element("div");
      create_component(searchbar.$$.fragment);
      t15 = space();
      create_component(menu.$$.fragment);
      t16 = space();
      create_component(sortby.$$.fragment);
      t17 = space();
      div13 = element("div");
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      th0 = element("th");
      div12 = element("div");
      div11 = element("div");
      input1 = element("input");
      t18 = space();
      span = element("span");
      t19 = space();
      ul = element("ul");
      li = element("li");
      a2 = element("a");
      a2.textContent = "Select not monitored";
      t21 = space();
      th1 = element("th");
      th1.textContent = "URL";
      t23 = space();
      th2 = element("th");
      th2.textContent = "Title";
      t25 = space();
      th3 = element("th");
      th3.textContent = "First Seen On";
      t27 = space();
      th4 = element("th");
      th4.textContent = "Monitored";
      t29 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t30 = space();
      div16 = element("div");
      div15 = element("div");
      button1 = element("button");
      t31 = text("Import Selected Monitors");
      attr(a0, "target", "_blank");
      attr(a0, "href", urlCfg.crawlerJobDetail(ctx[15], ctx[19], ctx[14]));
      attr(a1, "href", urlCfg.crawlerDetail(ctx[15], ctx[19]));
      attr(div0, "class", "ms-2 align-self-end");
      attr(div1, "class", "mx-1");
      attr(input0, "class", "form-check-input");
      attr(input0, "type", "checkbox");
      attr(input0, "role", "switch");
      attr(input0, "id", "cleanURLSwitch");
      attr(div2, "class", "form-check form-switch mb-0");
      attr(label, "class", "d-flex form-check-label");
      attr(label, "for", "cleanURLSwitch");
      attr(div3, "class", "d-flex align-items-center rounded me-1 align-self-center transition-hover hover:bg-white py-1");
      attr(button0, "class", "btn btn-sm btn-default");
      attr(div4, "class", "d-flex align-items-center align-self-end p-2");
      attr(div5, "class", "d-flex justify-content-between");
      set_style(div7, "flex", "1");
      attr(div8, "class", "flex-1");
      set_style(div8, "max-width", "50px");
      attr(div9, "class", "d-flex align-self-end");
      attr(div10, "class", "card-header flex items-center");
      attr(input1, "class", "form-check-input");
      attr(input1, "type", "checkbox");
      input1.value = "";
      attr(input1, "id", "flexCheckDefault");
      attr(span, "class", "absolute left-4 dropdown-toggle pt-1 px-1 rounded transition-hover hover:bg-white");
      attr(span, "data-bs-toggle", "dropdown");
      attr(span, "aria-expanded", "false");
      attr(a2, "class", "dropdown-item");
      attr(a2, "href", "#");
      attr(ul, "class", "dropdown-menu");
      attr(div12, "class", "btn-group mx-2 align-items-center");
      attr(th0, "class", "align-middle");
      set_style(th0, "position", "sticky");
      set_style(th0, "top", "0");
      set_style(th0, "width", "4rem");
      set_style(th1, "position", "sticky");
      set_style(th1, "top", "0");
      set_style(th2, "position", "sticky");
      set_style(th2, "top", "0");
      set_style(th3, "position", "sticky");
      set_style(th3, "top", "0");
      set_style(th3, "width", "13rem");
      set_style(th4, "position", "sticky");
      set_style(th4, "top", "0");
      set_style(th4, "width", "6rem");
      attr(tr, "class", "bg-gray-200");
      attr(thead, "class", "table-light");
      attr(table, "class", "table");
      set_style(div13, "max-height", "55vh");
      set_style(div13, "overflow-y", "auto");
      set_style(div13, "scrollbar-width", "thin");
      attr(div14, "class", "card panel-default mt-2 me-2");
      attr(button1, "class", "btn btn-primary me-2");
      button1.disabled = button1_disabled_value = !ctx[11];
      attr(div16, "class", "d-flex w-100 mt-4 justify-content-end");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      append(div0, p);
      append(p, t0);
      append(p, t1);
      append(p, a0);
      append(a0, t2);
      append(p, t3);
      append(p, a1);
      append(a1, t4);
      append(div5, t5);
      append(div5, div4);
      append(div4, div3);
      append(div3, label);
      append(label, div1);
      append(label, t7);
      append(label, div2);
      append(div2, input0);
      append(div4, t8);
      append(div4, button0);
      insert(target, t9, anchor);
      insert(target, div14, anchor);
      append(div14, div10);
      append(div10, div6);
      append(div6, h3);
      append(div6, t11);
      if_block.m(div6, null);
      append(div10, t12);
      append(div10, div7);
      append(div10, t13);
      append(div10, div8);
      append(div10, t14);
      append(div10, div9);
      mount_component(searchbar, div9, null);
      append(div9, t15);
      mount_component(menu, div9, null);
      append(div9, t16);
      mount_component(sortby, div9, null);
      append(div14, t17);
      append(div14, div13);
      append(div13, table);
      append(table, thead);
      append(thead, tr);
      append(tr, th0);
      append(th0, div12);
      append(div12, div11);
      append(div11, input1);
      append(div12, t18);
      append(div12, span);
      append(div12, t19);
      append(div12, ul);
      append(ul, li);
      append(li, a2);
      append(tr, t21);
      append(tr, th1);
      append(tr, t23);
      append(tr, th2);
      append(tr, t25);
      append(tr, th3);
      append(tr, t27);
      append(tr, th4);
      append(table, t29);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      insert(target, t30, anchor);
      insert(target, div16, anchor);
      append(div16, div15);
      append(div15, button1);
      append(button1, t31);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "click", ctx[21]),
          listen(button0, "click", ctx[35]),
          listen(input1, "click", ctx[22]),
          listen(a2, "click", ctx[37]),
          listen(button1, "click", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 512) && t0_value !== (t0_value = ctx2[9].total + ""))
        set_data(t0, t0_value);
      if ((!current || dirty[0] & 8192) && t2_value !== (t2_value = ctx2[13].ts + ""))
        set_data(t2, t2_value);
      if ((!current || dirty[0] & 4096) && t4_value !== (t4_value = ctx2[12].name + ""))
        set_data(t4, t4_value);
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div6, null);
        }
      }
      const menu_changes = {};
      if (dirty[0] & 16)
        menu_changes.defaultActionLabel = ctx2[17][ctx2[4]].title;
      if (!updating_id && dirty[0] & 16) {
        updating_id = true;
        menu_changes.id = ctx2[4];
        add_flush_callback(() => updating_id = false);
      }
      menu.$set(menu_changes);
      const sortby_changes = {};
      if (dirty[0] & 8)
        sortby_changes.currentFieldName = ctx2[3];
      sortby.$set(sortby_changes);
      if (dirty[0] & 32) {
        each_value = ctx2[5];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$p, null, get_each_context$p);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block_1$b();
          each_1_else.c();
          each_1_else.m(tbody, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
      if (!current || dirty[0] & 2048 && button1_disabled_value !== (button1_disabled_value = !ctx2[11])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      transition_in(menu.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      transition_out(menu.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (detaching)
        detach(t9);
      if (detaching)
        detach(div14);
      if_block.d();
      destroy_component(searchbar);
      destroy_component(menu);
      destroy_component(sortby);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
      if (detaching)
        detach(t30);
      if (detaching)
        detach(div16);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_2$4(ctx) {
  let small;
  return {
    c() {
      small = element("small");
      small.textContent = "No summary to display";
    },
    m(target, anchor) {
      insert(target, small, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_if_block_1$x(ctx) {
  let small;
  let t0_value = ctx[9].totalUnlinked + "";
  let t0;
  let t1;
  let t2_value = ctx[9].totalUnlinked > 1 ? "s" : "";
  let t2;
  let t3;
  return {
    c() {
      small = element("small");
      t0 = text(t0_value);
      t1 = text(" URL");
      t2 = text(t2_value);
      t3 = text(" not monitored");
    },
    m(target, anchor) {
      insert(target, small, anchor);
      append(small, t0);
      append(small, t1);
      append(small, t2);
      append(small, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 512 && t0_value !== (t0_value = ctx2[9].totalUnlinked + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 512 && t2_value !== (t2_value = ctx2[9].totalUnlinked > 1 ? "s" : ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(small);
    }
  };
}
function create_else_block_1$b(ctx) {
  let td;
  return {
    c() {
      td = element("td");
      td.textContent = "No diff data to display";
      attr(td, "class", "ps-3 py-1");
      attr(td, "colspan", "4");
    },
    m(target, anchor) {
      insert(target, td, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(td);
    }
  };
}
function create_each_block$p(key_1, ctx) {
  let first2;
  let diffdatarow;
  let current;
  diffdatarow = new DiffDataRow({
    props: { diffData: ctx[46] }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(diffdatarow.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(diffdatarow, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const diffdatarow_changes = {};
      if (dirty[0] & 32)
        diffdatarow_changes.diffData = ctx[46];
      diffdatarow.$set(diffdatarow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(diffdatarow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(diffdatarow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(diffdatarow, detaching);
    }
  };
}
function create_pending_block$i(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$1s(ctx) {
  let t;
  let current_block_type_index;
  let if_block1;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[7] && create_if_block_2$o(ctx);
  const if_block_creators = [create_if_block$K, create_else_block$v];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[7]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$o(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$1p($$self, $$props, $$invalidate) {
  let enableImport;
  let $crawler, $$unsubscribe_crawler = noop$1, $$subscribe_crawler = () => ($$unsubscribe_crawler(), $$unsubscribe_crawler = subscribe(crawler, ($$value) => $$invalidate(12, $crawler = $$value)), crawler);
  let $diffDataModel, $$unsubscribe_diffDataModel = noop$1, $$subscribe_diffDataModel = () => ($$unsubscribe_diffDataModel(), $$unsubscribe_diffDataModel = subscribe(diffDataModel, ($$value) => $$invalidate(30, $diffDataModel = $$value)), diffDataModel);
  let $params;
  let $job;
  component_subscribe($$self, params, ($$value) => $$invalidate(41, $params = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_crawler());
  $$self.$$.on_destroy.push(() => $$unsubscribe_diffDataModel());
  let { crawler } = $$props;
  $$subscribe_crawler();
  let { jobIDs } = $$props;
  const { jobID1, jobID2 } = jobIDs;
  const team = $params.team;
  const SORTING_FIELDS = [
    {
      value: "url",
      label: "URL Ascending",
      comparator(model) {
        return model.get("url");
      }
    },
    {
      value: "-url",
      label: "URL Descending",
      comparator(diffA, diffB) {
        if (diffA.get("url") > diffB.get("url"))
          return -1;
        if (diffB.get("url") > diffA.get("url"))
          return 1;
        return 0;
      }
    },
    {
      value: "first_seen_on",
      label: "First Seen (Oldest to Newest)",
      comparator(model) {
        return -new Date(model.get("first_seen_on"));
      }
    },
    {
      value: "-first_seen_on",
      label: "First Seen (Newest to Oldest)",
      comparator(model) {
        return new Date(model.get("first_seen_on"));
      }
    },
    {
      value: "monitor",
      label: "Monitored (First)",
      comparator(model) {
        return -model.get("monitored");
      }
    },
    {
      value: "-monitor",
      label: "Monitored (Last)",
      comparator(model) {
        return model.get("monitored");
      }
    }
  ];
  let excludedParams = [
    "__hsfp",
    "__hssc",
    "__hstc",
    "__s",
    "_bhlid",
    "_branch_match_id",
    "_branch_referrer",
    "_gl",
    "_hsenc",
    "_kx",
    "_openstat",
    "at_recipient_id",
    "at_recipient_list",
    "bbeml",
    "bsft_clkid",
    "bsft_uid",
    "dclid",
    "et_rid",
    "fb_action_ids",
    "fb_comment_id",
    "fbclid",
    "gbraid",
    "gclid",
    "guce_referrer",
    "guce_referrer_sig",
    "hsCtaTracking",
    "irclickid",
    "mc_eid",
    "ml_subscriber",
    "ml_subscriber_hash",
    "msclkid",
    "mtm_cid",
    "oft_c",
    "oft_ck",
    "oft_d",
    "oft_id",
    "oft_ids",
    "oft_k",
    "oft_lk",
    "oft_sk",
    "oly_anon_id",
    "oly_enc_id",
    "pk_cid",
    "rb_clickid",
    "s_cid",
    "srsltid",
    "ss_email_id",
    "twclid",
    "unicorn_click_id",
    "utm_source",
    "utm_source",
    "utm_medium",
    "utm_campaign",
    "utm_term",
    "utm_content",
    "vero_conv",
    "vero_id",
    "vgo_ee",
    "wbraid",
    "wickedid",
    "yclid",
    "ymclid",
    "ysclid"
  ];
  let currentSortingField = "-monitor";
  const MENU_ITEMS = [
    {
      id: 0,
      name: "Show All URLs",
      title: "Show All URLs"
    },
    {
      id: 1,
      name: "Show URLs Without monitors",
      title: "Show URLs Without monitors"
    }
  ];
  let id2 = 0;
  let diffDataModel;
  let filteredDiff;
  let showImportPage = false;
  let showFilterModal = false;
  let currentFilterString = excludedParams.join(", ");
  let summary = {};
  let fetchResolved;
  let pagePromise = new Promise((res) => {
    fetchResolved = res;
  });
  let crawlerID = $crawler.id;
  let job = new CrawlerJob({ id: jobID1 }, { crawler_id: crawlerID });
  component_subscribe($$self, job, (value) => $$invalidate(13, $job = value));
  let importSieves = [];
  let opt = {};
  let collectionFilters = {};
  async function cleanURLs(e) {
    if (e.target.checked) {
      opt.excludedParams = excludedParams;
    } else {
      delete opt.excludedParams;
    }
    await fetchURLs();
  }
  async function selectURLs(event, selectNotMonitored) {
    if (selectNotMonitored) {
      filteredDiff.map((el2) => {
        if (!el2.get("monitored")) {
          el2.set("checked", true);
        }
      });
      return;
    }
    filteredDiff.map((el2) => {
      el2.set("checked", event.target.checked);
    });
  }
  async function goToImportPage() {
    let selectedModels = diffDataModel.getSelected();
    $$invalidate(10, importSieves = selectedModels.map((model) => {
      var _a;
      let url = model.get("url");
      return {
        name: `${((_a = model.get("meta")) == null ? void 0 : _a.title) || getNameFromURL(url)}`,
        url,
        content_type: getSieveContentType(model.get("content_type"))
      };
    }));
    $$invalidate(6, showImportPage = true);
  }
  function applyFilters(model) {
    if (typeof collectionFilters.monitored !== "undefined") {
      if (model.get("monitored")) {
        return false;
      }
    }
    if (collectionFilters.like) {
      if (!model.get("url").includes(collectionFilters.like)) {
        return false;
      }
    }
    return true;
  }
  async function fetchURLs() {
    try {
      let diffEndpoint = `/crawlers/${crawlerID}/diff-summary/${jobID1}?id2=${jobID2}`;
      const diffData = await Api.utils({
        url: diffEndpoint,
        method: "GET",
        json: opt
      });
      $$subscribe_diffDataModel($$invalidate(1, diffDataModel = new UrlDiffs(diffData.diff, { crawlerID, jobID1, jobID2 })));
      $$invalidate(9, summary = diffData.summary);
      diffDataModel.sort();
      $$invalidate(5, filteredDiff = diffDataModel.filter(applyFilters));
    } catch (err) {
      Msg.error("Failed to fetch URLs");
      console.error("Could not fetch URLs", err);
    }
  }
  function updateFilters() {
    $$invalidate(2, excludedParams = currentFilterString.split(",").map((el2) => el2.trim()));
  }
  function onSearch(e) {
    var _a;
    let searchQuery = (_a = e.detail) == null ? void 0 : _a.phrase;
    if (searchQuery.length === 0) {
      delete collectionFilters.like;
    } else {
      collectionFilters.like = searchQuery;
    }
    $$invalidate(5, filteredDiff = diffDataModel.filter(applyFilters));
  }
  function onFilterMonitored(e) {
    if (e.detail) {
      collectionFilters.monitored = true;
    } else {
      delete collectionFilters.monitored;
    }
    $$invalidate(5, filteredDiff = diffDataModel.filter(applyFilters));
  }
  function onSort(sortingField) {
    $$subscribe_diffDataModel($$invalidate(1, diffDataModel.comparator = SORTING_FIELDS.find((field) => field.value === sortingField).comparator, diffDataModel));
    $$invalidate(3, currentSortingField = sortingField);
    diffDataModel.sort();
    $$invalidate(5, filteredDiff = diffDataModel.filter(applyFilters));
  }
  function getSieveContentType(contentType) {
    switch (contentType) {
      case "application/pdf":
        return C$1.TYPE_PDF_HTML;
      default:
        return C$1.TYPE_HTML;
    }
  }
  job.fetch();
  fetchURLs().then((res) => {
    fetchResolved();
  });
  function textarea_input_handler() {
    currentFilterString = this.value;
    $$invalidate(8, currentFilterString);
  }
  const func2 = () => {
    updateFilters();
    $$invalidate(7, showFilterModal = false);
    fetchURLs();
  };
  const close_handler = () => {
    $$invalidate(8, currentFilterString = excludedParams.join(", "));
    $$invalidate(7, showFilterModal = false);
  };
  const back_handler = () => {
    $$invalidate(6, showImportPage = false);
  };
  const click_handler = () => {
    $$invalidate(7, showFilterModal = !showFilterModal);
  };
  function menu_id_binding(value) {
    id2 = value;
    $$invalidate(4, id2);
  }
  const click_handler_1 = (e) => selectURLs(e, true);
  $$self.$$set = ($$props2) => {
    if ("crawler" in $$props2)
      $$subscribe_crawler($$invalidate(0, crawler = $$props2.crawler));
    if ("jobIDs" in $$props2)
      $$invalidate(29, jobIDs = $$props2.jobIDs);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 1073741826) {
      $$invalidate(11, enableImport = $diffDataModel && diffDataModel.getSelected().length > 0);
    }
  };
  return [
    crawler,
    diffDataModel,
    excludedParams,
    currentSortingField,
    id2,
    filteredDiff,
    showImportPage,
    showFilterModal,
    currentFilterString,
    summary,
    importSieves,
    enableImport,
    $crawler,
    $job,
    jobID1,
    team,
    SORTING_FIELDS,
    MENU_ITEMS,
    pagePromise,
    crawlerID,
    job,
    cleanURLs,
    selectURLs,
    goToImportPage,
    fetchURLs,
    updateFilters,
    onSearch,
    onFilterMonitored,
    onSort,
    jobIDs,
    $diffDataModel,
    textarea_input_handler,
    func2,
    close_handler,
    back_handler,
    click_handler,
    menu_id_binding,
    click_handler_1
  ];
}
class DiffList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1p, create_fragment$1s, safe_not_equal, { crawler: 0, jobIDs: 29 }, null, [-1, -1]);
  }
}
function create_catch_block$h(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$h(ctx) {
  let difflist;
  let current;
  difflist = new DiffList({
    props: {
      crawler: ctx[4],
      jobIDs: {
        jobID1: ctx[0],
        jobID2: ctx[1]
      }
    }
  });
  return {
    c() {
      create_component(difflist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(difflist, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(difflist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(difflist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(difflist, detaching);
    }
  };
}
function create_pending_block$h(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$1r(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$h,
    then: create_then_block$h,
    catch: create_catch_block$h,
    value: 12,
    blocks: [, , ,]
  };
  handle_promise(ctx[3], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$1o($$self, $$props, $$invalidate) {
  let $user;
  let $querystring;
  component_subscribe($$self, querystring, ($$value) => $$invalidate(8, $querystring = $$value));
  let query = qs.parse($querystring);
  const crawlerID = query.crawler_id;
  const jobID1 = query.job_id1;
  const jobID2 = query.job_id2;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(7, $user = value));
  let labels = new ModelLabel.Labels();
  let fetchResolved;
  let pagePromise = new Promise((res) => {
    fetchResolved = res;
  });
  labels.fetch();
  setContext("labels", labels);
  const clients = new ModelClient.Clients($user.clients);
  clients.defaultId = getContext("clientId");
  setContext("clients", clients);
  window.App.clients = clients;
  let crawler = new Crawler$2({ id: crawlerID });
  crawler.fetch().then((res) => {
    fetchResolved();
  });
  return [jobID1, jobID2, user, pagePromise, crawler];
}
class Import_sitemap extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1o, create_fragment$1r, safe_not_equal, {});
  }
}
function create_else_block$u(ctx) {
  let importjson;
  let current;
  importjson = new Import_json({});
  return {
    c() {
      create_component(importjson.$$.fragment);
    },
    m(target, anchor) {
      mount_component(importjson, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(importjson.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(importjson.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(importjson, detaching);
    }
  };
}
function create_if_block_1$w(ctx) {
  let importsitemap;
  let current;
  importsitemap = new Import_sitemap({});
  return {
    c() {
      create_component(importsitemap.$$.fragment);
    },
    m(target, anchor) {
      mount_component(importsitemap, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(importsitemap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(importsitemap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(importsitemap, detaching);
    }
  };
}
function create_if_block$J(ctx) {
  let importcsv;
  let current;
  importcsv = new Import_csv({});
  return {
    c() {
      create_component(importcsv.$$.fragment);
    },
    m(target, anchor) {
      mount_component(importcsv, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(importcsv.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(importcsv.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(importcsv, detaching);
    }
  };
}
function create_fragment$1q(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$J, create_if_block_1$w, create_else_block$u];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].prefix == "csv")
      return 0;
    if (ctx2[0].prefix == "from-sitemap")
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1n($$self, $$props, $$invalidate) {
  let { route: route2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("route" in $$props2)
      $$invalidate(0, route2 = $$props2.route);
  };
  return [route2];
}
class Import extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1n, create_fragment$1q, safe_not_equal, { route: 0 });
  }
}
function create_default_slot$H(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$1p(ctx) {
  let menuitem;
  let current;
  const menuitem_spread_levels = [
    {
      disabled: ctx[1].readOnly || ctx[0]
    },
    ctx[3]
  ];
  let menuitem_props = {
    $$slots: { default: [create_default_slot$H] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < menuitem_spread_levels.length; i2 += 1) {
    menuitem_props = assign(menuitem_props, menuitem_spread_levels[i2]);
  }
  menuitem = new MenuItem({ props: menuitem_props });
  menuitem.$on("click", ctx[5]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menuitem_changes = dirty & 11 ? get_spread_update(menuitem_spread_levels, [
        dirty & 3 && {
          disabled: ctx2[1].readOnly || ctx2[0]
        },
        dirty & 8 && get_spread_object(ctx2[3])
      ]) : {};
      if (dirty & 64) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function instance$1m($$self, $$props, $$invalidate) {
  const omit_props_names = ["disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $permissionsModel;
  let { $$slots: slots = {}, $$scope } = $$props;
  const permissionsModel = App.user.permissionsModel;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(1, $permissionsModel = value));
  let { disabled = false } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("disabled" in $$new_props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  return [
    disabled,
    $permissionsModel,
    permissionsModel,
    $$restProps,
    slots,
    click_handler,
    $$scope
  ];
}
class MenuItemWithPermissions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1m, create_fragment$1p, safe_not_equal, { disabled: 0 });
  }
}
function create_action_slot$b(ctx) {
  let a;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      attr(a, "class", "nav-link dropdown-toggle");
      set_style(a, "margin-left", "-24px");
      toggle_class(a, "active", ctx[5]);
      toggle_class(a, "text-white", ctx[5]);
      toggle_class(a, "text-secondsary-emphasis", !ctx[5]);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      if (!mounted) {
        dispose = listen(a, "click", function() {
          if (is_function(ctx[12]))
            ctx[12].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32) {
        toggle_class(a, "active", ctx[5]);
      }
      if (dirty & 32) {
        toggle_class(a, "text-white", ctx[5]);
      }
      if (dirty & 32) {
        toggle_class(a, "text-secondsary-emphasis", !ctx[5]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3$6(ctx) {
  let i2;
  let t0;
  let t1_value = TXT("a_rename") + "";
  let t1;
  return {
    c() {
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fa fa-pencil");
      attr(i2, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(i2);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot_2$7(ctx) {
  let i2;
  let t0;
  let t1_value = TXT("a_del") + "";
  let t1;
  return {
    c() {
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fa fa-trash-o");
      attr(i2, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(i2);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot_1$b(ctx) {
  let menuitemwithpermissions0;
  let t;
  let menuitemwithpermissions1;
  let current;
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_3$6] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions0.$on("click", ctx[7]);
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_2$7] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1.$on("click", ctx[6]);
  return {
    c() {
      create_component(menuitemwithpermissions0.$$.fragment);
      t = space();
      create_component(menuitemwithpermissions1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions0, target, anchor);
      insert(target, t, anchor);
      mount_component(menuitemwithpermissions1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions0_changes = {};
      if (dirty & 8192) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 8192) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions0, detaching);
      if (detaching)
        detach(t);
      destroy_component(menuitemwithpermissions1, detaching);
    }
  };
}
function create_if_block$I(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      onSave: ctx[8],
      title: TXT("Rename Label"),
      $$slots: { default: [create_default_slot$G] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[11]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 8208) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$G(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "class", "form-control");
      attr(input, "type", "text");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[4]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16 && input.value !== ctx2[4]) {
        set_input_value(input, ctx2[4]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1o(ctx) {
  let li;
  let a;
  let t0_value = ctx[2].name + "";
  let t0;
  let a_href_value;
  let a_title_value;
  let t1;
  let menu;
  let t2;
  let if_block_anchor;
  let current;
  menu = new Menu({
    props: {
      strategy: "fixed",
      placement: "bottom-end",
      $$slots: {
        default: [create_default_slot_1$b],
        action: [
          create_action_slot$b,
          ({ onClick }) => ({ 12: onClick }),
          ({ onClick }) => onClick ? 4096 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[3] && create_if_block$I(ctx);
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      create_component(menu.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(a, "class", "flex-1 nav-link");
      attr(a, "href", a_href_value = "#/w/" + ctx[1].team + "/list/label/" + ctx[9]() + ".d/");
      attr(a, "title", a_title_value = ctx[2].name);
      toggle_class(a, "active", ctx[5]);
      attr(li, "class", "nav-item text-nowrap overflow-hidden d-flex align-items-center");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
      mount_component(menu, li, null);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 4) && t0_value !== (t0_value = ctx2[2].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 2 && a_href_value !== (a_href_value = "#/w/" + ctx2[1].team + "/list/label/" + ctx2[9]() + ".d/")) {
        attr(a, "href", a_href_value);
      }
      if (!current || dirty & 4 && a_title_value !== (a_title_value = ctx2[2].name)) {
        attr(a, "title", a_title_value);
      }
      if (!current || dirty & 32) {
        toggle_class(a, "active", ctx2[5]);
      }
      const menu_changes = {};
      if (dirty & 12320) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$I(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      destroy_component(menu);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$1l($$self, $$props, $$invalidate) {
  let $route;
  let $label, $$unsubscribe_label = noop$1, $$subscribe_label = () => ($$unsubscribe_label(), $$unsubscribe_label = subscribe(label, ($$value) => $$invalidate(2, $label = $$value)), label);
  component_subscribe($$self, route, ($$value) => $$invalidate(1, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_label());
  let { label } = $$props;
  $$subscribe_label();
  let renameModal = false;
  let newLabelName = $label.name;
  let active = false;
  async function onDel(e) {
    e.preventDefault();
    await label.destroy();
  }
  async function onRename(e) {
    e.preventDefault();
    $$invalidate(3, renameModal = true);
  }
  async function onSaveName() {
    let name = newLabelName;
    await label.save({ name }, { patch: true, wait: true });
    $$invalidate(3, renameModal = false);
  }
  function getPath() {
    return $label.id;
  }
  function input_input_handler() {
    newLabelName = this.value;
    $$invalidate(4, newLabelName);
  }
  const close_handler = (e) => $$invalidate(3, renameModal = false);
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$subscribe_label($$invalidate(0, label = $$props2.label));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      $$invalidate(5, active = $route.prefix === "label" && $label.id == $route.data);
    }
  };
  return [
    label,
    $route,
    $label,
    renameModal,
    newLabelName,
    active,
    onDel,
    onRename,
    onSaveName,
    getPath,
    input_input_handler,
    close_handler
  ];
}
class Label extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1l, create_fragment$1o, safe_not_equal, { label: 0 });
  }
}
function get_each_context$o(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  return child_ctx;
}
function create_default_slot_9$1(ctx) {
  let t_value = TXT("l_webpage") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_8$3(ctx) {
  let t_value = TXT("l_feed") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7$3(ctx) {
  let t_value = TXT("l_json") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6$3(ctx) {
  let t_value = TXT("l_pdf") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5$3(ctx) {
  let t_value = TXT("l_uptime") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_4$3(ctx) {
  let t_value = TXT("l_doc") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$5(ctx) {
  let t_value = TXT("l_xml") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$6(ctx) {
  let t_value = TXT("l_sitemap") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3$j(ctx) {
  let menuitemwithpermissions;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      href: "#/w/" + ctx[1] + "/sieve/add/json.d?type=" + C$1.DS_TYPE_SCRAPER,
      $$slots: { default: [create_default_slot_1$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 2)
        menuitemwithpermissions_changes.href = "#/w/" + ctx2[1] + "/sieve/add/json.d?type=" + C$1.DS_TYPE_SCRAPER;
      if (dirty & 1048576) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_default_slot_1$a(ctx) {
  let t_value = TXT("l_scraper") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$n(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[4]);
      attr(span, "class", "badge rounded-pill bg-primary float-end");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        set_data(t, ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_1$v(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[3]);
      attr(span, "class", "badge rounded-pill bg-danger float-end");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$o(key_1, ctx) {
  let first2;
  let label;
  let current;
  label = new Label({ props: { label: ctx[17] } });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(label.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(label, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const label_changes = {};
      if (dirty & 64)
        label_changes.label = ctx[17];
      label.$set(label_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(label.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(label, detaching);
    }
  };
}
function create_if_block$H(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Add Label",
      onSave: ctx[13],
      $$slots: { default: [create_default_slot$F] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[15]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 1048576) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot$F(ctx) {
  let inputedit;
  let current;
  inputedit = new InputEdit({ props: { field: ctx[11] } });
  return {
    c() {
      create_component(inputedit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputedit, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(inputedit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputedit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputedit, detaching);
    }
  };
}
function create_fragment$1n(ctx) {
  let div1;
  let div0;
  let button0;
  let t1;
  let ul0;
  let menuitemwithpermissions0;
  let t2;
  let menuitemwithpermissions1;
  let t3;
  let menuitemwithpermissions2;
  let t4;
  let menuitemwithpermissions3;
  let t5;
  let menuitemwithpermissions4;
  let t6;
  let menuitemwithpermissions5;
  let t7;
  let menuitemwithpermissions6;
  let t8;
  let menuitemwithpermissions7;
  let t9;
  let t10;
  let ul1;
  let li0;
  let a0;
  let t11_value = TXT("l_all") + "";
  let t11;
  let a0_href_value;
  let t12;
  let li1;
  let a1;
  let t13_value = TXT("l_unread") + "";
  let t13;
  let t14;
  let a1_href_value;
  let t15;
  let li2;
  let a2;
  let t16_value = TXT("l_error") + "";
  let t16;
  let t17;
  let a2_href_value;
  let t18;
  let li3;
  let a3;
  let t19_value = TXT("l_trash") + "";
  let t19;
  let a3_href_value;
  let t20;
  let hr;
  let t21;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t22;
  let div2;
  let button1;
  let t23_value = TXT("a_add_label") + "";
  let t23;
  let button1_disabled_value;
  let t24;
  let if_block3_anchor;
  let current;
  let mounted;
  let dispose;
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      "ph-event": PHEvents.ADD_MONITOR.WEBPAGE,
      href: "#/w/" + ctx[1] + "/sieve/add/page.d",
      $$slots: { default: [create_default_slot_9$1] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      "ph-event": PHEvents.ADD_MONITOR.FEED,
      href: "#/w/" + ctx[1] + "/sieve/add/feed.d",
      $$slots: { default: [create_default_slot_8$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions2 = new MenuItemWithPermissions({
    props: {
      "ph-event": PHEvents.ADD_MONITOR.JSON,
      href: "#/w/" + ctx[1] + "/sieve/add/json.d?type=" + C$1.DS_TYPE_JSON,
      $$slots: { default: [create_default_slot_7$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions3 = new MenuItemWithPermissions({
    props: {
      "ph-event": PHEvents.ADD_MONITOR.PDF,
      href: "#/w/" + ctx[1] + "/sieve/add/pdf.d",
      $$slots: { default: [create_default_slot_6$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions4 = new MenuItemWithPermissions({
    props: {
      "ph-event": PHEvents.ADD_MONITOR.UPTIME,
      href: "#/w/" + ctx[1] + "/sieve/add/json.d?type=" + C$1.DS_TYPE_UPTIME,
      $$slots: { default: [create_default_slot_5$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions5 = new MenuItemWithPermissions({
    props: {
      "ph-event": PHEvents.ADD_MONITOR.DOC,
      href: "#/w/" + ctx[1] + "/sieve/add/doc.d",
      $$slots: { default: [create_default_slot_4$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions6 = new MenuItemWithPermissions({
    props: {
      "ph-event": PHEvents.ADD_MONITOR.XML,
      href: "#/w/" + ctx[1] + "/sieve/add/xml.d",
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions7 = new MenuItemWithPermissions({
    props: {
      "ph-event": PHEvents.ADD_MONITOR.SITEMAP,
      href: "#/w/" + ctx[1] + "/sieve/add/sitemap.d",
      $$slots: { default: [create_default_slot_2$6] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[5] == true && create_if_block_3$j(ctx);
  let if_block1 = ctx[4] > 0 && create_if_block_2$n(ctx);
  let if_block2 = ctx[3] > 0 && create_if_block_1$v(ctx);
  let each_value = ctx[6].models;
  const get_key = (ctx2) => ctx2[17].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$o(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$o(key, child_ctx));
  }
  let if_block3 = ctx[0] && create_if_block$H(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.textContent = `${TXT("l_add_monitor")}`;
      t1 = space();
      ul0 = element("ul");
      create_component(menuitemwithpermissions0.$$.fragment);
      t2 = space();
      create_component(menuitemwithpermissions1.$$.fragment);
      t3 = space();
      create_component(menuitemwithpermissions2.$$.fragment);
      t4 = space();
      create_component(menuitemwithpermissions3.$$.fragment);
      t5 = space();
      create_component(menuitemwithpermissions4.$$.fragment);
      t6 = space();
      create_component(menuitemwithpermissions5.$$.fragment);
      t7 = space();
      create_component(menuitemwithpermissions6.$$.fragment);
      t8 = space();
      create_component(menuitemwithpermissions7.$$.fragment);
      t9 = space();
      if (if_block0)
        if_block0.c();
      t10 = space();
      ul1 = element("ul");
      li0 = element("li");
      a0 = element("a");
      t11 = text(t11_value);
      t12 = space();
      li1 = element("li");
      a1 = element("a");
      t13 = text(t13_value);
      t14 = space();
      if (if_block1)
        if_block1.c();
      t15 = space();
      li2 = element("li");
      a2 = element("a");
      t16 = text(t16_value);
      t17 = space();
      if (if_block2)
        if_block2.c();
      t18 = space();
      li3 = element("li");
      a3 = element("a");
      t19 = text(t19_value);
      t20 = space();
      hr = element("hr");
      t21 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t22 = space();
      div2 = element("div");
      button1 = element("button");
      t23 = text(t23_value);
      t24 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      attr(button0, "class", "btn btn-success rounded-end");
      attr(button0, "data-bs-toggle", "dropdown");
      attr(ul0, "class", "dropdown-menu w-100");
      attr(ul0, "role", "menu");
      attr(div0, "class", "btn-group btn-block mb-3 w-100");
      attr(a0, "class", "nav-link");
      attr(a0, "href", a0_href_value = "#/w/" + ctx[1] + "/list/all/");
      toggle_class(a0, "active", ctx[2].prefix === "all");
      attr(li0, "class", "nav-item");
      attr(a1, "class", "nav-link");
      attr(a1, "href", a1_href_value = "#/w/" + ctx[1] + "/list/unread/");
      toggle_class(a1, "active", ctx[2].prefix === "unread");
      attr(li1, "class", "nav-item");
      attr(a2, "class", "nav-link");
      attr(a2, "href", a2_href_value = "#/w/" + ctx[1] + "/list/error/");
      toggle_class(a2, "active", ctx[2].prefix === "error");
      attr(li2, "class", "nav-item");
      attr(a3, "class", "nav-link");
      attr(a3, "href", a3_href_value = "#/w/" + ctx[1] + "/list/trash/");
      toggle_class(a3, "active", ctx[2].prefix === "trash");
      attr(li3, "class", "nav-item");
      attr(hr, "class", "p-0 m-0");
      attr(ul1, "class", "nav nav-pills watchlist-nav-spacing flex-column mb-4");
      attr(button1, "class", "btn btn-default w-100 mt-2");
      button1.disabled = button1_disabled_value = ctx[7].readOnly;
      attr(div2, "class", "sticky-bottom z-0");
      attr(div2, "style", "");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, ul0);
      mount_component(menuitemwithpermissions0, ul0, null);
      append(ul0, t2);
      mount_component(menuitemwithpermissions1, ul0, null);
      append(ul0, t3);
      mount_component(menuitemwithpermissions2, ul0, null);
      append(ul0, t4);
      mount_component(menuitemwithpermissions3, ul0, null);
      append(ul0, t5);
      mount_component(menuitemwithpermissions4, ul0, null);
      append(ul0, t6);
      mount_component(menuitemwithpermissions5, ul0, null);
      append(ul0, t7);
      mount_component(menuitemwithpermissions6, ul0, null);
      append(ul0, t8);
      mount_component(menuitemwithpermissions7, ul0, null);
      append(ul0, t9);
      if (if_block0)
        if_block0.m(ul0, null);
      append(div1, t10);
      append(div1, ul1);
      append(ul1, li0);
      append(li0, a0);
      append(a0, t11);
      append(ul1, t12);
      append(ul1, li1);
      append(li1, a1);
      append(a1, t13);
      append(a1, t14);
      if (if_block1)
        if_block1.m(a1, null);
      append(ul1, t15);
      append(ul1, li2);
      append(li2, a2);
      append(a2, t16);
      append(a2, t17);
      if (if_block2)
        if_block2.m(a2, null);
      append(ul1, t18);
      append(ul1, li3);
      append(li3, a3);
      append(a3, t19);
      append(ul1, t20);
      append(ul1, hr);
      append(ul1, t21);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ul1, null);
        }
      }
      insert(target, t22, anchor);
      insert(target, div2, anchor);
      append(div2, button1);
      append(button1, t23);
      insert(target, t24, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button1, "click", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const menuitemwithpermissions0_changes = {};
      if (dirty & 2)
        menuitemwithpermissions0_changes.href = "#/w/" + ctx2[1] + "/sieve/add/page.d";
      if (dirty & 1048576) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 2)
        menuitemwithpermissions1_changes.href = "#/w/" + ctx2[1] + "/sieve/add/feed.d";
      if (dirty & 1048576) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
      const menuitemwithpermissions2_changes = {};
      if (dirty & 2)
        menuitemwithpermissions2_changes.href = "#/w/" + ctx2[1] + "/sieve/add/json.d?type=" + C$1.DS_TYPE_JSON;
      if (dirty & 1048576) {
        menuitemwithpermissions2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions2.$set(menuitemwithpermissions2_changes);
      const menuitemwithpermissions3_changes = {};
      if (dirty & 2)
        menuitemwithpermissions3_changes.href = "#/w/" + ctx2[1] + "/sieve/add/pdf.d";
      if (dirty & 1048576) {
        menuitemwithpermissions3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions3.$set(menuitemwithpermissions3_changes);
      const menuitemwithpermissions4_changes = {};
      if (dirty & 2)
        menuitemwithpermissions4_changes.href = "#/w/" + ctx2[1] + "/sieve/add/json.d?type=" + C$1.DS_TYPE_UPTIME;
      if (dirty & 1048576) {
        menuitemwithpermissions4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions4.$set(menuitemwithpermissions4_changes);
      const menuitemwithpermissions5_changes = {};
      if (dirty & 2)
        menuitemwithpermissions5_changes.href = "#/w/" + ctx2[1] + "/sieve/add/doc.d";
      if (dirty & 1048576) {
        menuitemwithpermissions5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions5.$set(menuitemwithpermissions5_changes);
      const menuitemwithpermissions6_changes = {};
      if (dirty & 2)
        menuitemwithpermissions6_changes.href = "#/w/" + ctx2[1] + "/sieve/add/xml.d";
      if (dirty & 1048576) {
        menuitemwithpermissions6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions6.$set(menuitemwithpermissions6_changes);
      const menuitemwithpermissions7_changes = {};
      if (dirty & 2)
        menuitemwithpermissions7_changes.href = "#/w/" + ctx2[1] + "/sieve/add/sitemap.d";
      if (dirty & 1048576) {
        menuitemwithpermissions7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions7.$set(menuitemwithpermissions7_changes);
      if (ctx2[5] == true) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$j(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(ul0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & 2 && a0_href_value !== (a0_href_value = "#/w/" + ctx2[1] + "/list/all/")) {
        attr(a0, "href", a0_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a0, "active", ctx2[2].prefix === "all");
      }
      if (ctx2[4] > 0) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$n(ctx2);
          if_block1.c();
          if_block1.m(a1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & 2 && a1_href_value !== (a1_href_value = "#/w/" + ctx2[1] + "/list/unread/")) {
        attr(a1, "href", a1_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a1, "active", ctx2[2].prefix === "unread");
      }
      if (ctx2[3] > 0) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$v(ctx2);
          if_block2.c();
          if_block2.m(a2, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & 2 && a2_href_value !== (a2_href_value = "#/w/" + ctx2[1] + "/list/error/")) {
        attr(a2, "href", a2_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a2, "active", ctx2[2].prefix === "error");
      }
      if (!current || dirty & 2 && a3_href_value !== (a3_href_value = "#/w/" + ctx2[1] + "/list/trash/")) {
        attr(a3, "href", a3_href_value);
      }
      if (!current || dirty & 4) {
        toggle_class(a3, "active", ctx2[2].prefix === "trash");
      }
      if (dirty & 64) {
        each_value = ctx2[6].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul1, outro_and_destroy_block, create_each_block$o, null, get_each_context$o);
        check_outros();
      }
      if (!current || dirty & 128 && button1_disabled_value !== (button1_disabled_value = ctx2[7].readOnly)) {
        button1.disabled = button1_disabled_value;
      }
      if (ctx2[0]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$H(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      transition_in(menuitemwithpermissions2.$$.fragment, local);
      transition_in(menuitemwithpermissions3.$$.fragment, local);
      transition_in(menuitemwithpermissions4.$$.fragment, local);
      transition_in(menuitemwithpermissions5.$$.fragment, local);
      transition_in(menuitemwithpermissions6.$$.fragment, local);
      transition_in(menuitemwithpermissions7.$$.fragment, local);
      transition_in(if_block0);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      transition_out(menuitemwithpermissions2.$$.fragment, local);
      transition_out(menuitemwithpermissions3.$$.fragment, local);
      transition_out(menuitemwithpermissions4.$$.fragment, local);
      transition_out(menuitemwithpermissions5.$$.fragment, local);
      transition_out(menuitemwithpermissions6.$$.fragment, local);
      transition_out(menuitemwithpermissions7.$$.fragment, local);
      transition_out(if_block0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(menuitemwithpermissions0);
      destroy_component(menuitemwithpermissions1);
      destroy_component(menuitemwithpermissions2);
      destroy_component(menuitemwithpermissions3);
      destroy_component(menuitemwithpermissions4);
      destroy_component(menuitemwithpermissions5);
      destroy_component(menuitemwithpermissions6);
      destroy_component(menuitemwithpermissions7);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (detaching)
        detach(t22);
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t24);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(if_block3_anchor);
      mounted = false;
      dispose();
    }
  };
}
function instance$1k($$self, $$props, $$invalidate) {
  let isInternalUser;
  let $route;
  let $user;
  let $labels;
  let $permissionsModel;
  component_subscribe($$self, route, ($$value) => $$invalidate(2, $route = $$value));
  let labels = getContext("labels");
  component_subscribe($$self, labels, (value) => $$invalidate(6, $labels = value));
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(14, $user = value));
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(7, $permissionsModel = value));
  const field = createFieldStore({ required: false, type: "string" });
  let nError = 0;
  let nUnread = 0;
  let addLabel = false;
  let team = 0;
  onMount(() => {
    instance$5s.on("user_states", onChangeUnreadError);
  });
  onDestroy(() => {
    instance$5s.off("user_states", onChangeUnreadError);
  });
  async function onAddLabel() {
    $$invalidate(0, addLabel = true);
  }
  async function onAddLabelSave() {
    const labelModels = labels.models;
    const labelNamesSet = new Set(labelModels.map((model) => model.attributes.name));
    const enteredLabelName = field.get();
    if (_.isEmpty(enteredLabelName)) {
      const message = TXT("e_value_incorrect_check");
      field.error.set({ message });
    } else if (labelNamesSet.has(enteredLabelName)) {
      const message = TXT(`e_value_exists`);
      field.error.set({ message });
    } else {
      await labels.create({ name: enteredLabelName }, { wait: true });
      $$invalidate(0, addLabel = false);
    }
  }
  function onChangeUnreadError({ error: error2, unread }) {
    $$invalidate(3, nError = error2);
    $$invalidate(4, nUnread = unread);
  }
  const close_handler = (e) => $$invalidate(0, addLabel = false);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16384) {
      $$invalidate(5, isInternalUser = $user.is_internal_user);
    }
    if ($$self.$$.dirty & 4) {
      {
        $$invalidate(1, team = $route.team);
      }
    }
    if ($$self.$$.dirty & 2) {
      labels.fetch();
    }
    if ($$self.$$.dirty & 1) {
      if (!addLabel) {
        field.set("");
      }
    }
  };
  return [
    addLabel,
    team,
    $route,
    nError,
    nUnread,
    isInternalUser,
    $labels,
    $permissionsModel,
    labels,
    user,
    permissionsModel,
    field,
    onAddLabel,
    onAddLabelSave,
    $user,
    close_handler
  ];
}
class Sidebar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1k, create_fragment$1n, safe_not_equal, {});
  }
}
let messageCount = 0;
const messageMapResolve = {};
const messageMapReject = {};
function messageExtension(details) {
  return new Promise((resolve, reject2) => {
    const id2 = ++messageCount;
    details = { ...details, id: id2 };
    messageMapResolve[id2] = resolve;
    messageMapReject[id2] = reject2;
    const event = new CustomEvent("webapp", { detail: { ...details, id: id2 } });
    event.initEvent("webapp");
    document.dispatchEvent(event);
  });
}
document.addEventListener("webapp_response", (evt) => {
  const detail = JSON.parse(evt.detail);
  const id2 = detail.id;
  const response = detail.response;
  if (response[0]) {
    messageMapReject[id2] && messageMapReject[id2](response[0]);
  } else {
    messageMapResolve[id2] && messageMapResolve[id2](response[1]);
  }
  messageMapResolve[id2] && delete messageMapResolve[id2];
  messageMapReject[id2] && delete messageMapReject[id2];
});
function create_action_slot$a(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "type", "button");
      attr(button, "class", "xbtn-light dropdown-toggle");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[5]))
            ctx[5].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$E(ctx) {
  let li0;
  let a0;
  let t1;
  let li1;
  let a1;
  let t3;
  let li2;
  let a2;
  let t5;
  let li3;
  let a3;
  let mounted;
  let dispose;
  return {
    c() {
      li0 = element("li");
      a0 = element("a");
      a0.textContent = `${TXT("l_all")}`;
      t1 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = `${TXT("l_none")}`;
      t3 = space();
      li2 = element("li");
      a2 = element("a");
      a2.textContent = `${TXT("l_read")}`;
      t5 = space();
      li3 = element("li");
      a3 = element("a");
      a3.textContent = `${TXT("l_unread")}`;
      attr(a0, "class", "dropdown-item");
      attr(a1, "class", "dropdown-item");
      attr(a2, "class", "dropdown-item");
      attr(a3, "class", "dropdown-item");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      append(li0, a0);
      insert(target, t1, anchor);
      insert(target, li1, anchor);
      append(li1, a1);
      insert(target, t3, anchor);
      insert(target, li2, anchor);
      append(li2, a2);
      insert(target, t5, anchor);
      insert(target, li3, anchor);
      append(li3, a3);
      if (!mounted) {
        dispose = [
          listen(a0, "click", ctx[1]),
          listen(a1, "click", ctx[2]),
          listen(a2, "click", ctx[3]),
          listen(a3, "click", ctx[4])
        ];
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(li1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(li2);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(li3);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$1m(ctx) {
  let menu;
  let current;
  menu = new Menu({
    props: {
      showCaret: false,
      $$slots: {
        default: [create_default_slot$E],
        action: [
          create_action_slot$a,
          ({ onClick }) => ({ 5: onClick }),
          ({ onClick }) => onClick ? 32 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 97) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$1j($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const click_handler = () => sieves.toggleSieveSelection(true);
  const click_handler_1 = () => sieves.toggleSieveSelection(false);
  const click_handler_2 = () => sieves.toggleSieveSelection((sieve) => sieve.isRead());
  const click_handler_3 = () => sieves.toggleSieveSelection((sieve) => !sieve.isRead());
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(0, sieves = $$props2.sieves);
  };
  return [sieves, click_handler, click_handler_1, click_handler_2, click_handler_3];
}
class SieveSelectMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1j, create_fragment$1m, safe_not_equal, { sieves: 0 });
  }
}
function create_action_slot$9(ctx) {
  let div;
  let a;
  let i0;
  let t;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      a = element("a");
      i0 = element("i");
      t = space();
      button = element("button");
      button.innerHTML = `<i class="caret"></i>`;
      attr(i0, "class", "fa fa-check");
      attr(a, "class", "btn btn-default min-w-[60px]");
      attr(a, "title", TXT("a_mark_read"));
      toggle_class(a, "disabled", ctx[0]);
      attr(button, "class", "btn btn-default dropdown-toggle");
      attr(button, "data-toggle", "dropdown");
      set_style(button, "min-width", "20px");
      attr(div, "class", "btn-group flex nowrap");
      attr(div, "disabled", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(a, i0);
      append(div, t);
      append(div, button);
      if (!mounted) {
        dispose = [
          listen(a, "click", prevent_default(ctx[3])),
          listen(button, "click", function() {
            if (is_function(ctx[4]))
              ctx[4].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1) {
        toggle_class(a, "disabled", ctx[0]);
      }
      if (dirty & 1) {
        attr(div, "disabled", ctx[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_1$9(ctx) {
  let t_value = TXT("Mark as unread") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$D(ctx) {
  let menuitemwithpermissions;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      tabindex: "-1",
      $$slots: { default: [create_default_slot_1$9] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions.$on("click", ctx[2]);
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 32) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_fragment$1l(ctx) {
  let menu;
  let current;
  menu = new Menu({
    props: {
      $$slots: {
        default: [create_default_slot$D],
        action: [
          create_action_slot$9,
          ({ onClick }) => ({ 4: onClick }),
          ({ onClick }) => onClick ? 16 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 51) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$1i($$self, $$props, $$invalidate) {
  let { disabled = false } = $$props;
  let { sieves } = $$props;
  const click_handler = () => sieves.markAsRead(false);
  const click_handler_1 = () => !disabled && sieves.markAsRead();
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(0, disabled = $$props2.disabled);
    if ("sieves" in $$props2)
      $$invalidate(1, sieves = $$props2.sieves);
  };
  return [disabled, sieves, click_handler, click_handler_1];
}
class MarkSieveReadMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1i, create_fragment$1l, safe_not_equal, { disabled: 0, sieves: 1 });
  }
}
function get_each_context$n(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_action_slot$8(ctx) {
  let button;
  let i2;
  let t;
  let span;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      t = space();
      span = element("span");
      attr(i2, "class", "fa fa-tags");
      attr(span, "class", "caret");
      attr(button, "class", "btn btn-default");
      button.disabled = button_disabled_value = ctx[0].length === 0;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      append(button, t);
      append(button, span);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[9]))
            ctx[9].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && button_disabled_value !== (button_disabled_value = ctx[0].length === 0)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$8(ctx) {
  let t0_value = ctx[6].get("name") + "";
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[6].get("name") + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_each_block$n(key_1, ctx) {
  let first2;
  let menuitemwithpermissions;
  let current;
  function click_handler() {
    return ctx[5](ctx[6]);
  }
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions.$on("click", click_handler);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(menuitemwithpermissions.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitemwithpermissions_changes = {};
      if (dirty & 1025) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_default_slot$C(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[0].models;
  const get_key = (ctx2) => ctx2[6].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$n(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$n(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value = ctx2[0].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$n, each_1_anchor, get_each_context$n);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_fragment$1k(ctx) {
  let menu;
  let current;
  menu = new Menu({
    props: {
      showCaret: false,
      dropDownStyle: `overflow-y:auto;max-height:'+ ${window.$(window).height() - 120 + "px"}`,
      $$slots: {
        default: [create_default_slot$C],
        action: [
          create_action_slot$8,
          ({ onClick }) => ({ 9: onClick }),
          ({ onClick }) => onClick ? 512 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 1537) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$1h($$self, $$props, $$invalidate) {
  let $labels;
  let { sieves } = $$props;
  let { disabled = false } = $$props;
  const labels = getContext("labels");
  component_subscribe($$self, labels, (value) => $$invalidate(0, $labels = value));
  async function applyLabel(id2) {
    const models = sieves.getSelectedSieves();
    Msg.info("l_loading");
    try {
      for (let i2 = 0; i2 < models.length; i2++) {
        let model = models[i2];
        let tags = model.get("tags");
        if (tags) {
          if (tags.indexOf(id2) >= 0) {
            continue;
          }
          tags += "," + id2;
        } else {
          tags = id2;
        }
        await model.save("tags", tags, { patch: true });
      }
      Msg.reset();
    } catch (e) {
      Msg.error("e_req");
    }
  }
  const click_handler = (label) => applyLabel(label.id);
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(3, sieves = $$props2.sieves);
    if ("disabled" in $$props2)
      $$invalidate(4, disabled = $$props2.disabled);
  };
  return [$labels, labels, applyLabel, sieves, disabled, click_handler];
}
class LabelListMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1h, create_fragment$1k, safe_not_equal, { sieves: 3, disabled: 4 });
  }
}
function create_if_block_1$u(ctx) {
  let div;
  let raw_value = ctx[4].helpText + "";
  return {
    c() {
      div = element("div");
      attr(div, "class", "alert alert-info");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$G(ctx) {
  let div2;
  let div0;
  let input0;
  let t0;
  let label0;
  let t2;
  let div1;
  let input1;
  let t3;
  let label1;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(ctx[12][0]);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      input0 = element("input");
      t0 = space();
      label0 = element("label");
      label0.textContent = `${TXT("l_download_selected_monitors")}`;
      t2 = space();
      div1 = element("div");
      input1 = element("input");
      t3 = space();
      label1 = element("label");
      label1.textContent = `${TXT("l_download_all_monitors")}`;
      attr(input0, "class", "form-check-input");
      attr(input0, "type", "radio");
      input0.__value = true;
      input0.value = input0.__value;
      attr(label0, "class", "form-check-label text-lg");
      attr(div0, "class", "form-check");
      attr(input1, "class", "form-check-input");
      attr(input1, "type", "radio");
      input1.__value = false;
      input1.value = input1.__value;
      attr(label1, "class", "form-check-label text-lg");
      attr(div1, "class", "form-check");
      attr(div2, "class", "ps-3");
      binding_group.p(input0, input1);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, input0);
      input0.checked = input0.__value === ctx[3];
      append(div0, t0);
      append(div0, label0);
      append(div2, t2);
      append(div2, div1);
      append(div1, input1);
      input1.checked = input1.__value === ctx[3];
      append(div1, t3);
      append(div1, label1);
      if (!mounted) {
        dispose = [
          listen(input0, "change", ctx[11]),
          listen(input1, "change", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8) {
        input0.checked = input0.__value === ctx2[3];
      }
      if (dirty & 8) {
        input1.checked = input1.__value === ctx2[3];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$B(ctx) {
  let t0;
  let t1;
  let a;
  let t2;
  let textarea_1;
  let if_block0 = ctx[4].helpText && create_if_block_1$u(ctx);
  let if_block1 = ctx[5].length && create_if_block$G(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      a = element("a");
      t2 = space();
      textarea_1 = element("textarea");
      a.hidden = true;
      textarea_1.hidden = true;
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      insert(target, a, anchor);
      ctx[14](a);
      insert(target, t2, anchor);
      insert(target, textarea_1, anchor);
      ctx[15](textarea_1);
    },
    p(ctx2, dirty) {
      if (ctx2[4].helpText)
        if_block0.p(ctx2, dirty);
      if (ctx2[5].length)
        if_block1.p(ctx2, dirty);
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(a);
      ctx[14](null);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(textarea_1);
      ctx[15](null);
    }
  };
}
function create_header_slot$a(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `Export - ${ctx[4].title}`;
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_catch_block$g(ctx) {
  return { c: noop$1, m: noop$1, d: noop$1 };
}
function create_then_block$g(ctx) {
  let t;
  return {
    c() {
      t = text("Download");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_pending_block$g(ctx) {
  let div;
  let t1;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span class="sr-only">Loading...</span>`;
      t1 = text("\n        Downloading...");
      attr(div, "class", "spinner-border text-light spinner-border-sm");
      attr(div, "role", "status");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t1, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
    }
  };
}
function create_buttons_slot$4(ctx) {
  let button;
  let promise;
  let mounted;
  let dispose;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$g,
    then: create_then_block$g,
    catch: create_catch_block$g
  };
  handle_promise(promise = ctx[2], info);
  return {
    c() {
      button = element("button");
      info.block.c();
      attr(button, "class", "btn btn-primary btn-md");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      info.block.m(button, info.anchor = null);
      info.mount = () => button;
      info.anchor = null;
      if (!mounted) {
        dispose = listen(button, "click", ctx[10]);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      dirty & 4 && promise !== (promise = ctx[2]) && handle_promise(promise, info);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      info.block.d();
      info.token = null;
      info = null;
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1j(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      $$slots: {
        buttons: [create_buttons_slot$4],
        header: [create_header_slot$a],
        default: [create_default_slot$B]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[7]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 1073741839) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
const LIMIT = 50;
function instance$1g($$self, $$props, $$invalidate) {
  let { format: format$1 } = $$props;
  let { sieves } = $$props;
  const labels = getContext("labels");
  const FORMATS = {
    json: {
      type: "json",
      title: "JSON",
      fields: [
        "name",
        "uri",
        "config",
        "tags",
        "content_type",
        "state",
        "rule_id",
        "schedule",
        "ts",
        "datasource_id"
      ],
      helpText: `
                You can import the exported monitors later.<br>
                Note: Actions are not exported. You can create actions for all monitors while importing them.<br>
                <a href="https://distill.io/docs/web-monitor/how-export-and-import-monitors/" target="_blank" rel="noopener">Learn More</a>
              `
    },
    csv: {
      type: "csv",
      title: "CSV",
      fields: [
        "id",
        "uri",
        "name",
        "tags",
        "content_type",
        "text",
        "err",
        "ts",
        "ts_mod",
        "datasource_id"
      ],
      helpText: `
                If you want to import monitors later, we recommend exporting as JSON.<br>
                <a href="https://distill.io/docs/web-monitor/how-export-and-import-monitors/" target="_blank" rel="noopener">Learn More</a>
                `,
      columnHeaders: [
        "Name",
        "URL",
        "Labels",
        "Content Type",
        "Created On",
        "Changed On",
        "Text",
        "Error?",
        "DatasourceID?"
      ]
    }
  };
  const formatOpts = FORMATS[format$1];
  const dispatch = createEventDispatcher();
  let textarea;
  let downloadHref;
  let fileUrl;
  let downloadPromise = Promise.resolve();
  let sieveData = [];
  let offset = 0;
  let selectedSieveIds = sieves.getSelectedSieveIds();
  let downloadSelected = selectedSieveIds.length ? true : false;
  async function downloadSieves() {
    try {
      const exportContent = await createContent();
      await downloadContent(exportContent);
      Msg.info("Exported successfully");
      closeModal();
    } catch (e) {
      console.error(e);
      Msg.error("Error while exporting, Please try again later");
    }
  }
  async function createContent() {
    offset = 0;
    if (downloadSelected) {
      await fetchSelectedSieveData();
    } else {
      await fetchSieveData();
    }
    if (format$1 === "json") {
      return await createJSONContent();
    } else if (format$1 === "csv") {
      return await createCSVContent();
    }
  }
  async function createJSONContent() {
    let data = [];
    for (let i2 = 0, len = sieveData.length; i2 < len; i2 += 5) {
      data = data.concat(await Promise.all(sieveData.slice(i2, i2 + 5).map(async (sieve) => {
        if (sieve.rule_id) {
          sieve.rule = await fetchRules(sieve);
        }
        if (typeof sieve.tags === "string") {
          sieve.tags = getTags(sieve.tags);
        }
        ["id", "rule_id", "ts_mod", "_state"].forEach((key) => {
          delete sieve[key];
        });
        return sieve;
      })));
    }
    return JSON.stringify({ client: Supports.agents, data });
  }
  function createCSVContent() {
    const data = sieveData.map((sieve) => {
      let tags = sieve.tags;
      if (typeof tags === "string") {
        tags = getTags(tags).join(",");
      }
      return [
        sieve.name,
        sieve.uri,
        tags || "",
        sieve.content_type,
        sieve.ts,
        sieve.ts_mod,
        sieve.text,
        sieve.err || "",
        sieve.datasource_id || ""
      ];
    });
    return Papa.unparse([FORMATS.csv.columnHeaders, ...data]);
  }
  async function fetchRules(sieve) {
    try {
      const response = await Api.api(`/rules/${sieve.rule_id}`, "GET", { _opt: { only: ["config", "version"] } });
      return {
        config: response.config,
        version: response.version
      };
    } catch (err) {
      console.error("error importing rule", err);
    }
  }
  function getTags(tagsStr = "") {
    return tagsStr.split(",").map((id2) => {
      const tag = labels.get(id2);
      if (tag) {
        return tag.get("name");
      }
    }).filter((tag) => tag);
  }
  function downloadContent(content) {
    const blob = new Blob([content], { type: "text/plain" });
    fileUrl = URL.createObjectURL(blob);
    $$invalidate(1, downloadHref.href = fileUrl, downloadHref);
    $$invalidate(1, downloadHref.download = `export - ${format(new Date(), "hh-mm_yyyy-MM-dd")}.${formatOpts.type}`, downloadHref);
    downloadHref.click();
  }
  async function fetchSieveData() {
    const res = await Api.api("/sieves", "GET", {
      "state.in": [40, 45],
      _opt: {
        order: ["ts"],
        limit: LIMIT,
        offset,
        only: formatOpts.fields
      }
    });
    sieveData = sieveData.concat(res.data);
    offset += res.count;
    if (res.count === LIMIT) {
      await fetchSieveData();
    }
  }
  async function fetchSelectedSieveData() {
    if (!selectedSieveIds.length) {
      return;
    }
    const res = await Api.api("/sieves", "GET", {
      "state.in": [40, 45],
      "id.in": selectedSieveIds.splice(0, LIMIT),
      _opt: { limit: LIMIT, only: formatOpts.fields }
    });
    sieveData = sieveData.concat(res.data);
    await fetchSelectedSieveData();
  }
  function closeModal() {
    if (fileUrl) {
      URL.revokeObjectURL(fileUrl);
    }
    dispatch("close");
  }
  const $$binding_groups = [[]];
  const click_handler = () => $$invalidate(2, downloadPromise = downloadSieves());
  function input0_change_handler() {
    downloadSelected = this.__value;
    $$invalidate(3, downloadSelected);
  }
  function input1_change_handler() {
    downloadSelected = this.__value;
    $$invalidate(3, downloadSelected);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      downloadHref = $$value;
      $$invalidate(1, downloadHref);
    });
  }
  function textarea_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      textarea = $$value;
      $$invalidate(0, textarea);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("format" in $$props2)
      $$invalidate(8, format$1 = $$props2.format);
    if ("sieves" in $$props2)
      $$invalidate(9, sieves = $$props2.sieves);
  };
  return [
    textarea,
    downloadHref,
    downloadPromise,
    downloadSelected,
    formatOpts,
    selectedSieveIds,
    downloadSieves,
    closeModal,
    format$1,
    sieves,
    click_handler,
    input0_change_handler,
    $$binding_groups,
    input1_change_handler,
    a_binding,
    textarea_1_binding
  ];
}
class ExportModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1g, create_fragment$1j, safe_not_equal, { format: 8, sieves: 9 });
  }
}
function create_action_slot$7(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-bars"></i> 
      <span class="caret"></span>`;
      attr(button, "class", "btn btn-default dropdown-toggle");
      attr(button, "data-bs-toggle", "dropdown");
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[23]))
            ctx[23].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_12(ctx) {
  let t;
  return {
    c() {
      t = text("JSON");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_11(ctx) {
  let t;
  return {
    c() {
      t = text("CSV");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_10(ctx) {
  let t;
  return {
    c() {
      t = text("JSON");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_9(ctx) {
  let t;
  return {
    c() {
      t = text("CSV");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_8$2(ctx) {
  let t_value = TXT("Crawlers") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7$2(ctx) {
  let t_value = TXT("Macros") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6$2(ctx) {
  let t_value = TXT("Profiles") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5$2(ctx) {
  let t_value = TXT("Proxies") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_4$2(ctx) {
  let t_value = TXT("Global Actions") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$4(ctx) {
  let t_value = TXT("Global Conditions") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_5$6(ctx) {
  let menuitemwithpermissions;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_2$5] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions.$on("click", ctx[15]);
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_default_slot_2$5(ctx) {
  let t;
  return {
    c() {
      t = text("AI Summary");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$7(ctx) {
  let t;
  return {
    c() {
      t = text("Error Actions");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$A(ctx) {
  let li0;
  let a0;
  let t1;
  let ul0;
  let menuitem0;
  let t2;
  let menuitem1;
  let t3;
  let li1;
  let a1;
  let t5;
  let ul1;
  let menuitemwithpermissions0;
  let t6;
  let menuitemwithpermissions1;
  let t7;
  let menuitemwithpermissions2;
  let t8;
  let menuitemwithpermissions3;
  let t9;
  let menuitemwithpermissions4;
  let t10;
  let menuitemwithpermissions5;
  let t11;
  let li2;
  let t12;
  let menuitemwithpermissions6;
  let t13;
  let menuitemwithpermissions7;
  let t14;
  let t15;
  let menuitemwithpermissions8;
  let current;
  menuitem0 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  menuitem0.$on("click", ctx[11]);
  menuitem1 = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    }
  });
  menuitem1.$on("click", ctx[12]);
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      href: `#/w/${ctx[1]}/import/json/`,
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      href: `#/w/${ctx[1]}/import/csv/`,
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions2 = new MenuItemWithPermissions({
    props: {
      href: `#/u/${ctx[1]}/crawlers/`,
      $$slots: { default: [create_default_slot_8$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions3 = new MenuItemWithPermissions({
    props: {
      href: `#/w/${ctx[1]}/macros/`,
      $$slots: { default: [create_default_slot_7$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions4 = new MenuItemWithPermissions({
    props: {
      href: `#/w/${ctx[1]}/profiles/`,
      $$slots: { default: [create_default_slot_6$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions5 = new MenuItemWithPermissions({
    props: {
      href: `#/w/${ctx[1]}/proxies/`,
      $$slots: { default: [create_default_slot_5$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions6 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions6.$on("click", ctx[13]);
  menuitemwithpermissions7 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions7.$on("click", ctx[14]);
  let if_block = ctx[9] && create_if_block_5$6(ctx);
  menuitemwithpermissions8 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions8.$on("click", ctx[16]);
  return {
    c() {
      li0 = element("li");
      a0 = element("a");
      a0.textContent = `${TXT("a_export")}`;
      t1 = space();
      ul0 = element("ul");
      create_component(menuitem0.$$.fragment);
      t2 = space();
      create_component(menuitem1.$$.fragment);
      t3 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = `${TXT("a_import")}`;
      t5 = space();
      ul1 = element("ul");
      create_component(menuitemwithpermissions0.$$.fragment);
      t6 = space();
      create_component(menuitemwithpermissions1.$$.fragment);
      t7 = space();
      create_component(menuitemwithpermissions2.$$.fragment);
      t8 = space();
      create_component(menuitemwithpermissions3.$$.fragment);
      t9 = space();
      create_component(menuitemwithpermissions4.$$.fragment);
      t10 = space();
      create_component(menuitemwithpermissions5.$$.fragment);
      t11 = space();
      li2 = element("li");
      t12 = space();
      create_component(menuitemwithpermissions6.$$.fragment);
      t13 = space();
      create_component(menuitemwithpermissions7.$$.fragment);
      t14 = space();
      if (if_block)
        if_block.c();
      t15 = space();
      create_component(menuitemwithpermissions8.$$.fragment);
      attr(a0, "role", "button");
      attr(a0, "class", "dropdown-item");
      attr(ul0, "class", "dropdown-menu");
      attr(li0, "class", "dropdown-submenu pe-2");
      attr(a1, "role", "button");
      attr(a1, "class", "dropdown-item");
      attr(ul1, "class", "dropdown-menu");
      attr(li1, "class", "dropdown-submenu pe-2");
      attr(li2, "class", "divider");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      append(li0, a0);
      append(li0, t1);
      append(li0, ul0);
      mount_component(menuitem0, ul0, null);
      append(ul0, t2);
      mount_component(menuitem1, ul0, null);
      insert(target, t3, anchor);
      insert(target, li1, anchor);
      append(li1, a1);
      append(li1, t5);
      append(li1, ul1);
      mount_component(menuitemwithpermissions0, ul1, null);
      append(ul1, t6);
      mount_component(menuitemwithpermissions1, ul1, null);
      insert(target, t7, anchor);
      mount_component(menuitemwithpermissions2, target, anchor);
      insert(target, t8, anchor);
      mount_component(menuitemwithpermissions3, target, anchor);
      insert(target, t9, anchor);
      mount_component(menuitemwithpermissions4, target, anchor);
      insert(target, t10, anchor);
      mount_component(menuitemwithpermissions5, target, anchor);
      insert(target, t11, anchor);
      insert(target, li2, anchor);
      insert(target, t12, anchor);
      mount_component(menuitemwithpermissions6, target, anchor);
      insert(target, t13, anchor);
      mount_component(menuitemwithpermissions7, target, anchor);
      insert(target, t14, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t15, anchor);
      mount_component(menuitemwithpermissions8, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem0_changes = {};
      if (dirty & 16777216) {
        menuitem0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem0.$set(menuitem0_changes);
      const menuitem1_changes = {};
      if (dirty & 16777216) {
        menuitem1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem1.$set(menuitem1_changes);
      const menuitemwithpermissions0_changes = {};
      if (dirty & 2)
        menuitemwithpermissions0_changes.href = `#/w/${ctx2[1]}/import/json/`;
      if (dirty & 16777216) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 2)
        menuitemwithpermissions1_changes.href = `#/w/${ctx2[1]}/import/csv/`;
      if (dirty & 16777216) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
      const menuitemwithpermissions2_changes = {};
      if (dirty & 2)
        menuitemwithpermissions2_changes.href = `#/u/${ctx2[1]}/crawlers/`;
      if (dirty & 16777216) {
        menuitemwithpermissions2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions2.$set(menuitemwithpermissions2_changes);
      const menuitemwithpermissions3_changes = {};
      if (dirty & 2)
        menuitemwithpermissions3_changes.href = `#/w/${ctx2[1]}/macros/`;
      if (dirty & 16777216) {
        menuitemwithpermissions3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions3.$set(menuitemwithpermissions3_changes);
      const menuitemwithpermissions4_changes = {};
      if (dirty & 2)
        menuitemwithpermissions4_changes.href = `#/w/${ctx2[1]}/profiles/`;
      if (dirty & 16777216) {
        menuitemwithpermissions4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions4.$set(menuitemwithpermissions4_changes);
      const menuitemwithpermissions5_changes = {};
      if (dirty & 2)
        menuitemwithpermissions5_changes.href = `#/w/${ctx2[1]}/proxies/`;
      if (dirty & 16777216) {
        menuitemwithpermissions5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions5.$set(menuitemwithpermissions5_changes);
      const menuitemwithpermissions6_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions6.$set(menuitemwithpermissions6_changes);
      const menuitemwithpermissions7_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions7_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions7.$set(menuitemwithpermissions7_changes);
      if (ctx2[9])
        if_block.p(ctx2, dirty);
      const menuitemwithpermissions8_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions8_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions8.$set(menuitemwithpermissions8_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem0.$$.fragment, local);
      transition_in(menuitem1.$$.fragment, local);
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      transition_in(menuitemwithpermissions2.$$.fragment, local);
      transition_in(menuitemwithpermissions3.$$.fragment, local);
      transition_in(menuitemwithpermissions4.$$.fragment, local);
      transition_in(menuitemwithpermissions5.$$.fragment, local);
      transition_in(menuitemwithpermissions6.$$.fragment, local);
      transition_in(menuitemwithpermissions7.$$.fragment, local);
      transition_in(if_block);
      transition_in(menuitemwithpermissions8.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem0.$$.fragment, local);
      transition_out(menuitem1.$$.fragment, local);
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      transition_out(menuitemwithpermissions2.$$.fragment, local);
      transition_out(menuitemwithpermissions3.$$.fragment, local);
      transition_out(menuitemwithpermissions4.$$.fragment, local);
      transition_out(menuitemwithpermissions5.$$.fragment, local);
      transition_out(menuitemwithpermissions6.$$.fragment, local);
      transition_out(menuitemwithpermissions7.$$.fragment, local);
      transition_out(if_block);
      transition_out(menuitemwithpermissions8.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li0);
      destroy_component(menuitem0);
      destroy_component(menuitem1);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(li1);
      destroy_component(menuitemwithpermissions0);
      destroy_component(menuitemwithpermissions1);
      if (detaching)
        detach(t7);
      destroy_component(menuitemwithpermissions2, detaching);
      if (detaching)
        detach(t8);
      destroy_component(menuitemwithpermissions3, detaching);
      if (detaching)
        detach(t9);
      destroy_component(menuitemwithpermissions4, detaching);
      if (detaching)
        detach(t10);
      destroy_component(menuitemwithpermissions5, detaching);
      if (detaching)
        detach(t11);
      if (detaching)
        detach(li2);
      if (detaching)
        detach(t12);
      destroy_component(menuitemwithpermissions6, detaching);
      if (detaching)
        detach(t13);
      destroy_component(menuitemwithpermissions7, detaching);
      if (detaching)
        detach(t14);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t15);
      destroy_component(menuitemwithpermissions8, detaching);
    }
  };
}
function create_if_block_4$c(ctx) {
  let exportmodal;
  let current;
  exportmodal = new ExportModal({
    props: {
      sieves: ctx[0],
      format: ctx[7]
    }
  });
  exportmodal.$on("close", ctx[17]);
  return {
    c() {
      create_component(exportmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(exportmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const exportmodal_changes = {};
      if (dirty & 1)
        exportmodal_changes.sieves = ctx2[0];
      if (dirty & 128)
        exportmodal_changes.format = ctx2[7];
      exportmodal.$set(exportmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(exportmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(exportmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(exportmodal, detaching);
    }
  };
}
function create_if_block_3$i(ctx) {
  let globalactionseditormodal;
  let current;
  globalactionseditormodal = new GlobalActionsEditorModal({});
  globalactionseditormodal.$on("close", ctx[18]);
  return {
    c() {
      create_component(globalactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalactionseditormodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(globalactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalactionseditormodal, detaching);
    }
  };
}
function create_if_block_2$m(ctx) {
  let globalruleeditormodal;
  let current;
  globalruleeditormodal = new GlobalRuleEditorModal({});
  globalruleeditormodal.$on("close", ctx[19]);
  return {
    c() {
      create_component(globalruleeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalruleeditormodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(globalruleeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalruleeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalruleeditormodal, detaching);
    }
  };
}
function create_if_block_1$t(ctx) {
  let erroractionsmodal;
  let current;
  erroractionsmodal = new ErrorActionsModal({});
  erroractionsmodal.$on("close", ctx[20]);
  return {
    c() {
      create_component(erroractionsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(erroractionsmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(erroractionsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(erroractionsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(erroractionsmodal, detaching);
    }
  };
}
function create_if_block$F(ctx) {
  let summaryconfigurationmodal;
  let current;
  summaryconfigurationmodal = new SummaryConfigurationModal({});
  summaryconfigurationmodal.$on("close", ctx[21]);
  return {
    c() {
      create_component(summaryconfigurationmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(summaryconfigurationmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(summaryconfigurationmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(summaryconfigurationmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(summaryconfigurationmodal, detaching);
    }
  };
}
function create_fragment$1i(ctx) {
  let menu;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block4_anchor;
  let current;
  menu = new Menu({
    props: {
      $$slots: {
        default: [create_default_slot$A],
        action: [
          create_action_slot$7,
          ({ onClick }) => ({ 23: onClick }),
          ({ onClick }) => onClick ? 8388608 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[5] && create_if_block_4$c(ctx);
  let if_block1 = ctx[2] && create_if_block_3$i(ctx);
  let if_block2 = ctx[3] && create_if_block_2$m(ctx);
  let if_block3 = ctx[4] && create_if_block_1$t(ctx);
  let if_block4 = ctx[6] && create_if_block$F(ctx);
  return {
    c() {
      create_component(menu.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      if_block4_anchor = empty();
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, t4, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert(target, if_block4_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 25166078) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$c(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$i(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$m(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$t(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t4.parentNode, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[6]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block$F(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(t4);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach(if_block4_anchor);
    }
  };
}
function instance$1f($$self, $$props, $$invalidate) {
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(10, $route = $$value));
  let { sieves } = $$props;
  const fileFormats = { JSON: "json", CSV: "csv" };
  let team;
  let showGlobalActionEditor2 = false;
  let showGlobalRuleEditor2 = false;
  let showErrorActionsModal = false;
  let showExportModal = false;
  let showAISummaryConfigModal = false;
  let exportFormat = fileFormats.JSON;
  const user = getContext("user");
  const isFlexi = user.isFlexi();
  const click_handler = () => {
    $$invalidate(5, showExportModal = true);
    $$invalidate(7, exportFormat = fileFormats.JSON);
  };
  const click_handler_1 = () => {
    $$invalidate(5, showExportModal = true);
    $$invalidate(7, exportFormat = fileFormats.CSV);
  };
  const click_handler_2 = () => $$invalidate(2, showGlobalActionEditor2 = true);
  const click_handler_3 = () => $$invalidate(3, showGlobalRuleEditor2 = true);
  const click_handler_4 = () => {
    $$invalidate(6, showAISummaryConfigModal = true);
  };
  const click_handler_5 = () => $$invalidate(4, showErrorActionsModal = true);
  const close_handler = () => $$invalidate(5, showExportModal = false);
  const close_handler_1 = () => $$invalidate(2, showGlobalActionEditor2 = false);
  const close_handler_2 = () => $$invalidate(3, showGlobalRuleEditor2 = false);
  const close_handler_3 = () => $$invalidate(4, showErrorActionsModal = false);
  const close_handler_4 = () => $$invalidate(6, showAISummaryConfigModal = false);
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(0, sieves = $$props2.sieves);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1024) {
      $$invalidate(1, { team } = $route, team);
    }
  };
  return [
    sieves,
    team,
    showGlobalActionEditor2,
    showGlobalRuleEditor2,
    showErrorActionsModal,
    showExportModal,
    showAISummaryConfigModal,
    exportFormat,
    fileFormats,
    isFlexi,
    $route,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    close_handler,
    close_handler_1,
    close_handler_2,
    close_handler_3,
    close_handler_4
  ];
}
class AdditionalOptionsMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1f, create_fragment$1i, safe_not_equal, { sieves: 0 });
  }
}
function create_default_slot$z(ctx) {
  let actionseditor;
  let updating_actions;
  let current;
  function actionseditor_actions_binding(value) {
    ctx[8](value);
  }
  let actionseditor_props = { sieve: ctx[4] };
  if (ctx[0] !== void 0) {
    actionseditor_props.actions = ctx[0];
  }
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  binding_callbacks.push(() => bind$1(actionseditor, "actions", actionseditor_actions_binding));
  actionseditor.$on("globalaction", ctx[9]);
  actionseditor.$on("manage", ctx[6]);
  return {
    c() {
      create_component(actionseditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actionseditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actionseditor_changes = {};
      if (!updating_actions && dirty & 1) {
        updating_actions = true;
        actionseditor_changes.actions = ctx2[0];
        add_flush_callback(() => updating_actions = false);
      }
      actionseditor.$set(actionseditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actionseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(actionseditor, detaching);
    }
  };
}
function create_if_block_2$l(ctx) {
  let globalactionseditormodal;
  let current;
  globalactionseditormodal = new GlobalActionsEditorModal({});
  globalactionseditormodal.$on("close", ctx[11]);
  return {
    c() {
      create_component(globalactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalactionseditormodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(globalactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalactionseditormodal, detaching);
    }
  };
}
function create_if_block_1$s(ctx) {
  let manageemailsmodal;
  let current;
  manageemailsmodal = new ManageEmailModal({});
  manageemailsmodal.$on("close", ctx[12]);
  return {
    c() {
      create_component(manageemailsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(manageemailsmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(manageemailsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(manageemailsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(manageemailsmodal, detaching);
    }
  };
}
function create_if_block$E(ctx) {
  let managephonesmodal;
  let current;
  managephonesmodal = new ManagePhonesModal({});
  managephonesmodal.$on("close", ctx[13]);
  return {
    c() {
      create_component(managephonesmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managephonesmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(managephonesmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managephonesmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managephonesmodal, detaching);
    }
  };
}
function create_fragment$1h(ctx) {
  let savemodal;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  savemodal = new SaveModal({
    props: {
      isDialog: false,
      title: "Add Actions - Batch Editor",
      onSave: ctx[5],
      $$slots: { default: [create_default_slot$z] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[10]);
  let if_block0 = ctx[3] && create_if_block_2$l(ctx);
  let if_block1 = ctx[1] && create_if_block_1$s(ctx);
  let if_block2 = ctx[2] && create_if_block$E(ctx);
  return {
    c() {
      create_component(savemodal.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 65545) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$l(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$s(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$E(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function instance$1e($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const dispatch = createEventDispatcher();
  const sieve = new Model$2.Sieve();
  let actions;
  let showManageEmailsModal = false;
  let showManagePhonesModal = false;
  let showGlobalActionEditor2 = false;
  function close() {
    dispatch("close");
  }
  async function save() {
    const isValid2 = actions.validateActions();
    if (isValid2) {
      const ids = sieves.getSelectedSieveIds();
      const actionsList = actions.getPosts();
      try {
        for (let i2 = 0; i2 < actionsList.length; i2 += 1) {
          const doc = actionsList[i2].toJSON();
          await Api.api("/batch/sieves/actions", "POST", { ...doc, ids });
        }
        close();
      } catch (e) {
        console.error(e);
        Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
      }
    }
  }
  function showModal(e) {
    const type = e.detail;
    if (type === "email") {
      $$invalidate(1, showManageEmailsModal = true);
    } else if (type === "phone") {
      $$invalidate(2, showManagePhonesModal = true);
    }
  }
  function actionseditor_actions_binding(value) {
    actions = value;
    $$invalidate(0, actions);
  }
  const globalaction_handler = () => {
    $$invalidate(3, showGlobalActionEditor2 = true);
  };
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  const close_handler_1 = () => $$invalidate(3, showGlobalActionEditor2 = false);
  const close_handler_2 = () => $$invalidate(1, showManageEmailsModal = false);
  const close_handler_3 = () => $$invalidate(2, showManagePhonesModal = false);
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(7, sieves = $$props2.sieves);
  };
  return [
    actions,
    showManageEmailsModal,
    showManagePhonesModal,
    showGlobalActionEditor2,
    sieve,
    save,
    showModal,
    sieves,
    actionseditor_actions_binding,
    globalaction_handler,
    close_handler,
    close_handler_1,
    close_handler_2,
    close_handler_3
  ];
}
class BatchActionsEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1e, create_fragment$1h, safe_not_equal, { sieves: 7 });
  }
}
function create_default_slot$y(ctx) {
  let label;
  return {
    c() {
      label = element("label");
      label.textContent = "This action will remove all actions for selected monitors. Remove all actions?";
    },
    m(target, anchor) {
      insert(target, label, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(label);
    }
  };
}
function create_buttons_slot$3(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = "Remove";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-danger");
      attr(div, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[0]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1g(ctx) {
  let confirmmodal;
  let current;
  confirmmodal = new ConfirmModal({
    props: {
      title: "Remove Actions - Batch Edit",
      $$slots: {
        buttons: [create_buttons_slot$3],
        default: [create_default_slot$y]
      },
      $$scope: { ctx }
    }
  });
  confirmmodal.$on("close", ctx[2]);
  return {
    c() {
      create_component(confirmmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmmodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const confirmmodal_changes = {};
      if (dirty & 32) {
        confirmmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmmodal.$set(confirmmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmmodal, detaching);
    }
  };
}
function instance$1d($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const dispatch = createEventDispatcher();
  function close() {
    dispatch("close");
  }
  async function remove() {
    const ids = sieves.getSelectedSieveIds();
    try {
      await Api.api("/batch/sieves/actions", "PUT", { ids, state: C$1.STATE_DEL });
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(1, sieves = $$props2.sieves);
  };
  return [remove, sieves, close_handler];
}
class BatchRemoveActionsModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1d, create_fragment$1g, safe_not_equal, { sieves: 1 });
  }
}
function create_fragment$1f(ctx) {
  let div;
  return {
    c() {
      div = element("div");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[3](div);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[3](null);
    }
  };
}
function instance$1c($$self, $$props, $$invalidate) {
  const omit_props_names = ["view", "renderedView"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { view } = $$props;
  let { renderedView = null } = $$props;
  const parent2 = getContext("view:root");
  let el2;
  onMount(() => {
    $$invalidate(1, renderedView = new view({ ...$$restProps, parent: parent2, el: el2 }).render());
    return () => {
      renderedView.remove();
    };
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el2 = $$value;
      $$invalidate(0, el2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("view" in $$new_props)
      $$invalidate(2, view = $$new_props.view);
    if ("renderedView" in $$new_props)
      $$invalidate(1, renderedView = $$new_props.renderedView);
  };
  return [el2, renderedView, view, div_binding];
}
class BackboneWrapper extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1c, create_fragment$1f, safe_not_equal, { view: 2, renderedView: 1 });
  }
}
function create_fragment$1e(ctx) {
  let backbonewrapper;
  let updating_renderedView;
  let current;
  const backbonewrapper_spread_levels = [{ view: JSONEdit }, ctx[1]];
  function backbonewrapper_renderedView_binding(value) {
    ctx[2](value);
  }
  let backbonewrapper_props = {};
  for (let i2 = 0; i2 < backbonewrapper_spread_levels.length; i2 += 1) {
    backbonewrapper_props = assign(backbonewrapper_props, backbonewrapper_spread_levels[i2]);
  }
  if (ctx[0] !== void 0) {
    backbonewrapper_props.renderedView = ctx[0];
  }
  backbonewrapper = new BackboneWrapper({ props: backbonewrapper_props });
  binding_callbacks.push(() => bind$1(backbonewrapper, "renderedView", backbonewrapper_renderedView_binding));
  return {
    c() {
      create_component(backbonewrapper.$$.fragment);
    },
    m(target, anchor) {
      mount_component(backbonewrapper, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const backbonewrapper_changes = dirty & 2 ? get_spread_update(backbonewrapper_spread_levels, [
        dirty & 0 && { view: JSONEdit },
        dirty & 2 && get_spread_object(ctx2[1])
      ]) : {};
      if (!updating_renderedView && dirty & 1) {
        updating_renderedView = true;
        backbonewrapper_changes.renderedView = ctx2[0];
        add_flush_callback(() => updating_renderedView = false);
      }
      backbonewrapper.$set(backbonewrapper_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(backbonewrapper.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(backbonewrapper.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(backbonewrapper, detaching);
    }
  };
}
function instance$1b($$self, $$props, $$invalidate) {
  const omit_props_names = ["configEditor"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { configEditor } = $$props;
  function backbonewrapper_renderedView_binding(value) {
    configEditor = value;
    $$invalidate(0, configEditor);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("configEditor" in $$new_props)
      $$invalidate(0, configEditor = $$new_props.configEditor);
  };
  return [configEditor, $$restProps, backbonewrapper_renderedView_binding];
}
class ConfigEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1b, create_fragment$1e, safe_not_equal, { configEditor: 0 });
  }
}
function create_default_slot$x(ctx) {
  let configeditor;
  let updating_configEditor;
  let current;
  function configeditor_configEditor_binding(value) {
    ctx[5](value);
  }
  let configeditor_props = {
    param: ctx[1],
    model: ctx[2]
  };
  if (ctx[0] !== void 0) {
    configeditor_props.configEditor = ctx[0];
  }
  configeditor = new ConfigEditor({ props: configeditor_props });
  binding_callbacks.push(() => bind$1(configeditor, "configEditor", configeditor_configEditor_binding));
  return {
    c() {
      create_component(configeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(configeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const configeditor_changes = {};
      if (!updating_configEditor && dirty & 1) {
        updating_configEditor = true;
        configeditor_changes.configEditor = ctx2[0];
        add_flush_callback(() => updating_configEditor = false);
      }
      configeditor.$set(configeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(configeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(configeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(configeditor, detaching);
    }
  };
}
function create_fragment$1d(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: "Config - Batch Edit",
      onSave: ctx[3],
      $$slots: { default: [create_default_slot$x] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[6]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 513) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$1a($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const dispatch = createEventDispatcher();
  const param = {
    label: "l_selection_config",
    must: false,
    name: "config",
    type: "json"
  };
  const model = new Backbone.Model({
    config: sieves.getSelectedSieves()[0].get("config").clone()
  });
  let configEditor;
  function close() {
    dispatch("close");
  }
  async function save() {
    Msg.info("l_loading");
    const ids = sieves.getSelectedSieveIds();
    try {
      await Api.api("/batch/sieves", "PUT", {
        ids,
        config: JSON.stringify(model.get("config"))
      });
      Msg.reset();
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function configeditor_configEditor_binding(value) {
    configEditor = value;
    $$invalidate(0, configEditor);
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(4, sieves = $$props2.sieves);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      if (configEditor) {
        configEditor.$el.find("textarea").css("height", 300);
      }
    }
  };
  return [
    configEditor,
    param,
    model,
    save,
    sieves,
    configeditor_configEditor_binding,
    close_handler
  ];
}
class BatchConfigEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1a, create_fragment$1d, safe_not_equal, { sieves: 4 });
  }
}
function create_default_slot$w(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "m-[5px]");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[3](div);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[3](null);
    }
  };
}
function create_fragment$1c(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      isDialog: false,
      title: "Device - Batch Editor",
      onSave: ctx[1],
      $$slots: { default: [create_default_slot$w] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[4]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 1025) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$19($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const dispatch = createEventDispatcher();
  let el2;
  let model;
  let clientSelector;
  function render2() {
    const selectedModels = sieves.getSelectedSieves();
    if (selectedModels.length == 0) {
      return;
    }
    const modelOne = selectedModels[0];
    model = new Model$2.Sieve({
      content_type: C$1.TYPE_HTML,
      client_id: modelOne.get("client_id")
    });
    clientSelector = new ViewClients.ClientSelector({ model });
    el2.appendChild(clientSelector.el);
  }
  function close() {
    dispatch("close");
  }
  async function save() {
    try {
      const ids = sieves.getSelectedSieveIds();
      const client_id = model.get("client_id");
      const proxy_id = model.get("proxy_id");
      const session_id = model.get("session_id");
      await Api.api("/batch/sieves", "PUT", { ids, client_id, proxy_id, session_id });
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el2 = $$value;
      $$invalidate(0, el2);
    });
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(2, sieves = $$props2.sieves);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      if (el2) {
        render2();
      }
    }
  };
  return [el2, save, sieves, div_binding, close_handler];
}
class BatchClientSelectorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$19, create_fragment$1c, safe_not_equal, { sieves: 2 });
  }
}
function create_default_slot$v(ctx) {
  let scheduleeditor;
  let current;
  scheduleeditor = new ScheduleEditor({
    props: { formModel: ctx[0] }
  });
  return {
    c() {
      create_component(scheduleeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scheduleeditor, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(scheduleeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scheduleeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scheduleeditor, detaching);
    }
  };
}
function create_fragment$1b(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      isDialog: false,
      title: "Schedule - Batch Editor",
      onSave: ctx[1],
      $$slots: { default: [create_default_slot$v] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[3]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const savemodal_changes = {};
      if (dirty & 128) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function instance$18($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  const dispatch = createEventDispatcher();
  let model = new Model$2.Sieve({ schedule: new Model$2.Schedule() });
  const formModel = new SieveFormModel(model);
  function close() {
    dispatch("close");
  }
  async function save() {
    const ids = sieves.getSelectedSieveIds();
    try {
      await Api.api("/batch/sieves", "PUT", {
        ids,
        schedule: JSON.stringify(model.get("schedule"))
      });
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(2, sieves = $$props2.sieves);
  };
  return [formModel, save, sieves, close_handler];
}
class BatchScheduleEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$18, create_fragment$1b, safe_not_equal, { sieves: 2 });
  }
}
function create_default_slot$u(ctx) {
  let strong;
  let t0;
  let t1;
  let t2_value = ctx[1] === 1 ? "monitor" : "monitors";
  let t2;
  let t3;
  let t4_value = ctx[0] ? "ON" : "OFF";
  let t4;
  let t5;
  return {
    c() {
      strong = element("strong");
      t0 = text(ctx[1]);
      t1 = space();
      t2 = text(t2_value);
      t3 = text(" will be switched ");
      t4 = text(t4_value);
      t5 = text(".");
    },
    m(target, anchor) {
      insert(target, strong, anchor);
      append(strong, t0);
      append(strong, t1);
      append(strong, t2);
      append(strong, t3);
      append(strong, t4);
      append(strong, t5);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t4_value !== (t4_value = ctx2[0] ? "ON" : "OFF"))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching)
        detach(strong);
    }
  };
}
function create_fragment$1a(ctx) {
  let confirmmodal;
  let current;
  confirmmodal = new ConfirmModal({
    props: {
      title: ctx[0] ? "Switch On Monitors - Batch Edit" : "Switch Off Monitors - Batch Edit",
      $$slots: { default: [create_default_slot$u] },
      $$scope: { ctx }
    }
  });
  confirmmodal.$on("click", ctx[2]);
  confirmmodal.$on("close", ctx[4]);
  return {
    c() {
      create_component(confirmmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(confirmmodal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const confirmmodal_changes = {};
      if (dirty & 1)
        confirmmodal_changes.title = ctx2[0] ? "Switch On Monitors - Batch Edit" : "Switch Off Monitors - Batch Edit";
      if (dirty & 257) {
        confirmmodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmmodal.$set(confirmmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(confirmmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(confirmmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(confirmmodal, detaching);
    }
  };
}
function instance$17($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  let { switchOn } = $$props;
  const dispatch = createEventDispatcher();
  const ids = sieves.getSelectedSieveIds();
  const noSelected = ids == null ? void 0 : ids.length;
  function close() {
    dispatch("close");
  }
  async function updateSieveState() {
    try {
      await Api.api("/batch/sieves", "PUT", {
        ids,
        state: switchOn ? C$1.STATE_READY : C$1.STATE_PAUSED
      });
      close();
    } catch (e) {
      console.error(e);
      Msg.error(`Please try again later - error in batch action ${e.message || e.msg}`);
    }
  }
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(3, sieves = $$props2.sieves);
    if ("switchOn" in $$props2)
      $$invalidate(0, switchOn = $$props2.switchOn);
  };
  return [switchOn, noSelected, updateSieveState, sieves, close_handler];
}
class BatchSieveStateEditorModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$17, create_fragment$1a, safe_not_equal, { sieves: 3, switchOn: 0 });
  }
}
function create_action_slot$6(ctx) {
  let button;
  let t0_value = TXT("a_bulk_edit") + "";
  let t0;
  let t1;
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      span = element("span");
      attr(span, "class", "caret");
      attr(button, "class", "btn btn-default dropdown-toggle");
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      append(button, span);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[23]))
            ctx[23].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$t(ctx) {
  let li1;
  let a;
  let t1;
  let ul;
  let menuitemwithpermissions0;
  let t2;
  let li0;
  let t3;
  let menuitemwithpermissions1;
  let current;
  let mounted;
  let dispose;
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions0.$on("click", ctx[9]);
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      menuItemStyle: "color:red;",
      $$slots: { default: [create_default_slot_7$1] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1.$on("click", ctx[10]);
  return {
    c() {
      li1 = element("li");
      a = element("a");
      a.textContent = "Actions";
      t1 = space();
      ul = element("ul");
      create_component(menuitemwithpermissions0.$$.fragment);
      t2 = space();
      li0 = element("li");
      t3 = space();
      create_component(menuitemwithpermissions1.$$.fragment);
      attr(a, "class", "dropdown-item");
      attr(li0, "class", "divider");
      attr(ul, "class", "dropdown-menu");
      attr(li1, "class", "dropdown-submenu pe-2");
      attr(li1, "role", "menu");
    },
    m(target, anchor) {
      insert(target, li1, anchor);
      append(li1, a);
      append(li1, t1);
      append(li1, ul);
      mount_component(menuitemwithpermissions0, ul, null);
      append(ul, t2);
      append(ul, li0);
      append(ul, t3);
      mount_component(menuitemwithpermissions1, ul, null);
      current = true;
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[8]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions0_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li1);
      destroy_component(menuitemwithpermissions0);
      destroy_component(menuitemwithpermissions1);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_7$2(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      menuItemStyle: "--bs-dropdown-link-color: rgba(var(--bs-link-color-rgb))",
      href: urlCfg.login,
      $$slots: { default: [create_default_slot_6$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 16777216) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_8$1(ctx) {
  let t;
  return {
    c() {
      t = text("Add");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7$1(ctx) {
  let t;
  return {
    c() {
      t = text("Remove All");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6$1(ctx) {
  let t_value = TXT("Sign in") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5$1(ctx) {
  let t_value = TXT("Config") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_4$1(ctx) {
  let t_value = TXT("l_device") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let t_value = TXT("l_schedule") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$4(ctx) {
  let t_value = TXT("Switch ON") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$6(ctx) {
  let t_value = TXT("Switch OFF") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$t(ctx) {
  let current_block_type_index;
  let if_block;
  let t0;
  let menuitemwithpermissions0;
  let t1;
  let menuitemwithpermissions1;
  let t2;
  let menuitemwithpermissions2;
  let t3;
  let menuitemwithpermissions3;
  let t4;
  let menuitemwithpermissions4;
  let current;
  const if_block_creators = [create_if_block_7$2, create_else_block$t];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!USER.id)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type();
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      disabled: !USER.id,
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions0.$on("click", ctx[11]);
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      disabled: !USER.id,
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1.$on("click", ctx[12]);
  menuitemwithpermissions2 = new MenuItemWithPermissions({
    props: {
      disabled: !USER.id,
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions2.$on("click", ctx[13]);
  menuitemwithpermissions3 = new MenuItemWithPermissions({
    props: {
      disabled: !USER.id,
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions3.$on("click", ctx[14]);
  menuitemwithpermissions4 = new MenuItemWithPermissions({
    props: {
      disabled: !USER.id,
      $$slots: { default: [create_default_slot_1$6] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions4.$on("click", ctx[15]);
  return {
    c() {
      if_block.c();
      t0 = space();
      create_component(menuitemwithpermissions0.$$.fragment);
      t1 = space();
      create_component(menuitemwithpermissions1.$$.fragment);
      t2 = space();
      create_component(menuitemwithpermissions2.$$.fragment);
      t3 = space();
      create_component(menuitemwithpermissions3.$$.fragment);
      t4 = space();
      create_component(menuitemwithpermissions4.$$.fragment);
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitemwithpermissions0, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitemwithpermissions1, target, anchor);
      insert(target, t2, anchor);
      mount_component(menuitemwithpermissions2, target, anchor);
      insert(target, t3, anchor);
      mount_component(menuitemwithpermissions3, target, anchor);
      insert(target, t4, anchor);
      mount_component(menuitemwithpermissions4, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
      const menuitemwithpermissions0_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
      const menuitemwithpermissions2_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions2.$set(menuitemwithpermissions2_changes);
      const menuitemwithpermissions3_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions3.$set(menuitemwithpermissions3_changes);
      const menuitemwithpermissions4_changes = {};
      if (dirty & 16777216) {
        menuitemwithpermissions4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions4.$set(menuitemwithpermissions4_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      transition_in(menuitemwithpermissions2.$$.fragment, local);
      transition_in(menuitemwithpermissions3.$$.fragment, local);
      transition_in(menuitemwithpermissions4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      transition_out(menuitemwithpermissions2.$$.fragment, local);
      transition_out(menuitemwithpermissions3.$$.fragment, local);
      transition_out(menuitemwithpermissions4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitemwithpermissions0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitemwithpermissions1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(menuitemwithpermissions2, detaching);
      if (detaching)
        detach(t3);
      destroy_component(menuitemwithpermissions3, detaching);
      if (detaching)
        detach(t4);
      destroy_component(menuitemwithpermissions4, detaching);
    }
  };
}
function create_if_block_6$3(ctx) {
  let batchactionseditormodal;
  let current;
  batchactionseditormodal = new BatchActionsEditorModal({ props: { sieves: ctx[0] } });
  batchactionseditormodal.$on("close", ctx[16]);
  return {
    c() {
      create_component(batchactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchactionseditormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchactionseditormodal_changes = {};
      if (dirty & 1)
        batchactionseditormodal_changes.sieves = ctx2[0];
      batchactionseditormodal.$set(batchactionseditormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchactionseditormodal, detaching);
    }
  };
}
function create_if_block_5$5(ctx) {
  let batchremoveactionsmodal;
  let current;
  batchremoveactionsmodal = new BatchRemoveActionsModal({ props: { sieves: ctx[0] } });
  batchremoveactionsmodal.$on("close", ctx[17]);
  return {
    c() {
      create_component(batchremoveactionsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchremoveactionsmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchremoveactionsmodal_changes = {};
      if (dirty & 1)
        batchremoveactionsmodal_changes.sieves = ctx2[0];
      batchremoveactionsmodal.$set(batchremoveactionsmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchremoveactionsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchremoveactionsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchremoveactionsmodal, detaching);
    }
  };
}
function create_if_block_4$b(ctx) {
  let batchconfigeditormodal;
  let current;
  batchconfigeditormodal = new BatchConfigEditorModal({ props: { sieves: ctx[0] } });
  batchconfigeditormodal.$on("close", ctx[18]);
  return {
    c() {
      create_component(batchconfigeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchconfigeditormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchconfigeditormodal_changes = {};
      if (dirty & 1)
        batchconfigeditormodal_changes.sieves = ctx2[0];
      batchconfigeditormodal.$set(batchconfigeditormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchconfigeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchconfigeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchconfigeditormodal, detaching);
    }
  };
}
function create_if_block_3$h(ctx) {
  let batchclientselectormodal;
  let current;
  batchclientselectormodal = new BatchClientSelectorModal({ props: { sieves: ctx[0] } });
  batchclientselectormodal.$on("close", ctx[19]);
  return {
    c() {
      create_component(batchclientselectormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchclientselectormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchclientselectormodal_changes = {};
      if (dirty & 1)
        batchclientselectormodal_changes.sieves = ctx2[0];
      batchclientselectormodal.$set(batchclientselectormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchclientselectormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchclientselectormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchclientselectormodal, detaching);
    }
  };
}
function create_if_block_2$k(ctx) {
  let batchscheduleeditormodal;
  let current;
  batchscheduleeditormodal = new BatchScheduleEditorModal({ props: { sieves: ctx[0] } });
  batchscheduleeditormodal.$on("close", ctx[20]);
  return {
    c() {
      create_component(batchscheduleeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchscheduleeditormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchscheduleeditormodal_changes = {};
      if (dirty & 1)
        batchscheduleeditormodal_changes.sieves = ctx2[0];
      batchscheduleeditormodal.$set(batchscheduleeditormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchscheduleeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchscheduleeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchscheduleeditormodal, detaching);
    }
  };
}
function create_if_block_1$r(ctx) {
  let batchsievestateeditormodal;
  let current;
  batchsievestateeditormodal = new BatchSieveStateEditorModal({
    props: {
      sieves: ctx[0],
      switchOn: true
    }
  });
  batchsievestateeditormodal.$on("close", ctx[21]);
  return {
    c() {
      create_component(batchsievestateeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchsievestateeditormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchsievestateeditormodal_changes = {};
      if (dirty & 1)
        batchsievestateeditormodal_changes.sieves = ctx2[0];
      batchsievestateeditormodal.$set(batchsievestateeditormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchsievestateeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchsievestateeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchsievestateeditormodal, detaching);
    }
  };
}
function create_if_block$D(ctx) {
  let batchsievestateeditormodal;
  let current;
  batchsievestateeditormodal = new BatchSieveStateEditorModal({
    props: {
      sieves: ctx[0],
      switchOn: false
    }
  });
  batchsievestateeditormodal.$on("close", ctx[22]);
  return {
    c() {
      create_component(batchsievestateeditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchsievestateeditormodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const batchsievestateeditormodal_changes = {};
      if (dirty & 1)
        batchsievestateeditormodal_changes.sieves = ctx2[0];
      batchsievestateeditormodal.$set(batchsievestateeditormodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(batchsievestateeditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchsievestateeditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchsievestateeditormodal, detaching);
    }
  };
}
function create_fragment$19(ctx) {
  let menu;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let if_block6_anchor;
  let current;
  menu = new Menu({
    props: {
      $$slots: {
        default: [create_default_slot$t],
        action: [
          create_action_slot$6,
          ({ onClick }) => ({ 23: onClick }),
          ({ onClick }) => onClick ? 8388608 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[1] && create_if_block_6$3(ctx);
  let if_block1 = ctx[2] && create_if_block_5$5(ctx);
  let if_block2 = ctx[3] && create_if_block_4$b(ctx);
  let if_block3 = ctx[4] && create_if_block_3$h(ctx);
  let if_block4 = ctx[5] && create_if_block_2$k(ctx);
  let if_block5 = ctx[6] && create_if_block_1$r(ctx);
  let if_block6 = ctx[7] && create_if_block$D(ctx);
  return {
    c() {
      create_component(menu.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, t4, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert(target, t5, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert(target, t6, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert(target, if_block6_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 25166078) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_6$3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_5$5(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4$b(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_3$h(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(t4.parentNode, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[5]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_2$k(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(t5.parentNode, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (ctx2[6]) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_1$r(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(t6.parentNode, t6);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (ctx2[7]) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty & 128) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block$D(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block3)
        if_block3.d(detaching);
      if (detaching)
        detach(t4);
      if (if_block4)
        if_block4.d(detaching);
      if (detaching)
        detach(t5);
      if (if_block5)
        if_block5.d(detaching);
      if (detaching)
        detach(t6);
      if (if_block6)
        if_block6.d(detaching);
      if (detaching)
        detach(if_block6_anchor);
    }
  };
}
function instance$16($$self, $$props, $$invalidate) {
  let { sieves } = $$props;
  let showAddActionModal = false;
  let showRemoveActionModal = false;
  let showEditConfigModal = false;
  let showEditDevicesModal = false;
  let showEditScheduleModal = false;
  let showSieveOnModal = false;
  let showSieveOffModal = false;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler_1 = () => $$invalidate(1, showAddActionModal = true);
  const click_handler_2 = () => $$invalidate(2, showRemoveActionModal = true);
  const click_handler_3 = () => $$invalidate(3, showEditConfigModal = true);
  const click_handler_4 = () => $$invalidate(4, showEditDevicesModal = true);
  const click_handler_5 = () => $$invalidate(5, showEditScheduleModal = true);
  const click_handler_6 = () => $$invalidate(6, showSieveOnModal = true);
  const click_handler_7 = () => $$invalidate(7, showSieveOffModal = true);
  const close_handler = () => $$invalidate(1, showAddActionModal = false);
  const close_handler_1 = () => $$invalidate(2, showRemoveActionModal = false);
  const close_handler_2 = () => $$invalidate(3, showEditConfigModal = false);
  const close_handler_3 = () => $$invalidate(4, showEditDevicesModal = false);
  const close_handler_4 = () => $$invalidate(5, showEditScheduleModal = false);
  const close_handler_5 = () => $$invalidate(6, showSieveOnModal = false);
  const close_handler_6 = () => $$invalidate(7, showSieveOffModal = false);
  $$self.$$set = ($$props2) => {
    if ("sieves" in $$props2)
      $$invalidate(0, sieves = $$props2.sieves);
  };
  return [
    sieves,
    showAddActionModal,
    showRemoveActionModal,
    showEditConfigModal,
    showEditDevicesModal,
    showEditScheduleModal,
    showSieveOnModal,
    showSieveOffModal,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    click_handler_7,
    close_handler,
    close_handler_1,
    close_handler_2,
    close_handler_3,
    close_handler_4,
    close_handler_5,
    close_handler_6
  ];
}
class BatchOptionsMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$16, create_fragment$19, safe_not_equal, { sieves: 0 });
  }
}
function create_default_slot$s(ctx) {
  let div;
  let li0;
  let label0;
  let t2;
  let select0;
  let option0;
  let option1;
  let option2;
  let t6;
  let li1;
  let label1;
  let t9;
  let select1;
  let option3;
  let option4;
  let option5;
  let option6;
  let option7;
  let option8;
  let t16;
  let li2;
  let label2;
  let t19;
  let select2;
  let option9;
  let option10;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      li0 = element("li");
      label0 = element("label");
      label0.textContent = `${TXT("l_sort_by")}:`;
      t2 = space();
      select0 = element("select");
      option0 = element("option");
      option0.textContent = `${TXT("l_time_changed_on")}`;
      option1 = element("option");
      option1.textContent = `${TXT("l_name")}`;
      option2 = element("option");
      option2.textContent = `${TXT("l_device")}`;
      t6 = space();
      li1 = element("li");
      label1 = element("label");
      label1.textContent = `${TXT("l_page_size")}:`;
      t9 = space();
      select1 = element("select");
      option3 = element("option");
      option3.textContent = "5";
      option4 = element("option");
      option4.textContent = "20";
      option5 = element("option");
      option5.textContent = "50";
      option6 = element("option");
      option6.textContent = "100";
      option7 = element("option");
      option7.textContent = "200!!";
      option8 = element("option");
      option8.textContent = "500!!";
      t16 = space();
      li2 = element("li");
      label2 = element("label");
      label2.textContent = `${TXT("l_device_filter")}:`;
      t19 = space();
      select2 = element("select");
      option9 = element("option");
      option9.textContent = `${TXT("l_devices_all")}`;
      option10 = element("option");
      option10.textContent = `${TXT("l_device_this")}`;
      attr(label0, "class", "whitespace-nowrap");
      option0.__value = "-ts_data";
      option0.value = option0.__value;
      option1.__value = "name";
      option1.value = option1.__value;
      option2.__value = "client_id";
      option2.value = option2.__value;
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[3].call(select0));
      attr(li0, "class", "px-3 py-1 flex gap-1 justify-between items-center");
      attr(label1, "class", "whitespace-nowrap");
      option3.__value = 5;
      option3.value = option3.__value;
      option4.__value = 20;
      option4.value = option4.__value;
      option5.__value = 50;
      option5.value = option5.__value;
      option6.__value = 100;
      option6.value = option6.__value;
      option7.__value = 200;
      option7.value = option7.__value;
      option8.__value = 500;
      option8.value = option8.__value;
      if (ctx[1] === void 0)
        add_render_callback(() => ctx[4].call(select1));
      attr(li1, "class", "px-3 py-1 flex gap-1 justify-between items-center");
      attr(label2, "class", "whitespace-nowrap");
      option9.__value = 1;
      option9.value = option9.__value;
      option10.__value = 2;
      option10.value = option10.__value;
      if (ctx[2] === void 0)
        add_render_callback(() => ctx[5].call(select2));
      attr(li2, "class", "px-3 py-1 flex gap-1 justify-between items-center");
      attr(div, "class", "flex flex-column gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, li0);
      append(li0, label0);
      append(li0, t2);
      append(li0, select0);
      append(select0, option0);
      append(select0, option1);
      append(select0, option2);
      select_option(select0, ctx[0], true);
      append(div, t6);
      append(div, li1);
      append(li1, label1);
      append(li1, t9);
      append(li1, select1);
      append(select1, option3);
      append(select1, option4);
      append(select1, option5);
      append(select1, option6);
      append(select1, option7);
      append(select1, option8);
      select_option(select1, ctx[1], true);
      append(div, t16);
      append(div, li2);
      append(li2, label2);
      append(li2, t19);
      append(li2, select2);
      append(select2, option9);
      append(select2, option10);
      select_option(select2, ctx[2], true);
      if (!mounted) {
        dispose = [
          listen(select0, "change", ctx[3]),
          listen(select1, "change", ctx[4]),
          listen(select2, "change", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        select_option(select0, ctx2[0]);
      }
      if (dirty & 2) {
        select_option(select1, ctx2[1]);
      }
      if (dirty & 4) {
        select_option(select2, ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_action_slot$5(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-cog"></i> 
      <span class="caret"></span>`;
      attr(button, "class", "btn btn-default");
      attr(button, "type", "button");
      attr(button, "aria-expanded", "false");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[6]))
            ctx[6].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$18(ctx) {
  let menu;
  let current;
  menu = new Menu({
    props: {
      dropDownClass: "dropdown-menu-end",
      class: "mr-6",
      toggle: false,
      $$slots: {
        action: [
          create_action_slot$5,
          ({ onClick }) => ({ 6: onClick }),
          ({ onClick }) => onClick ? 64 : 0
        ],
        default: [create_default_slot$s]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 199) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$15($$self, $$props, $$invalidate) {
  let sort = App.store.get("ui.list.sortby") || "-ts_data";
  let pagesize = App.store.get("ui.list.pagesize") || 50;
  let clientfilter = App.store.get("ui.list.clientfilter") || 1;
  function select0_change_handler() {
    sort = select_value(this);
    $$invalidate(0, sort);
  }
  function select1_change_handler() {
    pagesize = select_value(this);
    $$invalidate(1, pagesize);
  }
  function select2_change_handler() {
    clientfilter = select_value(this);
    $$invalidate(2, clientfilter);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      sort && App.store.set("ui.list.sortby", sort);
    }
    if ($$self.$$.dirty & 2) {
      pagesize && App.store.set("ui.list.pagesize", pagesize);
    }
    if ($$self.$$.dirty & 4) {
      clientfilter && App.store.set("ui.list.clientfilter", clientfilter);
    }
  };
  return [
    sort,
    pagesize,
    clientfilter,
    select0_change_handler,
    select1_change_handler,
    select2_change_handler
  ];
}
class TableSettingsMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$15, create_fragment$18, safe_not_equal, {});
  }
}
class PagerStore extends base.Collection {
  constructor(store2, route2) {
    super();
    this.store = store2;
    this.route = route2;
    this.syncing = store2.syncing;
    this.store.subscribe(() => {
      this._notify();
    });
  }
  info() {
    return this.store.info();
  }
  hasNext() {
    return this.store.hasNext();
  }
  hasPrev() {
    return this.store.hasPrev();
  }
  goto(n) {
    urlCfg.sievesGotoPage(this.route, n);
  }
  onPrev() {
    this.goto(this.info().currentPage - 1);
  }
  onNext() {
    this.goto(this.info().currentPage + 1);
  }
}
function create_if_block_3$g(ctx) {
  let button0;
  let i0;
  let button0_disabled_value;
  let t0;
  let marksievereadmenu;
  let t1;
  let button1;
  let i1;
  let button1_disabled_value;
  let t2;
  let labellist;
  let current;
  let mounted;
  let dispose;
  marksievereadmenu = new MarkSieveReadMenu({
    props: {
      sieves: ctx[4],
      disabled: ctx[3].readOnly
    }
  });
  labellist = new LabelListMenu({
    props: {
      sieves: ctx[4],
      disabled: ctx[3].readOnly
    }
  });
  return {
    c() {
      button0 = element("button");
      i0 = element("i");
      t0 = space();
      create_component(marksievereadmenu.$$.fragment);
      t1 = space();
      button1 = element("button");
      i1 = element("i");
      t2 = space();
      create_component(labellist.$$.fragment);
      attr(i0, "class", "im-run");
      attr(button0, "class", "btn btn-default");
      attr(button0, "ph-event", PHEvents.SIEVE_RUN);
      attr(button0, "title", TXT("a_check_changes"));
      button0.disabled = button0_disabled_value = ctx[3].readOnly;
      attr(i1, "class", "im-trash");
      attr(button1, "class", "btn btn-default");
      attr(button1, "title", TXT("a_move_to_trash"));
      button1.disabled = button1_disabled_value = ctx[3].readOnly;
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, i0);
      insert(target, t0, anchor);
      mount_component(marksievereadmenu, target, anchor);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      append(button1, i1);
      insert(target, t2, anchor);
      mount_component(labellist, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[9]),
          listen(button1, "click", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & 8 && button0_disabled_value !== (button0_disabled_value = ctx2[3].readOnly)) {
        button0.disabled = button0_disabled_value;
      }
      const marksievereadmenu_changes = {};
      if (dirty & 8)
        marksievereadmenu_changes.disabled = ctx2[3].readOnly;
      marksievereadmenu.$set(marksievereadmenu_changes);
      if (!current || dirty & 8 && button1_disabled_value !== (button1_disabled_value = ctx2[3].readOnly)) {
        button1.disabled = button1_disabled_value;
      }
      const labellist_changes = {};
      if (dirty & 8)
        labellist_changes.disabled = ctx2[3].readOnly;
      labellist.$set(labellist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(marksievereadmenu.$$.fragment, local);
      transition_in(labellist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(marksievereadmenu.$$.fragment, local);
      transition_out(labellist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button0);
      if (detaching)
        detach(t0);
      destroy_component(marksievereadmenu, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(button1);
      if (detaching)
        detach(t2);
      destroy_component(labellist, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$j(ctx) {
  let button0;
  let t0_value = TXT("a_restore") + "";
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2_value = TXT("a_del_permanent") + "";
  let t2;
  let button1_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      attr(button0, "class", "btn btn-default");
      button0.disabled = button0_disabled_value = ctx[3].readOnly;
      attr(button1, "class", "btn btn-default");
      button1.disabled = button1_disabled_value = ctx[3].readOnly;
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      append(button0, t0);
      insert(target, t1, anchor);
      insert(target, button1, anchor);
      append(button1, t2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[10]),
          listen(button1, "click", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && button0_disabled_value !== (button0_disabled_value = ctx2[3].readOnly)) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & 8 && button1_disabled_value !== (button1_disabled_value = ctx2[3].readOnly)) {
        button1.disabled = button1_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(button1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$q(ctx) {
  let button;
  let i2;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      attr(i2, "class", "fa fa-refresh");
      toggle_class(i2, "fa-spin", ctx[0]);
      attr(button, "class", "btn btn-default");
      attr(button, "title", TXT("l_sync"));
      button.disabled = button_disabled_value = ctx[3].readOnly;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      if (!mounted) {
        dispose = listen(button, "click", ctx[13]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        toggle_class(i2, "fa-spin", ctx2[0]);
      }
      if (dirty & 8 && button_disabled_value !== (button_disabled_value = ctx2[3].readOnly)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$C(ctx) {
  let batchoptions;
  let current;
  batchoptions = new BatchOptionsMenu({ props: { sieves: ctx[4] } });
  return {
    c() {
      create_component(batchoptions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(batchoptions, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(batchoptions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(batchoptions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(batchoptions, detaching);
    }
  };
}
function create_fragment$17(ctx) {
  let div;
  let input;
  let t0;
  let sieveselectmenu;
  let t1;
  let t2;
  let t3;
  let t4;
  let additionaloptions;
  let t5;
  let t6;
  let i2;
  let t7;
  let listpager;
  let t8;
  let tablesettings;
  let current;
  let mounted;
  let dispose;
  sieveselectmenu = new SieveSelectMenu({ props: { sieves: ctx[4] } });
  let if_block0 = ctx[2] && !ctx[1] && create_if_block_3$g(ctx);
  let if_block1 = ctx[1] && create_if_block_2$j(ctx);
  let if_block2 = ctx[7] && create_if_block_1$q(ctx);
  additionaloptions = new AdditionalOptionsMenu({ props: { sieves: ctx[4] } });
  let if_block3 = ctx[2] && create_if_block$C(ctx);
  listpager = new ListPager({ props: { store: ctx[5] } });
  tablesettings = new TableSettingsMenu({});
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      create_component(sieveselectmenu.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      create_component(additionaloptions.$$.fragment);
      t5 = space();
      if (if_block3)
        if_block3.c();
      t6 = space();
      i2 = element("i");
      t7 = space();
      create_component(listpager.$$.fragment);
      t8 = space();
      create_component(tablesettings.$$.fragment);
      attr(input, "class", "xselect-all");
      attr(input, "type", "checkbox");
      set_style(input, "margin", "0 6px 0 0");
      set_style(i2, "flex", "1 1 0%");
      attr(div, "class", "flex justify-end items-center gap-1 pl-2 xtbar flex-nowrap");
      toggle_class(div, "xlocal", ctx[7]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      append(div, t0);
      mount_component(sieveselectmenu, div, null);
      append(div, t1);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t3);
      if (if_block2)
        if_block2.m(div, null);
      append(div, t4);
      mount_component(additionaloptions, div, null);
      append(div, t5);
      if (if_block3)
        if_block3.m(div, null);
      append(div, t6);
      append(div, i2);
      append(div, t7);
      mount_component(listpager, div, null);
      append(div, t8);
      mount_component(tablesettings, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(input, "change", ctx[15]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[2] && !ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 6) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$g(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$j(ctx2);
          if_block1.c();
          if_block1.m(div, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[7])
        if_block2.p(ctx2, dirty);
      if (ctx2[2]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$C(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, t6);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sieveselectmenu.$$.fragment, local);
      transition_in(if_block0);
      transition_in(additionaloptions.$$.fragment, local);
      transition_in(if_block3);
      transition_in(listpager.$$.fragment, local);
      transition_in(tablesettings.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sieveselectmenu.$$.fragment, local);
      transition_out(if_block0);
      transition_out(additionaloptions.$$.fragment, local);
      transition_out(if_block3);
      transition_out(listpager.$$.fragment, local);
      transition_out(tablesettings.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(sieveselectmenu);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(additionaloptions);
      if (if_block3)
        if_block3.d();
      destroy_component(listpager);
      destroy_component(tablesettings);
      mounted = false;
      dispose();
    }
  };
}
function instance$14($$self, $$props, $$invalidate) {
  let $route;
  let $isSieveSelected;
  let $permissionsModel;
  component_subscribe($$self, route, ($$value) => $$invalidate(14, $route = $$value));
  const { sieves, clients } = getContext("watchlist:stores");
  const pagerStore = new PagerStore(sieves, route);
  let isSieveSelected = derived(sieves, () => sieves.getSelectedSieveIds().length > 0);
  component_subscribe($$self, isSieveSelected, (value) => $$invalidate(2, $isSieveSelected = value));
  let isLocal = Supports.agents.local;
  let syncingLocalDB = false;
  let isTrash;
  const { permissionsModel } = App.user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(3, $permissionsModel = value));
  onMount(() => {
    if (!isLocal) {
      return;
    }
    instance$5s.on("user_states", toggleSync);
    return () => {
      instance$5s.off("user_states", toggleSync);
    };
  });
  function toggleSync({ sync }) {
    if (isLocal && sync) {
      setTimeout(() => $$invalidate(0, { syncingLocalDB } = sync, syncingLocalDB), 200);
    }
  }
  async function checkForChanges() {
    const models = sieves.getSelectedSieves();
    if (!isLocal) {
      runCloudSieves(models);
      return;
    }
    if (models.some((model) => model.isDeviceWeb())) {
      Msg.info("m_check_local_only");
    } else {
      Msg.info("m_started_check_for_changes");
    }
    const ids = _.pluck(models, "id");
    serviceProxy.service.checkNow(ids);
    if (!await serviceProxy.isActive()) {
      Msg.error("m_checks_paused");
    }
  }
  async function runCloudSieves(models) {
    const localSieve = models.find((model) => !model.isDeviceWeb());
    if (localSieve) {
      const actions = [];
      const clientId = localSieve.get("client_id");
      let client = clients.get(clientId);
      const errMsg = SPRINTF("m_check_web_only", client.get("info"));
      if (document.querySelector('[distill-ext="1"]')) {
        const currExtClientId = await messageExtension({
          type: "request",
          module: "Prefs",
          method: "get",
          args: ["client.id"]
        });
        if (clientId === currExtClientId || clientId === C$1.CLIENT_ID_ANY) {
          actions.push({
            name: "Open Extension",
            onclick: () => {
              messageExtension({
                type: "request",
                module: "service",
                method: "showWatchlist"
              });
            }
          });
        }
      }
      actions.push({
        name: "Learn More",
        attrs: {
          href: "https://distill.io/docs/web-monitor/cloud-local-monitors/",
          target: "_blank"
        }
      });
      Msg.info(errMsg, actions);
      return;
    }
    const ids = _.pluck(models, "id");
    Msg.info("l_loading");
    try {
      await Api.utils("/sieve/run", "POST", { ids });
      Msg.info("m_started_check_for_changes");
    } catch (err) {
      console.error("Could not check for changes", err);
      Msg.error("m_check_for_changes_failed");
    }
  }
  async function restoreSieves() {
    const models = sieves.getSelectedSieves();
    let sieveConstraint = {};
    try {
      sieveConstraint = await checkSieveConstraint(models.length);
    } catch (e) {
      console.error(e);
      sieveConstraint = { isOverLimit: false };
    }
    if (sieveConstraint.isOverLimit) {
      Msg.error("m_monitor_limit");
      return;
    }
    try {
      for (let i2 = 0; i2 < models.length; i2++) {
        let model = models[i2];
        await model.save("state", C$1.STATE_READY, {
          patch: true,
          success() {
            model.collection.remove(model);
          }
        });
      }
      sieves.fetch();
      Msg.info("m_restored_from_trash");
    } catch (err) {
      Msg.error("sieve:restore:err");
    }
  }
  async function deleteSieve() {
    const models = sieves.getSelectedSieves();
    try {
      await Promise.all(models.map((model) => model.save("state", C$1.STATE_DISCARD, {
        patch: true,
        wait: true,
        success() {
          model.collection.remove(model);
        }
      })));
      sieves.fetch();
    } catch (err) {
      Msg.error("sieve:del:err");
    }
    return true;
  }
  async function deleteSievePermanently() {
    const models = sieves.getSelectedSieves();
    try {
      for (let i2 = 0; i2 < models.length; i2 += 5) {
        await Promise.all(models.slice(i2, i2 + 5).map((model) => model.destroy({ wait: true })));
      }
      sieves.fetch();
      Msg.info("Permanently deleted selected items.");
    } catch (e) {
      Msg.error("sieve:del:err");
    }
  }
  async function syncLocalSieve() {
    if (!Supports.agents.local)
      return;
    Msg.info("l_syncing");
    let complete = false;
    try {
      await serviceProxy.SyncMan.sync(true);
      complete = true;
      Msg.reset();
    } catch (err) {
      console.error(JSON.stringify(err));
      try {
        complete = true;
        await serviceProxy.service.initSync();
      } catch (err2) {
        console.error(JSON.stringify(err2));
        Msg.error(err2.msg || err2.message || JSON.stringify(err2));
      }
    }
    setTimeout(
      function() {
        if (!complete) {
          Msg.info("l_syncing_wait");
        }
      },
      5e3
    );
  }
  const change_handler = (e) => sieves.toggleSieveSelection(e.target.checked);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16384) {
      $$invalidate(1, isTrash = $route.prefix === "trash");
    }
  };
  return [
    syncingLocalDB,
    isTrash,
    $isSieveSelected,
    $permissionsModel,
    sieves,
    pagerStore,
    isSieveSelected,
    isLocal,
    permissionsModel,
    checkForChanges,
    restoreSieves,
    deleteSieve,
    deleteSievePermanently,
    syncLocalSieve,
    $route,
    change_handler
  ];
}
class Toolbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$14, create_fragment$17, safe_not_equal, {});
  }
}
function create_topbar_slot$5(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({});
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_if_block_1$p(ctx) {
  let wltoolbar;
  let current;
  wltoolbar = new Toolbar({});
  return {
    c() {
      create_component(wltoolbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(wltoolbar, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(wltoolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(wltoolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(wltoolbar, detaching);
    }
  };
}
function create_if_block$B(ctx) {
  let button;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-chevron-left"></i> Back`;
      attr(button, "class", "btn btn-default w-min whitespace-nowrap");
      attr(button, "data-action", "go_back");
    },
    m(target, anchor) {
      insert(target, button, anchor);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
    }
  };
}
function create_default_slot$r(ctx) {
  let div3;
  let div0;
  let sidebar;
  let t0;
  let div2;
  let current_block_type_index;
  let if_block;
  let t1;
  let div1;
  let current;
  let mounted;
  let dispose;
  sidebar = new Sidebar({});
  const if_block_creators = [create_if_block$B, create_if_block_1$p];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    if (ctx2[3].module === "list")
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      create_component(sidebar.$$.fragment);
      t0 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "sidebar scrollbar-thin");
      attr(div1, "class", "flex-1 overflow-y-auto pb7 scrollbar-thin");
      attr(div2, "class", "flex-1 flex flex-column gap-2 items-stretch");
      attr(div3, "class", "flex h-full w-full");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      mount_component(sidebar, div0, null);
      append(div3, t0);
      append(div3, div2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      append(div2, t1);
      append(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      ctx[6](div1);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "scroll", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index !== previous_block_index) {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          }
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        } else {
          if_block = null;
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sidebar.$$.fragment, local);
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(sidebar.$$.fragment, local);
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(sidebar);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[6](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$16(ctx) {
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      contentScrollTop: ctx[1],
      $$slots: {
        default: [create_default_slot$r],
        topbar: [create_topbar_slot$5]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 2)
        layout_changes.contentScrollTop = ctx2[1];
      if (dirty & 141) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(layout, detaching);
    }
  };
}
function instance$13($$self, $$props, $$invalidate) {
  let $route;
  component_subscribe($$self, route, ($$value) => $$invalidate(3, $route = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { renderDefaultToolbar = false } = $$props;
  let { contentScrollTop = 0 } = $$props;
  let elContent;
  function setScroll() {
    setTimeout(() => {
      elContent && $$invalidate(2, elContent.scrollTop = contentScrollTop, elContent);
    });
  }
  function scroll_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elContent = $$value;
      $$invalidate(2, elContent);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("renderDefaultToolbar" in $$props2)
      $$invalidate(0, renderDefaultToolbar = $$props2.renderDefaultToolbar);
    if ("contentScrollTop" in $$props2)
      $$invalidate(1, contentScrollTop = $$props2.contentScrollTop);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      {
        contentScrollTop !== void 0 && setScroll();
      }
    }
  };
  return [
    renderDefaultToolbar,
    contentScrollTop,
    elContent,
    $route,
    slots,
    scroll_handler,
    div1_binding,
    $$scope
  ];
}
class WatchListLayout extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$13, create_fragment$16, safe_not_equal, {
      renderDefaultToolbar: 0,
      contentScrollTop: 1
    });
  }
}
function create_action_slot$4(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-caret-down"></i>`;
      attr(button, "class", "xtd xbtn xaction margin-0");
      attr(button, "data-bs-auto-close", "outside");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[28]))
            ctx[28].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_6$2(ctx) {
  let menuitemwithpermissions;
  let current;
  function click_handler() {
    return ctx[18](ctx[27]);
  }
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions.$on("click", click_handler);
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitemwithpermissions_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_default_slot_8(ctx) {
  let t_value = TXT("a_check_changes") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Options");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6(ctx) {
  let t;
  return {
    c() {
      t = text("Duplicate");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_5$4(ctx) {
  let menuitemwithpermissions;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      href: urlCfg.crawlerDetail(ctx[7].team || 0, ctx[6].crawler_id),
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 192)
        menuitemwithpermissions_changes.href = urlCfg.crawlerDetail(ctx2[7].team || 0, ctx2[6].crawler_id);
      if (dirty & 536870912) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_default_slot_5(ctx) {
  let t;
  return {
    c() {
      t = text("View Crawler");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_4$a(ctx) {
  let li0;
  let t0;
  let menuitemwithpermissions;
  let t1;
  let li1;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      class: "xview",
      menuItemStyle: "--bs-dropdown-link-hover-bg: transparent;\n                               --bs-dropdown-link-active-bg: transparent;\n                               --bs-dropdown-link-active-color: var(--bs-body-color)",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      li0 = element("li");
      li0.innerHTML = `<hr class="dropdown-divider"/>`;
      t0 = space();
      create_component(menuitemwithpermissions.$$.fragment);
      t1 = space();
      li1 = element("li");
      li1.innerHTML = `<hr class="dropdown-divider"/>`;
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      insert(target, t0, anchor);
      mount_component(menuitemwithpermissions, target, anchor);
      insert(target, t1, anchor);
      insert(target, li1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 536870925) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t0);
      destroy_component(menuitemwithpermissions, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(li1);
    }
  };
}
function create_default_slot_4(ctx) {
  let actionseditor;
  let current;
  let actionseditor_props = { sieve: ctx[0] };
  actionseditor = new ActionsEditor({ props: actionseditor_props });
  ctx[19](actionseditor);
  actionseditor.$on("globalaction", ctx[20]);
  actionseditor.$on("manage", ctx[11]);
  return {
    c() {
      create_component(actionseditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(actionseditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const actionseditor_changes = {};
      if (dirty & 1)
        actionseditor_changes.sieve = ctx2[0];
      actionseditor.$set(actionseditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(actionseditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionseditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[19](null);
      destroy_component(actionseditor, detaching);
    }
  };
}
function create_else_block$s(ctx) {
  let menuitemwithpermissions;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions.$on("click", ctx[14]);
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_if_block_3$f(ctx) {
  let menuitemwithpermissions;
  let current;
  menuitemwithpermissions = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions.$on("click", ctx[17]);
  return {
    c() {
      create_component(menuitemwithpermissions.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitemwithpermissions, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitemwithpermissions_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions.$set(menuitemwithpermissions_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitemwithpermissions.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitemwithpermissions.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitemwithpermissions, detaching);
    }
  };
}
function create_default_slot_3$2(ctx) {
  let t;
  return {
    c() {
      t = text("Move to Trash");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$3(ctx) {
  let t;
  return {
    c() {
      t = text("Restore");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$5(ctx) {
  let t;
  return {
    c() {
      t = text("Delete forever");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$q(ctx) {
  let t0;
  let menuitemwithpermissions0;
  let t1;
  let menuitemwithpermissions1;
  let t2;
  let t3;
  let t4;
  let current_block_type_index;
  let if_block3;
  let t5;
  let menuitemwithpermissions2;
  let current;
  let if_block0 = Supports.agents.local && create_if_block_6$2(ctx);
  menuitemwithpermissions0 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions0.$on("click", ctx[12]);
  menuitemwithpermissions1 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions1.$on("click", ctx[13]);
  let if_block1 = ctx[6].content_type === C$1.TYPE_SITEMAP && create_if_block_5$4(ctx);
  let if_block2 = !ctx[8].readOnly && create_if_block_4$a(ctx);
  const if_block_creators = [create_if_block_3$f, create_else_block$s];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[9].prefix === "trash")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  menuitemwithpermissions2 = new MenuItemWithPermissions({
    props: {
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  menuitemwithpermissions2.$on("click", ctx[15]);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(menuitemwithpermissions0.$$.fragment);
      t1 = space();
      create_component(menuitemwithpermissions1.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if_block3.c();
      t5 = space();
      create_component(menuitemwithpermissions2.$$.fragment);
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      mount_component(menuitemwithpermissions0, target, anchor);
      insert(target, t1, anchor);
      mount_component(menuitemwithpermissions1, target, anchor);
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t4, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t5, anchor);
      mount_component(menuitemwithpermissions2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (Supports.agents.local)
        if_block0.p(ctx2, dirty);
      const menuitemwithpermissions0_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions0.$set(menuitemwithpermissions0_changes);
      const menuitemwithpermissions1_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions1.$set(menuitemwithpermissions1_changes);
      if (ctx2[6].content_type === C$1.TYPE_SITEMAP) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_5$4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!ctx2[8].readOnly) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4$a(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(t4.parentNode, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block3 = if_blocks[current_block_type_index];
        if (!if_block3) {
          if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block3.c();
        } else {
          if_block3.p(ctx2, dirty);
        }
        transition_in(if_block3, 1);
        if_block3.m(t5.parentNode, t5);
      }
      const menuitemwithpermissions2_changes = {};
      if (dirty & 536870912) {
        menuitemwithpermissions2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitemwithpermissions2.$set(menuitemwithpermissions2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(menuitemwithpermissions0.$$.fragment, local);
      transition_in(menuitemwithpermissions1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(menuitemwithpermissions2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(menuitemwithpermissions0.$$.fragment, local);
      transition_out(menuitemwithpermissions1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(menuitemwithpermissions2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      destroy_component(menuitemwithpermissions0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(menuitemwithpermissions1, detaching);
      if (detaching)
        detach(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t3);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t4);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t5);
      destroy_component(menuitemwithpermissions2, detaching);
    }
  };
}
function create_if_block_2$i(ctx) {
  let globalactionseditormodal;
  let current;
  globalactionseditormodal = new GlobalActionsEditorModal({});
  globalactionseditormodal.$on("close", ctx[22]);
  return {
    c() {
      create_component(globalactionseditormodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(globalactionseditormodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(globalactionseditormodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(globalactionseditormodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(globalactionseditormodal, detaching);
    }
  };
}
function create_if_block_1$o(ctx) {
  let manageemailsmodal;
  let current;
  manageemailsmodal = new ManageEmailModal({});
  manageemailsmodal.$on("close", ctx[23]);
  return {
    c() {
      create_component(manageemailsmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(manageemailsmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(manageemailsmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(manageemailsmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(manageemailsmodal, detaching);
    }
  };
}
function create_if_block$A(ctx) {
  let managephonesmodal;
  let current;
  managephonesmodal = new ManagePhonesModal({});
  managephonesmodal.$on("close", ctx[24]);
  return {
    c() {
      create_component(managephonesmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(managephonesmodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(managephonesmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(managephonesmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(managephonesmodal, detaching);
    }
  };
}
function create_fragment$15(ctx) {
  let menu;
  let updating_show;
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  function menu_show_binding(value) {
    ctx[21](value);
  }
  let menu_props = {
    toggle: false,
    $$slots: {
      default: [
        create_default_slot$q,
        ({ close }) => ({ 27: close }),
        ({ close }) => close ? 134217728 : 0
      ],
      action: [
        create_action_slot$4,
        ({ onClick }) => ({ 28: onClick }),
        ({ onClick }) => onClick ? 268435456 : 0
      ]
    },
    $$scope: { ctx }
  };
  if (ctx[1] !== void 0) {
    menu_props.show = ctx[1];
  }
  menu = new Menu({ props: menu_props });
  binding_callbacks.push(() => bind$1(menu, "show", menu_show_binding));
  let if_block0 = ctx[3] && create_if_block_2$i(ctx);
  let if_block1 = ctx[4] && create_if_block_1$o(ctx);
  let if_block2 = ctx[5] && create_if_block$A(ctx);
  return {
    c() {
      create_component(menu.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 939525069) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_show && dirty & 2) {
        updating_show = true;
        menu_changes.show = ctx2[1];
        add_flush_callback(() => updating_show = false);
      }
      menu.$set(menu_changes);
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$i(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$o(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[5]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$A(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function instance$12($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop$1, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(6, $sieve = $$value)), sieve);
  let $params;
  let $permissionsModel;
  let $route;
  component_subscribe($$self, params, ($$value) => $$invalidate(7, $params = $$value));
  component_subscribe($$self, route, ($$value) => $$invalidate(9, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { sieve } = $$props;
  $$subscribe_sieve();
  const { permissionsModel } = App.user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(8, $permissionsModel = value));
  let showMenu;
  let actionEditor;
  let showGlobalActionEditor2 = false;
  let showManageEmailsModal = false;
  let showManagePhonesModal = false;
  function showModal(e) {
    const type = e.detail;
    if (type === "email") {
      $$invalidate(4, showManageEmailsModal = true);
    } else if (type === "phone") {
      $$invalidate(5, showManagePhonesModal = true);
    }
  }
  function sieveEdit() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/sieve/edit/${$sieve.id}.id`);
  }
  function duplicateSieve() {
    let team = get_store_value(params).team;
    push$1(`/w/${team}/sieve/dup/${$sieve.id}.id`);
  }
  function deleteSieve() {
    $$invalidate(1, showMenu = false);
    Msg.start("discard", "l_loading");
    sieve.save("state", C$1.STATE_DISCARD, {
      patch: true,
      wait: true,
      error() {
        Msg.stop("discard", { error: "e_req" });
      },
      success: () => {
        sieve.collection.fetch({ sort: false });
        sieve.collection.remove(sieve);
        Msg.stop("discard");
        trackEvent(PHEvents.SIEVE_STATE, {
          sieve_id: sieve.id,
          state: C$1.STATE_DISCARD
        });
      }
    });
  }
  function deleteSievePermanently() {
    const sieveCollection = sieve.collection;
    $$invalidate(1, showMenu = false);
    Msg.start("destroy", "l_loading");
    sieve.destroy({
      wait: true,
      error: () => {
        Msg.stop("destroy", { error: "e_req" });
      },
      success: () => {
        sieveCollection.fetch({ sort: false });
        Msg.stop("destroy");
        trackEvent(PHEvents.SIEVE_STATE, { sieve_id: sieve.id, state: C$1.STATE_DEL });
      }
    });
  }
  async function checkForChanges() {
    const ids = [$sieve.id];
    if (sieve.isDeviceWeb()) {
      Msg.info("m_check_local_only");
    } else {
      serviceProxy.service.checkNow(ids);
    }
    if (!await serviceProxy.isActive()) {
      Msg.error("m_checks_paused");
    }
  }
  async function saveSieveActions() {
    const changes = actionEditor.getChanges();
    await base.syncBatch(changes);
  }
  async function restoreSieve() {
    let sieveConstraint = {};
    try {
      sieveConstraint = await checkSieveConstraint(1);
    } catch (e) {
      console.error(e);
      sieveConstraint = { isOverLimit: false };
    }
    if (sieveConstraint.isOverLimit) {
      Msg.error("m_monitor_limit");
      return;
    }
    try {
      const sieveCollection = sieve.collection;
      await sieve.save("state", C$1.STATE_READY, {
        patch: true,
        success() {
          sieveCollection.fetch({ sort: false });
          sieve.collection.remove(sieve);
        }
      });
      Msg.info("m_restored_from_trash");
    } catch (err) {
      Msg.error("sieve:restore:err");
    }
  }
  const click_handler = (close) => {
    checkForChanges();
    close();
  };
  function actionseditor_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      actionEditor = $$value;
      $$invalidate(2, actionEditor);
    });
  }
  const globalaction_handler = () => {
    $$invalidate(3, showGlobalActionEditor2 = true);
  };
  function menu_show_binding(value) {
    showMenu = value;
    $$invalidate(1, showMenu);
  }
  const close_handler = () => $$invalidate(3, showGlobalActionEditor2 = false);
  const close_handler_1 = () => $$invalidate(4, showManageEmailsModal = false);
  const close_handler_2 = () => $$invalidate(5, showManagePhonesModal = false);
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(0, sieve = $$props2.sieve));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 6) {
      {
        if (!showMenu && actionEditor) {
          saveSieveActions();
        }
      }
    }
  };
  return [
    sieve,
    showMenu,
    actionEditor,
    showGlobalActionEditor2,
    showManageEmailsModal,
    showManagePhonesModal,
    $sieve,
    $params,
    $permissionsModel,
    $route,
    permissionsModel,
    showModal,
    sieveEdit,
    duplicateSieve,
    deleteSieve,
    deleteSievePermanently,
    checkForChanges,
    restoreSieve,
    click_handler,
    actionseditor_binding,
    globalaction_handler,
    menu_show_binding,
    close_handler,
    close_handler_1,
    close_handler_2
  ];
}
class SieveContextMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$12, create_fragment$15, safe_not_equal, { sieve: 0 });
  }
}
function create_action_slot$3(ctx) {
  let a;
  let small;
  let t0_value = (ctx[2].schedule ? getShortDisplayText(ctx[2].schedule.toJSON()) : "err: unset") + "";
  let t0;
  let t1;
  let i2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      small = element("small");
      t0 = text(t0_value);
      t1 = space();
      i2 = element("i");
      attr(i2, "class", "xcaret fa fa-caret-down");
      attr(a, "title", "Click to edit schedule");
      attr(a, "type", "button");
      attr(a, "aria-expanded", "false");
      attr(a, "data-bs-auto-close", "outside");
      attr(a, "class", "text-decoration-none xtd xdata xaction");
      toggle_class(a, "disabled", ctx[3].readOnly);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, small);
      append(small, t0);
      append(a, t1);
      append(a, i2);
      if (!mounted) {
        dispose = listen(a, "click", function() {
          if (is_function(ctx[9]))
            ctx[9].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 4 && t0_value !== (t0_value = (ctx[2].schedule ? getShortDisplayText(ctx[2].schedule.toJSON()) : "err: unset") + ""))
        set_data(t0, t0_value);
      if (dirty & 8) {
        toggle_class(a, "disabled", ctx[3].readOnly);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_top_slot$2(ctx) {
  let li;
  let i0;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      i0 = element("i");
      i0.textContent = `${TXT("l_schedule")}`;
      t1 = space();
      button = element("button");
      button.innerHTML = `<i class="fa fa-times"></i>`;
      set_style(i0, "margin-left", "18px");
      attr(button, "class", "btn xbtn-light me-1");
      attr(li, "class", "flex justify-between gap-2");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, i0);
      append(li, t1);
      append(li, button);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(function() {
          if (is_function(ctx[8]))
            ctx[8].apply(this, arguments);
        }));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$z(ctx) {
  let scheduleeditor;
  let current;
  const scheduleeditor_spread_levels = [
    { formModel: ctx[1] },
    { autoSync: true },
    ctx[5]
  ];
  let scheduleeditor_props = {};
  for (let i2 = 0; i2 < scheduleeditor_spread_levels.length; i2 += 1) {
    scheduleeditor_props = assign(scheduleeditor_props, scheduleeditor_spread_levels[i2]);
  }
  scheduleeditor = new ScheduleEditor({ props: scheduleeditor_props });
  return {
    c() {
      create_component(scheduleeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(scheduleeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const scheduleeditor_changes = dirty & 34 ? get_spread_update(scheduleeditor_spread_levels, [
        dirty & 2 && { formModel: ctx2[1] },
        scheduleeditor_spread_levels[1],
        dirty & 32 && get_spread_object(ctx2[5])
      ]) : {};
      scheduleeditor.$set(scheduleeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scheduleeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scheduleeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(scheduleeditor, detaching);
    }
  };
}
function create_default_slot$p(ctx) {
  let li;
  let current;
  let if_block = ctx[1] && create_if_block$z(ctx);
  return {
    c() {
      li = element("li");
      if (if_block)
        if_block.c();
      attr(li, "class", "xview");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (if_block)
        if_block.m(li, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$z(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(li, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block)
        if_block.d();
    }
  };
}
function create_fragment$14(ctx) {
  let menu;
  let current;
  menu = new Menu({
    props: {
      dropDownClass: "dropdown-menu-end",
      toggle: false,
      disabled: ctx[3].readOnly,
      $$slots: {
        default: [create_default_slot$p],
        top: [
          create_top_slot$2,
          ({ close }) => ({ 8: close }),
          ({ close }) => close ? 256 : 0
        ],
        action: [
          create_action_slot$3,
          ({ onClick }) => ({ 9: onClick }),
          ({ onClick }) => onClick ? 512 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  menu.$on("open", ctx[6]);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 8)
        menu_changes.disabled = ctx2[3].readOnly;
      if (dirty & 1806) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function instance$11($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop$1, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(2, $sieve = $$value)), sieve);
  let $permissionsModel;
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { sieve } = $$props;
  $$subscribe_sieve();
  const user = App.user;
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(3, $permissionsModel = value));
  let formModel;
  let sitemapAttributes = $sieve.content_type === C$1.TYPE_SITEMAP ? {
    editors: {
      AUTO: {
        name: "Auto",
        component: AutoScheduleMessage
      }
    },
    id: $sieve.crawler_id
  } : {};
  function onOpen() {
    $$invalidate(1, formModel = new SieveFormModel(sieve));
  }
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(0, sieve = $$props2.sieve));
  };
  return [
    sieve,
    formModel,
    $sieve,
    $permissionsModel,
    permissionsModel,
    sitemapAttributes,
    onOpen
  ];
}
class ScheduleMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$11, create_fragment$14, safe_not_equal, { sieve: 0 });
  }
}
function create_fragment$13(ctx) {
  let clientlist;
  let current;
  clientlist = new ClientList({ props: { clients: ctx[0] } });
  return {
    c() {
      create_component(clientlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clientlist, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(clientlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clientlist, detaching);
    }
  };
}
function instance$10($$self) {
  let clients = getContext("clients");
  return [clients];
}
class ClientManager extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$10, create_fragment$13, safe_not_equal, {});
  }
}
function create_default_slot$o(ctx) {
  let clientmanager;
  let current;
  clientmanager = new ClientManager({});
  return {
    c() {
      create_component(clientmanager.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clientmanager, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(clientmanager.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientmanager.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clientmanager, detaching);
    }
  };
}
function create_header_slot$9(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${TXT("l_devices")}`;
      attr(div, "slot", "header");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$12(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      bodyStyle: "--bs-modal-padding:0",
      $$slots: {
        header: [create_header_slot$9],
        default: [create_default_slot$o]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[0]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 2) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$$($$self) {
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  return [close_handler];
}
class ClientManagerModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$$, create_fragment$12, safe_not_equal, {});
  }
}
function get_each_context$m(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2];
  return child_ctx;
}
function create_action_slot$2(ctx) {
  let a;
  let i0;
  let i0_class_value;
  let t;
  let i1;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      i0 = element("i");
      t = space();
      i1 = element("i");
      attr(i0, "class", i0_class_value = App.clients.get(ctx[3].client_id) ? App.clients.get(ctx[3].client_id).getIcon() : "fa fa-lg error fa-question");
      set_style(i0, "margin", "auto");
      attr(i1, "class", "xcaret fa fa-caret-down");
      attr(a, "class", "xtd xdata xaction xbtn text-decoration-none");
      attr(a, "title", "Click to edit device");
      set_style(a, "text-align", "center");
      toggle_class(a, "disabled", ctx[2].readOnly);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i0);
      append(a, t);
      append(a, i1);
      if (!mounted) {
        dispose = listen(a, "click", function() {
          if (is_function(ctx[13]))
            ctx[13].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 8 && i0_class_value !== (i0_class_value = App.clients.get(ctx[3].client_id) ? App.clients.get(ctx[3].client_id).getIcon() : "fa fa-lg error fa-question")) {
        attr(i0, "class", i0_class_value);
      }
      if (dirty & 4) {
        toggle_class(a, "disabled", ctx[2].readOnly);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_top_slot$1(ctx) {
  let li0;
  let span;
  let t1;
  let li1;
  return {
    c() {
      li0 = element("li");
      span = element("span");
      span.textContent = `${TXT("a_select_device")}`;
      t1 = space();
      li1 = element("li");
      li1.innerHTML = `<hr class="dropdown-divider"/>`;
      attr(li0, "class", "xview");
    },
    m(target, anchor) {
      insert(target, li0, anchor);
      append(li0, span);
      insert(target, t1, anchor);
      insert(target, li1, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(li0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(li1);
    }
  };
}
function create_else_block$r(ctx) {
  let menuitem;
  let current;
  function click_handler_1() {
    return ctx[7](ctx[10]);
  }
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", click_handler_1);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const menuitem_changes = {};
      if (dirty & 16385) {
        menuitem_changes.$$scope = { dirty, ctx };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_if_block_1$n(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      menuItemStyle: "font-weight: bold;",
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 16385) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_3$1(ctx) {
  let i2;
  let i_class_value;
  let t0;
  let t1_value = ctx[10].getInfo() + "";
  let t1;
  let t2;
  return {
    c() {
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(i2, "class", i_class_value = ctx[10].getIcon());
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && i_class_value !== (i_class_value = ctx2[10].getIcon())) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & 1 && t1_value !== (t1_value = ctx2[10].getInfo() + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(i2);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(t2);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let i2;
  let t0;
  let t1_value = ctx[10].getInfo() + "";
  let t1;
  let t2;
  return {
    c() {
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      attr(i2, "class", "fa fa-check");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[10].getInfo() + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(i2);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block$m(key_1, ctx) {
  let first2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$n, create_else_block$r];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[10].id === ctx2[3].client_id)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ctx[0].getAccessibleClients(App.clients);
  const get_key = (ctx2) => ctx2[10].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$m(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$m(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 41) {
        each_value = ctx2[0].getAccessibleClients(App.clients);
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$m, each_1_anchor, get_each_context$m);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_default_slot$n(ctx) {
  let i2;
  let t0;
  let t1_value = TXT("a_edit") + "";
  let t1;
  return {
    c() {
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fa fa-edit");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(i2);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_bottom_slot$1(ctx) {
  let li;
  let t;
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$n] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[6]);
  return {
    c() {
      li = element("li");
      li.innerHTML = `<hr class="dropdown-divider"/>`;
      t = space();
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      insert(target, t, anchor);
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 16384) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (detaching)
        detach(t);
      destroy_component(menuitem, detaching);
    }
  };
}
function create_if_block$y(ctx) {
  let clientmanagermodal;
  let current;
  clientmanagermodal = new ClientManagerModal({});
  clientmanagermodal.$on("close", ctx[8]);
  return {
    c() {
      create_component(clientmanagermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clientmanagermodal, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(clientmanagermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clientmanagermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clientmanagermodal, detaching);
    }
  };
}
function create_fragment$11(ctx) {
  let menu;
  let t;
  let if_block_anchor;
  let current;
  menu = new Menu({
    props: {
      dropDownClass: "dropdown-menu-end",
      disabled: ctx[2].readOnly,
      $$slots: {
        bottom: [create_bottom_slot$1],
        default: [create_default_slot_1$4],
        top: [create_top_slot$1],
        action: [
          create_action_slot$2,
          ({ onClick }) => ({ 13: onClick }),
          ({ onClick }) => onClick ? 8192 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[1] && create_if_block$y(ctx);
  return {
    c() {
      create_component(menu.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 4)
        menu_changes.disabled = ctx2[2].readOnly;
      if (dirty & 24591) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$y(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$_($$self, $$props, $$invalidate) {
  let $permissionsModel;
  let $sieve, $$unsubscribe_sieve = noop$1, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(3, $sieve = $$value)), sieve);
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { sieve } = $$props;
  $$subscribe_sieve();
  const user = App.user;
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(2, $permissionsModel = value));
  let showModal = false;
  function changeClient(id2) {
    Msg.start("save", "l_loading");
    sieve.save("client_id", id2, {
      wait: true,
      error() {
        Msg.stop("save", { error: "e_req" });
      },
      success: () => {
        Msg.stop("save");
      }
    });
  }
  const click_handler = () => $$invalidate(1, showModal = true);
  const click_handler_1 = (client) => changeClient(client.id);
  const close_handler = () => $$invalidate(1, showModal = false);
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(0, sieve = $$props2.sieve));
  };
  return [
    sieve,
    showModal,
    $permissionsModel,
    $sieve,
    permissionsModel,
    changeClient,
    click_handler,
    click_handler_1,
    close_handler
  ];
}
class ClientManagerMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$_, create_fragment$11, safe_not_equal, { sieve: 0 });
  }
}
var LogMenu_svelte_svelte_type_style_lang = "";
function get_each_context$l(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_action_slot$1(ctx) {
  let a;
  let small;
  let t0;
  let t1;
  let i2;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      small = element("small");
      t0 = text(ctx[4]);
      t1 = space();
      i2 = element("i");
      attr(i2, "class", "xcaret fa fa-caret-down");
      attr(a, "title", "Click to view check/error log");
      attr(a, "class", "text-decoration-none xtd xdata xaction");
      attr(a, "type", "button");
      attr(a, "data-bs-auto-close", "outside");
      toggle_class(a, "xsieve-err", ctx[1].err);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, small);
      append(small, t0);
      append(a, t1);
      append(a, i2);
      if (!mounted) {
        dispose = listen(a, "click", function() {
          if (is_function(ctx[18]))
            ctx[18].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16)
        set_data(t0, ctx[4]);
      if (dirty & 2) {
        toggle_class(a, "xsieve-err", ctx[1].err);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_top_slot(ctx) {
  let li;
  let span;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      li = element("li");
      span = element("span");
      span.textContent = `${TXT("l_changed_on")}`;
      t1 = space();
      button = element("button");
      attr(span, "class", "dropdown-header py-0 pb-1 ttu");
      attr(button, "class", "btn-close me-2");
      attr(button, "data-bs-dismiss", "modal");
      attr(button, "aria-label", "Close");
      set_style(button, "width", "0.4rem");
      set_style(button, "height", "0.4rem");
      attr(li, "class", "flex justify-content-between gap-2");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span);
      append(li, t1);
      append(li, button);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(function() {
          if (is_function(ctx[17]))
            ctx[17].apply(this, arguments);
        }));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_catch_block$f(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$f(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$m, create_else_block$q];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$q(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[5].models;
  const get_key = (ctx2) => ctx2[14].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$l(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$l(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "scrollable-container svelte-3u0ikz");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen(div, "wheel", hideAllTooltips, { passive: true });
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 544) {
        each_value = ctx2[5].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$l, null, get_each_context$l);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$m(ctx) {
  let div;
  let t_value = TXT(ctx[3]) + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "ps-3 mr-3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = TXT(ctx2[3]) + ""))
        set_data(t, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_else_block_1$a(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      disabled: true,
      href: "#",
      class: "flex flex-col text-black",
      style: "font-size:small;",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 524320) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_if_block_2$h(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      href: ctx[9](ctx[14]),
      target: "_blank",
      rel: "noopener noreferrer",
      class: "link-danger hover:grey",
      style: "font-size: small; cursor: pointer;",
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 32)
        menuitem_changes.href = ctx2[9](ctx2[14]);
      if (dirty & 524320) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let span;
  let t0_value = formatLogTime(ctx[14].get("ts")) + "";
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      attr(span, "class", "ps-1 hover:grey gap-2 ");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t0_value !== (t0_value = formatLogTime(ctx2[14].get("ts")) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let div;
  let span0;
  let t0_value = formatLogTime(ctx[14].get("ts")) + "";
  let t0;
  let t1;
  let span1;
  let t2_value = (ctx[14].get("err").code || "EUNKNOWN") + "";
  let t2;
  let div_title_value;
  let initTooltip_action;
  let t3;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      t3 = space();
      attr(span0, "class", "ps-1 mr-3");
      attr(div, "class", "flex justify-between");
      attr(div, "data-toggle", "tooltip");
      attr(div, "data-placement", "top");
      attr(div, "title", div_title_value = '<div class="text-left">' + (ctx[14].get("err").message || "Unknown Error Occurred.") + '</div><div class="text-left">(click to view error details)</div>');
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(span0, t0);
      append(div, t1);
      append(div, span1);
      append(span1, t2);
      insert(target, t3, anchor);
      if (!mounted) {
        dispose = action_destroyer(initTooltip_action = initTooltip$1.call(null, div, ctx[14]));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 32 && t0_value !== (t0_value = formatLogTime(ctx[14].get("ts")) + ""))
        set_data(t0, t0_value);
      if (dirty & 32 && t2_value !== (t2_value = (ctx[14].get("err").code || "EUNKNOWN") + ""))
        set_data(t2, t2_value);
      if (dirty & 32 && div_title_value !== (div_title_value = '<div class="text-left">' + (ctx[14].get("err").message || "Unknown Error Occurred.") + '</div><div class="text-left">(click to view error details)</div>')) {
        attr(div, "title", div_title_value);
      }
      if (initTooltip_action && is_function(initTooltip_action.update) && dirty & 32)
        initTooltip_action.update.call(null, ctx[14]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t3);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$l(key_1, ctx) {
  let first2;
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$h, create_else_block_1$a];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty & 32)
      show_if = null;
    if (show_if == null)
      show_if = !!ctx2[14].get("err");
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_pending_block$f(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${TXT("l_loading")}`;
      attr(div, "class", "ps-3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot_1$3(ctx) {
  let li;
  let span0;
  let t0_value = (formatLogTime(ctx[1].ts_data) || "N/A") + "";
  let t0;
  let t1;
  let div;
  let span1;
  let t3;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$f,
    then: create_then_block$f,
    catch: create_catch_block$f,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[2], info);
  return {
    c() {
      li = element("li");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      div = element("div");
      span1 = element("span");
      span1.textContent = `${TXT("l_check_log")}`;
      t3 = space();
      info.block.c();
      attr(span0, "class", "ps-3 text-body");
      attr(span1, "class", "dropdown-header ttu pb-1");
      attr(div, "class", "");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span0);
      append(span0, t0);
      append(li, t1);
      append(li, div);
      append(div, span1);
      append(li, t3);
      info.block.m(li, info.anchor = null);
      info.mount = () => li;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 2) && t0_value !== (t0_value = (formatLogTime(ctx[1].ts_data) || "N/A") + ""))
        set_data(t0, t0_value);
      info.ctx = ctx;
      if (dirty & 4 && promise !== (promise = ctx[2]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_if_block$x(ctx) {
  let menuitem;
  let current;
  menuitem = new MenuItem({
    props: {
      $$slots: { default: [create_default_slot$m] },
      $$scope: { ctx }
    }
  });
  menuitem.$on("click", ctx[10]);
  return {
    c() {
      create_component(menuitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menuitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menuitem_changes = {};
      if (dirty & 524288) {
        menuitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menuitem.$set(menuitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menuitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menuitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menuitem, detaching);
    }
  };
}
function create_default_slot$m(ctx) {
  let t_value = TXT("a_clear_error") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_bottom_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1].err && create_if_block$x(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1].err) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$x(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$10(ctx) {
  let menu;
  let current;
  menu = new Menu({
    props: {
      dropDownClass: "dropdown-menu-end",
      placement: "bottom-end",
      toggle: false,
      $$slots: {
        bottom: [create_bottom_slot],
        default: [create_default_slot_1$3],
        top: [
          create_top_slot,
          ({ close }) => ({ 17: close }),
          ({ close }) => close ? 131072 : 0
        ],
        action: [
          create_action_slot$1,
          ({ onClick }) => ({ 18: onClick }),
          ({ onClick }) => onClick ? 262144 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  menu.$on("open", ctx[11]);
  menu.$on("close", ctx[12]);
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const menu_changes = {};
      if (dirty & 917566) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function initTooltip$1(el2, work) {
  const err = work.get("err");
  window.$(el2).tooltip({
    placement: "left",
    html: true,
    container: "body",
    err
  });
}
function hideAllTooltips() {
  window.$('[data-bs-toggle="tooltip"]').tooltip("hide");
}
function instance$Z($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop$1, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(1, $sieve = $$value)), sieve);
  let $works;
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { sieve } = $$props;
  $$subscribe_sieve();
  const works = new Model$2.Works(null, { sieve });
  component_subscribe($$self, works, (value) => $$invalidate(5, $works = value));
  let worksPromise;
  let msg;
  let runState;
  async function fetchWorks() {
    trackEvent(PHEvents.SIEVE_WORKLOG_VIEW, {
      sieve_id: $sieve.id,
      has_error: !!$sieve.err
    });
    await works.fetch();
    if (works.length === 0) {
      if ($sieve.client_id == App.clients.defaultId) {
        $$invalidate(3, msg = "m_log_na");
      } else {
        $$invalidate(3, msg = "Log for this monitor will be available on device that runs this monitor");
      }
    }
  }
  onMount(() => {
    const keyList = `sieves:run_state:${$sieve.id}  sieves:on_demand_run_status:${$sieve.id}`;
    instance$5s.on(keyList, getSieveState);
    return () => instance$5s.off(keyList, getSieveState);
  });
  function getSieveState(e = {}) {
    var _a;
    const state = e.state || ((_a = e.doc) == null ? void 0 : _a.state) || 0;
    if (state == C$1.RUN_STATE_WAIT) {
      $$invalidate(4, runState = "Waiting");
    } else if (state == C$1.RUN_STATE_WIP) {
      $$invalidate(4, runState = "Checking");
    } else {
      $$invalidate(4, runState = formatTime($sieve.ts_data, true) || "" || "NA");
    }
  }
  function clearError() {
    sieve.save("err", null, {
      error() {
        Msg.error("e_err");
      }
    });
  }
  function url(work) {
    if (work.get("err")) {
      const team = get_store_value(params).team;
      let err = work.get("err");
      if ($sieve.crawler_id && err) {
        return `${urlCfg.crawlerJobDetail(team, $sieve.crawler_id, err.jobId || "")}`;
      }
      return `#/checks/${team}/${$sieve.id}?work=${work.get("id")}`;
    } else {
      return "#";
    }
  }
  const click_handler = (e) => {
    e.preventDefault();
    clearError();
  };
  const open_handler = () => $$invalidate(2, worksPromise = fetchWorks());
  const close_handler = () => hideAllTooltips();
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(0, sieve = $$props2.sieve));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      getSieveState();
    }
  };
  return [
    sieve,
    $sieve,
    worksPromise,
    msg,
    runState,
    $works,
    works,
    fetchWorks,
    clearError,
    url,
    click_handler,
    open_handler,
    close_handler
  ];
}
class LogMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Z, create_fragment$10, safe_not_equal, { sieve: 0 });
  }
}
function get_each_context$k(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  return child_ctx;
}
function create_if_block$w(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Deleted";
      attr(span, "class", "badge rounded-pill text-bg-danger");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$k(key_1, ctx) {
  let span;
  let t_value = ctx[13].get("name") + "";
  let t;
  let span_title_value;
  return {
    key: key_1,
    first: null,
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "badge rounded-pill bg-primary mr-1 text-truncate");
      attr(span, "title", span_title_value = ctx[13].get("name"));
      set_style(span, "max-width", "100px");
      this.first = span;
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t_value !== (t_value = ctx[13].get("name") + ""))
        set_data(t, t_value);
      if (dirty & 1 && span_title_value !== (span_title_value = ctx[13].get("name"))) {
        attr(span, "title", span_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$$(ctx) {
  let tr;
  let td0;
  let label;
  let input;
  let input_checked_value;
  let t0;
  let td1;
  let sievecontextmenu;
  let t1;
  let td2;
  let a;
  let img;
  let img_src_value;
  let t2;
  let t3_value = (ctx[1].name || SPRINTF("l_untitled")) + "";
  let t3;
  let a_href_value;
  let a_title_value;
  let t4;
  let td3;
  let div1;
  let div0;
  let t5;
  let span0;
  let t6;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t7;
  let span1;
  let t8_value = (ctx[1].text != null ? ctx[1].text || "<" + SPRINTF("h_sieve_empty") + ">" : "<" + SPRINTF("h_sieve_new") + ">") + "";
  let t8;
  let t9;
  let i2;
  let t10;
  let td4;
  let schedulemenu;
  let td4_class_value;
  let t11;
  let td5;
  let logmenu;
  let t12;
  let td6;
  let clientmenu;
  let t13;
  let td7;
  let button;
  let t14_value = ctx[1].state === C$1.STATE_READY ? "ON " : "OFF";
  let t14;
  let button_class_value;
  let button_disabled_value;
  let current;
  let mounted;
  let dispose;
  sievecontextmenu = new SieveContextMenu({ props: { sieve: ctx[0] } });
  let if_block = (ctx[1].state === C$1.STATE_DISCARD || ctx[1].state === C$1.STATE_DEL) && create_if_block$w();
  let each_value = ctx[0].getTags(App.labels);
  const get_key = (ctx2) => ctx2[13].id;
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    let child_ctx = get_each_context$k(ctx, each_value, i3);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i3] = create_each_block$k(key, child_ctx));
  }
  schedulemenu = new ScheduleMenu({ props: { sieve: ctx[0] } });
  logmenu = new LogMenu({ props: { sieve: ctx[0] } });
  clientmenu = new ClientManagerMenu({ props: { sieve: ctx[0] } });
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      label = element("label");
      input = element("input");
      t0 = space();
      td1 = element("td");
      create_component(sievecontextmenu.$$.fragment);
      t1 = space();
      td2 = element("td");
      a = element("a");
      img = element("img");
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      td3 = element("td");
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t5 = space();
      span0 = element("span");
      t6 = space();
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      t7 = space();
      span1 = element("span");
      t8 = text(t8_value);
      t9 = space();
      i2 = element("i");
      t10 = space();
      td4 = element("td");
      create_component(schedulemenu.$$.fragment);
      t11 = space();
      td5 = element("td");
      create_component(logmenu.$$.fragment);
      t12 = space();
      td6 = element("td");
      create_component(clientmenu.$$.fragment);
      t13 = space();
      td7 = element("td");
      button = element("button");
      t14 = text(t14_value);
      attr(input, "type", "checkbox");
      set_style(input, "margin", "0");
      set_style(input, "vertical-align", "middle");
      input.checked = input_checked_value = ctx[1].selected;
      attr(label, "class", "xtd xdata xaction");
      attr(img, "width", "14");
      attr(img, "loading", "lazy");
      if (!src_url_equal(img.src, img_src_value = URL_ROOT + "/v1/getfavicon?url=" + escape(ctx[4]())))
        attr(img, "src", img_src_value);
      attr(a, "class", "xtd xdata text-decoration-none monitor-link");
      attr(a, "rel", "noopener");
      attr(a, "target", "_blank");
      attr(a, "href", a_href_value = ctx[1].uri);
      attr(a, "title", a_title_value = ctx[1].name);
      attr(td2, "class", "overflow-hidden");
      attr(div0, "class", "overflow-hidden");
      attr(div0, "title", "Click to view history");
      attr(i2, "class", "ms-auto xcaret fa fa-angle-double-down fa-lg align-self-center");
      attr(div1, "class", "d-flex xtd xdata xaction cursor-pointer");
      attr(td3, "class", "");
      attr(td4, "class", td4_class_value = ctx[1].schedule ? ctx[1].schedule.getFrequencyClass() : "error");
      set_style(td6, "padding", "0");
      attr(button, "class", button_class_value = "xtd btn " + (ctx[1].state === C$1.STATE_READY ? "btn-success" : "btn-default") + " btn-sm border-end border-start");
      set_style(button, "border-radius", "0");
      set_style(button, "height", "100%");
      attr(button, "title", "Turn monitor ON or OFF");
      attr(button, "data-placement", "left");
      button.disabled = button_disabled_value = ctx[2].readOnly;
      toggle_class(button, "disabled", ctx[1].state === C$1.STATE_DISCARD);
      set_style(td7, "padding", "0");
      attr(tr, "class", "xitem");
      toggle_class(tr, "xunread", !ctx[0].isRead());
      toggle_class(tr, "xfade", ctx[0].isRead());
      toggle_class(tr, "active", ctx[1].selected);
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, label);
      append(label, input);
      append(tr, t0);
      append(tr, td1);
      mount_component(sievecontextmenu, td1, null);
      append(tr, t1);
      append(tr, td2);
      append(td2, a);
      append(a, img);
      append(a, t2);
      append(a, t3);
      append(tr, t4);
      append(tr, td3);
      append(td3, div1);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div0, t5);
      append(div0, span0);
      append(div0, t6);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(div0, null);
        }
      }
      append(div0, t7);
      append(div0, span1);
      append(span1, t8);
      append(div1, t9);
      append(div1, i2);
      append(tr, t10);
      append(tr, td4);
      mount_component(schedulemenu, td4, null);
      append(tr, t11);
      append(tr, td5);
      mount_component(logmenu, td5, null);
      append(tr, t12);
      append(tr, td6);
      mount_component(clientmenu, td6, null);
      append(tr, t13);
      append(tr, td7);
      append(td7, button);
      append(button, t14);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[9]),
          listen(a, "click", ctx[10]),
          listen(div1, "click", ctx[5]),
          listen(button, "click", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 2 && input_checked_value !== (input_checked_value = ctx2[1].selected)) {
        input.checked = input_checked_value;
      }
      const sievecontextmenu_changes = {};
      if (dirty & 1)
        sievecontextmenu_changes.sieve = ctx2[0];
      sievecontextmenu.$set(sievecontextmenu_changes);
      if ((!current || dirty & 2) && t3_value !== (t3_value = (ctx2[1].name || SPRINTF("l_untitled")) + ""))
        set_data(t3, t3_value);
      if (!current || dirty & 2 && a_href_value !== (a_href_value = ctx2[1].uri)) {
        attr(a, "href", a_href_value);
      }
      if (!current || dirty & 2 && a_title_value !== (a_title_value = ctx2[1].name)) {
        attr(a, "title", a_title_value);
      }
      if (ctx2[1].state === C$1.STATE_DISCARD || ctx2[1].state === C$1.STATE_DEL) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$w();
          if_block.c();
          if_block.m(div0, t5);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 1) {
        each_value = ctx2[0].getTags(App.labels);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, destroy_block, create_each_block$k, t7, get_each_context$k);
      }
      if ((!current || dirty & 2) && t8_value !== (t8_value = (ctx2[1].text != null ? ctx2[1].text || "<" + SPRINTF("h_sieve_empty") + ">" : "<" + SPRINTF("h_sieve_new") + ">") + ""))
        set_data(t8, t8_value);
      const schedulemenu_changes = {};
      if (dirty & 1)
        schedulemenu_changes.sieve = ctx2[0];
      schedulemenu.$set(schedulemenu_changes);
      if (!current || dirty & 2 && td4_class_value !== (td4_class_value = ctx2[1].schedule ? ctx2[1].schedule.getFrequencyClass() : "error")) {
        attr(td4, "class", td4_class_value);
      }
      const logmenu_changes = {};
      if (dirty & 1)
        logmenu_changes.sieve = ctx2[0];
      logmenu.$set(logmenu_changes);
      const clientmenu_changes = {};
      if (dirty & 1)
        clientmenu_changes.sieve = ctx2[0];
      clientmenu.$set(clientmenu_changes);
      if ((!current || dirty & 2) && t14_value !== (t14_value = ctx2[1].state === C$1.STATE_READY ? "ON " : "OFF"))
        set_data(t14, t14_value);
      if (!current || dirty & 2 && button_class_value !== (button_class_value = "xtd btn " + (ctx2[1].state === C$1.STATE_READY ? "btn-success" : "btn-default") + " btn-sm border-end border-start")) {
        attr(button, "class", button_class_value);
      }
      if (!current || dirty & 4 && button_disabled_value !== (button_disabled_value = ctx2[2].readOnly)) {
        button.disabled = button_disabled_value;
      }
      if (!current || dirty & 2) {
        toggle_class(button, "disabled", ctx2[1].state === C$1.STATE_DISCARD);
      }
      if (!current || dirty & 1) {
        toggle_class(tr, "xunread", !ctx2[0].isRead());
      }
      if (!current || dirty & 1) {
        toggle_class(tr, "xfade", ctx2[0].isRead());
      }
      if (!current || dirty & 2) {
        toggle_class(tr, "active", ctx2[1].selected);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sievecontextmenu.$$.fragment, local);
      transition_in(schedulemenu.$$.fragment, local);
      transition_in(logmenu.$$.fragment, local);
      transition_in(clientmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievecontextmenu.$$.fragment, local);
      transition_out(schedulemenu.$$.fragment, local);
      transition_out(logmenu.$$.fragment, local);
      transition_out(clientmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_component(sievecontextmenu);
      if (if_block)
        if_block.d();
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].d();
      }
      destroy_component(schedulemenu);
      destroy_component(logmenu);
      destroy_component(clientmenu);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$Y($$self, $$props, $$invalidate) {
  let $sieve, $$unsubscribe_sieve = noop$1, $$subscribe_sieve = () => ($$unsubscribe_sieve(), $$unsubscribe_sieve = subscribe(sieve, ($$value) => $$invalidate(1, $sieve = $$value)), sieve);
  let $route;
  let $permissionsModel;
  component_subscribe($$self, route, ($$value) => $$invalidate(8, $route = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_sieve());
  let { sieve } = $$props;
  $$subscribe_sieve();
  const user = App.user;
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(2, $permissionsModel = value));
  let expanded = false;
  onMount(() => {
    const evt = `sieves:${sieve.id}`;
    instance$5s.on(evt, onSieveUpdate);
    return () => instance$5s.off(evt, onSieveUpdate);
  });
  function getHost() {
    let url = $sieve.uri;
    let host = "";
    try {
      host = "//" + new URL(url).host;
    } catch (e) {
    }
    return host;
  }
  function toggleExpanded() {
    let path = getBasePath();
    if ($route.id !== $sieve.id) {
      path += `${sieve.id}.id`;
    }
    let queryStr = qs.stringify($route.query);
    if (queryStr.length > 0) {
      path += `?${queryStr}`;
    }
    push$1(path);
  }
  function toggleSieve() {
    const toggledState = $sieve.state == C$1.STATE_READY ? C$1.STATE_PAUSED : C$1.STATE_READY;
    Msg.start("sieve:save", { info: "l_saving" });
    sieve.save(null, {
      data: { state: toggledState },
      patch: true,
      err(err, res) {
        Msg.stop("sieve:save", { error: "e_req" });
      },
      success() {
        Msg.stop("sieve:save");
        sieve.set("state", toggledState);
        trackEvent(PHEvents.SIEVE_STATE, { sieve_id: sieve.id, state: toggledState });
      }
    });
  }
  function onSieveUpdate(e) {
    if (e.doc) {
      sieve.set(sieve.parse(e.doc), { silent: true });
      sieve.trigger("change");
    } else {
      sieve.fetch();
    }
  }
  const change_handler = (e) => sieve.set("selected", e.target.checked);
  const click_handler = () => sieve.markRead();
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$subscribe_sieve($$invalidate(0, sieve = $$props2.sieve));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 385) {
      {
        let _expanded = $route.id === sieve.id;
        if (expanded !== _expanded) {
          $$invalidate(7, expanded = _expanded);
          sieve.set("selected", expanded);
        }
      }
    }
  };
  return [
    sieve,
    $sieve,
    $permissionsModel,
    permissionsModel,
    getHost,
    toggleExpanded,
    toggleSieve,
    expanded,
    $route,
    change_handler,
    click_handler
  ];
}
class SieveRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Y, create_fragment$$, safe_not_equal, { sieve: 0 });
  }
}
function create_fragment$_(ctx) {
  let div;
  let button0;
  let t0_value = TXT("Show More") + "";
  let t0;
  let button0_disabled_value;
  let t1;
  let button1;
  let t2_value = TXT("a_edit_options") + "";
  let t2;
  let button1_disabled_value;
  let t3;
  let button2;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      t3 = space();
      button2 = element("button");
      button2.textContent = `${TXT("Close")}`;
      attr(button0, "class", "btn btn-default");
      button0.disabled = button0_disabled_value = ctx[0] || ctx[1];
      attr(button1, "class", "btn btn-default ml-1");
      button1.disabled = button1_disabled_value = ctx[2].readOnly;
      attr(button2, "class", "btn btn-default ml-1");
      attr(div, "class", "form-actions flex align-item justify-center pa3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      append(button1, t2);
      append(div, t3);
      append(div, button2);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[9]),
          listen(button1, "click", ctx[6]),
          listen(button2, "click", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 3 && button0_disabled_value !== (button0_disabled_value = ctx2[0] || ctx2[1])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & 4 && button1_disabled_value !== (button1_disabled_value = ctx2[2].readOnly)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$X($$self, $$props, $$invalidate) {
  let $route;
  let $params;
  let $permissionsModel;
  component_subscribe($$self, route, ($$value) => $$invalidate(12, $route = $$value));
  component_subscribe($$self, params, ($$value) => $$invalidate(8, $params = $$value));
  const dispatch = createEventDispatcher();
  let { sieve } = $$props;
  let { disableShowMore = false } = $$props;
  let { loading: loading2 = false } = $$props;
  const user = App.user;
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(2, $permissionsModel = value));
  let { module, team } = $params;
  function showListView() {
    let path = getBasePath();
    let queryStr = qs.stringify($route.query);
    if (queryStr.length > 0) {
      path += `?${queryStr}`;
    }
    push$1(path);
  }
  function onClose() {
    if (module === "list") {
      showListView();
    } else {
      push$1(`/w/${team}/list/all/`);
    }
  }
  function editSieve() {
    push$1(`/w/${team}/sieve/edit/${sieve.id}.id`);
  }
  const click_handler = () => dispatch("showMore");
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$invalidate(7, sieve = $$props2.sieve);
    if ("disableShowMore" in $$props2)
      $$invalidate(0, disableShowMore = $$props2.disableShowMore);
    if ("loading" in $$props2)
      $$invalidate(1, loading2 = $$props2.loading);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      if ($params) {
        module = $params.module;
        team = $params.team;
      }
    }
  };
  return [
    disableShowMore,
    loading2,
    $permissionsModel,
    dispatch,
    permissionsModel,
    onClose,
    editSieve,
    sieve,
    $params,
    click_handler
  ];
}
class SieveToolbar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$X, create_fragment$_, safe_not_equal, { sieve: 7, disableShowMore: 0, loading: 1 });
  }
}
function get_each_context$j(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  child_ctx[19] = i2;
  return child_ctx;
}
function create_if_block_4$9(ctx) {
  let loader;
  let current;
  loader = new Loader({ props: { class: "absolute mt-[-2px]" } });
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_catch_block$e(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$e(ctx) {
  let t;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let if_block = ctx[2] && create_if_block_3$e();
  let each_value = ctx[1];
  const get_key = (ctx2) => ctx2[17].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$j(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$j(key, child_ctx));
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$e();
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 27) {
        each_value = ctx2[1];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$j, each_1_anchor, get_each_context$j);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_3$e(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${TXT("m_history_empty")}`;
      attr(div, "class", "xinfo");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$g(ctx) {
  let sievedata;
  let current;
  sievedata = new SieveData({
    props: {
      data: ctx[1][ctx[19]],
      oldData: ctx[1][ctx[19]],
      sieve: ctx[0]
    }
  });
  sievedata.$on("load", ctx[11]);
  return {
    c() {
      create_component(sievedata.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sievedata, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sievedata_changes = {};
      if (dirty & 2)
        sievedata_changes.data = ctx2[1][ctx2[19]];
      if (dirty & 2)
        sievedata_changes.oldData = ctx2[1][ctx2[19]];
      if (dirty & 1)
        sievedata_changes.sieve = ctx2[0];
      sievedata.$set(sievedata_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sievedata.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievedata.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sievedata, detaching);
    }
  };
}
function create_if_block_1$l(ctx) {
  let sievedata;
  let current;
  sievedata = new SieveData({
    props: {
      data: ctx[1][ctx[19]],
      oldData: ctx[1][ctx[19] + 1],
      sieve: ctx[0]
    }
  });
  sievedata.$on("load", ctx[10]);
  return {
    c() {
      create_component(sievedata.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sievedata, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sievedata_changes = {};
      if (dirty & 2)
        sievedata_changes.data = ctx2[1][ctx2[19]];
      if (dirty & 2)
        sievedata_changes.oldData = ctx2[1][ctx2[19] + 1];
      if (dirty & 1)
        sievedata_changes.sieve = ctx2[0];
      sievedata.$set(sievedata_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sievedata.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievedata.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sievedata, detaching);
    }
  };
}
function create_each_block$j(key_1, ctx) {
  let first2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$l, create_if_block_2$g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[19] !== ctx2[1].length - 1)
      return 0;
    if (ctx2[19] === ctx2[3] - 1)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_pending_block$e(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_if_block$v(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[5]);
      attr(div, "class", "xmsg centered");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$Z(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let sievetoolbar;
  let current;
  let if_block0 = ctx[4] && !ctx[2] && create_if_block_4$9();
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$e,
    then: create_then_block$e,
    catch: create_catch_block$e,
    value: 16,
    blocks: [, , ,]
  };
  handle_promise(ctx[7](), info);
  let if_block1 = ctx[5] && create_if_block$v(ctx);
  sievetoolbar = new SieveToolbar({
    props: {
      sieve: ctx[0],
      disableShowMore: ctx[3] === 0 || ctx[1].length === ctx[3],
      loading: ctx[4]
    }
  });
  sievetoolbar.$on("showMore", ctx[7]);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      info.block.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      create_component(sievetoolbar.$$.fragment);
      attr(div, "class", "flex flex-column");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t1;
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t2);
      mount_component(sievetoolbar, div, null);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (ctx[4] && !ctx[2]) {
        if (if_block0) {
          if (dirty & 20) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$9();
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      update_await_block_branch(info, ctx, dirty);
      if (ctx[5]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block$v(ctx);
          if_block1.c();
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      const sievetoolbar_changes = {};
      if (dirty & 1)
        sievetoolbar_changes.sieve = ctx[0];
      if (dirty & 10)
        sievetoolbar_changes.disableShowMore = ctx[3] === 0 || ctx[1].length === ctx[3];
      if (dirty & 16)
        sievetoolbar_changes.loading = ctx[4];
      sievetoolbar.$set(sievetoolbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(info.block);
      transition_in(sievetoolbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      transition_out(sievetoolbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      info.block.d();
      info.token = null;
      info = null;
      if (if_block1)
        if_block1.d();
      destroy_component(sievetoolbar);
    }
  };
}
function instance$W($$self, $$props, $$invalidate) {
  let $permissionsModel;
  let { sieve } = $$props;
  let { route: route2 } = $$props;
  let { initialFetchCount = 3 } = $$props;
  let data = [];
  let historyEmpty = false;
  let totalCount;
  let loading2;
  let lastTs;
  let msg;
  const user = getContext("user");
  const { permissionsModel } = user;
  component_subscribe($$self, permissionsModel, (value) => $$invalidate(13, $permissionsModel = value));
  onMount(() => {
    if (!sieve.isRead() && !$permissionsModel.readOnly) {
      sieve.markRead();
    }
    sieve.on("change:ts_data", updateView);
    return () => {
      sieve.off("change:ts_data", updateView);
    };
  });
  function updateView() {
    $$invalidate(5, msg = "Updated. Reloading now...");
    setTimeout(
      () => {
        fetch2({ reset: true });
      },
      200
    );
  }
  async function fetch2({ reset = false } = {}) {
    const init2 = !lastTs || reset;
    const limit = init2 ? initialFetchCount || 2 : 2;
    const query = { _opt: { limit } };
    if (!init2) {
      query["ts.lt"] = lastTs;
    }
    Msg.start("sieve:data:fetch", { info: "l_loading" });
    try {
      $$invalidate(4, loading2 = true);
      let res = await Api.api(`/sieves/${sieve.id}/data`, "GET", query);
      const newData = res.data;
      Msg.stop("sieve:data:fetch");
      if (init2) {
        if (res.count == 0) {
          $$invalidate(2, historyEmpty = true);
          return;
        }
        $$invalidate(3, totalCount = res.total_count);
      }
      lastTs = newData[newData.length - 1].ts;
      if (init2) {
        $$invalidate(1, data = []);
      }
      $$invalidate(1, data = data.concat(newData));
    } catch (err) {
      Msg.stop("sieve:data:fetch", { error: "err:sieve:data:fetch" });
    } finally {
      trackEvent(PHEvents.SIEVE_DATA_FETCH, { sieve_id: sieve.id, count: data.length });
    }
    $$invalidate(5, msg = null);
  }
  const load_handler = () => $$invalidate(4, loading2 = false);
  const load_handler_1 = () => $$invalidate(4, loading2 = false);
  $$self.$$set = ($$props2) => {
    if ("sieve" in $$props2)
      $$invalidate(0, sieve = $$props2.sieve);
    if ("route" in $$props2)
      $$invalidate(8, route2 = $$props2.route);
    if ("initialFetchCount" in $$props2)
      $$invalidate(9, initialFetchCount = $$props2.initialFetchCount);
  };
  return [
    sieve,
    data,
    historyEmpty,
    totalCount,
    loading2,
    msg,
    permissionsModel,
    fetch2,
    route2,
    initialFetchCount,
    load_handler,
    load_handler_1
  ];
}
class SieveDataList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$W, create_fragment$Z, safe_not_equal, { sieve: 0, route: 8, initialFetchCount: 9 });
  }
}
function get_each_context$i(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function create_catch_block$d(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$d(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$u, create_else_block$p];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    var _a;
    if ((_a = ctx2[3].models) == null ? void 0 : _a.length)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$p(ctx) {
  let h4;
  return {
    c() {
      h4 = element("h4");
      h4.textContent = "No monitor found.";
    },
    m(target, anchor) {
      insert(target, h4, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(h4);
    }
  };
}
function create_if_block$u(ctx) {
  let table;
  let colgroup;
  let t7;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let initTooltip_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[3].models;
  const get_key = (ctx2) => ctx2[16].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$i(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$i(key, child_ctx));
  }
  return {
    c() {
      table = element("table");
      colgroup = element("colgroup");
      colgroup.innerHTML = `<col style="width:28px"/> 
          <col style="width:28px"/> 
          <col class="w-[152px] lg:w-[304px]" style="padding: 0 10px;"/> 
          <col style="min-width: 100px;"/> 
          <col style="width:72px; padding: 0 10px;"/> 
          <col style="width:72px"/> 
          <col style="width:42px"/> 
          <col style="width:40px"/>`;
      t7 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(table, "class", "xlist xlist-shadow");
      attr(table, "cellpadding", "0");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, colgroup);
      append(table, t7);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(initTooltip_action = initTooltip.call(null, table, ctx[3]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 12) {
        each_value = ctx2[3].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$i, null, get_each_context$i);
        check_outros();
      }
      if (initTooltip_action && is_function(initTooltip_action.update) && dirty & 8)
        initTooltip_action.update.call(null, ctx2[3]);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(table);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$k(ctx) {
  let tr;
  let td;
  let sievedatalist;
  let t;
  let current;
  sievedatalist = new SieveDataList({ props: { sieve: ctx[16] } });
  return {
    c() {
      tr = element("tr");
      td = element("td");
      create_component(sievedatalist.$$.fragment);
      t = space();
      attr(td, "colspan", 8);
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      mount_component(sievedatalist, td, null);
      append(tr, t);
      current = true;
    },
    p(ctx2, dirty) {
      const sievedatalist_changes = {};
      if (dirty & 8)
        sievedatalist_changes.sieve = ctx2[16];
      sievedatalist.$set(sievedatalist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sievedatalist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievedatalist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_component(sievedatalist);
    }
  };
}
function create_each_block$i(key_1, ctx) {
  let first2;
  let sieverow;
  let t;
  let if_block_anchor;
  let current;
  sieverow = new SieveRow({ props: { sieve: ctx[16] } });
  let if_block = ctx[2].module === "list" && ctx[2].id === ctx[16].id && create_if_block_1$k(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(sieverow.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(sieverow, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const sieverow_changes = {};
      if (dirty & 8)
        sieverow_changes.sieve = ctx[16];
      sieverow.$set(sieverow_changes);
      if (ctx[2].module === "list" && ctx[2].id === ctx[16].id) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 12) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$k(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(sieverow.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(sieverow.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(sieverow, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_pending_block$d(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_fragment$Y(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$d,
    then: create_then_block$d,
    catch: create_catch_block$d,
    value: 15,
    blocks: [, , ,]
  };
  handle_promise(ctx[4](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "pb-[75px] flex-1");
      toggle_class(div, "d-none", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      if (!current || dirty & 1) {
        toggle_class(div, "d-none", ctx[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function initTooltip(node, sieves) {
  return {
    update(sieves2) {
      window.$('[data-toggle="tooltip"]').tooltip({ delay: { show: 400 } });
    }
  };
}
function instance$V($$self, $$props, $$invalidate) {
  let $route;
  let $sieves;
  component_subscribe($$self, route, ($$value) => $$invalidate(2, $route = $$value));
  let { hidden = false } = $$props;
  let { sieves } = getContext("watchlist:stores");
  component_subscribe($$self, sieves, (value) => $$invalidate(3, $sieves = value));
  let oldRoute;
  const errorUnreadModel = new Backbone.Model();
  onMount(() => {
    const keyList = "change:ui.list.sortby change:ui.list.pagesize change:ui.list.clientfilter";
    App.store.on(keyList, resetAndShow);
    instance$5s.on("sieves", onSieveUpdate);
    instance$5s.on("user_states", onUserStateChange);
    const unsubscribe = route.subscribe(show);
    return () => {
      App.store.off(keyList, resetAndShow);
      instance$5s.off("sieves", onSieveUpdate);
      instance$5s.off("user_states", onUserStateChange);
      unsubscribe();
    };
  });
  function onUserStateChange(data) {
    const oldError = errorUnreadModel.get("error");
    const oldUnread = errorUnreadModel.get("unread");
    const { error: error2, unread, sync } = data;
    errorUnreadModel.set(data);
    let { currentPage } = sieves.info();
    if (oldError < error2 && $route.prefix == "error" && currentPage == 0) {
      recentFetchAndShow();
    }
    if (oldUnread < unread && $route.prefix == "unread" && currentPage == 0) {
      recentFetchAndShow();
    }
  }
  function recentFetchAndShow(id2) {
    const tsModMax = sieves.length > 0 ? sieves.max((model) => new Date(model.get("ts_mod")).valueOf()).get("ts_mod") : new Date(0).toISOString();
    const tCollection = new Model$2.Sieves();
    Msg.start("fetch", { info: "l_loading" });
    tCollection.fetch({
      data: _.extend({ "ts_mod.gt": tsModMax }, getQuery($route)),
      success: () => {
        Msg.stop("fetch");
        sieves.add(tCollection["models"], { merge: true, at: 0 });
      }
    });
  }
  function onSieveUpdate({ op, id: id2 }) {
    if (op == "I") {
      if (!sieves.get(id2)) {
        onSieveInsert();
      }
    }
  }
  function onSieveInsert() {
    reload();
  }
  function reload(resetCurrentPage) {
    if (resetCurrentPage && $route.query.page > 1) {
      push$1(getBasePath());
    } else {
      fetchAndShow($route, { force: true });
    }
  }
  function getSortField() {
    const field = App.store.get("ui.list.sortby") || "-ts_data";
    $$invalidate(1, sieves.sortField = field, sieves);
    if (field == "name" && Supports.agents.local) {
      return "name nocase";
    }
    return field;
  }
  async function show() {
    await fetchAndShow($route);
  }
  async function resetAndShow() {
    await fetchAndShow($route, { force: true, resetPage: true });
  }
  async function fetchAndShow(route2, { force = false, resetPage = false } = {}) {
    if (route2.module !== "list" && !force) {
      return;
    }
    const limit = App.store.get("ui.list.pagesize") || 50;
    let routeKeys = ["team", "prefix", "data", "query"];
    let reloadList = force || !oldRoute || routeKeys.filter((key) => !_.isEqual(route2[key], oldRoute[key])).length > 0;
    oldRoute = { ...route2 };
    if (reloadList) {
      Msg.start("fetch", { info: "l_loading" });
      $$invalidate(1, sieves.limit = limit, sieves);
      let currentPage = resetPage ? 0 : parseInt(route2.query.page || "1") - 1;
      sieves.setOpt({ order: [getSortField()], limit, a: "a" });
      sieves.setQuery(getQuery(route2));
      try {
        await sieves.goto(currentPage, {
          sort: false,
          success: (collection, resp, options) => {
            _.each(options.previousModels, function(model) {
              model.trigger("remove");
            });
          }
        });
      } catch (error2) {
        console.error("Error caught in promise sieves.goto:", error2);
      }
      Msg.stop("fetch");
    }
  }
  $$self.$$set = ($$props2) => {
    if ("hidden" in $$props2)
      $$invalidate(0, hidden = $$props2.hidden);
  };
  return [hidden, sieves, $route, $sieves, show];
}
class List$6 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$V, create_fragment$Y, safe_not_equal, { hidden: 0 });
  }
}
function create_fragment$X(ctx) {
  let div0;
  let button0;
  let t1;
  let button1;
  let t3;
  let div1;
  let paramsview;
  let t4;
  let bbxtreeview;
  let current;
  let mounted;
  let dispose;
  paramsview = new Params$1({ props: { params: ctx[3] } });
  bbxtreeview = new TreeView({ props: { tree: ctx[0] } });
  return {
    c() {
      div0 = element("div");
      button0 = element("button");
      button0.textContent = "Save";
      t1 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      t3 = space();
      div1 = element("div");
      create_component(paramsview.$$.fragment);
      t4 = space();
      create_component(bbxtreeview.$$.fragment);
      attr(div0, "class", "flex gap-2 ml-2");
      attr(div1, "class", "w-4/5");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, button0);
      append(div0, t1);
      append(div0, button1);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      mount_component(paramsview, div1, null);
      append(div1, t4);
      mount_component(bbxtreeview, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[4]),
          listen(button1, "click", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const bbxtreeview_changes = {};
      if (dirty & 1)
        bbxtreeview_changes.tree = ctx2[0];
      bbxtreeview.$set(bbxtreeview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(paramsview.$$.fragment, local);
      transition_in(bbxtreeview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(paramsview.$$.fragment, local);
      transition_out(bbxtreeview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      destroy_component(paramsview);
      destroy_component(bbxtreeview);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$U($$self, $$props, $$invalidate) {
  let { tree } = $$props;
  let { onSave } = $$props;
  let { onCancel } = $$props;
  setContext("expressionCtx", {
    replace: {
      skipControl: false,
      stepNames: Object.keys(stepDefs),
      defaultExprs: {
        and: ["and", ["element_exists"]],
        or: ["or", ["element_exists"]],
        not: ["not", ["element_exists"]],
        "if..else": ["cond", [["or", ["and", ["element_exists"]]]]]
      }
    }
  });
  let params2 = new Params$2(tree.declarations);
  const click_handler = () => onSave(tree, params2);
  const click_handler_1 = () => onCancel();
  $$self.$$set = ($$props2) => {
    if ("tree" in $$props2)
      $$invalidate(0, tree = $$props2.tree);
    if ("onSave" in $$props2)
      $$invalidate(1, onSave = $$props2.onSave);
    if ("onCancel" in $$props2)
      $$invalidate(2, onCancel = $$props2.onCancel);
  };
  return [tree, onSave, onCancel, params2, click_handler, click_handler_1];
}
class Expression extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$U, create_fragment$X, safe_not_equal, { tree: 0, onSave: 1, onCancel: 2 });
  }
}
function create_else_block_1$9(ctx) {
  let div0;
  let t0_value = ctx[9].name + "";
  let t0;
  let t1;
  let div1;
  let t2_value = (ctx[9].meta.url || "") + "";
  let t2;
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      attr(div0, "class", "truncate");
      attr(div1, "class", "truncate");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 512 && t0_value !== (t0_value = ctx2[9].name + ""))
        set_data(t0, t0_value);
      if (dirty & 512 && t2_value !== (t2_value = (ctx2[9].meta.url || "") + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block_3$d(ctx) {
  let div;
  let input0;
  let t0;
  let input1;
  let t1;
  let button0;
  let t3;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      button0 = element("button");
      button0.textContent = "Save";
      t3 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(input0, "type", "text");
      attr(input0, "class", "w-1/3");
      attr(input0, "placeholder", "Macro Name");
      attr(input1, "type", "text");
      attr(input1, "class", "w-1/3");
      attr(input1, "placeholder", "Start URL");
      attr(div, "class", "flex gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input0);
      set_input_value(input0, ctx[7]);
      append(div, t0);
      append(div, input1);
      set_input_value(input1, ctx[8]);
      append(div, t1);
      append(div, button0);
      append(div, t3);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[21]),
          listen(input1, "input", ctx[22]),
          listen(button0, "click", ctx[18]),
          listen(button1, "click", ctx[17])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 128 && input0.value !== ctx2[7]) {
        set_input_value(input0, ctx2[7]);
      }
      if (dirty & 256 && input1.value !== ctx2[8]) {
        set_input_value(input1, ctx2[8]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$f(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fa fa-pencil"></i>`;
      attr(button, "class", "btn btn-default btn-sm");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[16]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$o(ctx) {
  let t0;
  let a;
  let t1_value = ctx[9].steps.length + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  let if_block = ctx[4] && create_if_block_1$j();
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      a = element("a");
      t1 = text(t1_value);
      t2 = text(" steps");
      attr(a, "href", "#");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, a, anchor);
      append(a, t1);
      append(a, t2);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(ctx[14]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[4]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$j();
          if_block.c();
          if_block.m(t0.parentNode, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 512 && t1_value !== (t1_value = ctx2[9].steps.length + ""))
        set_data(t1, t1_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$t(ctx) {
  let div;
  let expression;
  let current;
  expression = new Expression({
    props: {
      tree: ctx[10],
      onSave: ctx[11],
      onCancel: ctx[12]
    }
  });
  return {
    c() {
      div = element("div");
      create_component(expression.$$.fragment);
      attr(div, "class", "w-full");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(expression, div, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(expression.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(expression.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(expression);
    }
  };
}
function create_if_block_1$j(ctx) {
  let t;
  return {
    c() {
      t = text("Saving...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$l(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-trash-o error");
      set_style(i2, "font-size", "1.5em");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_fragment$W(ctx) {
  let tr;
  let td0;
  let div1;
  let div0;
  let t0;
  let t1;
  let td1;
  let div2;
  let current_block_type_index;
  let if_block2;
  let t2;
  let td2;
  let div3;
  let button0;
  let t4;
  let button1;
  let t6;
  let button2;
  let t8;
  let td3;
  let div4;
  let confirmbtn;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[6])
      return create_if_block_3$d;
    return create_else_block_1$9;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[5] && !ctx[6] && create_if_block_2$f(ctx);
  const if_block_creators = [create_if_block$t, create_else_block$o];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  confirmbtn = new ConfirmBtn({
    props: {
      alignRight: "1",
      $$slots: { default: [create_default_slot$l] },
      $$scope: { ctx }
    }
  });
  confirmbtn.$on("click", ctx[27]);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      td1 = element("td");
      div2 = element("div");
      if_block2.c();
      t2 = space();
      td2 = element("td");
      div3 = element("div");
      button0 = element("button");
      button0.textContent = "Open Recorder";
      t4 = space();
      button1 = element("button");
      button1.textContent = "View Monitors";
      t6 = space();
      button2 = element("button");
      button2.textContent = "Export Macro";
      t8 = space();
      td3 = element("td");
      div4 = element("div");
      create_component(confirmbtn.$$.fragment);
      attr(div0, "class", "w-11/12 mr-2");
      attr(div1, "class", "flex items-center flex-wrap");
      set_style(div1, "min-height", "3em");
      attr(div2, "class", "flex items-center flex-wrap");
      set_style(div2, "min-height", "3em");
      attr(button0, "class", "btn btn-default btn-sm");
      attr(button1, "class", "btn btn-default btn-sm");
      attr(button2, "class", "btn btn-default btn-sm");
      attr(div3, "class", "flex items-center flex-wrap gap-1");
      set_style(div3, "min-height", "3em");
      attr(div4, "class", "flex items-center flex-wrap gap-1");
      set_style(div4, "min-height", "3em");
      attr(td3, "title", "Delete");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, div1);
      append(div1, div0);
      if_block0.m(div0, null);
      append(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append(tr, t1);
      append(tr, td1);
      append(td1, div2);
      if_blocks[current_block_type_index].m(div2, null);
      append(tr, t2);
      append(tr, td2);
      append(td2, div3);
      append(div3, button0);
      append(div3, t4);
      append(div3, button1);
      append(div3, t6);
      append(div3, button2);
      append(tr, t8);
      append(tr, td3);
      append(td3, div4);
      mount_component(confirmbtn, div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div1, "mouseenter", ctx[23]),
          listen(div1, "mouseleave", ctx[24]),
          listen(button0, "click", ctx[13]),
          listen(button1, "click", ctx[25]),
          listen(button2, "click", ctx[26])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if (ctx2[5] && !ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$f(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div2, null);
      }
      const confirmbtn_changes = {};
      if (dirty & 1073741824) {
        confirmbtn_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn.$set(confirmbtn_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      transition_in(confirmbtn.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      transition_out(confirmbtn.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if_blocks[current_block_type_index].d();
      destroy_component(confirmbtn);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$T($$self, $$props, $$invalidate) {
  var _a;
  let $macro, $$unsubscribe_macro = noop$1, $$subscribe_macro = () => ($$unsubscribe_macro(), $$unsubscribe_macro = subscribe(macro, ($$value) => $$invalidate(9, $macro = $$value)), macro);
  $$self.$$.on_destroy.push(() => $$unsubscribe_macro());
  let { macro } = $$props;
  $$subscribe_macro();
  let { onSaveSteps: onSaveSteps2 } = $$props;
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let { onDelete } = $$props;
  let expanded = false;
  let saving = false;
  let msgTimeout = null;
  let expressionTree = parseSteps$3($macro.steps, { declarations: (_a = $macro.spec) == null ? void 0 : _a.params });
  async function onSave(tree, declarations) {
    $$invalidate(4, saving = true);
    try {
      await macro.save({
        steps: tree.toJSON(),
        spec: { params: declarations.toJSON() }
      });
      $$invalidate(3, expanded = false);
    } catch (e) {
      console.error("Unable to serialize the expressions tree.\n", e);
      Msg.error("Cannot save steps with errors. Please resolve");
      setTimeout(() => Msg.reset(), 3e3);
    }
    $$invalidate(4, saving = false);
  }
  function onCancel() {
    $$invalidate(3, expanded = false);
  }
  function openRecorder() {
    if ($macro.version > VERSION$1) {
      showMacroVersionError();
      return;
    }
    onCancel();
    openBrowser(macro);
  }
  function expandMacro() {
    if ($macro.version > VERSION$1) {
      showMacroVersionError();
      return;
    }
    $$invalidate(3, expanded = true);
  }
  function showMacroVersionError() {
    clearTimeout(msgTimeout);
    Msg.error("This macro was created with a newer version of the recorder. Please update the app to the latest version to use this macro.");
    msgTimeout = setTimeout(() => Msg.reset(), 5e3);
  }
  function exportMacro() {
    let exportFields = ["meta", "name", "spec", "steps", "version"];
    let macroJSON = {
      ...macro.attributes,
      version: VERSION$1
    };
    downloadBlob(
      JSON.stringify({
        macros: [_.pick(macroJSON, ...exportFields)]
      }),
      macro.attributes.name + "-" + macro.attributes.id + ".json"
    );
  }
  let showEditIcon = false;
  let editNameURL = false;
  let newName = $macro.name;
  let newURL = $macro.meta.url;
  function onEditNameURL() {
    $$invalidate(6, editNameURL = true);
  }
  function onCancelEditNameURL() {
    $$invalidate(6, editNameURL = false);
    $$invalidate(7, newName = $macro.name);
    $$invalidate(8, newURL = $macro.meta.url);
  }
  async function saveNameURL() {
    $$invalidate(6, editNameURL = false);
    await macro.save({
      name: newName,
      meta: { ...$macro.meta, url: newURL }
    });
  }
  function input0_input_handler() {
    newName = this.value;
    $$invalidate(7, newName);
  }
  function input1_input_handler() {
    newURL = this.value;
    $$invalidate(8, newURL);
  }
  const mouseenter_handler = () => $$invalidate(5, showEditIcon = true);
  const mouseleave_handler = () => $$invalidate(5, showEditIcon = false);
  const click_handler = (e) => showMonitors($macro);
  const click_handler_1 = () => exportMacro();
  const click_handler_2 = (e) => onDelete(macro);
  $$self.$$set = ($$props2) => {
    if ("macro" in $$props2)
      $$subscribe_macro($$invalidate(0, macro = $$props2.macro));
    if ("onSaveSteps" in $$props2)
      $$invalidate(19, onSaveSteps2 = $$props2.onSaveSteps);
    if ("openBrowser" in $$props2)
      $$invalidate(20, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(1, showMonitors = $$props2.showMonitors);
    if ("onDelete" in $$props2)
      $$invalidate(2, onDelete = $$props2.onDelete);
  };
  return [
    macro,
    showMonitors,
    onDelete,
    expanded,
    saving,
    showEditIcon,
    editNameURL,
    newName,
    newURL,
    $macro,
    expressionTree,
    onSave,
    onCancel,
    openRecorder,
    expandMacro,
    exportMacro,
    onEditNameURL,
    onCancelEditNameURL,
    saveNameURL,
    onSaveSteps2,
    openBrowser,
    input0_input_handler,
    input1_input_handler,
    mouseenter_handler,
    mouseleave_handler,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class Macro extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$T, create_fragment$W, safe_not_equal, {
      macro: 0,
      onSaveSteps: 19,
      openBrowser: 20,
      showMonitors: 1,
      onDelete: 2
    });
  }
}
function get_each_context$h(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[13] = i2;
  return child_ctx;
}
function create_else_block$n(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No macro found.
        </td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block$h(key_1, ctx) {
  let first2;
  let macro;
  let current;
  macro = new Macro({
    props: {
      macro: ctx[11],
      onSaveSteps,
      openBrowser: ctx[1],
      showMonitors: ctx[2],
      onDelete: ctx[0]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(macro.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(macro, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const macro_changes = {};
      if (dirty & 16)
        macro_changes.macro = ctx[11];
      if (dirty & 2)
        macro_changes.openBrowser = ctx[1];
      if (dirty & 4)
        macro_changes.showMonitors = ctx[2];
      if (dirty & 1)
        macro_changes.onDelete = ctx[0];
      macro.$set(macro_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(macro.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(macro.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(macro, detaching);
    }
  };
}
function create_fragment$V(ctx) {
  let div3;
  let div2;
  let div0;
  let h3;
  let t1;
  let small;
  let t2;
  let a;
  let t3;
  let t4;
  let div1;
  let t5;
  let searchbar;
  let t6;
  let listpager;
  let t7;
  let sortby;
  let t8;
  let table;
  let colgroup;
  let t12;
  let tbody;
  let tr0;
  let td;
  let t13;
  let tr1;
  let t20;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[6]);
  listpager = new ListPager({ props: { store: ctx[3] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[7],
      sortingFields: ctx[5],
      currentFieldName: ctx[4].orderBy
    }
  });
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let each_value = ctx[4].models;
  const get_key = (ctx2) => ctx2[11].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$h(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$h(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$n();
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = "Macros (beta)";
      t1 = space();
      small = element("small");
      t2 = text("Create and use macros to perform automated actions.\n      ");
      a = element("a");
      t3 = text("Learn More");
      t4 = space();
      div1 = element("div");
      t5 = space();
      create_component(searchbar.$$.fragment);
      t6 = space();
      create_component(listpager.$$.fragment);
      t7 = space();
      create_component(sortby.$$.fragment);
      t8 = space();
      table = element("table");
      colgroup = element("colgroup");
      colgroup.innerHTML = `<col style="width: 30%"/> 
      <col style="width: 40%"/> 
      <col style="width: 20%"/> 
      <col style="width: 10%"/>`;
      t12 = space();
      tbody = element("tbody");
      tr0 = element("tr");
      td = element("td");
      if (default_slot)
        default_slot.c();
      t13 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<th>Name</th> 
        <th>Recorded Steps</th> 
        <th>Actions</th> 
        <th></th>`;
      t20 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      attr(a, "href", window.URL_WEBSITE + "/docs/web-monitor/macro-to-record-replay-actions");
      attr(a, "target", "_blank");
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      attr(div2, "class", "card-header flex items-center");
      attr(td, "colspan", "4");
      set_style(td, "background-color", "#eee");
      attr(tr1, "class", "bg-gray-200");
      attr(table, "class", "table table-fixed");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h3);
      append(div0, t1);
      append(div0, small);
      append(small, t2);
      append(small, a);
      append(a, t3);
      append(div2, t4);
      append(div2, div1);
      append(div2, t5);
      mount_component(searchbar, div2, null);
      append(div2, t6);
      mount_component(listpager, div2, null);
      append(div2, t7);
      mount_component(sortby, div2, null);
      append(div3, t8);
      append(div3, table);
      append(table, colgroup);
      append(table, t12);
      append(table, tbody);
      append(tbody, tr0);
      append(tr0, td);
      if (default_slot) {
        default_slot.m(td, null);
      }
      append(tbody, t13);
      append(tbody, tr1);
      append(tbody, t20);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const listpager_changes = {};
      if (dirty & 8)
        listpager_changes.store = ctx2[3];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty & 16)
        sortby_changes.currentFieldName = ctx2[4].orderBy;
      sortby.$set(sortby_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      if (dirty & 23) {
        each_value = ctx2[4].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$h, null, get_each_context$h);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$n();
          each_1_else.c();
          each_1_else.m(tbody, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      transition_in(default_slot, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      transition_out(default_slot, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(searchbar);
      destroy_component(listpager);
      destroy_component(sortby);
      if (default_slot)
        default_slot.d(detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
async function onSaveSteps(e) {
  let macro = e.detail;
  await macro.save();
}
function instance$S($$self, $$props, $$invalidate) {
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { onDelete } = $$props;
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let searchQuery = "";
  let sortingFields = [
    { value: "-ts", label: "Newest First" },
    { value: "ts", label: "Oldest First" },
    { value: "name", label: "Name" },
    {
      value: "-name",
      label: "Name - Descending"
    }
  ];
  let store2 = getContext("store");
  component_subscribe($$self, store2, (value) => $$invalidate(4, $store = value));
  async function onSearch(e) {
    let { phrase } = e.detail;
    if (!phrase) {
      store2.setQuery({});
      return await store2.fetch({ reset: true });
    }
    searchQuery = `%${phrase}%`;
    store2.setQuery({
      $or: {
        "name.ilike": searchQuery,
        "meta:->>'url'.ilike": searchQuery
      }
    });
    return await store2.goto(0, { reset: true });
  }
  async function onSort(by) {
    $$invalidate(3, store2.orderBy = by, store2);
    await store2.fetch({ reset: true });
  }
  $$self.$$set = ($$props2) => {
    if ("onDelete" in $$props2)
      $$invalidate(0, onDelete = $$props2.onDelete);
    if ("openBrowser" in $$props2)
      $$invalidate(1, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(2, showMonitors = $$props2.showMonitors);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  return [
    onDelete,
    openBrowser,
    showMonitors,
    store2,
    $store,
    sortingFields,
    onSearch,
    onSort,
    $$scope,
    slots
  ];
}
class List$5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$S, create_fragment$V, safe_not_equal, {
      onDelete: 0,
      openBrowser: 1,
      showMonitors: 2
    });
  }
}
function create_fragment$U(ctx) {
  let div1;
  let div0;
  let t1;
  let recorder;
  let div1_class_value;
  let current;
  recorder = new Recorder$1({
    props: {
      disablePointer: ctx[7],
      expressionTree: ctx[1],
      findSelector: ctx[2],
      getRecorder: ctx[8],
      getPlayer: ctx[9],
      optInParams: ctx[3],
      params: ctx[4],
      url: ctx[5]
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.innerHTML = `<span class="bbx-flex-grow">Macro</span>`;
      t1 = space();
      create_component(recorder.$$.fragment);
      attr(div0, "class", "bbx-subheader bbx-flex ms-2");
      attr(div1, "class", div1_class_value = "bbx-sidebar " + ctx[0]);
      toggle_class(div1, "active", ctx[6]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t1);
      mount_component(recorder, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const recorder_changes = {};
      if (dirty & 2)
        recorder_changes.expressionTree = ctx2[1];
      if (dirty & 4)
        recorder_changes.findSelector = ctx2[2];
      if (dirty & 8)
        recorder_changes.optInParams = ctx2[3];
      if (dirty & 16)
        recorder_changes.params = ctx2[4];
      if (dirty & 32)
        recorder_changes.url = ctx2[5];
      recorder.$set(recorder_changes);
      if (!current || dirty & 1 && div1_class_value !== (div1_class_value = "bbx-sidebar " + ctx2[0])) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & 65) {
        toggle_class(div1, "active", ctx2[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(recorder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recorder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(recorder);
    }
  };
}
function instance$R($$self, $$props, $$invalidate) {
  let { browserView } = $$props;
  let { class: clazz = "" } = $$props;
  let { expressionTree } = $$props;
  let { findSelector } = $$props;
  let { optInParams: optInParams2 = false } = $$props;
  let { params: params2 } = $$props;
  let { url } = $$props;
  let isPointerDisabled = false;
  setContext("browserView", browserView);
  setContext("expressionCtx", {
    replace: {
      skipControl: false,
      stepNames: Object.keys(stepDefs),
      defaultStep: "click",
      defaultExprs: {
        and: ["and", ["element_exists"]],
        or: ["or", ["element_exists"]],
        not: ["not", ["element_exists"]],
        "if..else": ["cond", [["or", ["and", ["element_exists"]]]]],
        "while loop": ["while", ["or", ["and", ["element_exists"]]], []],
        "for loop": ["for", "item", ["range", 10, 0, 1], []]
      }
    }
  });
  function disablePointer(disable = true) {
    $$invalidate(6, isPointerDisabled = disable);
  }
  function getRecorder(bv, findSelector2, tree, params3) {
    return new Base(bv, findSelector2, tree, { optInParams: optInParams2, params: params3 });
  }
  function getBuiltInDeclarationValue(declaration) {
    if (declaration.name === "start_url") {
      return url;
    } else {
      throw new Error(`Unknown built-in declaration: ${declaration.name}`);
    }
  }
  function getPlayer(bv, opts) {
    for (let j = 0; j < builtInDeclarations.length; j++) {
      let builtInDeclaration = builtInDeclarations[j];
      let variableAlreadyExists = false;
      for (let i2 = 0; i2 < opts.vars; i2++) {
        if (opts.vars[i2].name === builtInDeclaration.name) {
          variableAlreadyExists = true;
        }
      }
      if (!variableAlreadyExists) {
        opts.vars.push({
          ...builtInDeclaration,
          value: getBuiltInDeclarationValue(builtInDeclaration)
        });
      }
    }
    return new Player$2(expressionTree, new BrowserImpl(bv), opts);
  }
  $$self.$$set = ($$props2) => {
    if ("browserView" in $$props2)
      $$invalidate(10, browserView = $$props2.browserView);
    if ("class" in $$props2)
      $$invalidate(0, clazz = $$props2.class);
    if ("expressionTree" in $$props2)
      $$invalidate(1, expressionTree = $$props2.expressionTree);
    if ("findSelector" in $$props2)
      $$invalidate(2, findSelector = $$props2.findSelector);
    if ("optInParams" in $$props2)
      $$invalidate(3, optInParams2 = $$props2.optInParams);
    if ("params" in $$props2)
      $$invalidate(4, params2 = $$props2.params);
    if ("url" in $$props2)
      $$invalidate(5, url = $$props2.url);
  };
  return [
    clazz,
    expressionTree,
    findSelector,
    optInParams2,
    params2,
    url,
    isPointerDisabled,
    disablePointer,
    getRecorder,
    getPlayer,
    browserView
  ];
}
class App$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$R, create_fragment$U, safe_not_equal, {
      browserView: 10,
      class: 0,
      expressionTree: 1,
      findSelector: 2,
      optInParams: 3,
      params: 4,
      url: 5
    });
  }
}
const get_tb_l_slot_changes = (dirty) => ({});
const get_tb_l_slot_context = (ctx) => ({});
const get_tb_url_l_slot_changes = (dirty) => ({});
const get_tb_url_l_slot_context = (ctx) => ({});
const get_tb_url_r_slot_changes = (dirty) => ({});
const get_tb_url_r_slot_context = (ctx) => ({});
const get_tb_r_l_slot_changes = (dirty) => ({});
const get_tb_r_l_slot_context = (ctx) => ({});
const get_tb_r_r_slot_changes = (dirty) => ({});
const get_tb_r_r_slot_context = (ctx) => ({});
const get_tb_save_slot_changes = (dirty) => ({ onSave: dirty & 65536 });
const get_tb_save_slot_context = (ctx) => ({
  slot: "tb-save",
  onSave: ctx[16]
});
function create_tb_l_slot(ctx) {
  let current;
  const tb_l_slot_template = ctx[19]["tb-l"];
  const tb_l_slot = create_slot(tb_l_slot_template, ctx, ctx[22], get_tb_l_slot_context);
  return {
    c() {
      if (tb_l_slot)
        tb_l_slot.c();
    },
    m(target, anchor) {
      if (tb_l_slot) {
        tb_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_l_slot) {
        if (tb_l_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            tb_l_slot,
            tb_l_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(tb_l_slot_template, ctx2[22], dirty, get_tb_l_slot_changes),
            get_tb_l_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_l_slot)
        tb_l_slot.d(detaching);
    }
  };
}
function create_tb_url_l_slot(ctx) {
  let current;
  const tb_url_l_slot_template = ctx[19]["tb-url-l"];
  const tb_url_l_slot = create_slot(tb_url_l_slot_template, ctx, ctx[22], get_tb_url_l_slot_context);
  return {
    c() {
      if (tb_url_l_slot)
        tb_url_l_slot.c();
    },
    m(target, anchor) {
      if (tb_url_l_slot) {
        tb_url_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_url_l_slot) {
        if (tb_url_l_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            tb_url_l_slot,
            tb_url_l_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(tb_url_l_slot_template, ctx2[22], dirty, get_tb_url_l_slot_changes),
            get_tb_url_l_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_url_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_url_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_url_l_slot)
        tb_url_l_slot.d(detaching);
    }
  };
}
function create_tb_url_r_slot$1(ctx) {
  let current;
  const tb_url_r_slot_template = ctx[19]["tb-url-r"];
  const tb_url_r_slot = create_slot(tb_url_r_slot_template, ctx, ctx[22], get_tb_url_r_slot_context);
  return {
    c() {
      if (tb_url_r_slot)
        tb_url_r_slot.c();
    },
    m(target, anchor) {
      if (tb_url_r_slot) {
        tb_url_r_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_url_r_slot) {
        if (tb_url_r_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            tb_url_r_slot,
            tb_url_r_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(tb_url_r_slot_template, ctx2[22], dirty, get_tb_url_r_slot_changes),
            get_tb_url_r_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_url_r_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_url_r_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_url_r_slot)
        tb_url_r_slot.d(detaching);
    }
  };
}
function create_tb_r_l_slot(ctx) {
  let current;
  const tb_r_l_slot_template = ctx[19]["tb-r-l"];
  const tb_r_l_slot = create_slot(tb_r_l_slot_template, ctx, ctx[22], get_tb_r_l_slot_context);
  return {
    c() {
      if (tb_r_l_slot)
        tb_r_l_slot.c();
    },
    m(target, anchor) {
      if (tb_r_l_slot) {
        tb_r_l_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_r_l_slot) {
        if (tb_r_l_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            tb_r_l_slot,
            tb_r_l_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(tb_r_l_slot_template, ctx2[22], dirty, get_tb_r_l_slot_changes),
            get_tb_r_l_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_r_l_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_r_l_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_r_l_slot)
        tb_r_l_slot.d(detaching);
    }
  };
}
function create_tb_r_r_slot(ctx) {
  let current;
  const tb_r_r_slot_template = ctx[19]["tb-r-r"];
  const tb_r_r_slot = create_slot(tb_r_r_slot_template, ctx, ctx[22], get_tb_r_r_slot_context);
  return {
    c() {
      if (tb_r_r_slot)
        tb_r_r_slot.c();
    },
    m(target, anchor) {
      if (tb_r_r_slot) {
        tb_r_r_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_r_r_slot) {
        if (tb_r_r_slot.p && (!current || dirty & 4194304)) {
          update_slot_base(
            tb_r_r_slot,
            tb_r_r_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(tb_r_r_slot_template, ctx2[22], dirty, get_tb_r_r_slot_changes),
            get_tb_r_r_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_r_r_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tb_r_r_slot, local);
      current = false;
    },
    d(detaching) {
      if (tb_r_r_slot)
        tb_r_r_slot.d(detaching);
    }
  };
}
function fallback_block$1(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Save";
      attr(button, "type", "button");
      attr(button, "class", "btn btn-sm btn-primary");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", function() {
          if (is_function(ctx[16]))
            ctx[16].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_tb_save_slot(ctx) {
  let current;
  const tb_save_slot_template = ctx[19]["tb-save"];
  const tb_save_slot = create_slot(tb_save_slot_template, ctx, ctx[22], get_tb_save_slot_context);
  const tb_save_slot_or_fallback = tb_save_slot || fallback_block$1(ctx);
  return {
    c() {
      if (tb_save_slot_or_fallback)
        tb_save_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (tb_save_slot_or_fallback) {
        tb_save_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tb_save_slot) {
        if (tb_save_slot.p && (!current || dirty & 4259840)) {
          update_slot_base(
            tb_save_slot,
            tb_save_slot_template,
            ctx2,
            ctx2[22],
            !current ? get_all_dirty_from_scope(ctx2[22]) : get_slot_changes(tb_save_slot_template, ctx2[22], dirty, get_tb_save_slot_changes),
            get_tb_save_slot_context
          );
        }
      } else {
        if (tb_save_slot_or_fallback && tb_save_slot_or_fallback.p && (!current || dirty & 65536)) {
          tb_save_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tb_save_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(tb_save_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (tb_save_slot_or_fallback)
        tb_save_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block$s(ctx) {
  let app;
  let current;
  app = new App$1({
    props: {
      browserView: ctx[10],
      expressionTree: ctx[11],
      findSelector: ctx[4],
      optInParams: ctx[5],
      params: ctx[12],
      url: ctx[9]
    }
  });
  return {
    c() {
      create_component(app.$$.fragment);
    },
    m(target, anchor) {
      mount_component(app, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const app_changes = {};
      if (dirty & 1024)
        app_changes.browserView = ctx2[10];
      if (dirty & 16)
        app_changes.findSelector = ctx2[4];
      if (dirty & 32)
        app_changes.optInParams = ctx2[5];
      if (dirty & 512)
        app_changes.url = ctx2[9];
      app.$set(app_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(app.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(app.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(app, detaching);
    }
  };
}
function create_browser_r_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[10] && create_if_block$s(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[10]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$s(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$T(ctx) {
  let browsercontainer;
  let updating_url;
  let updating_extensions;
  let current;
  function browsercontainer_url_binding(value) {
    ctx[20](value);
  }
  function browsercontainer_extensions_binding(value) {
    ctx[21](value);
  }
  let browsercontainer_props = {
    bbx: ctx[2],
    class: ctx[3],
    onCancel: ctx[13],
    onSave: ctx[16],
    proxy: ctx[6],
    session: ctx[7],
    onProxyChange: ctx[8],
    $$slots: {
      "browser-r": [create_browser_r_slot],
      "tb-save": [
        create_tb_save_slot,
        ({ onSave }) => ({ 16: onSave }),
        ({ onSave }) => onSave ? 65536 : 0
      ],
      "tb-r-r": [create_tb_r_r_slot],
      "tb-r-l": [create_tb_r_l_slot],
      "tb-url-r": [create_tb_url_r_slot$1],
      "tb-url-l": [create_tb_url_l_slot],
      "tb-l": [create_tb_l_slot]
    },
    $$scope: { ctx }
  };
  if (ctx[0] !== void 0) {
    browsercontainer_props.url = ctx[0];
  }
  if (ctx[1] !== void 0) {
    browsercontainer_props.extensions = ctx[1];
  }
  browsercontainer = new BrowserContainer({ props: browsercontainer_props });
  binding_callbacks.push(() => bind$1(browsercontainer, "url", browsercontainer_url_binding));
  binding_callbacks.push(() => bind$1(browsercontainer, "extensions", browsercontainer_extensions_binding));
  browsercontainer.$on("goto", ctx[14]);
  browsercontainer.$on("ready", ctx[15]);
  return {
    c() {
      create_component(browsercontainer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(browsercontainer, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const browsercontainer_changes = {};
      if (dirty & 4)
        browsercontainer_changes.bbx = ctx2[2];
      if (dirty & 8)
        browsercontainer_changes.class = ctx2[3];
      if (dirty & 64)
        browsercontainer_changes.proxy = ctx2[6];
      if (dirty & 128)
        browsercontainer_changes.session = ctx2[7];
      if (dirty & 256)
        browsercontainer_changes.onProxyChange = ctx2[8];
      if (dirty & 4261424) {
        browsercontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_url && dirty & 1) {
        updating_url = true;
        browsercontainer_changes.url = ctx2[0];
        add_flush_callback(() => updating_url = false);
      }
      if (!updating_extensions && dirty & 2) {
        updating_extensions = true;
        browsercontainer_changes.extensions = ctx2[1];
        add_flush_callback(() => updating_extensions = false);
      }
      browsercontainer.$set(browsercontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(browsercontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(browsercontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(browsercontainer, detaching);
    }
  };
}
function instance$Q($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  const _Msg = getContext("Msg");
  const Msg2 = new MsgClass(_Msg);
  setContext("Msg", Msg2);
  let { bbx } = $$props;
  let { class: clazz = "" } = $$props;
  let { findSelector } = $$props;
  let { initialParams = [] } = $$props;
  let { initialSteps = [] } = $$props;
  let { optInParams: optInParams2 = false } = $$props;
  let { proxy = void 0 } = $$props;
  let { session = void 0 } = $$props;
  let { url } = $$props;
  let { extensions } = $$props;
  let { onProxyChange = void 0 } = $$props;
  let startURL = url;
  let browserView;
  const expressionTree = parseSteps$3(initialSteps, { declarations: initialParams });
  const params2 = new Params$2(expressionTree.declarations);
  function onCancel() {
    dispatch("cancel");
  }
  function onSave() {
    let steps;
    try {
      steps = expressionTree.toJSON();
    } catch (e) {
      Msg2.error("Cannot save steps with errors. Please resolve ");
      throw e;
    }
    dispatch("save", {
      steps,
      params: params2.toJSON(),
      extensions
    });
  }
  function onGotoURL(event) {
    $$invalidate(9, startURL = event.detail);
  }
  function onBrowserContainerReady(event) {
    $$invalidate(10, browserView = event.detail);
    if (browserView) {
      const mainFrameStore = browserView.store.pages[0].mainFrame;
      mainFrameStore.on("change", () => {
        if (mainFrameStore.url.startsWith("http")) {
          $$invalidate(0, url = mainFrameStore.url);
        }
      });
    }
    dispatch("ready", browserView);
  }
  function browsercontainer_url_binding(value) {
    url = value;
    $$invalidate(0, url);
  }
  function browsercontainer_extensions_binding(value) {
    extensions = value;
    $$invalidate(1, extensions);
  }
  $$self.$$set = ($$props2) => {
    if ("bbx" in $$props2)
      $$invalidate(2, bbx = $$props2.bbx);
    if ("class" in $$props2)
      $$invalidate(3, clazz = $$props2.class);
    if ("findSelector" in $$props2)
      $$invalidate(4, findSelector = $$props2.findSelector);
    if ("initialParams" in $$props2)
      $$invalidate(17, initialParams = $$props2.initialParams);
    if ("initialSteps" in $$props2)
      $$invalidate(18, initialSteps = $$props2.initialSteps);
    if ("optInParams" in $$props2)
      $$invalidate(5, optInParams2 = $$props2.optInParams);
    if ("proxy" in $$props2)
      $$invalidate(6, proxy = $$props2.proxy);
    if ("session" in $$props2)
      $$invalidate(7, session = $$props2.session);
    if ("url" in $$props2)
      $$invalidate(0, url = $$props2.url);
    if ("extensions" in $$props2)
      $$invalidate(1, extensions = $$props2.extensions);
    if ("onProxyChange" in $$props2)
      $$invalidate(8, onProxyChange = $$props2.onProxyChange);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  return [
    url,
    extensions,
    bbx,
    clazz,
    findSelector,
    optInParams2,
    proxy,
    session,
    onProxyChange,
    startURL,
    browserView,
    expressionTree,
    params2,
    onCancel,
    onGotoURL,
    onBrowserContainerReady,
    onSave,
    initialParams,
    initialSteps,
    slots,
    browsercontainer_url_binding,
    browsercontainer_extensions_binding,
    $$scope
  ];
}
class Index extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Q, create_fragment$T, safe_not_equal, {
      bbx: 2,
      class: 3,
      findSelector: 4,
      initialParams: 17,
      initialSteps: 18,
      optInParams: 5,
      proxy: 6,
      session: 7,
      url: 0,
      extensions: 1,
      onProxyChange: 8
    });
  }
}
function create_catch_block$c(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$c(ctx) {
  let bbxrecorder;
  let current;
  bbxrecorder = new Index({
    props: {
      bbx: ctx[3],
      onProxyChange: ctx[10],
      initialSteps: ctx[7],
      initialParams: ctx[8],
      optInParams: true,
      findSelector: ctx[9],
      proxy: ctx[1],
      session: ctx[2],
      url: ctx[4].meta.url,
      extensions: ctx[5],
      $$slots: { "tb-url-r": [create_tb_url_r_slot] },
      $$scope: { ctx }
    }
  });
  bbxrecorder.$on("save", ctx[13]);
  bbxrecorder.$on("cancel", ctx[14]);
  return {
    c() {
      create_component(bbxrecorder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(bbxrecorder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const bbxrecorder_changes = {};
      if (dirty & 8)
        bbxrecorder_changes.bbx = ctx2[3];
      if (dirty & 2)
        bbxrecorder_changes.proxy = ctx2[1];
      if (dirty & 4)
        bbxrecorder_changes.session = ctx2[2];
      if (dirty & 16)
        bbxrecorder_changes.url = ctx2[4].meta.url;
      if (dirty & 524294) {
        bbxrecorder_changes.$$scope = { dirty, ctx: ctx2 };
      }
      bbxrecorder.$set(bbxrecorder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(bbxrecorder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(bbxrecorder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(bbxrecorder, detaching);
    }
  };
}
function create_tb_url_r_slot(ctx) {
  let selectproxy;
  let updating_proxy;
  let t;
  let selectsession;
  let updating_session;
  let current;
  function selectproxy_proxy_binding(value) {
    ctx[11](value);
  }
  let selectproxy_props = {
    class: "bbx-action btn btn-default",
    title: "Proxy"
  };
  if (ctx[1] !== void 0) {
    selectproxy_props.proxy = ctx[1];
  }
  selectproxy = new SelectProxy({ props: selectproxy_props });
  binding_callbacks.push(() => bind$1(selectproxy, "proxy", selectproxy_proxy_binding));
  function selectsession_session_binding(value) {
    ctx[12](value);
  }
  let selectsession_props = {
    class: "bbx-action btn btn-default",
    title: "Profile"
  };
  if (ctx[2] !== void 0) {
    selectsession_props.session = ctx[2];
  }
  selectsession = new SelectSession({ props: selectsession_props });
  binding_callbacks.push(() => bind$1(selectsession, "session", selectsession_session_binding));
  return {
    c() {
      create_component(selectproxy.$$.fragment);
      t = space();
      create_component(selectsession.$$.fragment);
    },
    m(target, anchor) {
      mount_component(selectproxy, target, anchor);
      insert(target, t, anchor);
      mount_component(selectsession, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectproxy_changes = {};
      if (!updating_proxy && dirty & 2) {
        updating_proxy = true;
        selectproxy_changes.proxy = ctx2[1];
        add_flush_callback(() => updating_proxy = false);
      }
      selectproxy.$set(selectproxy_changes);
      const selectsession_changes = {};
      if (!updating_session && dirty & 4) {
        updating_session = true;
        selectsession_changes.session = ctx2[2];
        add_flush_callback(() => updating_session = false);
      }
      selectsession.$set(selectsession_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(selectproxy.$$.fragment, local);
      transition_in(selectsession.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectproxy.$$.fragment, local);
      transition_out(selectsession.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(selectproxy, detaching);
      if (detaching)
        detach(t);
      destroy_component(selectsession, detaching);
    }
  };
}
function create_pending_block$c(ctx) {
  let loader;
  let t0;
  let div;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
      t0 = space();
      div = element("div");
      div.textContent = "Creating browser...";
      attr(div, "class", "fs-2 pt-2 text-center");
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$S(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$c,
    then: create_then_block$c,
    catch: create_catch_block$c,
    value: 18,
    blocks: [, , ,]
  };
  handle_promise(ctx[6](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$P($$self, $$props, $$invalidate) {
  var _a, _b;
  let $macro, $$unsubscribe_macro = noop$1, $$subscribe_macro = () => ($$unsubscribe_macro(), $$unsubscribe_macro = subscribe(macro, ($$value) => $$invalidate(4, $macro = $$value)), macro);
  $$self.$$.on_destroy.push(() => $$unsubscribe_macro());
  const dispatch = createEventDispatcher();
  let { macro } = $$props;
  $$subscribe_macro();
  let proxy;
  let session;
  let api = getContext("api");
  let bbx;
  let extensions = [];
  function prepareExtArray() {
    var _a2, _b2;
    extensions.push({
      id: ADBLOCKER_ID,
      enabled: (_b2 = (_a2 = $macro.meta) == null ? void 0 : _a2[EXT_ID_PROPS[ADBLOCKER_ID]]) != null ? _b2 : false
    });
  }
  prepareExtArray();
  async function createBBX() {
    try {
      Msg.reset();
      $$invalidate(3, bbx = await api("/selectors2", "POST"));
    } catch (e) {
      dispatch("cancel");
      Msg.error("Failed to create remote browser. Please try again later.");
    }
  }
  let initialSteps = $macro.steps;
  let initialParams = (_b = (_a = $macro.spec) == null ? void 0 : _a.params) != null ? _b : [];
  async function findSelector(el2) {
    let expr = await getCSS([el2], {
      filterCallback: (_2, name, value) => {
        if ([
          "href",
          "src",
          "srcset",
          "hasinclude__",
          "include__",
          "title",
          "aria-label",
          "alt"
        ].includes(name) || (value == null ? void 0 : value.length) > 30) {
          return false;
        }
        return true;
      }
    });
    return new CSSSelector(expr);
  }
  async function onProxyChange(proxy2, browserView) {
    var _a2;
    if (!browserView) {
      return;
    }
    const bbxInstanceId = bbx.id;
    await Api.api(`/selectors2/${bbxInstanceId}/set-proxy`, "PUT", { proxy_id: (_a2 = proxy2 == null ? void 0 : proxy2.id) != null ? _a2 : null });
    if (browserView) {
      await browserView.store.clearAllSiteData();
      if ((session == null ? void 0 : session.cookies.length) > 0) {
        await browserView.manager.browser.call("setCookies", session.cookies);
      }
    }
  }
  function selectproxy_proxy_binding(value) {
    proxy = value;
    $$invalidate(1, proxy);
  }
  function selectsession_session_binding(value) {
    session = value;
    $$invalidate(2, session);
  }
  function save_handler(event) {
    bubble.call(this, $$self, event);
  }
  function cancel_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("macro" in $$props2)
      $$subscribe_macro($$invalidate(0, macro = $$props2.macro));
  };
  return [
    macro,
    proxy,
    session,
    bbx,
    $macro,
    extensions,
    createBBX,
    initialSteps,
    initialParams,
    findSelector,
    onProxyChange,
    selectproxy_proxy_binding,
    selectsession_session_binding,
    save_handler,
    cancel_handler
  ];
}
class Recorder extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$P, create_fragment$S, safe_not_equal, { macro: 0 });
  }
}
function get_each_context$g(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  child_ctx[29] = i2;
  return child_ctx;
}
function create_if_block_5$3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Please enter name and a valid start url for the recorder";
      attr(div, "class", "error");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4$8(ctx) {
  let span;
  let t0;
  let t1_value = ctx[1].models.length + "";
  let t1;
  let t2;
  let t3;
  let t4;
  return {
    c() {
      span = element("span");
      t0 = text("Used ");
      t1 = text(t1_value);
      t2 = text(" of ");
      t3 = text(ctx[9]);
      t4 = text(" macros.");
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(span, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t1_value !== (t1_value = ctx2[1].models.length + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_3$c(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Upgrade account to create and use macros in cloud.";
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_2(ctx) {
  let div1;
  let div0;
  let input0;
  let t0;
  let input1;
  let t1;
  let span;
  let button0;
  let t2;
  let button0_disabled_value;
  let t3;
  let button1;
  let t4;
  let button1_disabled_value;
  let t5;
  let t6;
  let mounted;
  let dispose;
  let if_block0 = ctx[5] && create_if_block_5$3();
  function select_block_type(ctx2, dirty) {
    if (ctx2[9] == 0)
      return create_if_block_3$c;
    if (ctx2[2])
      return create_if_block_4$8;
  }
  let current_block_type = select_block_type(ctx);
  let if_block1 = current_block_type && current_block_type(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      span = element("span");
      button0 = element("button");
      t2 = text("Add New Macro");
      t3 = space();
      button1 = element("button");
      t4 = text("Import Macro");
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      if (if_block1)
        if_block1.c();
      attr(input0, "type", "text");
      attr(input0, "class", "form-control w-96");
      attr(input0, "placeholder", "New Macro Name");
      attr(input1, "type", "text");
      attr(input1, "class", "form-control w-96");
      attr(input1, "placeholder", "Start URL");
      attr(button0, "class", "btn btn-default");
      attr(button0, "role", "button");
      button0.disabled = button0_disabled_value = ctx[2] || ctx[7];
      attr(button1, "class", "btn btn-default");
      attr(button1, "role", "button");
      button1.disabled = button1_disabled_value = ctx[2] || ctx[7];
      attr(span, "class", "inline-block");
      attr(div0, "class", "flex gap-2");
      attr(div1, "class", "");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, input0);
      set_input_value(input0, ctx[3]);
      append(div0, t0);
      append(div0, input1);
      set_input_value(input1, ctx[4]);
      append(div0, t1);
      append(div0, span);
      append(span, button0);
      append(button0, t2);
      append(span, t3);
      append(span, button1);
      append(button1, t4);
      append(div1, t5);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t6);
      if (if_block1)
        if_block1.m(div1, null);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[19]),
          listen(input1, "input", ctx[20]),
          listen(button0, "click", ctx[11]),
          listen(button1, "click", ctx[17])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && input0.value !== ctx2[3]) {
        set_input_value(input0, ctx2[3]);
      }
      if (dirty & 16 && input1.value !== ctx2[4]) {
        set_input_value(input1, ctx2[4]);
      }
      if (dirty & 132 && button0_disabled_value !== (button0_disabled_value = ctx2[2] || ctx2[7])) {
        button0.disabled = button0_disabled_value;
      }
      if (dirty & 132 && button1_disabled_value !== (button1_disabled_value = ctx2[2] || ctx2[7])) {
        button1.disabled = button1_disabled_value;
      }
      if (ctx2[5]) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_5$3();
          if_block0.c();
          if_block0.m(div1, t6);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if (if_block1)
          if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1) {
        if_block1.d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$e(ctx) {
  let recordermodal;
  let current;
  recordermodal = new Modal$1({
    props: {
      widthClass: "modal-fullscreen",
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(recordermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recordermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recordermodal_changes = {};
      if (dirty & 1073741888) {
        recordermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      recordermodal.$set(recordermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recordermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recordermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recordermodal, detaching);
    }
  };
}
function create_default_slot_1$2(ctx) {
  let recorder;
  let current;
  recorder = new Recorder({
    props: {
      class: "w-full",
      macro: ctx[6]
    }
  });
  recorder.$on("cancel", ctx[14]);
  recorder.$on("save", ctx[13]);
  return {
    c() {
      create_component(recorder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recorder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recorder_changes = {};
      if (dirty & 64)
        recorder_changes.macro = ctx2[6];
      recorder.$set(recorder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recorder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recorder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recorder, detaching);
    }
  };
}
function create_if_block$r(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      $$slots: {
        header: [create_header_slot$8],
        default: [create_default_slot$k]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[21]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 1073742080) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_else_block$m(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ctx[8].sieves;
  const get_key = (ctx2) => ctx2[27].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$g(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$g(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$8();
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 256) {
        each_value = ctx2[8].sieves;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$g, each_1_anchor, get_each_context$g);
        if (each_value.length) {
          if (each_1_else) {
            each_1_else.d(1);
            each_1_else = null;
          }
        } else if (!each_1_else) {
          each_1_else = create_else_block_1$8();
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        }
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_if_block_1$i(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block_1$8(ctx) {
  let t;
  return {
    c() {
      t = text("No monitor found using this macro.");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$g(key_1, ctx) {
  let div;
  let t_value = ctx[27].name + "";
  let t;
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      t = text(t_value);
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 256 && t_value !== (t_value = ctx[27].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$k(ctx) {
  let div;
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[8].sieves)
      return create_if_block_1$i;
    return create_else_block$m;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      set_style(div, "max-height", "70vh");
      set_style(div, "overflow", "auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_header_slot$8(ctx) {
  let span;
  let t0;
  let t1_value = ctx[8].name + "";
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("Monitors - ");
      t1 = text(t1_value);
      attr(span, "slot", "header");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 256 && t1_value !== (t1_value = ctx2[8].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$R(ctx) {
  let list;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  list = new List$5({
    props: {
      onDelete: ctx[12],
      openBrowser: ctx[15],
      showMonitors: ctx[16],
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[6] && create_if_block_2$e(ctx);
  let if_block1 = ctx[8] && create_if_block$r(ctx);
  return {
    c() {
      create_component(list.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const list_changes = {};
      if (dirty & 1073742014) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
      if (ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$e(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[8]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$r(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$O($$self, $$props, $$invalidate) {
  let $openMacro, $$unsubscribe_openMacro = noop$1, $$subscribe_openMacro = () => ($$unsubscribe_openMacro(), $$unsubscribe_openMacro = subscribe(openMacro, ($$value) => $$invalidate(22, $openMacro = $$value)), openMacro);
  let $store;
  let $user, $$unsubscribe_user = noop$1, $$subscribe_user = () => ($$unsubscribe_user(), $$unsubscribe_user = subscribe(user, ($$value) => $$invalidate(23, $user = $$value)), user);
  $$self.$$.on_destroy.push(() => $$unsubscribe_openMacro());
  $$self.$$.on_destroy.push(() => $$unsubscribe_user());
  let { api = getContext("api") } = $$props;
  let { user = getContext("user") } = $$props;
  $$subscribe_user();
  setContext("Msg", Msg);
  let limit = $user.constraint.macro;
  let limitReached = false;
  let newName = "";
  let url = "";
  let missingInfo = false;
  let openMacro;
  let savingMacro = false;
  let showMonitorsForMacro = null;
  let store2 = new Macros$1([], { orderBy: "-ts" });
  component_subscribe($$self, store2, (value) => $$invalidate(1, $store = value));
  setContext("store", store2);
  onMount(async () => {
    await store2.fetch();
  });
  async function onAdd() {
    if (!newName || !url) {
      $$invalidate(5, missingInfo = true);
      return;
    }
    if (!url.startsWith("http")) {
      $$invalidate(4, url = "https://" + url);
    }
    $$invalidate(5, missingInfo = false);
    $$invalidate(7, savingMacro = true);
    $$subscribe_openMacro($$invalidate(6, openMacro = await store2.create(
      {
        name: newName || "Untitled",
        meta: { url, [EXT_ID_PROPS[ADBLOCKER_ID]]: true }
      },
      { wait: true }
    )));
    $$invalidate(3, newName = "");
    $$invalidate(7, savingMacro = false);
    store2.fetch();
  }
  async function onDelete(model) {
    await removeMacroFromSieve(model.id);
    await model.destroy();
  }
  async function removeMacroFromSieve(id2) {
    let res = await api(`/sieves?macro_id=${id2}`, {
      "state.in": [40, 45, 90],
      _opt: { only: ["id"], limit: 100 }
    });
    let ids = res.data.map((s) => s.id);
    if (ids.length == 0) {
      return;
    }
    await api("/batch/sieves", "PUT", { ids, macro_id: null });
    if (res.total_count > res.count) {
      await removeMacroFromSieve(id2);
    }
  }
  async function onSaveMacro(e) {
    let { steps, params: params2, extensions } = e.detail;
    let meta = $openMacro.meta;
    for (const { id: id2, enabled } of extensions) {
      meta[EXT_ID_PROPS[ADBLOCKER_ID]] = enabled;
    }
    if (!steps.length) {
      steps = [["wait_doc"]];
    }
    await openMacro.save({ steps, spec: { params: params2 }, meta });
    $$subscribe_openMacro($$invalidate(6, openMacro = null));
    await store2.fetch();
  }
  function onDiscardMacro() {
    $$subscribe_openMacro($$invalidate(6, openMacro = null));
  }
  function openBrowser(macro) {
    $$subscribe_openMacro($$invalidate(6, openMacro = macro));
  }
  async function showMonitors(macro) {
    $$invalidate(8, showMonitorsForMacro = { ...macro, sieves: null });
    $$invalidate(8, showMonitorsForMacro.sieves = (await api(`/sieves?state.in[0]=40&state.in[1]=45&_opt[limit]=500&macro_id=${macro.id}`)).data, showMonitorsForMacro);
  }
  function importMacro() {
    let el2 = document.createElement("input");
    el2.type = "file";
    el2.accept = ".json";
    el2.addEventListener("change", (e) => {
      let file = e.target.files[0];
      let reader = new FileReader();
      reader.onload = async (e2) => {
        let obj = JSON.parse(e2.target.result);
        let macros = obj.macros;
        for (let macro of macros) {
          await store2.create(macro, { wait: true });
        }
        store2.fetch();
      };
      reader.readAsText(file);
    });
    el2.click();
  }
  function input0_input_handler() {
    newName = this.value;
    $$invalidate(3, newName);
  }
  function input1_input_handler() {
    url = this.value;
    $$invalidate(4, url);
  }
  const close_handler = () => $$invalidate(8, showMonitorsForMacro = null);
  $$self.$$set = ($$props2) => {
    if ("api" in $$props2)
      $$invalidate(18, api = $$props2.api);
    if ("user" in $$props2)
      $$subscribe_user($$invalidate(0, user = $$props2.user));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $$invalidate(2, limitReached = $store.models.length >= limit);
    }
  };
  return [
    user,
    $store,
    limitReached,
    newName,
    url,
    missingInfo,
    openMacro,
    savingMacro,
    showMonitorsForMacro,
    limit,
    store2,
    onAdd,
    onDelete,
    onSaveMacro,
    onDiscardMacro,
    openBrowser,
    showMonitors,
    importMacro,
    api,
    input0_input_handler,
    input1_input_handler,
    close_handler
  ];
}
class Macros_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$O, create_fragment$R, safe_not_equal, { api: 18, user: 0 });
  }
}
class Session extends base.Model {
}
class Sessions extends base.PagedCollection {
  constructor() {
    super(...arguments);
    __publicField(this, "model", Session);
    __publicField(this, "url", "/sessions");
    __publicField(this, "limit", 20);
  }
}
function create_if_block$q(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = "Save Cookies";
      attr(button, "class", "btn btn-default");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[9]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_catch_block$b(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Failed to create remote browser. Please try again later.";
      attr(div, "class", "fs-4 pt-2 text-danger text-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_then_block$b(ctx) {
  let div1;
  let div0;
  let input_1;
  let t0;
  let button;
  let t2;
  let selectproxy;
  let t3;
  let div2;
  let current;
  let mounted;
  let dispose;
  selectproxy = new SelectProxy({
    props: {
      showLabelPrefix: true,
      class: "bbx-action btn btn-default px-0",
      actionClass: "d-flex align-items-center",
      title: "Select Proxy"
    }
  });
  selectproxy.$on("select", ctx[8]);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      input_1 = element("input");
      t0 = space();
      button = element("button");
      button.textContent = "Go";
      t2 = space();
      create_component(selectproxy.$$.fragment);
      t3 = space();
      div2 = element("div");
      attr(input_1, "class", "form-control");
      attr(input_1, "type", "text");
      attr(button, "class", "btn btn-outline-dark");
      attr(div0, "class", "input-group flex-1");
      attr(div1, "class", "flex gap-1 mb-1");
      attr(div2, "class", "flex-auto");
      set_style(div2, "position", "relative");
      set_style(div2, "background-color", "#fff");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, input_1);
      set_input_value(input_1, ctx[4]);
      ctx[13](input_1);
      append(div0, t0);
      append(div0, button);
      append(div1, t2);
      mount_component(selectproxy, div1, null);
      insert(target, t3, anchor);
      insert(target, div2, anchor);
      ctx[14](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input_1, "input", ctx[12]),
          listen(input_1, "keypress", ctx[11]),
          listen(button, "click", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16 && input_1.value !== ctx2[4]) {
        set_input_value(input_1, ctx2[4]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(selectproxy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selectproxy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[13](null);
      destroy_component(selectproxy);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div2);
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_pending_block$b(ctx) {
  let loader;
  let current;
  loader = new Loader({ props: { style: "margin-top: 0;" } });
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$Q(ctx) {
  let div3;
  let div1;
  let h3;
  let t0_value = ctx[5].name + "";
  let t0;
  let t1;
  let t2;
  let div0;
  let t3;
  let button;
  let t4;
  let div2;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[3] && create_if_block$q(ctx);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$b,
    then: create_then_block$b,
    catch: create_catch_block$b,
    value: 24,
    blocks: [, , ,]
  };
  handle_promise(ctx[6], info);
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = text(" - Remote Browser");
      t2 = space();
      div0 = element("div");
      if (if_block)
        if_block.c();
      t3 = space();
      button = element("button");
      t4 = space();
      div2 = element("div");
      info.block.c();
      set_style(h3, "flex", "1");
      attr(button, "class", "btn btn-close");
      attr(div0, "class", "d-flex gap-3 align-items-center");
      attr(div1, "class", "card-header");
      set_style(div1, "display", "flex");
      set_style(div1, "align-items", "center");
      attr(div2, "class", "card-body flex-auto flex flex-column");
      set_style(div2, "padding", "0");
      attr(div3, "class", "card panel-default flex-auto flex flex-column");
      set_style(div3, "margin", "0");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, h3);
      append(h3, t0);
      append(h3, t1);
      append(div1, t2);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div0, t3);
      append(div0, button);
      append(div3, t4);
      append(div3, div2);
      info.block.m(div2, info.anchor = null);
      info.mount = () => div2;
      info.anchor = null;
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[10]);
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & 32) && t0_value !== (t0_value = ctx[5].name + ""))
        set_data(t0, t0_value);
      if (ctx[3]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$q(ctx);
          if_block.c();
          if_block.m(div0, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block)
        if_block.d();
      info.block.d();
      info.token = null;
      info = null;
      mounted = false;
      dispose();
    }
  };
}
function instance$N($$self, $$props, $$invalidate) {
  let $session, $$unsubscribe_session = noop$1, $$subscribe_session = () => ($$unsubscribe_session(), $$unsubscribe_session = subscribe(session, ($$value) => $$invalidate(5, $session = $$value)), session);
  $$self.$$.on_destroy.push(() => $$unsubscribe_session());
  const dispatch = createEventDispatcher();
  let { session } = $$props;
  $$subscribe_session();
  let api = getContext("api");
  let input;
  let container;
  let bbx;
  let browserView;
  let browser2;
  let url = "https://www.google.com";
  let bbxPromise = createBBX();
  async function createBBX() {
    bbx = await api("/selectors2", "POST");
  }
  async function createBrowserView() {
    $$invalidate(3, browserView = await createView({ ...bbx, container }));
    browser2 = browserView.store;
    await browser2.call("setCookies", session.get("cookies") || []);
    await getProxies();
    go();
  }
  onDestroy(() => {
    if (bbx) {
      api("/selectors2/" + bbx.id, "DELETE");
    }
  });
  function go() {
    if (url) {
      browser2.pages[0].goto(url);
    }
  }
  async function onSelectProxy(e) {
    let id2 = e.detail;
    await Api.api(`/selectors2/${bbx.id}/set-proxy`, "PUT", { proxy_id: id2 != null ? id2 : null });
  }
  async function onSaveAndClose() {
    let res = await browser2.call("getCookies");
    let cookies = res;
    dispatch("save", { url, cookies });
  }
  function onDiscard(e) {
    e.preventDefault();
    dispatch("discard");
  }
  function onInputKey(e) {
    if (e.keyCode == 13) {
      go();
      input.blur();
    }
  }
  function input_1_input_handler() {
    url = this.value;
    $$invalidate(4, url);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(2, input);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(1, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("session" in $$props2)
      $$subscribe_session($$invalidate(0, session = $$props2.session));
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      if (container) {
        createBrowserView();
      }
    }
  };
  return [
    session,
    container,
    input,
    browserView,
    url,
    $session,
    bbxPromise,
    go,
    onSelectProxy,
    onSaveAndClose,
    onDiscard,
    onInputKey,
    input_1_input_handler,
    input_1_binding,
    div2_binding
  ];
}
class Browser extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$N, create_fragment$Q, safe_not_equal, { session: 0 });
  }
}
function create_else_block$l(ctx) {
  let div;
  let t_value = ctx[5][ctx[1]] + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "flex-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & 34 && t_value !== (t_value = ctx2[5][ctx2[1]] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$p(ctx) {
  let input;
  let t0;
  let button0;
  let t2;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      t0 = space();
      button0 = element("button");
      button0.textContent = "Save";
      t2 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(input, "type", "text");
      attr(input, "class", "form-control form-control-sm flex-1");
      attr(input, "placeholder", ctx[1]);
      input.autofocus = true;
      attr(button0, "class", "btn btn-sm btn-primary");
      attr(button1, "class", "btn btn-sm btn-default");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[2]);
      insert(target, t0, anchor);
      insert(target, button0, anchor);
      insert(target, t2, anchor);
      insert(target, button1, anchor);
      input.focus();
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[10]),
          listen(input, "keydown", ctx[9]),
          listen(button0, "click", ctx[7]),
          listen(button1, "click", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2) {
        attr(input, "placeholder", ctx2[1]);
      }
      if (dirty & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(button0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(button1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$P(ctx) {
  let form;
  let t0;
  let button;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return create_if_block$p;
    return create_else_block$l;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      form = element("form");
      if_block.c();
      t0 = space();
      button = element("button");
      button.textContent = "Edit";
      attr(button, "class", "btn btn-default btn-sm mx-2 pull-right");
      toggle_class(button, "invisible", !ctx[3] || ctx[4]);
      attr(form, "class", "flex items-center gap-2 w-100");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      if_block.m(form, null);
      append(form, t0);
      append(form, button);
      if (!mounted) {
        dispose = [
          listen(button, "click", ctx[6]),
          listen(form, "mouseenter", ctx[11]),
          listen(form, "mouseleave", ctx[12])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(form, t0);
        }
      }
      if (dirty & 24) {
        toggle_class(button, "invisible", !ctx2[3] || ctx2[4]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(form);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$M($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop$1, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store2, ($$value) => $$invalidate(5, $store = $$value)), store2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  let { store: store2 } = $$props;
  $$subscribe_store();
  let { name } = $$props;
  let newValue = $store[name];
  let showEditBtn = false;
  let editValue = false;
  function onEdit() {
    $$invalidate(4, editValue = true);
  }
  function onSave() {
    $$invalidate(4, editValue = false);
    store2.save({ [name]: newValue });
  }
  function onCancel() {
    $$invalidate(4, editValue = false);
    $$invalidate(2, newValue = $store[name]);
  }
  function onKeydown(e) {
    if (e.key === "Escape") {
      onCancel();
    } else if (e.key === "Enter") {
      onSave();
    }
  }
  function input_input_handler() {
    newValue = this.value;
    $$invalidate(2, newValue);
  }
  const mouseenter_handler = () => $$invalidate(3, showEditBtn = true);
  const mouseleave_handler = () => $$invalidate(3, showEditBtn = false);
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(0, store2 = $$props2.store));
    if ("name" in $$props2)
      $$invalidate(1, name = $$props2.name);
  };
  return [
    store2,
    name,
    newValue,
    showEditBtn,
    editValue,
    $store,
    onEdit,
    onSave,
    onCancel,
    onKeydown,
    input_input_handler,
    mouseenter_handler,
    mouseleave_handler
  ];
}
class InlineEditable extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$M, create_fragment$P, safe_not_equal, { store: 0, name: 1 });
  }
}
function create_default_slot_1$1(ctx) {
  let t;
  return {
    c() {
      t = text("clear cookies");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$j(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa fa-trash-o error");
      set_style(i2, "font-size", "1.5em");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(i2);
    }
  };
}
function create_fragment$O(ctx) {
  let tr;
  let td0;
  let inlineeditable;
  let t0;
  let td1;
  let t1_value = (ctx[5].cookies ? ctx[5].cookies.length : 0) + "";
  let t1;
  let t2;
  let td2;
  let button0;
  let t4;
  let button1;
  let t6;
  let div1;
  let confirmbtn0;
  let t7;
  let div0;
  let t8;
  let td3;
  let confirmbtn1;
  let current;
  let mounted;
  let dispose;
  inlineeditable = new InlineEditable({
    props: { store: ctx[0], name: "name" }
  });
  confirmbtn0 = new ConfirmBtn({
    props: {
      class: "btn-sm",
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  confirmbtn0.$on("click", ctx[8]);
  confirmbtn1 = new ConfirmBtn({
    props: {
      alignRight: "1",
      $$slots: { default: [create_default_slot$j] },
      $$scope: { ctx }
    }
  });
  confirmbtn1.$on("click", ctx[9]);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      create_component(inlineeditable.$$.fragment);
      t0 = space();
      td1 = element("td");
      t1 = text(t1_value);
      t2 = space();
      td2 = element("td");
      button0 = element("button");
      button0.textContent = "open remote browser";
      t4 = space();
      button1 = element("button");
      button1.textContent = "view monitors";
      t6 = space();
      div1 = element("div");
      create_component(confirmbtn0.$$.fragment);
      t7 = space();
      div0 = element("div");
      t8 = space();
      td3 = element("td");
      create_component(confirmbtn1.$$.fragment);
      set_style(td0, "min-width", "40%");
      attr(button0, "class", "btn btn-default btn-sm");
      attr(button1, "class", "btn btn-default btn-sm");
      attr(div1, "class", "inline");
      attr(td3, "title", "Delete");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      mount_component(inlineeditable, td0, null);
      append(tr, t0);
      append(tr, td1);
      append(td1, t1);
      append(tr, t2);
      append(tr, td2);
      append(td2, button0);
      append(td2, t4);
      append(td2, button1);
      append(td2, t6);
      append(td2, div1);
      mount_component(confirmbtn0, div1, null);
      append(div1, t7);
      append(div1, div0);
      append(tr, t8);
      append(tr, td3);
      mount_component(confirmbtn1, td3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[6]),
          listen(button1, "click", ctx[7])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const inlineeditable_changes = {};
      if (dirty & 1)
        inlineeditable_changes.store = ctx2[0];
      inlineeditable.$set(inlineeditable_changes);
      if ((!current || dirty & 32) && t1_value !== (t1_value = (ctx2[5].cookies ? ctx2[5].cookies.length : 0) + ""))
        set_data(t1, t1_value);
      const confirmbtn0_changes = {};
      if (dirty & 1024) {
        confirmbtn0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn0.$set(confirmbtn0_changes);
      const confirmbtn1_changes = {};
      if (dirty & 1024) {
        confirmbtn1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      confirmbtn1.$set(confirmbtn1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlineeditable.$$.fragment, local);
      transition_in(confirmbtn0.$$.fragment, local);
      transition_in(confirmbtn1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlineeditable.$$.fragment, local);
      transition_out(confirmbtn0.$$.fragment, local);
      transition_out(confirmbtn1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_component(inlineeditable);
      destroy_component(confirmbtn0);
      destroy_component(confirmbtn1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$L($$self, $$props, $$invalidate) {
  let $sess, $$unsubscribe_sess = noop$1, $$subscribe_sess = () => ($$unsubscribe_sess(), $$unsubscribe_sess = subscribe(sess, ($$value) => $$invalidate(5, $sess = $$value)), sess);
  $$self.$$.on_destroy.push(() => $$unsubscribe_sess());
  let { sess } = $$props;
  $$subscribe_sess();
  let { onClear: onClear2 } = $$props;
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let { onDelete } = $$props;
  const click_handler = (e) => openBrowser(sess);
  const click_handler_1 = (e) => showMonitors($sess);
  const click_handler_2 = (e) => onClear2(sess);
  const click_handler_3 = (e) => onDelete(sess);
  $$self.$$set = ($$props2) => {
    if ("sess" in $$props2)
      $$subscribe_sess($$invalidate(0, sess = $$props2.sess));
    if ("onClear" in $$props2)
      $$invalidate(1, onClear2 = $$props2.onClear);
    if ("openBrowser" in $$props2)
      $$invalidate(2, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(3, showMonitors = $$props2.showMonitors);
    if ("onDelete" in $$props2)
      $$invalidate(4, onDelete = $$props2.onDelete);
  };
  return [
    sess,
    onClear2,
    openBrowser,
    showMonitors,
    onDelete,
    $sess,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
class Profile extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$L, create_fragment$O, safe_not_equal, {
      sess: 0,
      onClear: 1,
      openBrowser: 2,
      showMonitors: 3,
      onDelete: 4
    });
  }
}
function get_each_context$f(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  child_ctx[15] = i2;
  return child_ctx;
}
function create_else_block$k(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No profile found.
      </td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block$f(key_1, ctx) {
  let first2;
  let profile;
  let current;
  profile = new Profile({
    props: {
      sess: ctx[13],
      onClear: ctx[2],
      openBrowser: ctx[0],
      showMonitors: ctx[1],
      onDelete: ctx[3]
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(profile.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(profile, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const profile_changes = {};
      if (dirty & 32)
        profile_changes.sess = ctx[13];
      if (dirty & 4)
        profile_changes.onClear = ctx[2];
      if (dirty & 1)
        profile_changes.openBrowser = ctx[0];
      if (dirty & 2)
        profile_changes.showMonitors = ctx[1];
      if (dirty & 8)
        profile_changes.onDelete = ctx[3];
      profile.$set(profile_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(profile.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profile.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(profile, detaching);
    }
  };
}
function create_fragment$N(ctx) {
  let div3;
  let div2;
  let div0;
  let h3;
  let t1;
  let small;
  let t2;
  let a;
  let t3;
  let t4;
  let div1;
  let t5;
  let searchbar;
  let t6;
  let listpager;
  let t7;
  let sortby;
  let t8;
  let table;
  let tbody;
  let tr0;
  let td;
  let t9;
  let tr1;
  let t16;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[7]);
  listpager = new ListPager({ props: { store: ctx[4] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[8],
      sortingFields: ctx[6],
      currentFieldName: ctx[5].orderBy
    }
  });
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let each_value = ctx[5].models;
  const get_key = (ctx2) => ctx2[13].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$f(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$f(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$k();
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      h3.textContent = "Profiles";
      t1 = space();
      small = element("small");
      t2 = text("Create and use profiles for checks in cloud that require cookies or authentication.\n      ");
      a = element("a");
      t3 = text("Learn More");
      t4 = space();
      div1 = element("div");
      t5 = space();
      create_component(searchbar.$$.fragment);
      t6 = space();
      create_component(listpager.$$.fragment);
      t7 = space();
      create_component(sortby.$$.fragment);
      t8 = space();
      table = element("table");
      tbody = element("tbody");
      tr0 = element("tr");
      td = element("td");
      if (default_slot)
        default_slot.c();
      t9 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<th>Name</th> 
        <th>Cookies</th> 
        <th>Options</th> 
        <th style="width: 20px"></th>`;
      t16 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      attr(a, "href", URL_WEBSITE + "/docs/web-monitor/profiles-for-cloud-monitors");
      attr(a, "target", "_blank");
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      set_style(div1, "max-width", "50px");
      attr(div2, "class", "card-header flex items-center");
      attr(td, "colspan", "4");
      set_style(td, "background-color", "#eee");
      attr(tr1, "class", "bg-gray-200");
      attr(table, "class", "table");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h3);
      append(div0, t1);
      append(div0, small);
      append(small, t2);
      append(small, a);
      append(a, t3);
      append(div2, t4);
      append(div2, div1);
      append(div2, t5);
      mount_component(searchbar, div2, null);
      append(div2, t6);
      mount_component(listpager, div2, null);
      append(div2, t7);
      mount_component(sortby, div2, null);
      append(div3, t8);
      append(div3, table);
      append(table, tbody);
      append(tbody, tr0);
      append(tr0, td);
      if (default_slot) {
        default_slot.m(td, null);
      }
      append(tbody, t9);
      append(tbody, tr1);
      append(tbody, t16);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const listpager_changes = {};
      if (dirty & 16)
        listpager_changes.store = ctx2[4];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty & 32)
        sortby_changes.currentFieldName = ctx2[5].orderBy;
      sortby.$set(sortby_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      if (dirty & 47) {
        each_value = ctx2[5].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$f, null, get_each_context$f);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$k();
          each_1_else.c();
          each_1_else.m(tbody, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      transition_in(default_slot, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      transition_out(default_slot, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(searchbar);
      destroy_component(listpager);
      destroy_component(sortby);
      if (default_slot)
        default_slot.d(detaching);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$K($$self, $$props, $$invalidate) {
  let $store;
  let { $$slots: slots = {}, $$scope } = $$props;
  let store2 = getContext("store");
  component_subscribe($$self, store2, (value) => $$invalidate(5, $store = value));
  store2.syncing;
  let { openBrowser } = $$props;
  let { showMonitors } = $$props;
  let { onClear: onClear2 } = $$props;
  let { onDelete } = $$props;
  let searchQuery = "";
  let sortingFields = [
    { value: "-ts", label: "Newest First" },
    { value: "ts", label: "Oldest First" },
    { value: "name", label: "Name" },
    {
      value: "-name",
      label: "Name - Descending"
    }
  ];
  async function onSearch(e) {
    let { phrase } = e.detail;
    if (!phrase) {
      store2.setQuery({});
      return await store2.fetch({ reset: true });
    }
    searchQuery = `%${phrase}%`;
    store2.setQuery({ "name.ilike": searchQuery });
    await store2.goto(0, { reset: true });
  }
  async function onSort(by) {
    $$invalidate(4, store2.orderBy = by, store2);
    await store2.fetch({ reset: true });
  }
  $$self.$$set = ($$props2) => {
    if ("openBrowser" in $$props2)
      $$invalidate(0, openBrowser = $$props2.openBrowser);
    if ("showMonitors" in $$props2)
      $$invalidate(1, showMonitors = $$props2.showMonitors);
    if ("onClear" in $$props2)
      $$invalidate(2, onClear2 = $$props2.onClear);
    if ("onDelete" in $$props2)
      $$invalidate(3, onDelete = $$props2.onDelete);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  return [
    openBrowser,
    showMonitors,
    onClear2,
    onDelete,
    store2,
    $store,
    sortingFields,
    onSearch,
    onSort,
    $$scope,
    slots
  ];
}
class List$4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$K, create_fragment$N, safe_not_equal, {
      openBrowser: 0,
      showMonitors: 1,
      onClear: 2,
      onDelete: 3
    });
  }
}
const get_header_slot_changes = (dirty) => ({});
const get_header_slot_context = (ctx) => ({});
function create_fragment$M(ctx) {
  let div5;
  let div4;
  let div3;
  let div0;
  let button0;
  let t1;
  let h4;
  let t2;
  let div1;
  let t3;
  let div2;
  let button1;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = ctx[4].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[3], get_header_slot_context);
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      button0 = element("button");
      button0.innerHTML = `<span aria-hidden="true">\xD7</span>`;
      t1 = space();
      h4 = element("h4");
      if (header_slot)
        header_slot.c();
      t2 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t3 = space();
      div2 = element("div");
      button1 = element("button");
      button1.textContent = "close modal";
      attr(button0, "type", "button");
      attr(button0, "class", "close");
      attr(button0, "data-dismiss", "modal");
      attr(button0, "aria-label", "Close");
      attr(h4, "class", "modal-title");
      attr(div0, "class", "modal-header");
      attr(div1, "class", "modal-body");
      attr(button1, "type", "button");
      button1.autofocus = true;
      attr(button1, "class", "btn btn-default");
      attr(div2, "class", "modal-footer");
      attr(div3, "class", "modal-content");
      attr(div4, "class", "modal-dialog");
      attr(div4, "role", "document");
      attr(div5, "class", "modal");
      attr(div5, "tabindex", "-1");
      attr(div5, "role", "dialog");
      set_style(div5, "display", "block");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div3);
      append(div3, div0);
      append(div0, button0);
      append(div0, t1);
      append(div0, h4);
      if (header_slot) {
        header_slot.m(h4, null);
      }
      append(div3, t2);
      append(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append(div3, t3);
      append(div3, div2);
      append(div2, button1);
      ctx[5](div5);
      current = true;
      button1.focus();
      if (!mounted) {
        dispose = [
          listen(window, "keydown", ctx[2]),
          listen(button1, "click", ctx[1]),
          listen(div5, "click", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(header_slot_template, ctx2[3], dirty, get_header_slot_changes),
            get_header_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (header_slot)
        header_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[5](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$J($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  const close = () => dispatch("close");
  let modal;
  const handle_keydown = (e) => {
    if (e.key === "Escape") {
      close();
      return;
    }
    if (e.key === "Tab") {
      const nodes = modal.querySelectorAll("*");
      const tabbable = Array.from(nodes).filter((n) => n.tabIndex >= 0);
      let index2 = tabbable.indexOf(document.activeElement);
      if (index2 === -1 && e.shiftKey)
        index2 = 0;
      index2 += tabbable.length + (e.shiftKey ? -1 : 1);
      index2 %= tabbable.length;
      tabbable[index2].focus();
      e.preventDefault();
    }
  };
  const previously_focused = typeof document !== "undefined" && document.activeElement;
  if (previously_focused) {
    onDestroy(() => {
      previously_focused.focus();
    });
  }
  function div5_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modal = $$value;
      $$invalidate(0, modal);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [modal, close, handle_keydown, $$scope, slots, div5_binding];
}
class Modal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$J, create_fragment$M, safe_not_equal, {});
  }
}
function get_each_context$e(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  child_ctx[24] = i2;
  return child_ctx;
}
function create_if_block_4$7(ctx) {
  let span;
  let t0;
  let t1_value = ctx[0].models.length + "";
  let t1;
  let t2;
  let t3;
  let t4;
  return {
    c() {
      span = element("span");
      t0 = text("Used ");
      t1 = text(t1_value);
      t2 = text(" of ");
      t3 = text(ctx[6]);
      t4 = text(" profiles.");
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(span, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[0].models.length + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_3$b(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Upgrade account to create and use profiles in cloud.";
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_1(ctx) {
  let div2;
  let div1;
  let div0;
  let input;
  let t0;
  let button;
  let t1;
  let t2;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[6] == 0)
      return create_if_block_3$b;
    if (ctx2[1])
      return create_if_block_4$7;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      button = element("button");
      t1 = text("Add New Profile");
      t2 = space();
      if (if_block)
        if_block.c();
      attr(input, "type", "text");
      attr(input, "class", "form-control");
      attr(input, "placeholder", "New Profile Name");
      attr(button, "class", "btn btn-default");
      attr(button, "role", "button");
      button.disabled = ctx[1];
      attr(div0, "class", "input-group mr3");
      attr(div1, "class", "col-6 col-lg-4 ");
      attr(div2, "class", "row");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, input);
      set_input_value(input, ctx[2]);
      append(div0, t0);
      append(div0, button);
      append(button, t1);
      append(div2, t2);
      if (if_block)
        if_block.m(div2, null);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[14]),
          listen(button, "click", ctx[8])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
      if (dirty & 2) {
        button.disabled = ctx2[1];
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div2, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (if_block) {
        if_block.d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$d(ctx) {
  let div;
  let browser2;
  let current;
  browser2 = new Browser({
    props: { session: ctx[3] }
  });
  browser2.$on("save", ctx[10]);
  browser2.$on("discard", ctx[11]);
  browser2.$on("clear", ctx[15]);
  return {
    c() {
      div = element("div");
      create_component(browser2.$$.fragment);
      attr(div, "class", "flex");
      set_style(div, "z-index", "10");
      set_style(div, "background-color", "#fff");
      set_style(div, "position", "fixed");
      set_style(div, "right", "0");
      set_style(div, "bottom", "0");
      set_style(div, "width", "70vw");
      set_style(div, "height", "80vh");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(browser2, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const browser_changes = {};
      if (dirty & 8)
        browser_changes.session = ctx2[3];
      browser2.$set(browser_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(browser2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(browser2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(browser2);
    }
  };
}
function create_if_block$o(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      $$slots: {
        header: [create_header_slot$7],
        default: [create_default_slot$i]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[16]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 33554448) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_else_block$j(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ctx[4].sieves;
  const get_key = (ctx2) => ctx2[22].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$e(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$e(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_1$7();
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16) {
        each_value = ctx2[4].sieves;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$e, each_1_anchor, get_each_context$e);
        if (each_value.length) {
          if (each_1_else) {
            each_1_else.d(1);
            each_1_else = null;
          }
        } else if (!each_1_else) {
          each_1_else = create_else_block_1$7();
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        }
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_if_block_1$h(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block_1$7(ctx) {
  let t;
  return {
    c() {
      t = text("No monitor found");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$e(key_1, ctx) {
  let div;
  let t_value = ctx[22].name + "";
  let t;
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      t = text(t_value);
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16 && t_value !== (t_value = ctx[22].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$i(ctx) {
  let div;
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[4].sieves)
      return create_if_block_1$h;
    return create_else_block$j;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      set_style(div, "max-height", "70vh");
      set_style(div, "overflow", "auto");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_header_slot$7(ctx) {
  let span;
  let t0;
  let t1_value = ctx[4].name + "";
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("Monitors - ");
      t1 = text(t1_value);
      attr(span, "slot", "header");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t1_value !== (t1_value = ctx2[4].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$L(ctx) {
  let list;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  list = new List$4({
    props: {
      store: ctx[7],
      openBrowser: ctx[12],
      showMonitors: ctx[13],
      onClear,
      onDelete: ctx[9],
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[3] && create_if_block_2$d(ctx);
  let if_block1 = ctx[4] && create_if_block$o(ctx);
  return {
    c() {
      create_component(list.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      insert(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const list_changes = {};
      if (dirty & 33554439) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$d(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$o(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
      if (detaching)
        detach(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
async function onClear(session) {
  await session.save({ cookies: [] });
}
function instance$I($$self, $$props, $$invalidate) {
  let $store;
  let $user;
  let api = getContext("api");
  let user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(17, $user = value));
  getContext("labels");
  let limit = $user.constraint.session;
  let limitReached = false;
  let newName;
  let openSession;
  let showMonitorsForSession = null;
  let store2 = new Sessions([], { orderBy: "-ts" });
  component_subscribe($$self, store2, (value) => $$invalidate(0, $store = value));
  setContext("api", api);
  setContext("store", store2);
  onMount(async () => {
    await store2.fetch();
  });
  async function onAdd() {
    $$invalidate(3, openSession = await store2.create({ name: newName || "Untitled" }));
    $$invalidate(2, newName = "");
  }
  async function onDelete(model) {
    await removeSessionFromSieve(model.id);
    await model.destroy();
  }
  async function removeSessionFromSieve(id2) {
    let res = await api(`/sieves?session_id=${id2}`, {
      "state.in": [40, 45, 90],
      _opt: { only: ["id"], limit: 100 }
    });
    let ids = res.data.map((s) => s.id);
    if (ids.length == 0) {
      return;
    }
    await api("/batch/sieves", "PUT", { ids, session_id: null });
    if (res.total_count > res.count) {
      await removeSessionFromSieve(id2);
    }
  }
  async function onSaveData(e) {
    let { cookies } = e.detail;
    await openSession.save({ cookies });
    $$invalidate(3, openSession = null);
  }
  function onDiscard() {
    $$invalidate(3, openSession = null);
  }
  function openBrowser(session) {
    $$invalidate(3, openSession = session);
  }
  async function showMonitors(session) {
    $$invalidate(4, showMonitorsForSession = { ...session, sieves: null });
    $$invalidate(4, showMonitorsForSession.sieves = (await api(`/sieves?state.in[0]=40&state.in[1]=45&_opt[limit]=500&session_id=${session.id}`)).data, showMonitorsForSession);
  }
  function input_input_handler() {
    newName = this.value;
    $$invalidate(2, newName);
  }
  const clear_handler = (e) => onClear(openSession.id);
  const close_handler = () => $$invalidate(4, showMonitorsForSession = null);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, limitReached = $store.length >= limit);
    }
  };
  return [
    $store,
    limitReached,
    newName,
    openSession,
    showMonitorsForSession,
    user,
    limit,
    store2,
    onAdd,
    onDelete,
    onSaveData,
    onDiscard,
    openBrowser,
    showMonitors,
    input_input_handler,
    clear_handler,
    close_handler
  ];
}
class Profiles extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$L, safe_not_equal, {});
  }
}
function createProxies(api) {
  let fetched = false;
  const { subscribe: subscribe2, set, update } = writable({
    loading: true,
    custom: {
      total_count: 0,
      count: 0,
      offset: 0,
      data: []
    },
    global: {
      total_count: 0,
      count: 0,
      offset: 0,
      data: []
    },
    plan_id: ""
  });
  async function fetch_custom_proxy() {
    const [custom, constraint, global2] = await Promise.all([
      api("/proxies"),
      api("/users/constraints"),
      api("/proxies/global?show_all=true")
    ]);
    for (let proxy of global2.data) {
      if (!proxy.children || proxy.children.length === 0) {
        continue;
      }
      const childProxies = proxy.children;
      const costs = childProxies.map((p) => p.cost);
      const minCost = Math.min(...costs);
      const maxCost = Math.max(...costs);
      if (minCost === maxCost) {
        proxy.cost_range = minCost;
      } else {
        proxy.cost_range = `${minCost} - ${maxCost}`;
      }
    }
    update((old) => ({
      loading: false,
      constraint,
      custom,
      global: global2,
      plan_id: constraint.plan_id
    }));
  }
  async function del(id2) {
    let res = await api("/proxies/" + id2, "DELETE");
    fetch_custom_proxy();
    return res;
  }
  async function add(doc) {
    const res = await api("/proxies", "POST", doc);
    fetch_custom_proxy();
    return res;
  }
  async function patch(doc) {
    const res = await api("/proxies/" + doc.id, "PATCH", doc);
    await fetch_custom_proxy();
    return res;
  }
  return {
    subscribe: subscribe2,
    async fetch() {
      !fetched && await fetch_custom_proxy();
      fetched = true;
    },
    del,
    add,
    patch
  };
}
var EditProxy_svelte_svelte_type_style_lang = "";
function create_if_block_1$g(ctx) {
  let p;
  let t;
  return {
    c() {
      p = element("p");
      t = text(ctx[1]);
      attr(p, "class", "error");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_default_slot$h(ctx) {
  let form;
  let div1;
  let label0;
  let t1;
  let div0;
  let input0;
  let t2;
  let div3;
  let label1;
  let t4;
  let div2;
  let input1;
  let t5;
  let span;
  let t9;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block_1$g(ctx);
  return {
    c() {
      form = element("form");
      div1 = element("div");
      label0 = element("label");
      label0.textContent = "Name";
      t1 = space();
      div0 = element("div");
      input0 = element("input");
      t2 = space();
      div3 = element("div");
      label1 = element("label");
      label1.textContent = "Proxy";
      t4 = space();
      div2 = element("div");
      input1 = element("input");
      t5 = space();
      span = element("span");
      span.innerHTML = `Add a proxy that authenticates using username and password. <br/> 
          Format: username:password@address:port<br/>
          Example: alpha:bravo@my-proxy-host:9000`;
      t9 = space();
      if (if_block)
        if_block.c();
      attr(label0, "for", "name");
      attr(label0, "class", "col-sm-3 col-form-label svelte-va63su");
      attr(input0, "id", "name");
      attr(input0, "type", "text");
      attr(input0, "class", "form-control");
      attr(input0, "placeholder", "A name to identify proxies from dropdowns");
      attr(div0, "class", "col-sm-9");
      attr(div1, "class", "form-group row");
      attr(label1, "for", "proxylist");
      attr(label1, "class", "col-sm-3 col-form-label svelte-va63su");
      attr(input1, "type", "text");
      attr(input1, "class", "form-control");
      attr(input1, "rows", "4");
      attr(span, "class", "help");
      attr(div2, "class", "col-sm-9");
      attr(div3, "class", "form-group row mt-1");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, div1);
      append(div1, label0);
      append(div1, t1);
      append(div1, div0);
      append(div0, input0);
      set_input_value(input0, ctx[0].name);
      append(form, t2);
      append(form, div3);
      append(div3, label1);
      append(div3, t4);
      append(div3, div2);
      append(div2, input1);
      set_input_value(input1, ctx[0].gateway);
      append(div2, t5);
      append(div2, span);
      append(form, t9);
      if (if_block)
        if_block.m(form, null);
      if (!mounted) {
        dispose = [
          listen(input0, "input", ctx[5]),
          listen(input1, "input", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input0.value !== ctx2[0].name) {
        set_input_value(input0, ctx2[0].name);
      }
      if (dirty & 1 && input1.value !== ctx2[0].gateway) {
        set_input_value(input1, ctx2[0].gateway);
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$g(ctx2);
          if_block.c();
          if_block.m(form, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(form);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$i(ctx) {
  let t;
  return {
    c() {
      t = text("Edit Proxy");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$n(ctx) {
  let t;
  return {
    c() {
      t = text("Add New Proxy");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_header_slot$6(ctx) {
  let span;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return create_if_block$n;
    return create_else_block$i;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      span = element("span");
      if_block.c();
      attr(span, "slot", "header");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if_block.m(span, null);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
      if_block.d();
    }
  };
}
function create_buttons_slot$2(ctx) {
  let span;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      button = element("button");
      button.textContent = "Save";
      attr(button, "class", "btn btn-primary");
      attr(span, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[4]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$K(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      $$slots: {
        buttons: [create_buttons_slot$2],
        header: [create_header_slot$6],
        default: [create_default_slot$h]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[3]);
  modal.$on("submit", ctx[4]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 515) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let { proxy } = $$props;
  const dispatch = createEventDispatcher();
  const store2 = getContext("store");
  let errMsg = "";
  let isNew = !proxy.id;
  function close() {
    dispatch("close");
  }
  async function handleEdit() {
    let gateway = proxy.gateway;
    $$invalidate(1, errMsg = "");
    if (/https*:\/\//.test(gateway)) {
      gateway = gateway.slice(gateway.indexOf(":") + 3);
    }
    try {
      let url = new URL("http://" + gateway);
      if (!url.username || !url.password) {
        throw new Error("Missing username or password");
      }
    } catch (e) {
      $$invalidate(1, errMsg = `Invalid proxy ${gateway} at line #${i + 1} (${e.message})`);
      return;
    }
    try {
      if (isNew) {
        await store2.add({ ...proxy, gateway });
      } else {
        await store2.patch({ ...proxy, gateway });
      }
      close();
    } catch (err) {
      $$invalidate(1, errMsg = err.message);
    }
  }
  function input0_input_handler() {
    proxy.name = this.value;
    $$invalidate(0, proxy);
  }
  function input1_input_handler() {
    proxy.gateway = this.value;
    $$invalidate(0, proxy);
  }
  $$self.$$set = ($$props2) => {
    if ("proxy" in $$props2)
      $$invalidate(0, proxy = $$props2.proxy);
  };
  return [
    proxy,
    errMsg,
    isNew,
    close,
    handleEdit,
    input0_input_handler,
    input1_input_handler
  ];
}
class EditProxy extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$K, safe_not_equal, { proxy: 0 });
  }
}
function get_each_context$d(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  child_ctx[8] = i2;
  return child_ctx;
}
function create_else_block$h(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td colspan="4">Click the add button to add your own proxies and use them for checks in cloud.</td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_if_block$m(ctx) {
  let tr;
  let td0;
  let t0_value = ctx[6].name + "";
  let t0;
  let t1;
  let td1;
  let t2_value = ctx[6].description + "";
  let t2;
  let t3;
  let td2;
  let div;
  let t4_value = ctx[6].gateway + "";
  let t4;
  let t5;
  let td3;
  let t7;
  let td4;
  let button1;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return ctx[3](ctx[6], ...args);
  }
  function click_handler_1(...args) {
    return ctx[4](ctx[6], ...args);
  }
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      div = element("div");
      t4 = text(t4_value);
      t5 = space();
      td3 = element("td");
      td3.innerHTML = `<button class="btn btn-default btn-sm btn-slim">Edit</button>`;
      t7 = space();
      td4 = element("td");
      button1 = element("button");
      button1.textContent = "Delete";
      set_style(div, "max-height", "200px");
      set_style(div, "overflow", "hidden");
      attr(button1, "class", "btn btn-danger btn-sm btn-slim");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, div);
      append(div, t4);
      append(tr, t5);
      append(tr, td3);
      append(tr, t7);
      append(tr, td4);
      append(td4, button1);
      if (!mounted) {
        dispose = [
          listen(td3, "click", click_handler),
          listen(button1, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[6].name + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t2_value !== (t2_value = ctx[6].description + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx[6].gateway + ""))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block$d(key_1, ctx) {
  let first2;
  let if_block_anchor;
  let if_block = ctx[6].state == 40 && create_if_block$m(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[6].state == 40) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$m(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$J(ctx) {
  let div2;
  let div1;
  let t1;
  let table;
  let thead;
  let t9;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t10;
  let tr1;
  let td;
  let button;
  let t12;
  let p;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[6].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$d(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$d(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$h();
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = `<div style="flex: 1"><h3>My Proxies (beta)</h3></div>`;
      t1 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th class="col-name">Name</th> 
        <th class="col-desc">Description</th> 
        <th class="col-gateway">Proxy</th> 
        <th class="col-edit"></th> 
        <th class="col-del"></th></tr>`;
      t9 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t10 = space();
      tr1 = element("tr");
      td = element("td");
      button = element("button");
      button.textContent = "Add New Proxy";
      t12 = space();
      p = element("p");
      p.textContent = "Custom proxies are available in Flexi in Enterprise plans";
      attr(div1, "class", "card-header flex items-center");
      attr(button, "class", "btn btn-primary");
      attr(p, "class", "help");
      attr(td, "colspan", "5");
      attr(table, "class", "table");
      attr(div2, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div2, t1);
      append(div2, table);
      append(table, thead);
      append(table, t9);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      append(tbody, t10);
      append(tbody, tr1);
      append(tr1, td);
      append(td, button);
      append(td, t12);
      append(td, p);
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 7) {
        each_value = ctx2[0];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, destroy_block, create_each_block$d, t10, get_each_context$d);
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$h();
          each_1_else.c();
          each_1_else.m(tbody, t10);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$G($$self, $$props, $$invalidate) {
  let { proxies } = $$props;
  let { onDelete } = $$props;
  let { onEdit } = $$props;
  const click_handler = (proxy, e) => onEdit(proxy);
  const click_handler_1 = (proxy, e) => onDelete(proxy.id);
  const click_handler_2 = (e) => onEdit({
    name: "New Proxy Name",
    gateway: "",
    description: ""
  });
  $$self.$$set = ($$props2) => {
    if ("proxies" in $$props2)
      $$invalidate(0, proxies = $$props2.proxies);
    if ("onDelete" in $$props2)
      $$invalidate(1, onDelete = $$props2.onDelete);
    if ("onEdit" in $$props2)
      $$invalidate(2, onEdit = $$props2.onEdit);
  };
  return [proxies, onDelete, onEdit, click_handler, click_handler_1, click_handler_2];
}
class List$3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$J, safe_not_equal, { proxies: 0, onDelete: 1, onEdit: 2 });
  }
}
function create_fragment$I(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", ctx[0]);
      attr(svg, "height", ctx[1]);
      attr(svg, "fill", "currentColor");
      attr(svg, "class", "bi bi-chevron-down");
      attr(svg, "viewBox", "0 0 16 16");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "width", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "height", ctx2[1]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$F($$self, $$props, $$invalidate) {
  let { width = "16" } = $$props;
  let { height = "16" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
  };
  return [width, height];
}
class ChevronDown extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$F, create_fragment$I, safe_not_equal, { width: 0, height: 1 });
  }
}
function create_fragment$H(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", ctx[0]);
      attr(svg, "height", ctx[1]);
      attr(svg, "fill", "currentColor");
      attr(svg, "class", "bi bi-chevron-right");
      attr(svg, "viewBox", "0 0 16 16");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "width", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "height", ctx2[1]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$E($$self, $$props, $$invalidate) {
  let { width = "16" } = $$props;
  let { height = "16" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
  };
  return [width, height];
}
class ChevronRight extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$H, safe_not_equal, { width: 0, height: 1 });
  }
}
function get_each_context$c(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2];
  child_ctx[3] = list;
  child_ctx[4] = i2;
  return child_ctx;
}
function get_each_context_1$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  child_ctx[7] = i2;
  return child_ctx;
}
function create_else_block_3(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td colspan="3">We are adding proxies to the inventory. Check back soon to view updated list.</td>`;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_if_block_3$a(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_4$6, create_else_block_2$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].open)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function click_handler() {
    return ctx[1](ctx[2], ctx[3], ctx[4]);
  }
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", "btn btn-sm border-0 shadow-none p-0");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_2$3(ctx) {
  let chevronright;
  let current;
  chevronright = new ChevronRight({ props: { width: "12", height: "12" } });
  return {
    c() {
      create_component(chevronright.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevronright, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevronright, detaching);
    }
  };
}
function create_if_block_4$6(ctx) {
  let chevrondown;
  let current;
  chevrondown = new ChevronDown({ props: { width: "12", height: "12" } });
  return {
    c() {
      create_component(chevrondown.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevrondown, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(chevrondown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevrondown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevrondown, detaching);
    }
  };
}
function create_else_block_1$6(ctx) {
  let t;
  return {
    c() {
      t = text("Available");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$c(ctx) {
  let t_value = ctx[2].msgUpgrade + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[2].msgUpgrade + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$l(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value_1 = ctx[2].children;
  const get_key = (ctx2) => ctx2[5].id;
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$3(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$3(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value_1 = ctx2[2].children;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block_1$3, each_1_anchor, get_each_context_1$3);
      }
    },
    d(detaching) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_else_block$g(ctx) {
  let t;
  return {
    c() {
      t = text("Available");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$f(ctx) {
  let t_value = ctx[5].msgUpgrade + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[5].msgUpgrade + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block_1$3(key_1, ctx) {
  let tr;
  let td0;
  let t0;
  let td1;
  let t1;
  let t2_value = ctx[5].grade + "";
  let t2;
  let t3;
  let td2;
  let t4_value = (ctx[5].cost || 2) + "";
  let t4;
  let t5;
  let td3;
  let t6_value = ctx[5].description + "";
  let t6;
  let t7;
  let td4;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[5].msgUpgrade)
      return create_if_block_1$f;
    return create_else_block$g;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      td0 = element("td");
      t0 = space();
      td1 = element("td");
      t1 = text("Grade ");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      t4 = text(t4_value);
      t5 = space();
      td3 = element("td");
      t6 = text(t6_value);
      t7 = space();
      td4 = element("td");
      if_block.c();
      set_style(td0, "width", "1em");
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(tr, t0);
      append(tr, td1);
      append(td1, t1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, t4);
      append(tr, t5);
      append(tr, td3);
      append(td3, t6);
      append(tr, t7);
      append(tr, td4);
      if_block.m(td4, null);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t2_value !== (t2_value = ctx[5].grade + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = (ctx[5].cost || 2) + ""))
        set_data(t4, t4_value);
      if (dirty & 1 && t6_value !== (t6_value = ctx[5].description + ""))
        set_data(t6, t6_value);
      if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(td4, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block.d();
    }
  };
}
function create_each_block$c(key_1, ctx) {
  var _a, _b, _c;
  let tr;
  let td0;
  let t0;
  let td1;
  let t1_value = ctx[2].name + "";
  let t1;
  let t2;
  let td2;
  let t3_value = (ctx[2].cost_range || ctx[2].cost || 2) + "";
  let t3;
  let t4;
  let td3;
  let t5_value = ctx[2].description + "";
  let t5;
  let t6;
  let td4;
  let t7;
  let if_block2_anchor;
  let current;
  let if_block0 = ((_b = (_a = ctx[2]) == null ? void 0 : _a.children) == null ? void 0 : _b.length) > 0 && create_if_block_3$a(ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[2].msgUpgrade)
      return create_if_block_2$c;
    return create_else_block_1$6;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type(ctx);
  let if_block2 = ((_c = ctx[2].children) == null ? void 0 : _c.length) > 0 && ctx[2].open && create_if_block$l(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      td0 = element("td");
      if (if_block0)
        if_block0.c();
      t0 = space();
      td1 = element("td");
      t1 = text(t1_value);
      t2 = space();
      td2 = element("td");
      t3 = text(t3_value);
      t4 = space();
      td3 = element("td");
      t5 = text(t5_value);
      t6 = space();
      td4 = element("td");
      if_block1.c();
      t7 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      set_style(td0, "width", "1em");
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      if (if_block0)
        if_block0.m(td0, null);
      append(tr, t0);
      append(tr, td1);
      append(td1, t1);
      append(tr, t2);
      append(tr, td2);
      append(td2, t3);
      append(tr, t4);
      append(tr, td3);
      append(td3, t5);
      append(tr, t6);
      append(tr, td4);
      if_block1.m(td4, null);
      insert(target, t7, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      var _a2, _b2, _c2;
      ctx = new_ctx;
      if (((_b2 = (_a2 = ctx[2]) == null ? void 0 : _a2.children) == null ? void 0 : _b2.length) > 0) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$a(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(td0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx[2].name + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & 1) && t3_value !== (t3_value = (ctx[2].cost_range || ctx[2].cost || 2) + ""))
        set_data(t3, t3_value);
      if ((!current || dirty & 1) && t5_value !== (t5_value = ctx[2].description + ""))
        set_data(t5, t5_value);
      if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {
        if_block1.p(ctx, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx);
        if (if_block1) {
          if_block1.c();
          if_block1.m(td4, null);
        }
      }
      if (((_c2 = ctx[2].children) == null ? void 0 : _c2.length) > 0 && ctx[2].open) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block$l(ctx);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if (if_block0)
        if_block0.d();
      if_block1.d();
      if (detaching)
        detach(t7);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function create_fragment$G(ctx) {
  let div2;
  let div1;
  let t3;
  let table;
  let thead;
  let t12;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t13;
  let tr1;
  let current;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[2].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$c(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$c(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_3();
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = `<div style="flex: 1"><h3>Managed Proxies</h3> 
      <small>Distill provided premium proxies available for checks in cloud.</small></div>`;
      t3 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><th width="1em"></th> 
        <th width="200">Name</th> 
        <th width="100">Cost*</th> 
        <th>Description</th> 
        <th width="200">Availability</th></tr>`;
      t12 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      t13 = space();
      tr1 = element("tr");
      tr1.innerHTML = `<td colspan="4">*The cost of using a proxy is accounted as checks in the account. If a proxy&#39;s cost is N, 1 check using that proxy will be counted as N checks.</td>`;
      attr(div1, "class", "card-header flex items-center");
      attr(table, "class", "table table-hover");
      attr(div2, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div2, t3);
      append(div2, table);
      append(table, thead);
      append(table, t12);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      append(tbody, t13);
      append(tbody, tr1);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$c, t13, get_each_context$c);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block_3();
          each_1_else.c();
          each_1_else.m(tbody, t13);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$D($$self, $$props, $$invalidate) {
  let { proxies } = $$props;
  const click_handler = (proxy, each_value, index2) => $$invalidate(0, each_value[index2].open = !proxy.open, proxies);
  $$self.$$set = ($$props2) => {
    if ("proxies" in $$props2)
      $$invalidate(0, proxies = $$props2.proxies);
  };
  return [proxies, click_handler];
}
class ListManaged extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$G, safe_not_equal, { proxies: 0 });
  }
}
function create_else_block$f(ctx) {
  let div0;
  let list;
  let t0;
  let div1;
  let t1;
  let div2;
  let listmanaged;
  let current;
  list = new List$3({
    props: {
      proxies: ctx[1].custom.data,
      onDelete: ctx[5],
      onEdit: ctx[4]
    }
  });
  listmanaged = new ListManaged({
    props: { proxies: ctx[1].global.data }
  });
  return {
    c() {
      div0 = element("div");
      create_component(list.$$.fragment);
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      create_component(listmanaged.$$.fragment);
      attr(div0, "class", "pe-2");
      attr(div1, "class", "p-2");
      attr(div2, "class", "pe-2");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      mount_component(list, div0, null);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      mount_component(listmanaged, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const list_changes = {};
      if (dirty & 2)
        list_changes.proxies = ctx2[1].custom.data;
      list.$set(list_changes);
      const listmanaged_changes = {};
      if (dirty & 2)
        listmanaged_changes.proxies = ctx2[1].global.data;
      listmanaged.$set(listmanaged_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      transition_in(listmanaged.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      transition_out(listmanaged.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      destroy_component(list);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div2);
      destroy_component(listmanaged);
    }
  };
}
function create_if_block_1$e(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "Loading data...";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$k(ctx) {
  let modaleditproxy;
  let current;
  modaleditproxy = new EditProxy({
    props: {
      proxy: ctx[0],
      api: ctx[2]
    }
  });
  modaleditproxy.$on("close", ctx[6]);
  return {
    c() {
      create_component(modaleditproxy.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modaleditproxy, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modaleditproxy_changes = {};
      if (dirty & 1)
        modaleditproxy_changes.proxy = ctx2[0];
      modaleditproxy.$set(modaleditproxy_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modaleditproxy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modaleditproxy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modaleditproxy, detaching);
    }
  };
}
function create_fragment$F(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_1$e, create_else_block$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1].loading)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[0] != null && create_if_block$k(ctx);
  return {
    c() {
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t.parentNode, t);
      }
      if (ctx2[0] != null) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$k(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let $store;
  let api = getContext("api");
  let store2 = createProxies(api);
  component_subscribe($$self, store2, (value) => $$invalidate(1, $store = value));
  window.store = store2;
  setContext("store", store2);
  let proxy = null;
  onMount(async () => {
    await store2.fetch();
  });
  async function onEdit(_proxy) {
    if ($store.constraint.price < 8e3) {
      alert("Custom proxies are only available in Flexi and higher plans");
      return;
    }
    $$invalidate(0, proxy = _proxy);
  }
  async function onDelete(id2) {
    await store2.del(id2);
  }
  const close_handler = () => $$invalidate(0, proxy = null);
  return [proxy, $store, api, store2, onEdit, onDelete, close_handler];
}
class Proxies extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$F, safe_not_equal, {});
  }
}
function create_catch_block$a(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$a(ctx) {
  let recordermodal;
  let current;
  recordermodal = new Modal$1({
    props: {
      widthClass: "modal-fullscreen",
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(recordermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recordermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recordermodal_changes = {};
      if (dirty & 64) {
        recordermodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      recordermodal.$set(recordermodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recordermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recordermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recordermodal, detaching);
    }
  };
}
function create_default_slot$g(ctx) {
  let recorder;
  let current;
  recorder = new Recorder({
    props: { class: "w-full", macro: ctx[0] }
  });
  recorder.$on("cancel", ctx[3]);
  recorder.$on("save", ctx[2]);
  return {
    c() {
      create_component(recorder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recorder, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(recorder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recorder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recorder, detaching);
    }
  };
}
function create_pending_block$a(ctx) {
  let t;
  return {
    c() {
      t = text("Loading macro");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$E(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$a,
    then: create_then_block$a,
    catch: create_catch_block$a,
    value: 5,
    blocks: [, , ,]
  };
  handle_promise(ctx[1], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let { macroId } = $$props;
  setContext("Msg", Msg);
  const macro = new Macro$1({ id: macroId });
  const fetchPromise = macro.fetch();
  async function onSaveMacro(e) {
    let { steps, params: params2 } = e.detail;
    await macro.save({ steps, spec: { params: params2 } });
    pop();
  }
  function onDiscardMacro() {
    pop();
  }
  $$self.$$set = ($$props2) => {
    if ("macroId" in $$props2)
      $$invalidate(4, macroId = $$props2.macroId);
  };
  return [macro, fetchPromise, onSaveMacro, onDiscardMacro, macroId];
}
class StandaloneRecorder extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$E, safe_not_equal, { macroId: 4 });
  }
}
function create_catch_block$9(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$9(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let list;
  let current;
  const if_block_creators = [
    create_if_block$j,
    create_if_block_2$b,
    create_if_block_3$9,
    create_if_block_5$2,
    create_if_block_6$1,
    create_if_block_7$1,
    create_else_block_1$5
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].module == "sieve")
      return 0;
    if (ctx2[0].module == "import")
      return 1;
    if (ctx2[0].module == "macros")
      return 2;
    if (ctx2[0].module == "profiles")
      return 3;
    if (ctx2[0].module == "proxies")
      return 4;
    if (ctx2[0].module == "list")
      return 5;
    return 6;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  list = new List$6({
    props: {
      hidden: ctx[0].module != "list"
    }
  });
  return {
    c() {
      if_block.c();
      t = space();
      create_component(list.$$.fragment);
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
      const list_changes = {};
      if (dirty & 1)
        list_changes.hidden = ctx2[0].module != "list";
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      destroy_component(list, detaching);
    }
  };
}
function create_else_block_1$5(ctx) {
  let error404;
  let current;
  error404 = new Error404({ props: { useLayout: false } });
  return {
    c() {
      create_component(error404.$$.fragment);
    },
    m(target, anchor) {
      mount_component(error404, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(error404.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(error404.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(error404, detaching);
    }
  };
}
function create_if_block_7$1(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_if_block_6$1(ctx) {
  let proxies;
  let current;
  proxies = new Proxies({});
  return {
    c() {
      create_component(proxies.$$.fragment);
    },
    m(target, anchor) {
      mount_component(proxies, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(proxies.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(proxies.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(proxies, detaching);
    }
  };
}
function create_if_block_5$2(ctx) {
  let profiles;
  let current;
  profiles = new Profiles({});
  return {
    c() {
      create_component(profiles.$$.fragment);
    },
    m(target, anchor) {
      mount_component(profiles, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(profiles.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(profiles.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(profiles, detaching);
    }
  };
}
function create_if_block_3$9(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$5, create_else_block$e];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3].id !== void 0)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_2$b(ctx) {
  let import_1;
  let current;
  import_1 = new Import({ props: { route: ctx[0] } });
  return {
    c() {
      create_component(import_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(import_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const import_1_changes = {};
      if (dirty & 1)
        import_1_changes.route = ctx2[0];
      import_1.$set(import_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(import_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(import_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(import_1, detaching);
    }
  };
}
function create_if_block$j(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (ctx[0].prefix == "dup" || ctx[0].prefix == "add" || ctx[0].prefix == "edit") && create_if_block_1$d();
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0].prefix == "dup" || ctx2[0].prefix == "add" || ctx2[0].prefix == "edit") {
        if (if_block) {
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$d();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$e(ctx) {
  let macros;
  let current;
  macros = new Macros_1({ props: { route: ctx[0] } });
  return {
    c() {
      create_component(macros.$$.fragment);
    },
    m(target, anchor) {
      mount_component(macros, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const macros_changes = {};
      if (dirty & 1)
        macros_changes.route = ctx2[0];
      macros.$set(macros_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(macros.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(macros.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(macros, detaching);
    }
  };
}
function create_if_block_4$5(ctx) {
  let standalonerecorder;
  let current;
  standalonerecorder = new StandaloneRecorder({ props: { macroId: ctx[3].id } });
  return {
    c() {
      create_component(standalonerecorder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(standalonerecorder, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(standalonerecorder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(standalonerecorder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(standalonerecorder, detaching);
    }
  };
}
function create_if_block_1$d(ctx) {
  let edit;
  let current;
  edit = new Sieve_options({});
  return {
    c() {
      create_component(edit.$$.fragment);
    },
    m(target, anchor) {
      mount_component(edit, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(edit.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edit.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(edit, detaching);
    }
  };
}
function create_pending_block$9(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$f(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$9,
    then: create_then_block$9,
    catch: create_catch_block$9,
    blocks: [, , ,]
  };
  handle_promise(ctx[2], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$D(ctx) {
  let watchlistlayout;
  let current;
  watchlistlayout = new WatchListLayout({
    props: {
      contentScrollTop: ctx[1],
      renderDefaultToolbar: !["list", "sieve", "tpls"].includes(ctx[0].module) || ctx[0].module === "tpls" && ctx[0].prefix !== "add-from",
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    }
  });
  watchlistlayout.$on("scroll", ctx[4]);
  return {
    c() {
      create_component(watchlistlayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(watchlistlayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const watchlistlayout_changes = {};
      if (dirty & 2)
        watchlistlayout_changes.contentScrollTop = ctx2[1];
      if (dirty & 1)
        watchlistlayout_changes.renderDefaultToolbar = !["list", "sieve", "tpls"].includes(ctx2[0].module) || ctx2[0].module === "tpls" && ctx2[0].prefix !== "add-from";
      if (dirty & 262145) {
        watchlistlayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      watchlistlayout.$set(watchlistlayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(watchlistlayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(watchlistlayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(watchlistlayout, detaching);
    }
  };
}
function matchRoute(rParam, path) {
  let i2 = 0, params2 = {};
  let matches = rParam.pattern.exec(path);
  while (i2 < rParam.keys.length) {
    params2[rParam.keys[i2]] = matches[++i2] || null;
  }
  return params2;
}
function hasFolderChanged({ oldRoute, newRoute }) {
  const newPrefix = newRoute.prefix;
  const newWild = newRoute.wild;
  if (oldRoute.prefix === newPrefix && oldRoute.wild && !newWild) {
    return false;
  }
  if (newPrefix !== "label" && !newWild) {
    return true;
  }
  if (newPrefix === "label") {
    if (oldRoute.data !== newRoute.data) {
      return true;
    }
  }
  return false;
}
function instance$A($$self, $$props, $$invalidate) {
  let $route;
  let $querystring;
  component_subscribe($$self, route, ($$value) => $$invalidate(0, $route = $$value));
  component_subscribe($$self, querystring, ($$value) => $$invalidate(8, $querystring = $$value));
  let { params: params2 = {} } = $$props;
  let contentScrollTop = 0;
  let lastListScrollTop = 0;
  const user = getContext("user");
  const labels = getContext("labels");
  const clients = new ModelClient.Clients(user.clients);
  clients.setQuery({ is_worker: 1 });
  clients.defaultId = getContext("clientId");
  const sieves = new Model$2.Sieves(null, {});
  setContext("clients", clients);
  setContext("watchlist:stores", { clients, sieves });
  const initPromise = fetchAll();
  let query = qs.parse($querystring);
  setTimeout(
    () => {
      if (Supports.agents.local) {
        clientMsgs.fetch();
      }
      if (user.isLoggedIn()) {
        userMsgs.fetch({ data: { ts_viewed: "$null" } });
      }
    },
    2e3
  );
  window.App.clients = clients;
  window.App.sieves = sieves;
  const routes = [":data.d/:id.id", ":data.d/", ":id.id", ""];
  const rParams = routes.map(parse$2);
  function onParamsChange(params3) {
    let { prefix, wild } = params3;
    if (wild) {
      let path = "/" + wild;
      for (let rp of rParams) {
        if (rp.pattern.test(path)) {
          params3 = { ...params3, ...matchRoute(rp, path) };
          break;
        }
      }
    }
    params3.query = qs.parse($querystring);
    const oldRoute = $route;
    let oldModule = $route.module;
    let newModule = params3.module;
    let oldTeam = $route.team;
    let newTeam = params3.team;
    if (oldTeam != newTeam) {
      Api.setIdentityId(newTeam == 0 ? null : newTeam);
      if (oldTeam !== void 0) {
        fetchAll();
      }
    }
    route.set(params3);
    if (oldModule != newModule) {
      if (oldModule == "list") {
        $$invalidate(1, contentScrollTop = lastListScrollTop);
      } else if (newModule == "list") {
        $$invalidate(1, contentScrollTop += 1);
      }
    } else {
      if (hasFolderChanged({ oldRoute, newRoute: params3 })) {
        if (contentScrollTop === 0) {
          $$invalidate(1, contentScrollTop = 1);
        } else {
          $$invalidate(1, contentScrollTop = 0);
        }
      }
    }
  }
  function onScroll(e) {
    $route.module == "list" && (lastListScrollTop = e.target.scrollTop);
  }
  instance$5s.on("clients", fetchClients);
  instance$5s.on("tags", fetchLabels);
  onDestroy(() => {
    instance$5s.off("clients", fetchClients);
    instance$5s.off("tags", fetchLabels);
  });
  async function fetchClients() {
    await clients.fetch();
  }
  async function fetchAll() {
    await Promise.all([fetchClients()]);
  }
  async function fetchLabels() {
    await labels.fetch();
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(5, params2 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        window.App.route = $route;
      }
    }
    if ($$self.$$.dirty & 32) {
      {
        onParamsChange(params2);
      }
    }
  };
  return [$route, contentScrollTop, initPromise, query, onScroll, params2];
}
class Watchlist extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$D, safe_not_equal, { params: 5 });
  }
}
function create_else_block$d(ctx) {
  let t;
  return {
    c() {
      t = text("N/A");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$i(ctx) {
  var _a;
  let t0;
  let t1_value = ((_a = ctx[3]) == null ? void 0 : _a.total) + "";
  let t1;
  let t2;
  let t3_value = ctx[3].queued + "";
  let t3;
  let t4;
  let t5_value = ctx[3].crawled + "";
  let t5;
  let t6;
  let t7_value = ctx[3].errorred + "";
  let t7;
  return {
    c() {
      t0 = text("Total: ");
      t1 = text(t1_value);
      t2 = text(", Queued: ");
      t3 = text(t3_value);
      t4 = text(", Crawled: ");
      t5 = text(t5_value);
      t6 = text(", Errorred: ");
      t7 = text(t7_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
      insert(target, t5, anchor);
      insert(target, t6, anchor);
      insert(target, t7, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(t7);
    }
  };
}
function create_fragment$C(ctx) {
  let tr;
  let td0;
  let a;
  let t0_value = ctx[1].name + "";
  let t0;
  let a_href_value;
  let t1;
  let td1;
  let t2_value = (ctx[1].url || "N/A") + "";
  let t2;
  let t3;
  let td2;
  let t4_value = new Date(ctx[1].ts).toLocaleString() + "";
  let t4;
  let t5;
  let td3;
  let t6;
  let td4;
  let span;
  let tr_id_value;
  function select_block_type(ctx2, dirty) {
    var _a;
    if ((_a = ctx2[3]) == null ? void 0 : _a.total)
      return create_if_block$i;
    return create_else_block$d;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      tr = element("tr");
      td0 = element("td");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      t4 = text(t4_value);
      t5 = space();
      td3 = element("td");
      if_block.c();
      t6 = space();
      td4 = element("td");
      span = element("span");
      span.textContent = `${ctx[4]() ? "Active" : "Inactive"}`;
      attr(a, "href", a_href_value = "#/u/" + ctx[2] + "/crawlers/" + ctx[1].id);
      attr(tr, "id", tr_id_value = ctx[1].id);
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, a);
      append(a, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, t4);
      append(tr, t5);
      append(tr, td3);
      if_block.m(td3, null);
      append(tr, t6);
      append(tr, td4);
      append(td4, span);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1].name + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && a_href_value !== (a_href_value = "#/u/" + ctx2[2] + "/crawlers/" + ctx2[1].id)) {
        attr(a, "href", a_href_value);
      }
      if (dirty & 2 && t2_value !== (t2_value = (ctx2[1].url || "N/A") + ""))
        set_data(t2, t2_value);
      if (dirty & 2 && t4_value !== (t4_value = new Date(ctx2[1].ts).toLocaleString() + ""))
        set_data(t4, t4_value);
      if_block.p(ctx2, dirty);
      if (dirty & 2 && tr_id_value !== (tr_id_value = ctx2[1].id)) {
        attr(tr, "id", tr_id_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
      if_block.d();
    }
  };
}
function instance$z($$self, $$props, $$invalidate) {
  let $crawler, $$unsubscribe_crawler = noop$1, $$subscribe_crawler = () => ($$unsubscribe_crawler(), $$unsubscribe_crawler = subscribe(crawler, ($$value) => $$invalidate(1, $crawler = $$value)), crawler);
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(5, $params = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_crawler());
  let { crawler } = $$props;
  $$subscribe_crawler();
  let team = $params == null ? void 0 : $params.team;
  let meta = $crawler.meta;
  function isReady() {
    return $crawler.state === C$1.STATE_READY;
  }
  $$self.$$set = ($$props2) => {
    if ("crawler" in $$props2)
      $$subscribe_crawler($$invalidate(0, crawler = $$props2.crawler));
  };
  return [crawler, $crawler, team, meta, isReady];
}
class Crawler extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$C, safe_not_equal, { crawler: 0 });
  }
}
function get_each_context$b(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  child_ctx[8] = i2;
  return child_ctx;
}
function create_else_block$c(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No crawler found</td> 
        `;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block$b(key_1, ctx) {
  let first2;
  let crawler;
  let current;
  crawler = new Crawler({ props: { crawler: ctx[6] } });
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(crawler.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(crawler, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const crawler_changes = {};
      if (dirty & 2)
        crawler_changes.crawler = ctx[6];
      crawler.$set(crawler_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(crawler.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(crawler.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(crawler, detaching);
    }
  };
}
function create_fragment$B(ctx) {
  let div3;
  let div2;
  let div0;
  let t3;
  let div1;
  let t4;
  let searchbar;
  let t5;
  let listpager;
  let t6;
  let sortby;
  let t7;
  let table;
  let thead;
  let t17;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[4]);
  listpager = new ListPager({ props: { store: ctx[0] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[3],
      sortingFields: ctx[2],
      currentFieldName: ctx[1].orderBy
    }
  });
  let each_value = ctx[1].models;
  const get_key = (ctx2) => ctx2[6].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$b(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$b(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$c();
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3>Crawlers</h3> 
    <small>Manage all available crawlers</small>`;
      t3 = space();
      div1 = element("div");
      t4 = space();
      create_component(searchbar.$$.fragment);
      t5 = space();
      create_component(listpager.$$.fragment);
      t6 = space();
      create_component(sortby.$$.fragment);
      t7 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="bg-gray-200"><th>Name</th> 
      <th>Start URL</th> 
      <th>Created On</th> 
      <th>Last Run Summary</th> 
      <th>State</th></tr>`;
      t17 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      set_style(div1, "max-width", "50px");
      attr(div2, "class", "card-header flex items-center");
      attr(thead, "class", "table-light");
      attr(table, "class", "table");
      attr(div3, "class", "card panel-default");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t3);
      append(div2, div1);
      append(div2, t4);
      mount_component(searchbar, div2, null);
      append(div2, t5);
      mount_component(listpager, div2, null);
      append(div2, t6);
      mount_component(sortby, div2, null);
      append(div3, t7);
      append(div3, table);
      append(table, thead);
      append(table, t17);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      const listpager_changes = {};
      if (dirty & 1)
        listpager_changes.store = ctx2[0];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty & 2)
        sortby_changes.currentFieldName = ctx2[1].orderBy;
      sortby.$set(sortby_changes);
      if (dirty & 2) {
        each_value = ctx2[1].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$b, null, get_each_context$b);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$c();
          each_1_else.c();
          each_1_else.m(tbody, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(searchbar.$$.fragment, local);
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      transition_out(searchbar.$$.fragment, local);
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(searchbar);
      destroy_component(listpager);
      destroy_component(sortby);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (each_1_else)
        each_1_else.d();
    }
  };
}
function instance$y($$self, $$props, $$invalidate) {
  let $store, $$unsubscribe_store = noop$1, $$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store2, ($$value) => $$invalidate(1, $store = $$value)), store2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_store());
  const sortingFields = [
    { value: "ts", label: "Created" },
    {
      value: "-ts",
      label: "Created - Descending"
    },
    { value: "url", label: "Url" },
    { value: "-url", label: "Url - Descending" },
    { value: "name", label: "Name" },
    {
      value: "-name",
      label: "Name - Descending"
    }
  ];
  let searchQuery = "";
  let { store: store2 = new Crawlers() } = $$props;
  $$subscribe_store();
  async function onSort(by) {
    $$invalidate(0, store2.orderBy = by, store2);
    await store2.fetch({ reset: true });
  }
  async function onSearch(e) {
    let { phrase } = e.detail;
    if (!phrase) {
      store2.setQuery({});
      return await store2.fetch({ reset: true });
    }
    searchQuery = `%${phrase}%`;
    store2.setQuery({
      $or: {
        "name.ilike": searchQuery,
        "config:->>'url'.ilike": searchQuery
      }
    });
    return await store2.goto(0, { reset: true });
  }
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$subscribe_store($$invalidate(0, store2 = $$props2.store));
  };
  return [store2, $store, sortingFields, onSort, onSearch];
}
class List$2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$B, safe_not_equal, { store: 0 });
  }
}
function create_default_slot$e(ctx) {
  let div2;
  let div1;
  let div0;
  let list;
  let current;
  list = new List$2({ props: { store: ctx[0] } });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(list.$$.fragment);
      attr(div0, "class", "col-sm-12");
      attr(div1, "class", "row");
      attr(div2, "class", "container");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      mount_component(list, div0, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(list);
    }
  };
}
function create_header_slot$5(ctx) {
  let svlelte_fragment;
  return {
    c() {
      svlelte_fragment = element("svlelte:fragment");
      svlelte_fragment.innerHTML = `<div class="inline-block fw4 f2">Crawlers</div>`;
      attr(svlelte_fragment, "slot", "header");
    },
    m(target, anchor) {
      insert(target, svlelte_fragment, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(svlelte_fragment);
    }
  };
}
function create_topbar_slot$4(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({
    props: {
      showSearch: false,
      $$slots: { header: [create_header_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (dirty & 2) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topbar.$set(topbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$A(ctx) {
  let t;
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      renderDefaultToolbar: true,
      $$slots: {
        topbar: [create_topbar_slot$4],
        default: [create_default_slot$e]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(layout.$$.fragment);
      document.title = "Crawlers | Distill.io";
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 2) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(layout, detaching);
    }
  };
}
function instance$x($$self) {
  let store2 = new Crawlers();
  setContext("store", store2);
  onMount(async () => {
    await store2.fetch();
  });
  return [store2];
}
class Crawlers_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$A, safe_not_equal, {});
  }
}
function create_fragment$z(ctx) {
  let svg;
  let g0;
  let g1;
  let g3;
  let g2;
  let path;
  let svg_levels = [
    { viewBox: "0 0 24 24" },
    { fill: "none" },
    { xmlns: "http://www.w3.org/2000/svg" },
    { stroke: "currentColor" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      g0 = svg_element("g");
      g1 = svg_element("g");
      g3 = svg_element("g");
      g2 = svg_element("g");
      path = svg_element("path");
      attr(g0, "stroke-width", "0");
      attr(g1, "stroke-linecap", "round");
      attr(g1, "stroke-linejoin", "round");
      attr(path, "d", "M4 12L8.94975 16.9497L19.5572 6.34326");
      attr(path, "stroke-width", "3");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      attr(g2, "id", "Interface / Check_Big");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g0);
      append(svg, g1);
      append(svg, g3);
      append(g3, g2);
      append(g2, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { viewBox: "0 0 24 24" },
        { fill: "none" },
        { xmlns: "http://www.w3.org/2000/svg" },
        { stroke: "currentColor" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Check extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$z, safe_not_equal, {});
  }
}
function create_fragment$y(ctx) {
  let svg;
  let g0;
  let g1;
  let g3;
  let g2;
  let path;
  let svg_levels = [
    { viewBox: "0 0 24 24" },
    { fill: "none" },
    { xmlns: "http://www.w3.org/2000/svg" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      g0 = svg_element("g");
      g1 = svg_element("g");
      g3 = svg_element("g");
      g2 = svg_element("g");
      path = svg_element("path");
      attr(g0, "stroke-width", "0");
      attr(g1, "stroke-linecap", "round");
      attr(g1, "stroke-linejoin", "round");
      attr(path, "d", "M10 8H5V3M5.29102 16.3569C6.22284 17.7918 7.59014 18.8902 9.19218 19.4907C10.7942 20.0913 12.547 20.1624 14.1925 19.6937C15.8379 19.225 17.2893 18.2413 18.3344 16.8867C19.3795 15.5321 19.963 13.878 19.9989 12.1675C20.0347 10.4569 19.5211 8.78001 18.5337 7.38281C17.5462 5.98561 16.1366 4.942 14.5122 4.40479C12.8878 3.86757 11.1341 3.86499 9.5083 4.39795C7.88252 4.93091 6.47059 5.97095 5.47949 7.36556");
      attr(path, "stroke", "#000000");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g0);
      append(svg, g1);
      append(svg, g3);
      append(g3, g2);
      append(g2, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { viewBox: "0 0 24 24" },
        { fill: "none" },
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class ReloadCircle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$y, safe_not_equal, {});
  }
}
function create_fragment$x(ctx) {
  let svg;
  let path;
  let animateTransform;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      animateTransform = svg_element("animateTransform");
      attr(animateTransform, "attributeName", "transform");
      attr(animateTransform, "attributeType", "XML");
      attr(animateTransform, "type", "rotate");
      attr(animateTransform, "dur", "1s");
      attr(animateTransform, "from", "0 50 50");
      attr(animateTransform, "to", "360 50 50");
      attr(animateTransform, "repeatCount", "indefinite");
      attr(path, "d", "M31.6,3.5C5.9,13.6-6.6,42.7,3.5,68.4c10.1,25.7,39.2,38.3,64.9,28.1l-3.1-7.9c-21.3,8.4-45.4-2-53.8-23.3\n  c-8.4-21.3,2-45.4,23.3-53.8L31.6,3.5z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "x", "0px");
      attr(svg, "y", "0px");
      attr(svg, "viewBox", "0 0 100 100");
      attr(svg, "xml:space", "preserve");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(path, animateTransform);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class Loading extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$x, safe_not_equal, {});
  }
}
function create_fragment$w(ctx) {
  let svg;
  let g0;
  let g1;
  let g3;
  let g2;
  let path;
  let svg_levels = [
    { viewBox: "0 0 24 24" },
    { fill: "currentColor" },
    { xmlns: "http://www.w3.org/2000/svg" },
    { stroke: "currentColor" },
    ctx[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      g0 = svg_element("g");
      g1 = svg_element("g");
      g3 = svg_element("g");
      g2 = svg_element("g");
      path = svg_element("path");
      attr(g0, "stroke-width", "0");
      attr(g1, "stroke-linecap", "round");
      attr(g1, "stroke-linejoin", "round");
      attr(path, "d", "M5 17.3336V6.66698C5 5.78742 5 5.34715 5.18509 5.08691C5.34664 4.85977 5.59564 4.71064 5.87207 4.67499C6.18868 4.63415 6.57701 4.84126 7.35254 5.25487L17.3525 10.5882L17.3562 10.5898C18.2132 11.0469 18.642 11.2756 18.7826 11.5803C18.9053 11.8462 18.9053 12.1531 18.7826 12.4189C18.6418 12.7241 18.212 12.9537 17.3525 13.4121L7.35254 18.7454C6.57645 19.1593 6.1888 19.3657 5.87207 19.3248C5.59564 19.2891 5.34664 19.1401 5.18509 18.9129C5 18.6527 5 18.2132 5 17.3336Z");
      attr(path, "stroke-width", "2");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-linejoin", "round");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g0);
      append(svg, g1);
      append(svg, g3);
      append(g3, g2);
      append(g2, path);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { viewBox: "0 0 24 24" },
        { fill: "currentColor" },
        { xmlns: "http://www.w3.org/2000/svg" },
        { stroke: "currentColor" },
        dirty & 1 && ctx2[0]
      ]));
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
class Start extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$w, safe_not_equal, {});
  }
}
var RunDetail_svelte_svelte_type_style_lang = "";
function create_if_block_4$4(ctx) {
  let t0;
  let div;
  let t1_value = ctx[5][ctx[0].meta.type] + "";
  let t1;
  return {
    c() {
      t0 = text(":\xA0");
      div = element("div");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, div, anchor);
      append(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = ctx2[5][ctx2[0].meta.type] + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3$8(ctx) {
  var _a;
  let div;
  let span0;
  let t0_value = ((_a = ctx[0].meta) == null ? void 0 : _a.error.code) + "";
  let t0;
  let span0_data_bs_target_value;
  let span0_aria_controls_value;
  let t1;
  let span1;
  let a0;
  let t3;
  let a1;
  let span1_class_value;
  let span1_data_bs_target_value;
  let span1_aria_controls_value;
  return {
    c() {
      var _a2, _b;
      div = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      a0 = element("a");
      a0.innerHTML = `Show details <i class="fa fa-caret-down"></i>`;
      t3 = space();
      a1 = element("a");
      a1.innerHTML = `Hide details <i class="fa fa-caret-up"></i>`;
      attr(span0, "data-bs-toggle", "collapse");
      attr(span0, "data-bs-target", span0_data_bs_target_value = "#collapseErrorDetails-" + ctx[0].id);
      attr(span0, "aria-expanded", "false");
      attr(span0, "aria-controls", span0_aria_controls_value = "collapseErrorDetails-" + ctx[0].id);
      attr(a0, "href", "javascript:void(0)");
      attr(a0, "class", "if-collapsed svelte-1dm9k6n");
      attr(a1, "href", "javascript:void(0)");
      attr(a1, "class", "if-not-collapsed svelte-1dm9k6n");
      attr(span1, "class", span1_class_value = "collapsed help text-nowrap " + (((_b = (_a2 = ctx[0].meta) == null ? void 0 : _a2.error) == null ? void 0 : _b.url) ? "ms-3" : "") + " svelte-1dm9k6n");
      attr(span1, "data-bs-toggle", "collapse");
      attr(span1, "data-bs-target", span1_data_bs_target_value = "#collapseErrorDetails-" + ctx[0].id);
      attr(span1, "aria-expanded", "false");
      attr(span1, "aria-controls", span1_aria_controls_value = "collapseErrorDetails-" + ctx[0].id);
      attr(div, "class", "mx-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(span0, t0);
      append(div, t1);
      append(div, span1);
      append(span1, a0);
      append(span1, t3);
      append(span1, a1);
    },
    p(ctx2, dirty) {
      var _a2, _b, _c;
      if (dirty & 1 && t0_value !== (t0_value = ((_a2 = ctx2[0].meta) == null ? void 0 : _a2.error.code) + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && span0_data_bs_target_value !== (span0_data_bs_target_value = "#collapseErrorDetails-" + ctx2[0].id)) {
        attr(span0, "data-bs-target", span0_data_bs_target_value);
      }
      if (dirty & 1 && span0_aria_controls_value !== (span0_aria_controls_value = "collapseErrorDetails-" + ctx2[0].id)) {
        attr(span0, "aria-controls", span0_aria_controls_value);
      }
      if (dirty & 1 && span1_class_value !== (span1_class_value = "collapsed help text-nowrap " + (((_c = (_b = ctx2[0].meta) == null ? void 0 : _b.error) == null ? void 0 : _c.url) ? "ms-3" : "") + " svelte-1dm9k6n")) {
        attr(span1, "class", span1_class_value);
      }
      if (dirty & 1 && span1_data_bs_target_value !== (span1_data_bs_target_value = "#collapseErrorDetails-" + ctx2[0].id)) {
        attr(span1, "data-bs-target", span1_data_bs_target_value);
      }
      if (dirty & 1 && span1_aria_controls_value !== (span1_aria_controls_value = "collapseErrorDetails-" + ctx2[0].id)) {
        attr(span1, "aria-controls", span1_aria_controls_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$c(ctx) {
  var _a, _b;
  let t0;
  let div2;
  let div1;
  let div0;
  let label;
  let t2;
  let span;
  let t3_value = (((_b = (_a = ctx[0].meta) == null ? void 0 : _a.error) == null ? void 0 : _b.message) || "NA") + "";
  let t3;
  let div1_id_value;
  let if_block = ctx[3] && create_if_block_2$a(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      label = element("label");
      label.textContent = "Message:";
      t2 = space();
      span = element("span");
      t3 = text(t3_value);
      attr(div1, "class", "collapse collapse-vertical");
      attr(div1, "id", div1_id_value = "collapseErrorDetails-" + ctx[0].id);
      attr(div2, "class", "d-flex border-start py-1 ps-3 mb-1");
      set_style(div2, "margin-left", "-10px");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, label);
      append(div0, t2);
      append(div0, span);
      append(span, t3);
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      if (ctx2[3])
        if_block.p(ctx2, dirty);
      if (dirty & 1 && t3_value !== (t3_value = (((_b2 = (_a2 = ctx2[0].meta) == null ? void 0 : _a2.error) == null ? void 0 : _b2.message) || "NA") + ""))
        set_data(t3, t3_value);
      if (dirty & 1 && div1_id_value !== (div1_id_value = "collapseErrorDetails-" + ctx2[0].id)) {
        attr(div1, "id", div1_id_value);
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div2);
    }
  };
}
function create_if_block_2$a(ctx) {
  var _a, _b;
  let div;
  let a;
  let t_value = ((_b = (_a = ctx[0].meta) == null ? void 0 : _a.error) == null ? void 0 : _b.url) + "";
  let t;
  let a_title_value;
  let a_href_value;
  return {
    c() {
      var _a2, _b2, _c, _d;
      div = element("div");
      a = element("a");
      t = text(t_value);
      attr(a, "target", "_blank");
      attr(a, "title", a_title_value = (_b2 = (_a2 = ctx[0].meta) == null ? void 0 : _a2.error) == null ? void 0 : _b2.url);
      attr(a, "href", a_href_value = (_d = (_c = ctx[0].meta) == null ? void 0 : _c.error) == null ? void 0 : _d.url);
      attr(a, "class", "text-truncate fw-lighter text-break");
      attr(div, "class", "d-flex align-items-center border-start ps-3");
      set_style(div, "font-size", "12px");
      set_style(div, "margin-left", "-10px");
      set_style(div, "max-width", "700px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(a, t);
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c, _d, _e, _f;
      if (dirty & 1 && t_value !== (t_value = ((_b2 = (_a2 = ctx2[0].meta) == null ? void 0 : _a2.error) == null ? void 0 : _b2.url) + ""))
        set_data(t, t_value);
      if (dirty & 1 && a_title_value !== (a_title_value = (_d = (_c = ctx2[0].meta) == null ? void 0 : _c.error) == null ? void 0 : _d.url)) {
        attr(a, "title", a_title_value);
      }
      if (dirty & 1 && a_href_value !== (a_href_value = (_f = (_e = ctx2[0].meta) == null ? void 0 : _e.error) == null ? void 0 : _f.url)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$h(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "d-flex border-start h-8 my-1");
      set_style(div, "width", "20px");
      set_style(div, "margin-left", "180px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$v(ctx) {
  let div8;
  let div7;
  let div1;
  let div0;
  let t0_value = new Date(ctx[0].ts).toLocaleString() + "";
  let t0;
  let t1;
  let t2;
  let div2;
  let switch_instance;
  let t3;
  let div6;
  let div5;
  let div3;
  let strong;
  let t4_value = ctx[4][ctx[0].state] + "";
  let t4;
  let t5;
  let div4;
  let t6;
  let t7;
  let if_block2_anchor;
  let current;
  var switch_value = ctx[6][ctx[0].state].component;
  function switch_props(ctx2) {
    return {
      props: {
        class: ctx2[6][ctx2[0].state].class
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  function select_block_type(ctx2, dirty) {
    var _a;
    if (ctx2[2])
      return create_if_block_3$8;
    if ((_a = ctx2[0].meta) == null ? void 0 : _a.type)
      return create_if_block_4$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type && current_block_type(ctx);
  let if_block1 = ctx[2] && create_if_block_1$c(ctx);
  let if_block2 = !ctx[2] && !ctx[1] && create_if_block$h();
  return {
    c() {
      var _a;
      div8 = element("div");
      div7 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = text(":");
      t2 = space();
      div2 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t3 = space();
      div6 = element("div");
      div5 = element("div");
      div3 = element("div");
      strong = element("strong");
      t4 = text(t4_value);
      t5 = space();
      div4 = element("div");
      if (if_block0)
        if_block0.c();
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      attr(div1, "class", "d-flex");
      set_style(div1, "min-width", "170px");
      attr(div2, "class", "float-start");
      set_style(div2, "min-width", "20px");
      attr(div3, "class", "d-block pl-2 align-items-center");
      toggle_class(div3, "red", (_a = ctx[0].meta) == null ? void 0 : _a.error);
      attr(div4, "class", "d-flex align-items-center");
      attr(div5, "class", "d-flex align-items-center");
      attr(div7, "class", "d-flex");
      attr(div8, "class", "d-flex");
    },
    m(target, anchor) {
      insert(target, div8, anchor);
      append(div8, div7);
      append(div7, div1);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      append(div7, t2);
      append(div7, div2);
      if (switch_instance)
        mount_component(switch_instance, div2, null);
      append(div7, t3);
      append(div7, div6);
      append(div6, div5);
      append(div5, div3);
      append(div3, strong);
      append(strong, t4);
      append(div5, t5);
      append(div5, div4);
      if (if_block0)
        if_block0.m(div4, null);
      append(div6, t6);
      if (if_block1)
        if_block1.m(div6, null);
      insert(target, t7, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a;
      if ((!current || dirty & 1) && t0_value !== (t0_value = new Date(ctx2[0].ts).toLocaleString() + ""))
        set_data(t0, t0_value);
      const switch_instance_changes = {};
      if (dirty & 1)
        switch_instance_changes.class = ctx2[6][ctx2[0].state].class;
      if (dirty & 1 && switch_value !== (switch_value = ctx2[6][ctx2[0].state].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div2, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if ((!current || dirty & 1) && t4_value !== (t4_value = ctx2[4][ctx2[0].state] + ""))
        set_data(t4, t4_value);
      if (!current || dirty & 1) {
        toggle_class(div3, "red", (_a = ctx2[0].meta) == null ? void 0 : _a.error);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if (if_block0)
          if_block0.d(1);
        if_block0 = current_block_type && current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div4, null);
        }
      }
      if (ctx2[2])
        if_block1.p(ctx2, dirty);
      if (!ctx2[2] && !ctx2[1]) {
        if (if_block2)
          ;
        else {
          if_block2 = create_if_block$h();
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div8);
      if (switch_instance)
        destroy_component(switch_instance);
      if (if_block0) {
        if_block0.d();
      }
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach(t7);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  var _a, _b, _c;
  let { jobState } = $$props;
  let { lastJob = false } = $$props;
  const isError2 = (_a = jobState.meta) == null ? void 0 : _a.error;
  const showURLError = (_c = (_b = jobState.meta) == null ? void 0 : _b.error) == null ? void 0 : _c.url;
  const jobStateLabels = {
    [C$1.STATE_ERROR]: "Errored",
    [C$1.STATE_DISCARD]: "Expired",
    [C$1.STATE_DONE]: "Done",
    [C$1.STATE_READY]: "Running",
    [C$1.STATE_DEFAULT]: "Started",
    [C$1.STATE_TERMINATED]: "Terminated",
    [C$1.STATE_RETRYING]: "Started Retry"
  };
  const jobTypeLabels = {
    [C$1.JOB_TYPE_SCHEDULED]: "Scheduled Run",
    [C$1.JOB_TYPE_SCHED_RETRY]: "Auto Retry",
    [C$1.JOB_TYPE_RETRY]: "Manual Retry",
    [C$1.JOB_TYPE_BULL_RETRY]: "Internal Retry",
    [C$1.JOB_TYPE_ON_DEMAND]: "On Demand Run",
    unknown: ""
  };
  const JOB_STOPPED_ICON = { component: Cross, class: "center-block" };
  const JOB_RUNNING_ICON = {
    component: Loading,
    class: "center-block"
  };
  let jobStateIcon = {
    [C$1.STATE_ERROR]: JOB_STOPPED_ICON,
    [C$1.STATE_TERMINATED]: JOB_STOPPED_ICON,
    [C$1.STATE_DISCARD]: JOB_STOPPED_ICON,
    [C$1.STATE_DONE]: { component: Check, class: "center-block" },
    [C$1.STATE_DEFAULT]: { component: Start, class: "center-block" },
    [C$1.STATE_READY]: JOB_RUNNING_ICON,
    [C$1.STATE_RETRYING]: {
      component: ReloadCircle,
      class: "center-block"
    }
  };
  $$self.$$set = ($$props2) => {
    if ("jobState" in $$props2)
      $$invalidate(0, jobState = $$props2.jobState);
    if ("lastJob" in $$props2)
      $$invalidate(1, lastJob = $$props2.lastJob);
  };
  return [
    jobState,
    lastJob,
    isError2,
    showURLError,
    jobStateLabels,
    jobTypeLabels,
    jobStateIcon
  ];
}
class RunDetail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$v, safe_not_equal, { jobState: 0, lastJob: 1 });
  }
}
function get_each_context$a(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  child_ctx[18] = i2;
  return child_ctx;
}
function create_else_block_1$4(ctx) {
  let td0;
  let button;
  let i2;
  let i_class_value;
  let button_data_bs_target_value;
  let t0;
  let t1;
  let td1;
  let mounted;
  let dispose;
  function select_block_type_1(ctx2, dirty) {
    var _a;
    if ((_a = ctx2[5].meta) == null ? void 0 : _a.ts_truncated)
      return create_if_block_6;
    if (ctx2[5].ts_start || ctx2[5].ts)
      return create_if_block_7;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block0 = current_block_type && current_block_type(ctx);
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[5].ts_end && ctx2[5].state !== C$1.STATE_READY)
      return create_if_block_5$1;
    return create_else_block_2$2;
  }
  let current_block_type_1 = select_block_type_2(ctx);
  let if_block1 = current_block_type_1(ctx);
  return {
    c() {
      td0 = element("td");
      button = element("button");
      i2 = element("i");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      td1 = element("td");
      if_block1.c();
      attr(i2, "class", i_class_value = "fa " + (ctx[4] ? "fa-angle-down" : "fa-angle-right"));
      set_style(i2, "width", "10px");
      attr(button, "class", "btn shadow-none");
      attr(button, "data-bs-toggle", "collapse");
      attr(button, "data-bs-target", button_data_bs_target_value = "#collapsible-" + ctx[5].id);
      attr(button, "title", "Click to show job run history");
    },
    m(target, anchor) {
      insert(target, td0, anchor);
      append(td0, button);
      append(button, i2);
      append(td0, t0);
      if (if_block0)
        if_block0.m(td0, null);
      insert(target, t1, anchor);
      insert(target, td1, anchor);
      if_block1.m(td1, null);
      if (!mounted) {
        dispose = listen(button, "click", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16 && i_class_value !== (i_class_value = "fa " + (ctx2[4] ? "fa-angle-down" : "fa-angle-right"))) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & 32 && button_data_bs_target_value !== (button_data_bs_target_value = "#collapsible-" + ctx2[5].id)) {
        attr(button, "data-bs-target", button_data_bs_target_value);
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if (if_block0)
          if_block0.d(1);
        if_block0 = current_block_type && current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(td0, null);
        }
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(td1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(td0);
      if (if_block0) {
        if_block0.d();
      }
      if (detaching)
        detach(t1);
      if (detaching)
        detach(td1);
      if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$3(ctx) {
  let td0;
  let t1;
  let td1;
  return {
    c() {
      td0 = element("td");
      td0.textContent = "Waiting...";
      t1 = space();
      td1 = element("td");
      td1.textContent = "N/A";
    },
    m(target, anchor) {
      insert(target, td0, anchor);
      insert(target, t1, anchor);
      insert(target, td1, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(td0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(td1);
    }
  };
}
function create_if_block_7(ctx) {
  let a;
  let t_value = new Date(ctx[5].ts_start || ctx[5].ts).toLocaleString() + "";
  let t;
  let a_href_value;
  return {
    c() {
      a = element("a");
      t = text(t_value);
      attr(a, "href", a_href_value = "#/u/" + ctx[7] + "/crawlers/" + ctx[1] + "/" + ctx[0].id);
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = new Date(ctx2[5].ts_start || ctx2[5].ts).toLocaleString() + ""))
        set_data(t, t_value);
      if (dirty & 3 && a_href_value !== (a_href_value = "#/u/" + ctx2[7] + "/crawlers/" + ctx2[1] + "/" + ctx2[0].id)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(a);
    }
  };
}
function create_if_block_6(ctx) {
  let span;
  let t0_value = new Date(ctx[5].ts_start || ctx[5].ts).toLocaleString() + "";
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" (truncated)");
      attr(span, "class", "text-secondary");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t0_value !== (t0_value = new Date(ctx2[5].ts_start || ctx2[5].ts).toLocaleString() + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_else_block_2$2(ctx) {
  let t;
  return {
    c() {
      t = text("N/A");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_5$1(ctx) {
  let t_value = new Date(ctx[5].ts_end).toLocaleString() + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = new Date(ctx2[5].ts_end).toLocaleString() + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_else_block$b(ctx) {
  let t;
  return {
    c() {
      t = text("No meta");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3$7(ctx) {
  var _a;
  let t0;
  let t1_value = ((_a = ctx[5].meta) == null ? void 0 : _a.total) + "";
  let t1;
  let t2;
  let t3_value = ctx[5].meta.queued + "";
  let t3;
  let t4;
  let t5_value = ctx[5].meta.crawled + "";
  let t5;
  let t6;
  let t7_value = ctx[5].meta.errorred + "";
  let t7;
  return {
    c() {
      t0 = text("Total: ");
      t1 = text(t1_value);
      t2 = text(", Queued: ");
      t3 = text(t3_value);
      t4 = text(", Crawled: ");
      t5 = text(t5_value);
      t6 = text(", Errorred: ");
      t7 = text(t7_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
      insert(target, t5, anchor);
      insert(target, t6, anchor);
      insert(target, t7, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty & 32 && t1_value !== (t1_value = ((_a2 = ctx2[5].meta) == null ? void 0 : _a2.total) + ""))
        set_data(t1, t1_value);
      if (dirty & 32 && t3_value !== (t3_value = ctx2[5].meta.queued + ""))
        set_data(t3, t3_value);
      if (dirty & 32 && t5_value !== (t5_value = ctx2[5].meta.crawled + ""))
        set_data(t5, t5_value);
      if (dirty & 32 && t7_value !== (t7_value = ctx2[5].meta.errorred + ""))
        set_data(t7, t7_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(t7);
    }
  };
}
function create_if_block_2$9(ctx) {
  let button;
  let i2;
  let i_class_value;
  let t0;
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      t0 = space();
      div = element("div");
      div.textContent = "Stop";
      attr(i2, "class", i_class_value = "fa " + (ctx[3] ? "fa-spinner fa-spin" : "fa-stop"));
      attr(div, "class", "pl-2");
      attr(button, "class", "btn btn-danger btn-sm d-flex align-items-center");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      append(button, t0);
      append(button, div);
      if (!mounted) {
        dispose = listen(button, "click", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && i_class_value !== (i_class_value = "fa " + (ctx2[3] ? "fa-spinner fa-spin" : "fa-stop"))) {
        attr(i2, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$b(ctx) {
  let button;
  let i2;
  let i_class_value;
  let t0;
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      i2 = element("i");
      t0 = space();
      div = element("div");
      div.textContent = "Retry";
      attr(i2, "class", i_class_value = "fa fa-refresh " + (ctx[3] ? "fa-spin" : ""));
      attr(div, "class", "pl-2");
      attr(button, "class", "btn btn-primary btn-sm d-flex align-items-center");
      button.disabled = ctx[3];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, i2);
      append(button, t0);
      append(button, div);
      if (!mounted) {
        dispose = listen(button, "click", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 8 && i_class_value !== (i_class_value = "fa fa-refresh " + (ctx2[3] ? "fa-spin" : ""))) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & 8) {
        button.disabled = ctx2[3];
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$g(ctx) {
  let td;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$8,
    then: create_then_block$8,
    catch: create_catch_block$8,
    value: 15,
    blocks: [, , ,]
  };
  handle_promise(ctx[8].fetch(), info);
  return {
    c() {
      td = element("td");
      info.block.c();
      attr(td, "colspan", "6");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      info.block.m(td, info.anchor = null);
      info.mount = () => td;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(td);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block$8(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$8(ctx) {
  let div;
  let current;
  let each_value = ctx[8].toJSON();
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$a(get_each_context$a(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div, "class", "ms-4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 256) {
        each_value = ctx2[8].toJSON();
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$a(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$a(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$a(ctx) {
  let div;
  let rundetail;
  let t;
  let current;
  rundetail = new RunDetail({
    props: {
      jobState: ctx[16],
      lastJob: ctx[18] === ctx[8].length - 1
    }
  });
  return {
    c() {
      div = element("div");
      create_component(rundetail.$$.fragment);
      t = space();
      attr(div, "class", "mb-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(rundetail, div, null);
      append(div, t);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(rundetail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rundetail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(rundetail);
    }
  };
}
function create_pending_block$8(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$u(ctx) {
  var _a, _b;
  let tr0;
  let t0;
  let td0;
  let t2;
  let td1;
  let t3;
  let td2;
  let t4_value = ctx[6][ctx[5].state] + "";
  let t4;
  let t5_value = ctx[5].state === C$1.STATE_RETRYING ? ` (${((_a = ctx[5].meta) == null ? void 0 : _a.retries) || 0}/2)` : "";
  let t5;
  let t6_value = ((_b = ctx[5].meta) == null ? void 0 : _b.retries) ? `, Attempts: ${ctx[5].meta.retries + 1}` : "";
  let t6;
  let t7;
  let td3;
  let t8;
  let tr0_id_value;
  let t9;
  let tr1;
  let tr1_id_value;
  let tr1_data_bs_parent_value;
  let current;
  function select_block_type(ctx2, dirty) {
    if (ctx2[5].state === C$1.STATE_DEFAULT)
      return create_if_block_4$3;
    return create_else_block_1$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  function select_block_type_3(ctx2, dirty) {
    var _a2;
    if ((_a2 = ctx2[5].meta) == null ? void 0 : _a2.total)
      return create_if_block_3$7;
    return create_else_block$b;
  }
  let current_block_type_1 = select_block_type_3(ctx);
  let if_block1 = current_block_type_1(ctx);
  let if_block2 = ctx[5].state === C$1.STATE_READY && create_if_block_2$9(ctx);
  let if_block3 = (ctx[5].state === C$1.STATE_RETRYING || ctx[5].state === C$1.STATE_ERROR || ctx[5].state === C$1.STATE_DISCARD || ctx[5].state === C$1.STATE_TERMINATED) && ctx[2] && create_if_block_1$b(ctx);
  let if_block4 = ctx[4] && create_if_block$g(ctx);
  return {
    c() {
      tr0 = element("tr");
      if_block0.c();
      t0 = space();
      td0 = element("td");
      td0.textContent = `${ctx[9]()}`;
      t2 = space();
      td1 = element("td");
      if_block1.c();
      t3 = space();
      td2 = element("td");
      t4 = text(t4_value);
      t5 = text(t5_value);
      t6 = text(t6_value);
      t7 = space();
      td3 = element("td");
      if (if_block2)
        if_block2.c();
      t8 = space();
      if (if_block3)
        if_block3.c();
      t9 = space();
      tr1 = element("tr");
      if (if_block4)
        if_block4.c();
      toggle_class(td2, "text-danger", ctx[5].state === C$1.STATE_ERROR);
      attr(tr0, "id", tr0_id_value = "row-" + ctx[5].id);
      toggle_class(tr0, "border-white", ctx[4]);
      attr(tr1, "id", tr1_id_value = "collapsible-" + ctx[5].id);
      attr(tr1, "class", "accordion-collapse collapse");
      attr(tr1, "data-bs-parent", tr1_data_bs_parent_value = "#row-" + ctx[5].id);
    },
    m(target, anchor) {
      insert(target, tr0, anchor);
      if_block0.m(tr0, null);
      append(tr0, t0);
      append(tr0, td0);
      append(tr0, t2);
      append(tr0, td1);
      if_block1.m(td1, null);
      append(tr0, t3);
      append(tr0, td2);
      append(td2, t4);
      append(td2, t5);
      append(td2, t6);
      append(tr0, t7);
      append(tr0, td3);
      if (if_block2)
        if_block2.m(td3, null);
      append(td3, t8);
      if (if_block3)
        if_block3.m(td3, null);
      insert(target, t9, anchor);
      insert(target, tr1, anchor);
      if (if_block4)
        if_block4.m(tr1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(tr0, t0);
        }
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_3(ctx2)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(td1, null);
        }
      }
      if ((!current || dirty & 32) && t4_value !== (t4_value = ctx2[6][ctx2[5].state] + ""))
        set_data(t4, t4_value);
      if ((!current || dirty & 32) && t5_value !== (t5_value = ctx2[5].state === C$1.STATE_RETRYING ? ` (${((_a2 = ctx2[5].meta) == null ? void 0 : _a2.retries) || 0}/2)` : ""))
        set_data(t5, t5_value);
      if ((!current || dirty & 32) && t6_value !== (t6_value = ((_b2 = ctx2[5].meta) == null ? void 0 : _b2.retries) ? `, Attempts: ${ctx2[5].meta.retries + 1}` : ""))
        set_data(t6, t6_value);
      if (!current || dirty & 32) {
        toggle_class(td2, "text-danger", ctx2[5].state === C$1.STATE_ERROR);
      }
      if (ctx2[5].state === C$1.STATE_READY) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_2$9(ctx2);
          if_block2.c();
          if_block2.m(td3, t8);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if ((ctx2[5].state === C$1.STATE_RETRYING || ctx2[5].state === C$1.STATE_ERROR || ctx2[5].state === C$1.STATE_DISCARD || ctx2[5].state === C$1.STATE_TERMINATED) && ctx2[2]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_1$b(ctx2);
          if_block3.c();
          if_block3.m(td3, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (!current || dirty & 32 && tr0_id_value !== (tr0_id_value = "row-" + ctx2[5].id)) {
        attr(tr0, "id", tr0_id_value);
      }
      if (!current || dirty & 16) {
        toggle_class(tr0, "border-white", ctx2[4]);
      }
      if (ctx2[4]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block$g(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(tr1, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (!current || dirty & 32 && tr1_id_value !== (tr1_id_value = "collapsible-" + ctx2[5].id)) {
        attr(tr1, "id", tr1_id_value);
      }
      if (!current || dirty & 32 && tr1_data_bs_parent_value !== (tr1_data_bs_parent_value = "#row-" + ctx2[5].id)) {
        attr(tr1, "data-bs-parent", tr1_data_bs_parent_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr0);
      if_block0.d();
      if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (detaching)
        detach(t9);
      if (detaching)
        detach(tr1);
      if (if_block4)
        if_block4.d();
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  let $job, $$unsubscribe_job = noop$1, $$subscribe_job = () => ($$unsubscribe_job(), $$unsubscribe_job = subscribe(job, ($$value) => $$invalidate(5, $job = $$value)), job);
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(13, $params = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_job());
  const dispatch = createEventDispatcher();
  const jobStatesLabel = {
    [C$1.STATE_ERROR]: "Errored",
    [C$1.STATE_DISCARD]: "Cancelled",
    [C$1.STATE_EXPIRED]: "Expired",
    [C$1.STATE_DONE]: "Done",
    [C$1.STATE_READY]: "Running",
    [C$1.STATE_PAUSED]: "Paused",
    [C$1.STATE_DEFAULT]: "Scheduled",
    [C$1.STATE_TERMINATING]: "Terminating",
    [C$1.STATE_TERMINATED]: "Terminated",
    [C$1.STATE_RETRYING]: "Scheduled for Retry"
  };
  let { job } = $$props;
  $$subscribe_job();
  let { crawler_id } = $$props;
  let { isLatest = false } = $$props;
  let loading2 = false;
  let team = $params.team;
  let expanded = false;
  let jobStates = new JobStates({}, { crawler_id, id: job.id });
  function getJobDuration() {
    if ($job.state === C$1.STATE_DEFAULT || !$job.ts_end) {
      return "N/A";
    }
    if ($job.meta.duration) {
      return getDuration(Date.now(), Date.now() + $job.meta.duration * 1e3);
    }
    const jobEndDate = $job.state === C$1.STATE_READY || $job.state === C$1.STATE_DEFAULT || $job.state === C$1.STATE_TERMINATING ? Date.now() : new Date($job.ts_end).getTime();
    if (isNaN(jobEndDate)) {
      return "N/A";
    }
    const jobDate = new Date($job.ts).getTime();
    return getDuration(jobDate, jobEndDate);
  }
  getJobDuration();
  async function terminateJob() {
    try {
      $$invalidate(3, loading2 = true);
      await Api.api(`/crawlers/${crawler_id}/jobs/${job.id}/terminate`);
      Msg.info("Job terminated");
    } catch (err) {
      Msg.error("Could not terminate job");
      console.error("Could not terminate job", err);
    } finally {
      $$invalidate(3, loading2 = false);
      dispatch("refresh");
    }
  }
  async function retryJob() {
    try {
      $$invalidate(3, loading2 = true);
      Msg.info("Retrying job: Checking if crawler is busy...");
      let res = await Api.api(`/crawlers/${crawler_id}/jobs/${job.id}/retry`);
      if (res.crawler_id) {
        Msg.info("Successfully scheduled job retry");
      }
    } catch (err) {
      let msg = err.msg || "Could not schedule new job";
      if (err.code === "ERR_CRAWLER_BUSY") {
        msg = "Crawler is busy: " + getJobErrFromErr(err);
      }
      Msg.error(msg);
      console.error("Could not retry job", err);
    } finally {
      $$invalidate(3, loading2 = false);
      dispatch("refresh");
    }
  }
  async function toggleJobExpanded() {
    if (expanded) {
      $$invalidate(4, expanded = false);
      return;
    }
    $$invalidate(4, expanded = true);
  }
  $$self.$$set = ($$props2) => {
    if ("job" in $$props2)
      $$subscribe_job($$invalidate(0, job = $$props2.job));
    if ("crawler_id" in $$props2)
      $$invalidate(1, crawler_id = $$props2.crawler_id);
    if ("isLatest" in $$props2)
      $$invalidate(2, isLatest = $$props2.isLatest);
  };
  return [
    job,
    crawler_id,
    isLatest,
    loading2,
    expanded,
    $job,
    jobStatesLabel,
    team,
    jobStates,
    getJobDuration,
    terminateJob,
    retryJob,
    toggleJobExpanded
  ];
}
class Job extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$u, safe_not_equal, { job: 0, crawler_id: 1, isLatest: 2 });
  }
}
function get_each_context$9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_else_block$a(ctx) {
  let tr;
  return {
    c() {
      tr = element("tr");
      tr.innerHTML = `<td>No jobs found</td> 
        `;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block$9(key_1, ctx) {
  let first2;
  let job;
  let current;
  job = new Job({
    props: {
      job: ctx[8],
      crawler_id: ctx[0],
      isLatest: ctx[8].id === ctx[1]
    }
  });
  job.$on("refresh", ctx[5]);
  return {
    key: key_1,
    first: null,
    c() {
      first2 = empty();
      create_component(job.$$.fragment);
      this.first = first2;
    },
    m(target, anchor) {
      insert(target, first2, anchor);
      mount_component(job, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const job_changes = {};
      if (dirty & 8)
        job_changes.job = ctx[8];
      if (dirty & 1)
        job_changes.crawler_id = ctx[0];
      if (dirty & 10)
        job_changes.isLatest = ctx[8].id === ctx[1];
      job.$set(job_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(job.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(job.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first2);
      destroy_component(job, detaching);
    }
  };
}
function create_fragment$t(ctx) {
  let div4;
  let div3;
  let div0;
  let t3;
  let div1;
  let t4;
  let button;
  let i2;
  let i_class_value;
  let t5;
  let div2;
  let t7;
  let listpager;
  let t8;
  let table;
  let thead;
  let t20;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let mounted;
  let dispose;
  listpager = new ListPager({ props: { store: ctx[4] } });
  let each_value = ctx[3].models;
  const get_key = (ctx2) => ctx2[8].id;
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    let child_ctx = get_each_context$9(ctx, each_value, i3);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i3] = create_each_block$9(key, child_ctx));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$a();
  }
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3>Jobs</h3> 
    <small>List of jobs started by this crawler</small>`;
      t3 = space();
      div1 = element("div");
      t4 = space();
      button = element("button");
      i2 = element("i");
      t5 = space();
      div2 = element("div");
      div2.textContent = "Run New Job";
      t7 = space();
      create_component(listpager.$$.fragment);
      t8 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="bg-gray-200"><th>Started On</th> 
      <th>Ended On</th> 
      <th>Run Duration</th> 
      <th>Summary</th> 
      <th>Status</th> 
      <th>Action</th></tr>`;
      t20 = space();
      tbody = element("tbody");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      if (each_1_else) {
        each_1_else.c();
      }
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      set_style(div1, "max-width", "50px");
      attr(i2, "class", i_class_value = "fa " + (ctx[2] ? "fa-spinner fa-spin" : "fa-play"));
      attr(div2, "class", "pl-2");
      attr(button, "class", "btn btn-success btn-sm mx-2 pagination-sm d-flex align-items-center");
      button.disabled = ctx[2];
      attr(button, "title", "New run will cancel any jobs scheduled for retries");
      attr(div3, "class", "card-header flex items-center");
      attr(thead, "class", "table-light");
      attr(table, "class", "table");
      attr(div4, "class", "card panel-default my-5");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div0);
      append(div3, t3);
      append(div3, div1);
      append(div3, t4);
      append(div3, button);
      append(button, i2);
      append(button, t5);
      append(button, div2);
      append(div3, t7);
      mount_component(listpager, div3, null);
      append(div4, t8);
      append(div4, table);
      append(table, thead);
      append(table, t20);
      append(table, tbody);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(tbody, null);
        }
      }
      if (each_1_else) {
        each_1_else.m(tbody, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 4 && i_class_value !== (i_class_value = "fa " + (ctx2[2] ? "fa-spinner fa-spin" : "fa-play"))) {
        attr(i2, "class", i_class_value);
      }
      if (!current || dirty & 4) {
        button.disabled = ctx2[2];
      }
      if (dirty & 43) {
        each_value = ctx2[3].models;
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$9, null, get_each_context$9);
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$a();
          each_1_else.c();
          each_1_else.m(tbody, null);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(listpager.$$.fragment, local);
      for (let i3 = 0; i3 < each_value.length; i3 += 1) {
        transition_in(each_blocks[i3]);
      }
      current = true;
    },
    o(local) {
      transition_out(listpager.$$.fragment, local);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        transition_out(each_blocks[i3]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      destroy_component(listpager);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].d();
      }
      if (each_1_else)
        each_1_else.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let $store;
  let { crawler_id } = $$props;
  let { latestJobId } = $$props;
  let store2 = getContext("job:store");
  component_subscribe($$self, store2, (value) => $$invalidate(3, $store = value));
  let loading2 = false;
  async function refresh() {
    await store2.fetch();
  }
  let refreshInterval = setInterval(
    () => {
      refresh();
    },
    5e3
  );
  async function runNewJob() {
    try {
      $$invalidate(2, loading2 = true);
      Msg.info("Starting new job: Checking if crawler is busy...");
      let res = await Api.api(`/crawlers/${crawler_id}/jobs`, "POST");
      if (res.crawler_id) {
        $$invalidate(2, loading2 = false);
        Msg.info("Successfully scheduled new job");
      }
    } catch (err) {
      let msg = "Could not schedule new job";
      if (err.code === "ERR_CRAWLER_BUSY") {
        msg = "Crawler is busy: " + getJobErrFromErr(err);
      }
      Msg.error(msg);
      console.error("Could not run new job", err);
    } finally {
      $$invalidate(2, loading2 = false);
      await store2.fetch();
    }
  }
  onDestroy(() => {
    clearInterval(refreshInterval);
  });
  $$self.$$set = ($$props2) => {
    if ("crawler_id" in $$props2)
      $$invalidate(0, crawler_id = $$props2.crawler_id);
    if ("latestJobId" in $$props2)
      $$invalidate(1, latestJobId = $$props2.latestJobId);
  };
  return [crawler_id, latestJobId, loading2, $store, store2, refresh, runNewJob];
}
class List$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$t, safe_not_equal, { crawler_id: 0, latestJobId: 1 });
  }
}
function get_each_context$8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i2];
  child_ctx[3] = i2;
  return child_ctx;
}
function create_else_block$9(ctx) {
  let li;
  let a;
  let t0_value = ctx[1].name + "";
  let t0;
  let a_href_value;
  let t1;
  return {
    c() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "href", a_href_value = ctx[1].href);
      attr(li, "class", "breadcrumb-item");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t0);
      append(li, t1);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[1].name + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && a_href_value !== (a_href_value = ctx2[1].href)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_if_block$f(ctx) {
  let li;
  let t_value = ctx[1].name + "";
  let t;
  return {
    c() {
      li = element("li");
      t = text(t_value);
      attr(li, "class", "breadcrumb-item active");
      attr(li, "aria-current", "page");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[1].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_each_block$8(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3] === ctx2[0].length - 1)
      return create_if_block$f;
    return create_else_block$9;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$s(ctx) {
  let nav;
  let ol;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$8(get_each_context$8(ctx, each_value, i2));
  }
  return {
    c() {
      nav = element("nav");
      ol = element("ol");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ol, "class", "breadcrumb");
      attr(nav, "aria-label", "breadcrumb");
    },
    m(target, anchor) {
      insert(target, nav, anchor);
      append(nav, ol);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$8(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(ol, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(nav);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let { items } = $$props;
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
  };
  return [items];
}
class BreadCrumb extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$s, safe_not_equal, { items: 0 });
  }
}
function fade(node, { delay: delay2 = 0, duration = 400, easing = identity$1 } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay: delay2,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function get_each_context$7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_else_block_1$3(ctx) {
  let menu;
  let current;
  menu = new Menu({
    props: {
      defaultActionLabel: ctx[11].count + " crawls failed",
      allowNull: true,
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(menu.$$.fragment);
    },
    m(target, anchor) {
      mount_component(menu, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const menu_changes = {};
      if (dirty & 1)
        menu_changes.defaultActionLabel = ctx2[11].count + " crawls failed";
      if (dirty & 131089) {
        menu_changes.$$scope = { dirty, ctx: ctx2 };
      }
      menu.$set(menu_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(menu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(menu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(menu, detaching);
    }
  };
}
function create_if_block_1$a(ctx) {
  let span;
  let t_value = ctx[11].count + ` run${ctx[11].count > 1 ? "s" : ""} failed`;
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[11].count + ` run${ctx2[11].count > 1 ? "s" : ""} failed`))
        set_data(t, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2$8(ctx) {
  let each_1_anchor;
  let each_value_1 = ctx[11].job_ids || [];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i2));
  }
  let each_1_else = null;
  if (!each_value_1.length) {
    each_1_else = create_else_block_2$1();
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 49) {
        each_value_1 = ctx2[11].job_ids || [];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$2(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
        if (!each_value_1.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value_1.length) {
          each_1_else = create_else_block_2$1();
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_else_block_2$1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block_1$2(ctx) {
  let li;
  let a;
  let t_value = new Date(ctx[14].ts).toLocaleString() + "";
  let t;
  let a_href_value;
  return {
    c() {
      li = element("li");
      a = element("a");
      t = text(t_value);
      attr(a, "href", a_href_value = urlCfg.crawlerJobDetail(ctx[4], ctx[5], ctx[14].id));
      attr(li, "class", "px-2 my-1");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, a);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = new Date(ctx2[14].ts).toLocaleString() + ""))
        set_data(t, t_value);
      if (dirty & 17 && a_href_value !== (a_href_value = urlCfg.crawlerJobDetail(ctx2[4], ctx2[5], ctx2[14].id))) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_key_block(ctx) {
  let if_block_anchor;
  let if_block = ctx[11].job_ids && create_if_block_2$8(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[11].job_ids) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$8(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot$d(ctx) {
  let previous_key = ctx[4];
  let key_block_anchor;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && safe_not_equal(previous_key, previous_key = ctx2[4])) {
        key_block.d(1);
        key_block = create_key_block(ctx2);
        key_block.c();
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_else_block$8(ctx) {
  let button;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[8](ctx[11]);
  }
  return {
    c() {
      button = element("button");
      button.textContent = "Exclude url from crawl";
      attr(button, "class", "btn btn-default btn-sm");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$e(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Excluded";
      attr(span, "class", "px-2");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$7(key_1, ctx) {
  let tr;
  let td0;
  let a;
  let t0_value = ctx[11].url + "";
  let t0;
  let a_title_value;
  let a_href_value;
  let t1;
  let td1;
  let t2_value = ctx[11].code + "";
  let t2;
  let t3;
  let td2;
  let div;
  let current_block_type_index;
  let if_block0;
  let t4;
  let td3;
  let t5;
  let tr_id_value;
  let tr_class_value;
  let tr_outro;
  let current;
  const if_block_creators = [create_if_block_1$a, create_else_block_1$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[11].removed)
      return create_if_block$e;
    return create_else_block$8;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block1 = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      td0 = element("td");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      td1 = element("td");
      t2 = text(t2_value);
      t3 = space();
      td2 = element("td");
      div = element("div");
      if_block0.c();
      t4 = space();
      td3 = element("td");
      if_block1.c();
      t5 = space();
      attr(a, "title", a_title_value = ctx[11].url);
      attr(a, "target", "_blank");
      attr(a, "href", a_href_value = ctx[11].url);
      attr(td0, "class", "align-text-top text-break text-truncate");
      set_style(td0, "max-width", "400px");
      attr(td1, "class", "align-text-top");
      attr(div, "class", "d-flex");
      attr(td2, "class", "align-text-top");
      attr(td3, "class", "align-text-top");
      attr(tr, "id", tr_id_value = "url-" + ctx[11].id);
      attr(tr, "class", tr_class_value = "url-id-" + ctx[11].url_id);
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td0);
      append(td0, a);
      append(a, t0);
      append(tr, t1);
      append(tr, td1);
      append(td1, t2);
      append(tr, t3);
      append(tr, td2);
      append(td2, div);
      if_blocks[current_block_type_index].m(div, null);
      append(tr, t4);
      append(tr, td3);
      if_block1.m(td3, null);
      append(tr, t5);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[11].url + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 1 && a_title_value !== (a_title_value = ctx[11].url)) {
        attr(a, "title", a_title_value);
      }
      if (!current || dirty & 1 && a_href_value !== (a_href_value = ctx[11].url)) {
        attr(a, "href", a_href_value);
      }
      if ((!current || dirty & 1) && t2_value !== (t2_value = ctx[11].code + ""))
        set_data(t2, t2_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block0.c();
        } else {
          if_block0.p(ctx, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, null);
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {
        if_block1.p(ctx, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx);
        if (if_block1) {
          if_block1.c();
          if_block1.m(td3, null);
        }
      }
      if (!current || dirty & 1 && tr_id_value !== (tr_id_value = "url-" + ctx[11].id)) {
        attr(tr, "id", tr_id_value);
      }
      if (!current || dirty & 1 && tr_class_value !== (tr_class_value = "url-id-" + ctx[11].url_id)) {
        attr(tr, "class", tr_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      if (tr_outro)
        tr_outro.end(1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      if (local) {
        tr_outro = create_out_transition(tr, fade, { duration: 250, delay: 1e3 });
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      if_blocks[current_block_type_index].d();
      if_block1.d();
      if (detaching && tr_outro)
        tr_outro.end();
    }
  };
}
function create_fragment$r(ctx) {
  let div3;
  let div2;
  let div0;
  let h5;
  let t0;
  let t1;
  let div1;
  let table;
  let colgroup;
  let t5;
  let thead;
  let t13;
  let tbody;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let table_outro;
  let current;
  let each_value = ctx[0];
  const get_key = (ctx2) => ctx2[11].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$7(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$7(key, child_ctx));
  }
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h5 = element("h5");
      t0 = text(ctx[2]);
      t1 = space();
      div1 = element("div");
      table = element("table");
      colgroup = element("colgroup");
      colgroup.innerHTML = `<col style="width: 35%"/> 
          <col style="width: 25%"/> 
          <col style="width: 20%"/> 
          <col style="width: 20%"/>`;
      t5 = space();
      thead = element("thead");
      thead.innerHTML = `<tr><th class="w-30">URL</th> 
            <th>Code</th> 
            <th>Error Frequency</th> 
            <th>Actions</th></tr>`;
      t13 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "d-flex items-center");
      attr(table, "class", "table");
      attr(div2, "class", "p-3 bg-white bb bl br bt border-bootstrap-border");
      attr(div2, "id", "options_tab");
      attr(div3, "class", "items-center mt-3");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h5);
      append(h5, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, table);
      append(table, colgroup);
      append(table, t5);
      append(table, thead);
      append(table, t13);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 4)
        set_data(t0, ctx2[2]);
      if (dirty & 121) {
        each_value = ctx2[0];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, tbody, outro_and_destroy_block, create_each_block$7, null, get_each_context$7);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      if (table_outro)
        table_outro.end(1);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      if (local) {
        table_outro = create_out_transition(table, fade, { duration: 250, delay: 1e3 });
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (detaching && table_outro)
        table_outro.end();
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let $crawler, $$unsubscribe_crawler = noop$1, $$subscribe_crawler = () => ($$unsubscribe_crawler(), $$unsubscribe_crawler = subscribe(crawler, ($$value) => $$invalidate(9, $crawler = $$value)), crawler);
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(7, $params = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_crawler());
  let { errorSummary } = $$props;
  let { crawler } = $$props;
  $$subscribe_crawler();
  let { title } = $$props;
  let { isJobPage = false } = $$props;
  const dispatch = createEventDispatcher();
  let teamId = void 0;
  let id2 = $crawler.id;
  function addToIgnoreList(id3, url, url_id) {
    let regexURL = escapeRegex(url);
    errorSummary.forEach((errorUrl) => {
      if (errorUrl.url_id === url_id) {
        errorUrl.removed = true;
      }
    });
    $$invalidate(0, errorSummary);
    $crawler.config.excludes.push({ expr: regexURL, flags: "gim" });
    crawler.save();
    dispatch("excludes_update");
  }
  const click_handler = (errorUrl) => {
    addToIgnoreList(errorUrl.id, errorUrl.url, errorUrl.url_id);
  };
  $$self.$$set = ($$props2) => {
    if ("errorSummary" in $$props2)
      $$invalidate(0, errorSummary = $$props2.errorSummary);
    if ("crawler" in $$props2)
      $$subscribe_crawler($$invalidate(1, crawler = $$props2.crawler));
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("isJobPage" in $$props2)
      $$invalidate(3, isJobPage = $$props2.isJobPage);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      {
        $$invalidate(4, teamId = $params == null ? void 0 : $params.team);
      }
    }
  };
  return [
    errorSummary,
    crawler,
    title,
    isJobPage,
    teamId,
    id2,
    addToIgnoreList,
    $params,
    click_handler
  ];
}
class CrawlErrorDetails extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$r, safe_not_equal, {
      errorSummary: 0,
      crawler: 1,
      title: 2,
      isJobPage: 3
    });
  }
}
function get_each_context_1$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2];
  return child_ctx;
}
function get_each_context$6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  return child_ctx;
}
function create_catch_block$7(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$7(ctx) {
  let breadcrumb;
  let t0;
  let div1;
  let div0;
  let h3;
  let t1_value = ctx[4].name + "";
  let t1;
  let t2;
  let ul;
  let li0;
  let a0;
  let t4;
  let li1;
  let a1;
  let t6;
  let t7;
  let t8;
  let list;
  let current;
  let mounted;
  let dispose;
  breadcrumb = new BreadCrumb({
    props: { items: ctx[1] }
  });
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === ctx2[5].OPTIONS)
      return create_if_block_1$9;
    return create_else_block$7;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[2] && create_if_block$d(ctx);
  list = new List$1({
    props: {
      crawler_id: ctx[6],
      latestJobId: ctx[4].latest_job_id
    }
  });
  return {
    c() {
      create_component(breadcrumb.$$.fragment);
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t1 = text(t1_value);
      t2 = space();
      ul = element("ul");
      li0 = element("li");
      a0 = element("a");
      a0.textContent = "Options";
      t4 = space();
      li1 = element("li");
      a1 = element("a");
      a1.textContent = "Monitors";
      t6 = space();
      if_block0.c();
      t7 = space();
      if (if_block1)
        if_block1.c();
      t8 = space();
      create_component(list.$$.fragment);
      attr(div0, "class", "flex items-center xpage-header");
      attr(a0, "href", "#options_tab");
      attr(a0, "class", "nav-link");
      attr(a0, "data-toggle", "tab");
      toggle_class(a0, "active", ctx[0] == ctx[5].OPTIONS);
      attr(a1, "href", "#monitors_tab");
      attr(a1, "class", "nav-link");
      attr(a1, "data-toggle", "tab");
      toggle_class(a1, "active", ctx[0] == ctx[5].MONITORS);
      attr(ul, "class", "nav nav-tabs mt-2");
      attr(div1, "class", "items-center mt-3");
    },
    m(target, anchor) {
      mount_component(breadcrumb, target, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, h3);
      append(h3, t1);
      append(div1, t2);
      append(div1, ul);
      append(ul, li0);
      append(li0, a0);
      append(ul, t4);
      append(ul, li1);
      append(li1, a1);
      append(div1, t6);
      if_block0.m(div1, null);
      insert(target, t7, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t8, anchor);
      mount_component(list, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(a0, "click", prevent_default(ctx[15])),
          listen(a1, "click", prevent_default(ctx[16]))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const breadcrumb_changes = {};
      if (dirty & 2)
        breadcrumb_changes.items = ctx2[1];
      breadcrumb.$set(breadcrumb_changes);
      if ((!current || dirty & 16) && t1_value !== (t1_value = ctx2[4].name + ""))
        set_data(t1, t1_value);
      if (!current || dirty & 33) {
        toggle_class(a0, "active", ctx2[0] == ctx2[5].OPTIONS);
      }
      if (!current || dirty & 33) {
        toggle_class(a1, "active", ctx2[0] == ctx2[5].MONITORS);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div1, null);
        }
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$d(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t8.parentNode, t8);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const list_changes = {};
      if (dirty & 16)
        list_changes.latestJobId = ctx2[4].latest_job_id;
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(breadcrumb.$$.fragment, local);
      transition_in(if_block1);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(breadcrumb.$$.fragment, local);
      transition_out(if_block1);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(breadcrumb, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if_block0.d();
      if (detaching)
        detach(t7);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t8);
      destroy_component(list, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$7(ctx) {
  let div2;
  let div1;
  let div0;
  let table;
  let thead;
  let t1;
  let tbody;
  let each_value_1 = ctx[10].toJSON();
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i2));
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr><td>Linked Monitors</td></tr>`;
      t1 = space();
      tbody = element("tbody");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(table, "class", "table");
      set_style(div0, "width", "50%");
      attr(div1, "class", "flex");
      attr(div2, "class", "tab-pane bg-white bb bl br border-bootstrap-border");
      attr(div2, "id", "options_tab");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, table);
      append(table, thead);
      append(table, t1);
      append(table, tbody);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tbody, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1152) {
        each_value_1 = ctx2[10].toJSON();
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(tbody, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_1$9(ctx) {
  let div4;
  let div3;
  let div2;
  let table;
  let tbody;
  let tr0;
  let th0;
  let t1;
  let td0;
  let div0;
  let t2_value = ctx[4].state === C$1.STATE_READY ? "Active" : "Inactive";
  let t2;
  let t3;
  let tr1;
  let th1;
  let t5;
  let td1;
  let a0;
  let t6_value = ctx[4].url + "";
  let t6;
  let a0_href_value;
  let t7;
  let tr2;
  let th2;
  let t9;
  let td2;
  let t10_value = getShortDisplayText(ctx[4].schedule) + "";
  let t10;
  let t11;
  let tr3;
  let th3;
  let t13;
  let td3;
  let t14_value = ctx[4].config.maxPages + "";
  let t14;
  let t15;
  let t16;
  let tr4;
  let th4;
  let div1;
  let a1;
  let button;
  let a1_href_value;
  let t18;
  let td4;
  let if_block = ctx[4].config.excludes.length > 0 && create_if_block_2$7(ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div2 = element("div");
      table = element("table");
      tbody = element("tbody");
      tr0 = element("tr");
      th0 = element("th");
      th0.textContent = "State";
      t1 = space();
      td0 = element("td");
      div0 = element("div");
      t2 = text(t2_value);
      t3 = space();
      tr1 = element("tr");
      th1 = element("th");
      th1.textContent = "URL";
      t5 = space();
      td1 = element("td");
      a0 = element("a");
      t6 = text(t6_value);
      t7 = space();
      tr2 = element("tr");
      th2 = element("th");
      th2.textContent = "Schedule";
      t9 = space();
      td2 = element("td");
      t10 = text(t10_value);
      t11 = space();
      tr3 = element("tr");
      th3 = element("th");
      th3.textContent = "Max pages";
      t13 = space();
      td3 = element("td");
      t14 = text(t14_value);
      t15 = space();
      if (if_block)
        if_block.c();
      t16 = space();
      tr4 = element("tr");
      th4 = element("th");
      div1 = element("div");
      a1 = element("a");
      button = element("button");
      button.textContent = "Edit Crawler";
      t18 = space();
      td4 = element("td");
      set_style(th0, "width", "25%");
      toggle_class(div0, "error", ctx[4].state !== C$1.STATE_READY);
      set_style(th1, "width", "25%");
      attr(a0, "href", a0_href_value = ctx[4].url);
      attr(a0, "target", "_blank");
      set_style(th2, "width", "25%");
      set_style(th3, "width", "25%");
      attr(button, "class", "btn btn-default");
      attr(a1, "class", "text-body");
      attr(a1, "href", a1_href_value = "#/u/" + ctx[7] + "/crawlers/" + ctx[4].id + "/edit");
      attr(table, "class", "table");
      set_style(div2, "width", "50%");
      attr(div3, "class", "d-flex");
      attr(div4, "class", "tab-pane bg-white bb bl br border-bootstrap-border");
      attr(div4, "id", "options_tab");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div2);
      append(div2, table);
      append(table, tbody);
      append(tbody, tr0);
      append(tr0, th0);
      append(tr0, t1);
      append(tr0, td0);
      append(td0, div0);
      append(div0, t2);
      append(tbody, t3);
      append(tbody, tr1);
      append(tr1, th1);
      append(tr1, t5);
      append(tr1, td1);
      append(td1, a0);
      append(a0, t6);
      append(tbody, t7);
      append(tbody, tr2);
      append(tr2, th2);
      append(tr2, t9);
      append(tr2, td2);
      append(td2, t10);
      append(tbody, t11);
      append(tbody, tr3);
      append(tr3, th3);
      append(tr3, t13);
      append(tr3, td3);
      append(td3, t14);
      append(tbody, t15);
      if (if_block)
        if_block.m(tbody, null);
      append(tbody, t16);
      append(tbody, tr4);
      append(tr4, th4);
      append(th4, div1);
      append(div1, a1);
      append(a1, button);
      append(tr4, t18);
      append(tr4, td4);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t2_value !== (t2_value = ctx2[4].state === C$1.STATE_READY ? "Active" : "Inactive"))
        set_data(t2, t2_value);
      if (dirty & 16) {
        toggle_class(div0, "error", ctx2[4].state !== C$1.STATE_READY);
      }
      if (dirty & 16 && t6_value !== (t6_value = ctx2[4].url + ""))
        set_data(t6, t6_value);
      if (dirty & 16 && a0_href_value !== (a0_href_value = ctx2[4].url)) {
        attr(a0, "href", a0_href_value);
      }
      if (dirty & 16 && t10_value !== (t10_value = getShortDisplayText(ctx2[4].schedule) + ""))
        set_data(t10, t10_value);
      if (dirty & 16 && t14_value !== (t14_value = ctx2[4].config.maxPages + ""))
        set_data(t14, t14_value);
      if (ctx2[4].config.excludes.length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$7(ctx2);
          if_block.c();
          if_block.m(tbody, t16);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 16 && a1_href_value !== (a1_href_value = "#/u/" + ctx2[7] + "/crawlers/" + ctx2[4].id + "/edit")) {
        attr(a1, "href", a1_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_3$6(ctx) {
  let tr;
  let td;
  let a;
  let t0_value = ctx[25].name + "";
  let t0;
  let t1;
  return {
    c() {
      tr = element("tr");
      td = element("td");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      attr(a, "href", "#/w/" + ctx[7] + "/list/all/" + ctx[25].id + ".id");
      attr(a, "target", "_blank");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      append(td, a);
      append(a, t0);
      append(tr, t1);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_each_block_1$1(ctx) {
  let if_block_anchor;
  let if_block = (ctx[25].state === 40 || ctx[25].state === 45) && create_if_block_3$6(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[25].state === 40 || ctx2[25].state === 45)
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_2$7(ctx) {
  let tr;
  let th;
  let t1;
  let td;
  let each_value = ctx[4].config.excludes;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$6(get_each_context$6(ctx, each_value, i2));
  }
  return {
    c() {
      tr = element("tr");
      th = element("th");
      th.textContent = "Excludes";
      t1 = space();
      td = element("td");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      set_style(th, "width", "25%");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, th);
      append(tr, t1);
      append(tr, td);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(td, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 16) {
        each_value = ctx2[4].config.excludes;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$6(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(td, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(tr);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$6(ctx) {
  let div;
  let code0;
  let t0_value = ctx[22].expr + "";
  let t0;
  let t1;
  let code1;
  let t2_value = ctx[22].flags + "";
  let t2;
  let t3;
  return {
    c() {
      div = element("div");
      code0 = element("code");
      t0 = text(t0_value);
      t1 = text("\xA0\xA0");
      code1 = element("code");
      t2 = text(t2_value);
      t3 = space();
      attr(code0, "class", "bg-gray-200 px-2 rounded-md");
      attr(code1, "class", "bg-gray-200 px-2 rounded-md");
      attr(div, "class", "flex my-2 items-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, code0);
      append(code0, t0);
      append(div, t1);
      append(div, code1);
      append(code1, t2);
      append(div, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t0_value !== (t0_value = ctx2[22].expr + ""))
        set_data(t0, t0_value);
      if (dirty & 16 && t2_value !== (t2_value = ctx2[22].flags + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$d(ctx) {
  let crawlerrordetails;
  let current;
  crawlerrordetails = new CrawlErrorDetails({
    props: {
      crawler: ctx[9],
      title: "URLs causing failed crawls",
      errorSummary: ctx[3]
    }
  });
  crawlerrordetails.$on("excludes_update", ctx[17]);
  return {
    c() {
      create_component(crawlerrordetails.$$.fragment);
    },
    m(target, anchor) {
      mount_component(crawlerrordetails, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const crawlerrordetails_changes = {};
      if (dirty & 8)
        crawlerrordetails_changes.errorSummary = ctx2[3];
      crawlerrordetails.$set(crawlerrordetails_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(crawlerrordetails.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(crawlerrordetails.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(crawlerrordetails, detaching);
    }
  };
}
function create_pending_block$7(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_default_slot$c(ctx) {
  let div2;
  let div1;
  let div0;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$7,
    then: create_then_block$7,
    catch: create_catch_block$7,
    value: 21,
    blocks: [, , ,]
  };
  handle_promise(ctx[11], info);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      info.block.c();
      attr(div0, "class", "col-sm-12");
      attr(div1, "class", "row");
      attr(div2, "class", "container");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      info.block.m(div0, info.anchor = null);
      info.mount = () => div0;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_header_slot$4(ctx) {
  let svlelte_fragment;
  return {
    c() {
      svlelte_fragment = element("svlelte:fragment");
      svlelte_fragment.innerHTML = `<div class="inline-block fw4 f2">Crawlers</div>`;
      attr(svlelte_fragment, "slot", "header");
    },
    m(target, anchor) {
      insert(target, svlelte_fragment, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(svlelte_fragment);
    }
  };
}
function create_topbar_slot$3(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({
    props: {
      showSearch: false,
      $$slots: { header: [create_header_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (dirty & 268435456) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topbar.$set(topbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$q(ctx) {
  let title_value;
  let t;
  let layout;
  let current;
  document.title = title_value = ctx[4].name + " - Jobs | Distill.io";
  layout = new Layout$1({
    props: {
      renderDefaultToolbar: true,
      $$slots: {
        topbar: [create_topbar_slot$3],
        default: [create_default_slot$c]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 16) && title_value !== (title_value = ctx2[4].name + " - Jobs | Distill.io")) {
        document.title = title_value;
      }
      const layout_changes = {};
      if (dirty & 268435487) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(layout, detaching);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let $crawler;
  let $svelteParams;
  let $jobsStore;
  component_subscribe($$self, params, ($$value) => $$invalidate(19, $svelteParams = $$value));
  let { params: params$1 } = $$props;
  const TABS = { OPTIONS: "options", MONITORS: "monitors" };
  let currentTab = TABS.OPTIONS;
  let id2 = params$1 == null ? void 0 : params$1.id;
  let team = params$1.team;
  let jobsStore = new CrawlerJobs(null, { crawler_id: id2 });
  component_subscribe($$self, jobsStore, (value) => $$invalidate(14, $jobsStore = value));
  let crawler = new Crawler$2({ id: id2 });
  component_subscribe($$self, crawler, (value) => $$invalidate(4, $crawler = value));
  let sieveStore = new Model$2.Sieves();
  let fetchComplete;
  let pagePromise = new Promise((resolve, reject2) => {
    fetchComplete = resolve;
  });
  let breadCrumbItems = [];
  let showErrorSummary = false;
  let errorSummary = [];
  setContext("job:store", jobsStore);
  async function getLatestJobDetails() {
    $$invalidate(3, errorSummary = await getErrorDetails());
    if (errorSummary.length > 0) {
      $$invalidate(2, showErrorSummary = true);
    } else {
      $$invalidate(2, showErrorSummary = false);
    }
  }
  async function getErrorDetails() {
    let excludeList = $crawler.config.excludes;
    let excludesParams = { filter: excludeList.map((el2) => el2.expr) };
    let res = await Api.api(`/crawlers/data/${$crawler.id}/jobs/error_urls?${qs.stringify(excludesParams)}`);
    if (res.data.length > 0) {
      res.data.forEach((element2) => {
        element2.job_ids = element2.job_ids.map((job) => {
          return {
            ...job,
            name: new Date(job.ts).toLocaleString()
          };
        });
      });
    }
    return res == null ? void 0 : res.data;
  }
  onMount(async () => {
    sieveStore.setQuery({ crawler_id: id2 });
    await Promise.all([jobsStore.fetch(), crawler.fetch(), sieveStore.fetch()]);
    $$invalidate(1, breadCrumbItems = [
      {
        name: "Crawlers",
        href: urlCfg.crawlerDetail($svelteParams.team || 0, "")
      },
      { name: $crawler.name }
    ]);
    await getLatestJobDetails();
    fetchComplete(true);
  });
  const click_handler = (e) => $$invalidate(0, currentTab = TABS.OPTIONS);
  const click_handler_1 = (e) => $$invalidate(0, currentTab = TABS.MONITORS);
  const excludes_update_handler = () => {
    getLatestJobDetails();
  };
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(13, params$1 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16384) {
      $jobsStore.totalCount && getLatestJobDetails();
    }
  };
  return [
    currentTab,
    breadCrumbItems,
    showErrorSummary,
    errorSummary,
    $crawler,
    TABS,
    id2,
    team,
    jobsStore,
    crawler,
    sieveStore,
    pagePromise,
    getLatestJobDetails,
    params$1,
    $jobsStore,
    click_handler,
    click_handler_1,
    excludes_update_handler
  ];
}
class Crawler_detail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$q, safe_not_equal, { params: 13 });
  }
}
function navBack() {
  if (history.length > 1) {
    history.back();
  } else {
    replace("/w/0/list/all/");
  }
}
function appCommon({
  setContext: setContext2,
  clientId
}) {
  let labels = new ModelLabel.Labels();
  let user = new Self();
  let redirectedRoutes = prepareRedirects();
  window.redirectedRoutes = redirectedRoutes;
  setContext2("api", Api.api);
  setContext2("user", user);
  setContext2("labels", labels);
  setContext2("clientId", clientId);
  const newURL = redirectedRoutes({ location });
  if (newURL) {
    replace(newURL);
  }
  const Root2 = View.RoutedRoot.extend({
    actions: {
      "go_back": { fn: "action_go_back" },
      "go_up": { fn: "action_go_up" }
    },
    action_go_back: function() {
      navBack();
    },
    action_go_up: function() {
      let path = location.hash.slice(1);
      if (path.endsWith("/")) {
        let parts = path.split("/");
        let newParts = parts.slice(0, parts.length - 2);
        let newPath = newParts.join("/") + "/";
        push$1(newPath);
      } else {
        push$1(path.slice(0, path.lastIndexOf("/") + 1));
      }
    },
    route: function(path) {
      push$1(`/${path}`);
    }
  });
  let root2 = new Root2();
  setContext2("view:root", root2);
  Core.Acts.setView(root2);
  Api.on("error:403", (err) => {
    Msg.error("You do not have enough permissions. Please contact your account administrator.");
    setTimeout(() => {
      Msg.reset();
    }, 8 * 1e3);
  });
  user.once("sync", () => identifyUser({ user, clientId }));
  return {
    labels,
    user,
    root: root2,
    navBack
  };
}
function create_catch_block$6(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$6(ctx) {
  let breadcrumb;
  let t;
  let crawleditor;
  let current;
  breadcrumb = new BreadCrumb({
    props: { items: ctx[2] }
  });
  crawleditor = new CrawlEditor({
    props: {
      rewriteURLSteps: ctx[1].fields.config.fields.rewriteURLSteps,
      validationSteps: ctx[1].fields.config.fields.validationSteps,
      crawler: ctx[1],
      $$slots: { buttons: [create_buttons_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(breadcrumb.$$.fragment);
      t = space();
      create_component(crawleditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(breadcrumb, target, anchor);
      insert(target, t, anchor);
      mount_component(crawleditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const breadcrumb_changes = {};
      if (dirty & 4)
        breadcrumb_changes.items = ctx2[2];
      breadcrumb.$set(breadcrumb_changes);
      const crawleditor_changes = {};
      if (dirty & 2)
        crawleditor_changes.rewriteURLSteps = ctx2[1].fields.config.fields.rewriteURLSteps;
      if (dirty & 2)
        crawleditor_changes.validationSteps = ctx2[1].fields.config.fields.validationSteps;
      if (dirty & 2)
        crawleditor_changes.crawler = ctx2[1];
      if (dirty & 65537) {
        crawleditor_changes.$$scope = { dirty, ctx: ctx2 };
      }
      crawleditor.$set(crawleditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(breadcrumb.$$.fragment, local);
      transition_in(crawleditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(breadcrumb.$$.fragment, local);
      transition_out(crawleditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(breadcrumb, detaching);
      if (detaching)
        detach(t);
      destroy_component(crawleditor, detaching);
    }
  };
}
function create_buttons_slot$1(ctx) {
  let div;
  let button0;
  let t0_value = TXT(ctx[0] ? "l_loading" : "a_save") + "";
  let t0;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button0 = element("button");
      t0 = text(t0_value);
      t1 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(button0, "type", "button");
      attr(button0, "class", "btn btn-primary xbtn-default");
      button0.disabled = ctx[0];
      attr(button1, "class", "btn btn-secondary");
      attr(div, "slot", "buttons");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      append(button0, t0);
      append(div, t1);
      append(div, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[6]),
          listen(button1, "click", navBack)
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = TXT(ctx2[0] ? "l_loading" : "a_save") + ""))
        set_data(t0, t0_value);
      if (dirty & 1) {
        button0.disabled = ctx2[0];
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_pending_block$6(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_default_slot$b(ctx) {
  let div2;
  let div1;
  let div0;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$6,
    then: create_then_block$6,
    catch: create_catch_block$6,
    value: 15,
    blocks: [, , ,]
  };
  handle_promise(ctx[5], info);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      info.block.c();
      attr(div0, "class", "col-sm-12");
      attr(div1, "class", "row");
      attr(div2, "class", "container");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      info.block.m(div0, info.anchor = null);
      info.mount = () => div0;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_header_slot$3(ctx) {
  let svlelte_fragment;
  return {
    c() {
      svlelte_fragment = element("svlelte:fragment");
      svlelte_fragment.innerHTML = `<div class="inline-block fw4 f2">Crawlers</div>`;
      attr(svlelte_fragment, "slot", "header");
    },
    m(target, anchor) {
      insert(target, svlelte_fragment, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(svlelte_fragment);
    }
  };
}
function create_topbar_slot$2(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({
    props: {
      showSearch: false,
      $$slots: { header: [create_header_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (dirty & 65536) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topbar.$set(topbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$p(ctx) {
  let title_value;
  let t;
  let layout;
  let current;
  document.title = title_value = ctx[3].name + " - Jobs | Distill.io";
  layout = new Layout$1({
    props: {
      renderDefaultToolbar: true,
      $$slots: {
        topbar: [create_topbar_slot$2],
        default: [create_default_slot$b]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 8) && title_value !== (title_value = ctx2[3].name + " - Jobs | Distill.io")) {
        document.title = title_value;
      }
      const layout_changes = {};
      if (dirty & 65543) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(layout, detaching);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let $crawler;
  let $svelteParams;
  component_subscribe($$self, params, ($$value) => $$invalidate(11, $svelteParams = $$value));
  let { params: params$1 } = $$props;
  let id2 = params$1 == null ? void 0 : params$1.id;
  let saving = false;
  let jobsStore = new CrawlerJobs(null, { crawler_id: id2 });
  let crawler = new Crawler$2({ id: id2 });
  component_subscribe($$self, crawler, (value) => $$invalidate(3, $crawler = value));
  let crawlerForm;
  let sieveStore = new Model$2.Sieves();
  let fetchComplete;
  let pagePromise = new Promise((resolve, reject2) => {
    fetchComplete = resolve;
  });
  let breadCrumbItems = [];
  onMount(async () => {
    sieveStore.setQuery({ crawler_id: id2 });
    await Promise.all([jobsStore.fetch(), crawler.fetch(), sieveStore.fetch()]);
    $$invalidate(2, breadCrumbItems = [
      {
        name: "Crawlers",
        href: urlCfg.crawlerDetail($svelteParams.team || 0, "")
      },
      { name: $crawler.name }
    ]);
    $$invalidate(1, crawlerForm = new Crawler$1(crawler));
    crawlerForm.error;
    fetchComplete(true);
  });
  async function saveCrawler() {
    try {
      $$invalidate(0, saving = true);
      let updatedCrawler = crawlerForm.toJSON();
      crawler.set(updatedCrawler);
      await crawler.save();
      navBack();
    } catch (err) {
      console.error("Error saving", err);
      err.message;
    }
    $$invalidate(0, saving = false);
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(7, params$1 = $$props2.params);
  };
  return [
    saving,
    crawlerForm,
    breadCrumbItems,
    $crawler,
    crawler,
    pagePromise,
    saveCrawler,
    params$1
  ];
}
class Crawler_editor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$p, safe_not_equal, { params: 7 });
  }
}
function get_each_context$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i2];
  return child_ctx;
}
function create_if_block_5(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[0].url + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "URL:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t2_value !== (t2_value = ctx2[0].url + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_4$2(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[0].code + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Status Code:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t2_value !== (t2_value = ctx2[0].code + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3$5(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[0].body + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Body:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t2_value !== (t2_value = ctx2[0].body + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$c(ctx) {
  let div;
  let t1;
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (typeof ctx2[0].cause === "string")
      return create_if_block_1$8;
    return create_else_block$6;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      div.textContent = "Cause";
      t1 = space();
      if_block.c();
      if_block_anchor = empty();
      attr(div, "class", "gray f5 lh-copy");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t1, anchor);
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$6(ctx) {
  let each_1_anchor;
  let each_value = Object.keys(ctx[0].cause);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$5(get_each_context$5(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        each_value = Object.keys(ctx2[0].cause);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$5(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$8(ctx) {
  let div;
  let label;
  let t1;
  let span;
  let t2_value = ctx[0].cause + "";
  let t2;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "Message:";
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, span);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t2_value !== (t2_value = ctx2[0].cause + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$6(ctx) {
  let div;
  let label;
  let t0_value = ctx[3] + "";
  let t0;
  let t1;
  let t2;
  let span;
  let t3_value = (typeof ctx[0].cause[ctx[3]] === "string" ? ctx[0].cause[ctx[3]] : JSON.stringify(ctx[0].cause[ctx[3]])) + "";
  let t3;
  let t4;
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = text(":");
      t2 = space();
      span = element("span");
      t3 = text(t3_value);
      t4 = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      append(label, t1);
      append(div, t2);
      append(div, span);
      append(span, t3);
      append(div, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t0_value !== (t0_value = ctx2[3] + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && t3_value !== (t3_value = (typeof ctx2[0].cause[ctx2[3]] === "string" ? ctx2[0].cause[ctx2[3]] : JSON.stringify(ctx2[0].cause[ctx2[3]])) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$5(ctx) {
  let if_block_anchor;
  let if_block = ctx[3] !== "stack" && create_if_block_2$6(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[3] !== "stack") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$o(ctx) {
  let div4;
  let a;
  let div0;
  let t0;
  let t1;
  let span0;
  let t2;
  let div3;
  let div1;
  let t4;
  let div2;
  let label;
  let t6;
  let span1;
  let t7_value = (ctx[0].message || "NA") + "";
  let t7;
  let t8;
  let t9;
  let t10;
  let t11;
  let show_if = !_.isEmpty(ctx[0].cause);
  let if_block0 = ctx[0].url && create_if_block_5(ctx);
  let if_block1 = ctx[0].code && create_if_block_4$2(ctx);
  let if_block2 = ctx[0].body && create_if_block_3$5(ctx);
  let if_block3 = show_if && create_if_block$c(ctx);
  return {
    c() {
      div4 = element("div");
      a = element("a");
      div0 = element("div");
      t0 = text(ctx[1]);
      t1 = space();
      span0 = element("span");
      t2 = space();
      div3 = element("div");
      div1 = element("div");
      div1.textContent = "Details";
      t4 = space();
      div2 = element("div");
      label = element("label");
      label.textContent = "Message:";
      t6 = space();
      span1 = element("span");
      t7 = text(t7_value);
      t8 = space();
      if (if_block0)
        if_block0.c();
      t9 = space();
      if (if_block1)
        if_block1.c();
      t10 = space();
      if (if_block2)
        if_block2.c();
      t11 = space();
      if (if_block3)
        if_block3.c();
      attr(div0, "class", "text-truncate");
      set_style(div0, "max-width", "300px");
      attr(span0, "class", "ml-1 dropdown-toggle");
      attr(a, "href", "#");
      attr(a, "title", "Click to view details");
      attr(a, "class", "d-flex align-items-center pointer");
      attr(a, "data-bs-toggle", "dropdown");
      attr(a, "aria-haspopup", "true");
      attr(a, "aria-expanded", "false");
      toggle_class(a, "red", ctx[2]);
      attr(div1, "class", "gray f5 lh-copy");
      attr(div3, "class", "dropdown-menu pa2");
      attr(div4, "class", "dropdown clearfix mr-2");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, a);
      append(a, div0);
      append(div0, t0);
      append(a, t1);
      append(a, span0);
      append(div4, t2);
      append(div4, div3);
      append(div3, div1);
      append(div3, t4);
      append(div3, div2);
      append(div2, label);
      append(div2, t6);
      append(div2, span1);
      append(span1, t7);
      append(div3, t8);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t9);
      if (if_block1)
        if_block1.m(div3, null);
      append(div3, t10);
      if (if_block2)
        if_block2.m(div3, null);
      append(div3, t11);
      if (if_block3)
        if_block3.m(div3, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2)
        set_data(t0, ctx2[1]);
      if (dirty & 4) {
        toggle_class(a, "red", ctx2[2]);
      }
      if (dirty & 1 && t7_value !== (t7_value = (ctx2[0].message || "NA") + ""))
        set_data(t7, t7_value);
      if (ctx2[0].url) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          if_block0.m(div3, t9);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0].code) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4$2(ctx2);
          if_block1.c();
          if_block1.m(div3, t10);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[0].body) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_3$5(ctx2);
          if_block2.c();
          if_block2.m(div3, t11);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty & 1)
        show_if = !_.isEmpty(ctx2[0].cause);
      if (show_if) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block$c(ctx2);
          if_block3.c();
          if_block3.m(div3, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let { errorObj } = $$props;
  let { message } = $$props;
  let { isError: isError2 = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("errorObj" in $$props2)
      $$invalidate(0, errorObj = $$props2.errorObj);
    if ("message" in $$props2)
      $$invalidate(1, message = $$props2.message);
    if ("isError" in $$props2)
      $$invalidate(2, isError2 = $$props2.isError);
  };
  return [errorObj, message, isError2];
}
class Log extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$o, safe_not_equal, { errorObj: 0, message: 1, isError: 2 });
  }
}
function get_each_context$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  return child_ctx;
}
function create_catch_block$5(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$5(ctx) {
  var _a;
  let if_block_anchor;
  let if_block = ((_a = ctx[1].urls) == null ? void 0 : _a.length) > 0 && create_if_block$b(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (((_a2 = ctx2[1].urls) == null ? void 0 : _a2.length) > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$b(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$b(ctx) {
  let label;
  let t1;
  let each_1_anchor;
  let each_value = ctx[1].urls;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$4(get_each_context$4(ctx, each_value, i2));
  }
  return {
    c() {
      label = element("label");
      label.textContent = `${"Crawl Path:"}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(label, "class", "gray");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 18) {
        each_value = ctx2[1].urls;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(label);
      if (detaching)
        detach(t1);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$4(ctx) {
  let div0;
  let i2;
  let i_class_value;
  let t0;
  let span;
  let t1_value = ctx[4][ctx[11].type || 0] + "";
  let t1;
  let t2;
  let div2;
  let div1;
  let t3_value = ctx[11].url + "";
  let t3;
  let t4;
  return {
    c() {
      div0 = element("div");
      i2 = element("i");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      div1 = element("div");
      t3 = text(t3_value);
      t4 = space();
      attr(i2, "class", i_class_value = "fa fa-long-arrow-up " + (!ctx[11].type && "d-none"));
      attr(span, "class", "ms-2 help");
      attr(div0, "class", "d-flex align-items-center");
      attr(div1, "class", "my-2");
      attr(div2, "class", "d-flex");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, i2);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      insert(target, t2, anchor);
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, t3);
      append(div2, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && i_class_value !== (i_class_value = "fa fa-long-arrow-up " + (!ctx2[11].type && "d-none"))) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & 2 && t1_value !== (t1_value = ctx2[4][ctx2[11].type || 0] + ""))
        set_data(t1, t1_value);
      if (dirty & 2 && t3_value !== (t3_value = ctx2[11].url + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div2);
    }
  };
}
function create_pending_block$5(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_fragment$n(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$5,
    then: create_then_block$5,
    catch: create_catch_block$5,
    value: 10,
    blocks: [, , ,]
  };
  handle_promise(ctx[3], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let $store;
  let $urlChain, $$unsubscribe_urlChain = noop$1, $$subscribe_urlChain = () => ($$unsubscribe_urlChain(), $$unsubscribe_urlChain = subscribe(urlChain, ($$value) => $$invalidate(1, $urlChain = $$value)), urlChain);
  $$self.$$.on_destroy.push(() => $$unsubscribe_urlChain());
  let { url } = $$props;
  let store2 = getContext("url:store");
  component_subscribe($$self, store2, (value) => $$invalidate(7, $store = value));
  let { crawler_id, jobId } = $store;
  let fetchComplete;
  let pagePromise = new Promise((resolve, reject2) => {
    fetchComplete = resolve;
  });
  let urlChain;
  const PATH_LABEL = {
    "redirect": "Redirect",
    "source": "Found in",
    "rewrite": "Rewritten",
    0: ""
  };
  onMount(async () => {
    $$subscribe_urlChain($$invalidate(0, urlChain = new UrlChain(
      {},
      {
        crawlerId: crawler_id,
        jobId,
        urlId: url.id
      }
    )));
    await urlChain.fetch();
    fetchComplete();
  });
  $$self.$$set = ($$props2) => {
    if ("url" in $$props2)
      $$invalidate(5, url = $$props2.url);
  };
  return [urlChain, $urlChain, store2, pagePromise, PATH_LABEL, url];
}
class URLChain extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$n, safe_not_equal, { url: 5 });
  }
}
function create_fragment$m(ctx) {
  let div0;
  let t0;
  let div7;
  let div6;
  let div3;
  let div2;
  let div1;
  let urlchain;
  let t1;
  let div5;
  let label;
  let t3;
  let div4;
  let a;
  let t4_value = new Date(ctx[0].first_seen_on).toLocaleString() + "";
  let t4;
  let a_href_value;
  let current;
  urlchain = new URLChain({ props: { url: ctx[0] } });
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div7 = element("div");
      div6 = element("div");
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      create_component(urlchain.$$.fragment);
      t1 = space();
      div5 = element("div");
      label = element("label");
      label.textContent = "First Seen On:";
      t3 = space();
      div4 = element("div");
      a = element("a");
      t4 = text(t4_value);
      attr(div0, "class", "container");
      attr(div1, "class", "mb-2");
      attr(div2, "class", "col");
      attr(div3, "class", "row my-4");
      attr(label, "class", "gray");
      attr(a, "href", a_href_value = urlCfg.crawlerJobDetail(ctx[1].team, ctx[1].id, ctx[0].first_job_id));
      attr(a, "target", "_blank");
      attr(div5, "class", "row my-4");
      attr(div6, "class", "container text-start");
      attr(div7, "class", "my-4 mx-4 px-1");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t0, anchor);
      insert(target, div7, anchor);
      append(div7, div6);
      append(div6, div3);
      append(div3, div2);
      append(div2, div1);
      mount_component(urlchain, div1, null);
      append(div6, t1);
      append(div6, div5);
      append(div5, label);
      append(div5, t3);
      append(div5, div4);
      append(div4, a);
      append(a, t4);
      current = true;
    },
    p(ctx2, [dirty]) {
      const urlchain_changes = {};
      if (dirty & 1)
        urlchain_changes.url = ctx2[0];
      urlchain.$set(urlchain_changes);
      if ((!current || dirty & 1) && t4_value !== (t4_value = new Date(ctx2[0].first_seen_on).toLocaleString() + ""))
        set_data(t4, t4_value);
      if (!current || dirty & 3 && a_href_value !== (a_href_value = urlCfg.crawlerJobDetail(ctx2[1].team, ctx2[1].id, ctx2[0].first_job_id))) {
        attr(a, "href", a_href_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(urlchain.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urlchain.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div7);
      destroy_component(urlchain);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let $params;
  component_subscribe($$self, params, ($$value) => $$invalidate(1, $params = $$value));
  let { url } = $$props;
  $$self.$$set = ($$props2) => {
    if ("url" in $$props2)
      $$invalidate(0, url = $$props2.url);
  };
  return [url, $params];
}
class URLDetails extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$m, safe_not_equal, { url: 0 });
  }
}
function create_else_block_1$2(ctx) {
  let t;
  return {
    c() {
      t = text("Not Crawled");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3$4(ctx) {
  let show_if;
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    var _a;
    if (dirty & 8)
      show_if = null;
    if (show_if == null)
      show_if = !!((_a = ctx2[3].status_code) == null ? void 0 : _a.toString().startsWith("3"));
    if (show_if)
      return create_if_block_4$1;
    return create_else_block$5;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type_1(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_2$5(ctx) {
  let log;
  let current;
  log = new Log({
    props: {
      message: ctx[4](ctx[3].state) + (ctx[3].error.code || ctx[3].error.message),
      errorObj: ctx[3].error,
      isError: !!ctx[3].error.code
    }
  });
  return {
    c() {
      create_component(log.$$.fragment);
    },
    m(target, anchor) {
      mount_component(log, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const log_changes = {};
      if (dirty & 8)
        log_changes.message = ctx2[4](ctx2[3].state) + (ctx2[3].error.code || ctx2[3].error.message);
      if (dirty & 8)
        log_changes.errorObj = ctx2[3].error;
      if (dirty & 8)
        log_changes.isError = !!ctx2[3].error.code;
      log.$set(log_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(log.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(log.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(log, detaching);
    }
  };
}
function create_if_block_1$7(ctx) {
  let log;
  let current;
  log = new Log({
    props: {
      message: ctx[4](ctx[3].state),
      errorObj: { message: "Reached URL Limit" }
    }
  });
  return {
    c() {
      create_component(log.$$.fragment);
    },
    m(target, anchor) {
      mount_component(log, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const log_changes = {};
      if (dirty & 8)
        log_changes.message = ctx2[4](ctx2[3].state);
      log.$set(log_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(log.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(log.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(log, detaching);
    }
  };
}
function create_else_block$5(ctx) {
  let t;
  return {
    c() {
      t = text("Success");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_4$1(ctx) {
  let t;
  return {
    c() {
      t = text("Redirected");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$a(ctx) {
  let urldetails;
  let current;
  urldetails = new URLDetails({ props: { url: ctx[3] } });
  return {
    c() {
      create_component(urldetails.$$.fragment);
    },
    m(target, anchor) {
      mount_component(urldetails, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const urldetails_changes = {};
      if (dirty & 8)
        urldetails_changes.url = ctx2[3];
      urldetails.$set(urldetails_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(urldetails.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urldetails.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(urldetails, detaching);
    }
  };
}
function create_fragment$l(ctx) {
  let tr0;
  let td0;
  let button;
  let i2;
  let i_class_value;
  let button_data_bs_target_value;
  let t0;
  let t1_value = ctx[3].url + "";
  let t1;
  let td0_title_value;
  let t2;
  let td1;
  let t3_value = (ctx[3].content_type || "NA") + "";
  let t3;
  let t4;
  let td2;
  let t5_value = (ctx[3].status_code || "NA") + "";
  let t5;
  let t6;
  let td3;
  let current_block_type_index;
  let if_block0;
  let tr0_id_value;
  let t7;
  let tr1;
  let td4;
  let tr1_id_value;
  let tr1_data_bs_parent_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$7, create_if_block_2$5, create_if_block_3$4, create_else_block_1$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === C$1.STATE_DONE && ctx2[3].state === C$1.STATE_DEFAULT)
      return 0;
    if (ctx2[3].error)
      return 1;
    if (ctx2[3].state === C$1.STATE_DONE)
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[2] && create_if_block$a(ctx);
  return {
    c() {
      tr0 = element("tr");
      td0 = element("td");
      button = element("button");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      td1 = element("td");
      t3 = text(t3_value);
      t4 = space();
      td2 = element("td");
      t5 = text(t5_value);
      t6 = space();
      td3 = element("td");
      if_block0.c();
      t7 = space();
      tr1 = element("tr");
      td4 = element("td");
      if (if_block1)
        if_block1.c();
      attr(i2, "class", i_class_value = "fa " + (ctx[2] ? "fa-angle-down" : "fa-angle-right"));
      set_style(i2, "width", "10px");
      attr(button, "class", "btn shadow-none");
      attr(button, "data-bs-toggle", "collapse");
      attr(button, "data-bs-target", button_data_bs_target_value = "#collapsible-" + ctx[3].id);
      attr(button, "title", "Click to show job run history");
      attr(td0, "title", td0_title_value = ctx[3].url);
      attr(td0, "class", "truncate mw6");
      attr(tr0, "id", tr0_id_value = ctx[3].id);
      attr(td4, "colspan", "4");
      attr(tr1, "id", tr1_id_value = "collapsible-" + ctx[3].id);
      attr(tr1, "class", "accordion-collapse collapse");
      attr(tr1, "data-bs-parent", tr1_data_bs_parent_value = "#row-" + ctx[3].id);
    },
    m(target, anchor) {
      insert(target, tr0, anchor);
      append(tr0, td0);
      append(td0, button);
      append(button, i2);
      append(td0, t0);
      append(td0, t1);
      append(tr0, t2);
      append(tr0, td1);
      append(td1, t3);
      append(tr0, t4);
      append(tr0, td2);
      append(td2, t5);
      append(tr0, t6);
      append(tr0, td3);
      if_blocks[current_block_type_index].m(td3, null);
      insert(target, t7, anchor);
      insert(target, tr1, anchor);
      append(tr1, td4);
      if (if_block1)
        if_block1.m(td4, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 4 && i_class_value !== (i_class_value = "fa " + (ctx2[2] ? "fa-angle-down" : "fa-angle-right"))) {
        attr(i2, "class", i_class_value);
      }
      if (!current || dirty & 8 && button_data_bs_target_value !== (button_data_bs_target_value = "#collapsible-" + ctx2[3].id)) {
        attr(button, "data-bs-target", button_data_bs_target_value);
      }
      if ((!current || dirty & 8) && t1_value !== (t1_value = ctx2[3].url + ""))
        set_data(t1, t1_value);
      if (!current || dirty & 8 && td0_title_value !== (td0_title_value = ctx2[3].url)) {
        attr(td0, "title", td0_title_value);
      }
      if ((!current || dirty & 8) && t3_value !== (t3_value = (ctx2[3].content_type || "NA") + ""))
        set_data(t3, t3_value);
      if ((!current || dirty & 8) && t5_value !== (t5_value = (ctx2[3].status_code || "NA") + ""))
        set_data(t5, t5_value);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(td3, null);
      }
      if (!current || dirty & 8 && tr0_id_value !== (tr0_id_value = ctx2[3].id)) {
        attr(tr0, "id", tr0_id_value);
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$a(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(td4, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & 8 && tr1_id_value !== (tr1_id_value = "collapsible-" + ctx2[3].id)) {
        attr(tr1, "id", tr1_id_value);
      }
      if (!current || dirty & 8 && tr1_data_bs_parent_value !== (tr1_data_bs_parent_value = "#row-" + ctx2[3].id)) {
        attr(tr1, "data-bs-parent", tr1_data_bs_parent_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(tr0);
      if_blocks[current_block_type_index].d();
      if (detaching)
        detach(t7);
      if (detaching)
        detach(tr1);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let $url, $$unsubscribe_url = noop$1, $$subscribe_url = () => ($$unsubscribe_url(), $$unsubscribe_url = subscribe(url, ($$value) => $$invalidate(3, $url = $$value)), url);
  $$self.$$.on_destroy.push(() => $$unsubscribe_url());
  let { jobState } = $$props;
  const getStateText = (state) => {
    switch (state) {
      case C$1.STATE_DEFAULT:
      case C$1.STATE_PAUSED:
        return "Not Crawled: ";
      default:
        return "";
    }
  };
  let { url } = $$props;
  $$subscribe_url();
  let expanded = false;
  function toggleURLExpanded() {
    $$invalidate(2, expanded = !expanded);
  }
  $$self.$$set = ($$props2) => {
    if ("jobState" in $$props2)
      $$invalidate(0, jobState = $$props2.jobState);
    if ("url" in $$props2)
      $$subscribe_url($$invalidate(1, url = $$props2.url));
  };
  return [jobState, url, expanded, $url, getStateText, toggleURLExpanded];
}
class UrlRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$l, safe_not_equal, { jobState: 0, url: 1 });
  }
}
function get_each_context$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  child_ctx[5] = list;
  child_ctx[6] = i2;
  return child_ctx;
}
function create_each_block$3(ctx) {
  let div;
  let label;
  let t0_value = ctx[4].label + "";
  let t0;
  let label_for_value;
  let t1;
  let input;
  let input_id_value;
  let input_value_value;
  let t2;
  let mounted;
  let dispose;
  function input_change_handler() {
    ctx[2].call(input, ctx[5], ctx[6]);
  }
  return {
    c() {
      div = element("div");
      label = element("label");
      t0 = text(t0_value);
      t1 = space();
      input = element("input");
      t2 = space();
      attr(label, "class", "col-form-label");
      attr(label, "for", label_for_value = "filter-" + ctx[4].label);
      attr(input, "type", "checkbox");
      set_style(input, "vertical-align", "top");
      set_style(input, "margin", "0 4px");
      attr(input, "id", input_id_value = "filter-" + ctx[4].label);
      input.__value = input_value_value = ctx[4].label;
      input.value = input.__value;
      attr(div, "class", "flex items-center mr-6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(label, t0);
      append(div, t1);
      append(div, input);
      input.checked = ctx[4].checked;
      append(div, t2);
      if (!mounted) {
        dispose = [
          listen(input, "change", input_change_handler),
          listen(input, "change", ctx[1])
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[4].label + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && label_for_value !== (label_for_value = "filter-" + ctx[4].label)) {
        attr(label, "for", label_for_value);
      }
      if (dirty & 1 && input_id_value !== (input_id_value = "filter-" + ctx[4].label)) {
        attr(input, "id", input_id_value);
      }
      if (dirty & 1 && input_value_value !== (input_value_value = ctx[4].label)) {
        input.__value = input_value_value;
        input.value = input.__value;
      }
      if (dirty & 1) {
        input.checked = ctx[4].checked;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$k(ctx) {
  let each_1_anchor;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$3(get_each_context$3(ctx, each_value, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  const dispatch = createEventDispatcher();
  let { items } = $$props;
  function onSelect(e) {
    dispatch("select", items);
  }
  function input_change_handler(each_value, item_index) {
    each_value[item_index].checked = this.checked;
    $$invalidate(0, items);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
  };
  return [items, onSelect, input_change_handler];
}
class FilterMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$k, safe_not_equal, { items: 0 });
  }
}
function get_each_context$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2];
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  child_ctx[27] = list;
  child_ctx[28] = i2;
  return child_ctx;
}
function get_each_context_2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i2];
  return child_ctx;
}
function create_else_block_2(ctx) {
  let each_1_anchor;
  let each_value_1 = ctx[3];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16460) {
        each_value_1 = ctx2[3];
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$6(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_each_block_2(ctx) {
  let option;
  let t_value = (ctx[29] || "Other") + "";
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[29];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 8 && t_value !== (t_value = (ctx2[29] || "Other") + ""))
        set_data(t, t_value);
      if (dirty[0] & 8 && option_value_value !== (option_value_value = ctx2[29])) {
        option.__value = option_value_value;
        option.value = option.__value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_each_block_1(ctx) {
  let div;
  let select2;
  let option;
  let t0;
  let t1_value = ctx[6][ctx[26].field] + "";
  let t1;
  let select_title_value;
  let t2;
  let mounted;
  let dispose;
  let each_value_2 = ctx[26].values;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  function select_change_handler() {
    ctx[17].call(select2, ctx[26]);
  }
  function change_handler(...args) {
    return ctx[18](ctx[26], ...args);
  }
  return {
    c() {
      div = element("div");
      select2 = element("select");
      option = element("option");
      t0 = text("All ");
      t1 = text(t1_value);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      option.__value = "all";
      option.value = option.__value;
      attr(select2, "id", "job-type-selection");
      attr(select2, "class", "pa1 btn-sm");
      attr(select2, "title", select_title_value = "Select " + ctx[6][ctx[26].field]);
      if (ctx[2][ctx[26].field] === void 0)
        add_render_callback(select_change_handler);
      attr(div, "class", "mx-2 pa1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, select2);
      append(select2, option);
      append(option, t0);
      append(option, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(select2, null);
        }
      }
      select_option(select2, ctx[2][ctx[26].field], true);
      append(div, t2);
      if (!mounted) {
        dispose = [
          listen(select2, "change", select_change_handler),
          listen(select2, "change", change_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 8 && t1_value !== (t1_value = ctx[6][ctx[26].field] + ""))
        set_data(t1, t1_value);
      if (dirty[0] & 8) {
        each_value_2 = ctx[26].values;
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_2(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(select2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (dirty[0] & 8 && select_title_value !== (select_title_value = "Select " + ctx[6][ctx[26].field])) {
        attr(select2, "title", select_title_value);
      }
      if (dirty[0] & 12) {
        select_option(select2, ctx[2][ctx[26].field]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_1$1(ctx) {
  let tr;
  let td;
  let t0;
  let t1_value = new Date(ctx[0]).toLocaleString() + "";
  let t1;
  let t2;
  let a;
  return {
    c() {
      tr = element("tr");
      td = element("td");
      t0 = text("This job was truncated on ");
      t1 = text(t1_value);
      t2 = text(". Learn more about how ");
      a = element("a");
      a.textContent = "crawl log is stored and truncated.";
      attr(a, "target", "_blank");
      attr(a, "href", "https://distill.io/docs/web-monitor/sitemap-monitor-using-a-crawler/");
      attr(td, "colspan", "4");
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      append(tr, td);
      append(td, t0);
      append(td, t1);
      append(td, t2);
      append(td, a);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t1_value !== (t1_value = new Date(ctx2[0]).toLocaleString() + ""))
        set_data(t1, t1_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(tr);
    }
  };
}
function create_if_block$9(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[4].models;
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$2(get_each_context$2(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block$4();
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 65552) {
        each_value = ctx2[4].models;
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block$4();
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_else_block$4(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "No urls were crawled";
      attr(p, "class", "pl-3 mt-2");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_each_block$2(ctx) {
  let urlrow;
  let current;
  const urlrow_spread_levels = [{ url: ctx[23] }, ctx[16]];
  let urlrow_props = {};
  for (let i2 = 0; i2 < urlrow_spread_levels.length; i2 += 1) {
    urlrow_props = assign(urlrow_props, urlrow_spread_levels[i2]);
  }
  urlrow = new UrlRow({ props: urlrow_props });
  return {
    c() {
      create_component(urlrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(urlrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const urlrow_changes = dirty[0] & 65552 ? get_spread_update(urlrow_spread_levels, [
        dirty[0] & 16 && { url: ctx2[23] },
        dirty[0] & 65536 && get_spread_object(ctx2[16])
      ]) : {};
      urlrow.$set(urlrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(urlrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urlrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(urlrow, detaching);
    }
  };
}
function create_fragment$j(ctx) {
  let div3;
  let div2;
  let div0;
  let t3;
  let div1;
  let t4;
  let current_block_type_index;
  let if_block0;
  let t5;
  let filtermenu;
  let t6;
  let searchbar;
  let t7;
  let button;
  let t8;
  let listpager;
  let t9;
  let sortby;
  let t10;
  let table;
  let thead;
  let t18;
  let tbody;
  let current_block_type_index_1;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$6, create_else_block_2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5] === true)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  filtermenu = new FilterMenu({ props: { items: ctx[8] } });
  filtermenu.$on("select", ctx[12]);
  searchbar = new SearchBar({});
  searchbar.$on("search", ctx[13]);
  listpager = new ListPager({ props: { store: ctx[1] } });
  sortby = new SortBy({
    props: {
      onSort: ctx[11],
      sortingFields: ctx[7],
      currentFieldName: ctx[4].orderBy
    }
  });
  const if_block_creators_1 = [create_if_block$9, create_else_block_1$1];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (!ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_1(ctx);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      div0.innerHTML = `<h3>URLs</h3> 
    <small>List of urls obtained by crawler in this run</small>`;
      t3 = space();
      div1 = element("div");
      t4 = space();
      if_block0.c();
      t5 = space();
      create_component(filtermenu.$$.fragment);
      t6 = space();
      create_component(searchbar.$$.fragment);
      t7 = space();
      button = element("button");
      button.innerHTML = `<i class="fa fa-download"></i>`;
      t8 = space();
      create_component(listpager.$$.fragment);
      t9 = space();
      create_component(sortby.$$.fragment);
      t10 = space();
      table = element("table");
      thead = element("thead");
      thead.innerHTML = `<tr class="bg-gray-200"><th class="w-75">URL</th> 
        <th>Content Type</th> 
        <th>Status Code</th> 
        <th>Status</th></tr>`;
      t18 = space();
      tbody = element("tbody");
      if_block1.c();
      set_style(div0, "flex", "1");
      attr(div1, "class", "flex-1");
      set_style(div1, "max-width", "50px");
      attr(button, "class", "btn btn-default btn-sm mr-6 -ml-5");
      attr(button, "title", "download csv");
      attr(div2, "class", "card-header flex items-center");
      attr(thead, "class", "table-light");
      attr(table, "class", "table");
      attr(div3, "class", "card panel-default my-5");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div2, t3);
      append(div2, div1);
      append(div2, t4);
      if_blocks[current_block_type_index].m(div2, null);
      append(div2, t5);
      mount_component(filtermenu, div2, null);
      append(div2, t6);
      mount_component(searchbar, div2, null);
      append(div2, t7);
      append(div2, button);
      append(div2, t8);
      mount_component(listpager, div2, null);
      append(div2, t9);
      mount_component(sortby, div2, null);
      append(div3, t10);
      append(div3, table);
      append(table, thead);
      append(table, t18);
      append(table, tbody);
      if_blocks_1[current_block_type_index_1].m(tbody, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[15]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div2, t5);
      }
      const listpager_changes = {};
      if (dirty[0] & 2)
        listpager_changes.store = ctx2[1];
      listpager.$set(listpager_changes);
      const sortby_changes = {};
      if (dirty[0] & 16)
        sortby_changes.currentFieldName = ctx2[4].orderBy;
      sortby.$set(sortby_changes);
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block1 = if_blocks_1[current_block_type_index_1];
        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(tbody, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(filtermenu.$$.fragment, local);
      transition_in(searchbar.$$.fragment, local);
      transition_in(listpager.$$.fragment, local);
      transition_in(sortby.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(filtermenu.$$.fragment, local);
      transition_out(searchbar.$$.fragment, local);
      transition_out(listpager.$$.fragment, local);
      transition_out(sortby.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if_blocks[current_block_type_index].d();
      destroy_component(filtermenu);
      destroy_component(searchbar);
      destroy_component(listpager);
      destroy_component(sortby);
      if_blocks_1[current_block_type_index_1].d();
      mounted = false;
      dispose();
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  const omit_props_names = ["truncated"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $contentTypeStore;
  let $store;
  let $isSyncing;
  let { truncated } = $$props;
  let store2 = getContext("url:store");
  component_subscribe($$self, store2, (value) => $$invalidate(4, $store = value));
  let selectedJobTypes = {};
  let filterLabels = {
    content_type: "Content Types",
    domain: "Domains"
  };
  const sortingFields = [
    { value: "url", label: "Url" },
    { value: "-url", label: "Url - Descending" },
    {
      value: "content_type",
      label: "Content Type"
    },
    {
      value: "-content_type",
      label: "Content Type - Descending"
    }
  ];
  const items = [
    {
      fields: [
        {
          field: "status_code.in",
          value: [401, 404, 500]
        },
        { field: "state", value: C$1.STATE_ERROR }
      ],
      op: "$or",
      checked: false,
      label: "Errorred"
    }
  ];
  let { crawler_id, jobId } = $store;
  let contentTypeStore = new FieldFilter(
    {},
    {
      crawler_id,
      jobId,
      fields: ["content_type", "domain"]
    }
  );
  component_subscribe($$self, contentTypeStore, (value) => $$invalidate(20, $contentTypeStore = value));
  let isSyncing = contentTypeStore.syncing;
  component_subscribe($$self, isSyncing, (value) => $$invalidate(5, $isSyncing = value));
  let fields = [];
  let searchQuery = "";
  onMount(async () => {
    await contentTypeStore.fetch();
    $$invalidate(3, fields = $contentTypeStore.result);
    for (let field of fields) {
      $$invalidate(2, selectedJobTypes[field.field] = "all", selectedJobTypes);
    }
  });
  async function onSort(by) {
    $$invalidate(1, store2.orderBy = by, store2);
    await store2.fetch();
  }
  async function onFilter(e) {
    let filters = e.detail;
    let query = store2.getQuery();
    filters.forEach((filter2) => {
      if (!filter2.checked) {
        query[filter2.op] && delete query[filter2.op];
      } else {
        filter2.fields.forEach((filterDetails) => {
          query[filter2.op] = query[filter2.op] || [];
          query[filter2.op].push([filterDetails.field, filterDetails.value]);
        });
      }
    });
    store2.setQuery(query);
    return await store2.goto(0, { reset: true });
  }
  async function onSearch(e) {
    let { phrase } = e.detail;
    if (!phrase) {
      let query = store2.getQuery();
      delete query.$or["url.ilike"];
      store2.setQuery(query);
      return await store2.goto(0, { reset: true });
    }
    searchQuery = `%${phrase}%`;
    store2.setQuery({
      ...store2.getQuery(),
      $or: { "url.ilike": searchQuery }
    });
    return await store2.goto(0, { reset: true });
  }
  async function onJobTypeChange(e, field) {
    let query = store2.getQuery();
    if (selectedJobTypes[field] === null) {
      query[field] = "$null";
    } else if (selectedJobTypes[field] !== "all") {
      query[field] = selectedJobTypes[field];
    } else {
      delete query[field];
    }
    store2.setQuery(query);
    return await store2.goto(0, { reset: true });
  }
  async function downloadCSV() {
    const filename = `export - ${format(new Date(), "hh-mm_yyyy-MM-dd")}.csv`;
    const href2 = `${window.URL_API}/crawlers/data/${crawler_id}/jobs/${jobId}/download`;
    downloadUrl(href2, filename);
  }
  function select_change_handler(field) {
    selectedJobTypes[field.field] = select_value(this);
    $$invalidate(2, selectedJobTypes);
    $$invalidate(3, fields);
  }
  const change_handler = (field, e) => onJobTypeChange(e, field.field);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("truncated" in $$new_props)
      $$invalidate(0, truncated = $$new_props.truncated);
  };
  return [
    truncated,
    store2,
    selectedJobTypes,
    fields,
    $store,
    $isSyncing,
    filterLabels,
    sortingFields,
    items,
    contentTypeStore,
    isSyncing,
    onSort,
    onFilter,
    onSearch,
    onJobTypeChange,
    downloadCSV,
    $$restProps,
    select_change_handler,
    change_handler
  ];
}
class List extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$j, safe_not_equal, { truncated: 0 }, null, [-1, -1]);
  }
}
function get_each_context$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  child_ctx[23] = i2;
  return child_ctx;
}
function create_catch_block$4(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$4(ctx) {
  let breadcrumb;
  let t0;
  let div0;
  let h31;
  let h30;
  let t1_value = ctx[6].name + "";
  let t1;
  let t2;
  let t3_value = new Date(ctx[5].ts).toLocaleString() + "";
  let t3;
  let t4;
  let div3;
  let div2;
  let div1;
  let t5;
  let t6;
  let list;
  let current;
  breadcrumb = new BreadCrumb({
    props: { items: ctx[2] }
  });
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$1(get_each_context$1(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = ctx[3] && create_if_block$8(ctx);
  list = new List({
    props: {
      jobState: ctx[5].state,
      truncated: ctx[0]
    }
  });
  return {
    c() {
      create_component(breadcrumb.$$.fragment);
      t0 = space();
      div0 = element("div");
      h31 = element("h3");
      h30 = element("h3");
      t1 = text(t1_value);
      t2 = text(": Details for job run on ");
      t3 = text(t3_value);
      t4 = space();
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t5 = space();
      if (if_block)
        if_block.c();
      t6 = space();
      create_component(list.$$.fragment);
      attr(div0, "class", "flex items-center xpage-header mt-3");
      attr(div1, "class", "ms-2");
      attr(div2, "class", "ms-2");
      attr(div3, "class", "mt-5");
    },
    m(target, anchor) {
      mount_component(breadcrumb, target, anchor);
      insert(target, t0, anchor);
      insert(target, div0, anchor);
      append(div0, h31);
      append(h31, h30);
      append(h30, t1);
      append(h30, t2);
      append(h30, t3);
      insert(target, t4, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      insert(target, t5, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t6, anchor);
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const breadcrumb_changes = {};
      if (dirty & 4)
        breadcrumb_changes.items = ctx2[2];
      breadcrumb.$set(breadcrumb_changes);
      if ((!current || dirty & 64) && t1_value !== (t1_value = ctx2[6].name + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & 32) && t3_value !== (t3_value = new Date(ctx2[5].ts).toLocaleString() + ""))
        set_data(t3, t3_value);
      if (dirty & 2) {
        each_value = ctx2[1];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div1, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t6.parentNode, t6);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const list_changes = {};
      if (dirty & 32)
        list_changes.jobState = ctx2[5].state;
      if (dirty & 1)
        list_changes.truncated = ctx2[0];
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(breadcrumb.$$.fragment, local);
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(breadcrumb.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(breadcrumb, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(div3);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t5);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t6);
      destroy_component(list, detaching);
    }
  };
}
function create_each_block$1(ctx) {
  let rundetail;
  let current;
  rundetail = new RunDetail({
    props: {
      lastJob: ctx[23] === ctx[1].length - 1,
      jobState: ctx[21]
    }
  });
  return {
    c() {
      create_component(rundetail.$$.fragment);
    },
    m(target, anchor) {
      mount_component(rundetail, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const rundetail_changes = {};
      if (dirty & 2)
        rundetail_changes.lastJob = ctx2[23] === ctx2[1].length - 1;
      if (dirty & 2)
        rundetail_changes.jobState = ctx2[21];
      rundetail.$set(rundetail_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(rundetail.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rundetail.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(rundetail, detaching);
    }
  };
}
function create_if_block$8(ctx) {
  let crawlerrordetails;
  let current;
  crawlerrordetails = new CrawlErrorDetails({
    props: {
      isJobPage: true,
      crawler: ctx[7],
      title: "URLs causing failed crawls",
      errorSummary: ctx[4]
    }
  });
  crawlerrordetails.$on("excludes_update", ctx[12]);
  return {
    c() {
      create_component(crawlerrordetails.$$.fragment);
    },
    m(target, anchor) {
      mount_component(crawlerrordetails, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const crawlerrordetails_changes = {};
      if (dirty & 16)
        crawlerrordetails_changes.errorSummary = ctx2[4];
      crawlerrordetails.$set(crawlerrordetails_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(crawlerrordetails.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(crawlerrordetails.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(crawlerrordetails, detaching);
    }
  };
}
function create_pending_block$4(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_default_slot$a(ctx) {
  let div2;
  let div1;
  let div0;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$4,
    then: create_then_block$4,
    catch: create_catch_block$4,
    value: 20,
    blocks: [, , ,]
  };
  handle_promise(ctx[9], info);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      info.block.c();
      attr(div0, "class", "col-sm-12");
      attr(div1, "class", "row");
      attr(div2, "class", "container");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      info.block.m(div0, info.anchor = null);
      info.mount = () => div0;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_header_slot$2(ctx) {
  let svlelte_fragment;
  return {
    c() {
      svlelte_fragment = element("svlelte:fragment");
      svlelte_fragment.innerHTML = `<div class="inline-block fw4 f2">Crawlers</div>`;
      attr(svlelte_fragment, "slot", "header");
    },
    m(target, anchor) {
      insert(target, svlelte_fragment, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(svlelte_fragment);
    }
  };
}
function create_topbar_slot$1(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({
    props: {
      showSearch: false,
      $$slots: { header: [create_header_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (dirty & 16777216) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topbar.$set(topbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$i(ctx) {
  let title_value;
  let t;
  let layout;
  let current;
  document.title = title_value = ctx[6].name + " - Job Details | Distill.io";
  layout = new Layout$1({
    props: {
      renderDefaultToolbar: true,
      $$slots: {
        topbar: [create_topbar_slot$1],
        default: [create_default_slot$a]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(layout.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 64) && title_value !== (title_value = ctx2[6].name + " - Job Details | Distill.io")) {
        document.title = title_value;
      }
      const layout_changes = {};
      if (dirty & 16777343) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(layout, detaching);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let $job;
  let $crawler;
  let $svelteParams;
  component_subscribe($$self, params, ($$value) => $$invalidate(14, $svelteParams = $$value));
  let { params: params$1 } = $$props;
  let truncated = false;
  let states = [];
  let crawler_id = params$1 == null ? void 0 : params$1.id;
  let id2 = params$1 == null ? void 0 : params$1.jobId;
  let crawler = new Crawler$2({ id: crawler_id });
  component_subscribe($$self, crawler, (value) => $$invalidate(6, $crawler = value));
  let job = new CrawlerJob({ id: id2 }, { crawler_id });
  component_subscribe($$self, job, (value) => $$invalidate(5, $job = value));
  let urlStore = new Urls({}, { crawler_id, id: id2 });
  let jobStates = new JobStates({}, { crawler_id, id: id2 });
  let fetchComplete;
  let pagePromise = new Promise((resolve, reject2) => {
    fetchComplete = resolve;
  });
  let breadCrumbItems = [];
  let showErrorSummary = false;
  let errorSummary = [];
  async function getLatestJobDetails() {
    $$invalidate(4, errorSummary = await getErrorDetails());
    $$invalidate(3, showErrorSummary = errorSummary.length > 0 && !!states.find((el2) => el2.state === C$1.STATE_ERROR));
  }
  async function getErrorDetails() {
    let excludeList = $crawler.config.excludes;
    let excludesParams = { filter: excludeList.map((el2) => el2.expr) };
    let res = await Api.api(`/crawlers/data/${$crawler.id}/jobs/${id2}/error_urls?${qs.stringify(excludesParams)}`);
    return res.errored;
  }
  setContext("url:store", urlStore);
  onMount(async () => {
    await Promise.all([crawler.fetch(), job.fetch(), jobStates.fetch()]);
    $$invalidate(0, truncated = $job.meta.ts_truncated);
    if (!truncated) {
      await urlStore.fetch();
    }
    $$invalidate(1, states = jobStates.toJSON());
    await getLatestJobDetails();
    $$invalidate(2, breadCrumbItems = [
      {
        name: "Crawlers",
        href: urlCfg.crawlerDetail($svelteParams.team || 0, "")
      },
      {
        name: $crawler.name,
        href: urlCfg.crawlerDetail($svelteParams.team || 0, $crawler.id)
      },
      { name: new Date($job.ts).toLocaleString() }
    ]);
    fetchComplete(true);
  });
  const excludes_update_handler = () => {
    getLatestJobDetails();
  };
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(11, params$1 = $$props2.params);
  };
  return [
    truncated,
    states,
    breadCrumbItems,
    showErrorSummary,
    errorSummary,
    $job,
    $crawler,
    crawler,
    job,
    pagePromise,
    getLatestJobDetails,
    params$1,
    excludes_update_handler
  ];
}
class Job_detail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$i, safe_not_equal, { params: 11 });
  }
}
function create_else_block$3(ctx) {
  let div1;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = `<div class="alert alert-success">Thank you! Your response has been saved.</div>`;
      attr(div1, "class", "flex align-item justify-center");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_if_block$7(ctx) {
  var _a;
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = ((_a = ctx[2]) == null ? void 0 : _a.formName) && create_if_block_3$3(ctx);
  let if_block1 = ctx[0].formId && create_if_block_2$4(ctx);
  let if_block2 = ctx[2] && create_if_block_1$5(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      if ((_a2 = ctx2[2]) == null ? void 0 : _a2.formName) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$3(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0].formId) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_1$5(ctx2);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function create_if_block_3$3(ctx) {
  let h4;
  let t_value = ctx[2].formName + "";
  let t;
  return {
    c() {
      h4 = element("h4");
      t = text(t_value);
      attr(h4, "class", "pl3 font-bold");
    },
    m(target, anchor) {
      insert(target, h4, anchor);
      append(h4, t);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[2].formName + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(h4);
    }
  };
}
function create_if_block_2$4(ctx) {
  let formgroup;
  let updating_model;
  let current;
  function formgroup_model_binding(value) {
    ctx[4](value);
  }
  let formgroup_props = { id: ctx[0].formId };
  if (ctx[2] !== void 0) {
    formgroup_props.model = ctx[2];
  }
  formgroup = new FormGroup({ props: formgroup_props });
  binding_callbacks.push(() => bind$1(formgroup, "model", formgroup_model_binding));
  return {
    c() {
      create_component(formgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formgroup_changes = {};
      if (dirty & 1)
        formgroup_changes.id = ctx2[0].formId;
      if (!updating_model && dirty & 4) {
        updating_model = true;
        formgroup_changes.model = ctx2[2];
        add_flush_callback(() => updating_model = false);
      }
      formgroup.$set(formgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formgroup, detaching);
    }
  };
}
function create_if_block_1$5(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.textContent = `${TXT("a_submit")}`;
      attr(button, "class", "btn btn-primary xbtn-default mt-1 mb-4");
      attr(div, "class", "pl3 xbg-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[3]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$9(ctx) {
  let div4;
  let div3;
  let div0;
  let t;
  let div2;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$7, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      t = space();
      div2 = element("div");
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "col-sm-4");
      attr(div1, "class", "row mb2");
      attr(div2, "class", "col-sm-4");
      attr(div3, "class", "row");
      attr(div4, "class", "container");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div0);
      append(div3, t);
      append(div3, div2);
      append(div2, div1);
      if_blocks[current_block_type_index].m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_header_slot$1(ctx) {
  let svlelte_fragment;
  return {
    c() {
      svlelte_fragment = element("svlelte:fragment");
      svlelte_fragment.innerHTML = `<div class="inline-block fw4 f2">Feedback</div>`;
      attr(svlelte_fragment, "slot", "header");
    },
    m(target, anchor) {
      insert(target, svlelte_fragment, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(svlelte_fragment);
    }
  };
}
function create_topbar_slot(ctx) {
  let topbar;
  let current;
  topbar = new Topbar({
    props: {
      showSearch: false,
      $$slots: { header: [create_header_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(topbar.$$.fragment);
    },
    m(target, anchor) {
      mount_component(topbar, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const topbar_changes = {};
      if (dirty & 64) {
        topbar_changes.$$scope = { dirty, ctx: ctx2 };
      }
      topbar.$set(topbar_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(topbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(topbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(topbar, detaching);
    }
  };
}
function create_fragment$h(ctx) {
  let t;
  let layout;
  let current;
  layout = new Layout$1({
    props: {
      $$slots: {
        topbar: [create_topbar_slot],
        default: [create_default_slot$9]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(layout.$$.fragment);
      document.title = "Feedback | Distill.io";
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(layout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const layout_changes = {};
      if (dirty & 71) {
        layout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      layout.$set(layout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(layout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(layout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(layout, detaching);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let $querystring;
  component_subscribe($$self, querystring, ($$value) => $$invalidate(5, $querystring = $$value));
  let { params: params2 } = $$props;
  let submitted = false;
  let model;
  async function submit() {
    try {
      const parsedQs = qs.parse($querystring);
      await (model == null ? void 0 : model.submit(parsedQs));
    } catch (e) {
      console.error("error while submitting the feedback form", e);
      return;
    }
    $$invalidate(1, submitted = true);
  }
  function formgroup_model_binding(value) {
    model = value;
    $$invalidate(2, model);
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(0, params2 = $$props2.params);
  };
  return [params2, submitted, model, submit, formgroup_model_binding];
}
class Forms extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$h, safe_not_equal, { params: 0 });
  }
}
const get_title_slot_changes = (dirty) => ({});
const get_title_slot_context = (ctx) => ({});
function create_fragment$g(ctx) {
  let div0;
  let div0_class_value;
  let t;
  let div1;
  let div1_class_value;
  let current;
  const title_slot_template = ctx[4].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[3], get_title_slot_context);
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div0 = element("div");
      if (title_slot)
        title_slot.c();
      t = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", div0_class_value = "fs-2 p-4 pb-5 text-center " + ctx[0]);
      attr(div1, "class", div1_class_value = "px-4 flex-fill " + ctx[2]);
      attr(div1, "style", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      if (title_slot) {
        title_slot.m(div0, null);
      }
      insert(target, t, anchor);
      insert(target, div1, anchor);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(title_slot_template, ctx2[3], dirty, get_title_slot_changes),
            get_title_slot_context
          );
        }
      }
      if (!current || dirty & 1 && div0_class_value !== (div0_class_value = "fs-2 p-4 pb-5 text-center " + ctx2[0])) {
        attr(div0, "class", div0_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4 && div1_class_value !== (div1_class_value = "px-4 flex-fill " + ctx2[2])) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & 2) {
        attr(div1, "style", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (title_slot)
        title_slot.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { titleClasses = "" } = $$props;
  let { style = "" } = $$props;
  let { class: classes = "" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("titleClasses" in $$props2)
      $$invalidate(0, titleClasses = $$props2.titleClasses);
    if ("style" in $$props2)
      $$invalidate(1, style = $$props2.style);
    if ("class" in $$props2)
      $$invalidate(2, classes = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [titleClasses, style, classes, $$scope, slots];
}
class OnboardingPageLayout extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$g, safe_not_equal, { titleClasses: 0, style: 1, class: 2 });
  }
}
function create_default_slot$8(ctx) {
  let div;
  let h4;
  let t1;
  let a0;
  let t2;
  let t3;
  let a1;
  let t4;
  return {
    c() {
      div = element("div");
      h4 = element("h4");
      h4.textContent = "Sign In/Sign Up to get the best out of Distill";
      t1 = space();
      a0 = element("a");
      t2 = text("Sign In");
      t3 = space();
      a1 = element("a");
      t4 = text("Sign Up");
      attr(a0, "class", "btn btn-primary btn-lg");
      set_style(a0, "width", "200px");
      attr(a0, "href", urls.serviceLogin({ href: location.href }));
      attr(a1, "class", "btn btn-primary btn-lg");
      set_style(a1, "width", "200px");
      attr(a1, "href", AUTH + "/register");
      attr(div, "class", "d-flex flex-column justify-content-center align-items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, h4);
      append(div, t1);
      append(div, a0);
      append(a0, t2);
      append(div, t3);
      append(div, a1);
      append(a1, t4);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$f(ctx) {
  let onboardingpagelayout;
  let current;
  onboardingpagelayout = new OnboardingPageLayout({
    props: {
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(onboardingpagelayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(onboardingpagelayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const onboardingpagelayout_changes = {};
      if (dirty & 1) {
        onboardingpagelayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      onboardingpagelayout.$set(onboardingpagelayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(onboardingpagelayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(onboardingpagelayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(onboardingpagelayout, detaching);
    }
  };
}
class Login extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$f, safe_not_equal, {});
  }
}
function create_title_slot$4(ctx) {
  let t_value = TXT("l_onboarding_welcome_title") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$6(ctx) {
  let div;
  let a;
  let t_value = TXT("a_signin") + "";
  let t;
  return {
    c() {
      div = element("div");
      a = element("a");
      t = text(t_value);
      attr(a, "class", "btn btn-primary fs-5");
      set_style(a, "width", "100px");
      attr(a, "href", urlCfg.serviceLogin({ href: location.href }));
      attr(div, "class", "d-flex flex-column justify-content-center align-items-center gap-2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, a);
      append(a, t);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$7(ctx) {
  let div6;
  let div4;
  let div3;
  let div1;
  let t0_value = TXT("m_onboarding_welcome_1") + "";
  let t0;
  let br0;
  let t1;
  let t2_value = TXT("m_onboarding_welcome_2") + "";
  let t2;
  let br1;
  let t3;
  let t4_value = TXT("m_onboarding_welcome_3") + "";
  let t4;
  let br2;
  let t5;
  let div0;
  let t7;
  let div2;
  let t8_value = TXT("m_onboarding_welcome_5") + "";
  let t8;
  let br3;
  let t9;
  let t10_value = TXT("m_onboarding_welcome_6") + "";
  let t10;
  let br4;
  let t11;
  let t12_value = TXT("m_onboarding_welcome_7") + "";
  let t12;
  let t13;
  let show_if = !ctx[0].isLoggedIn();
  let t14;
  let div5;
  let if_block = show_if && create_if_block$6();
  return {
    c() {
      div6 = element("div");
      div4 = element("div");
      div3 = element("div");
      div1 = element("div");
      t0 = text(t0_value);
      br0 = element("br");
      t1 = space();
      t2 = text(t2_value);
      br1 = element("br");
      t3 = space();
      t4 = text(t4_value);
      br2 = element("br");
      t5 = space();
      div0 = element("div");
      div0.textContent = `${TXT("m_onboarding_welcome_4")}`;
      t7 = space();
      div2 = element("div");
      t8 = text(t8_value);
      br3 = element("br");
      t9 = space();
      t10 = text(t10_value);
      br4 = element("br");
      t11 = space();
      t12 = text(t12_value);
      t13 = space();
      if (if_block)
        if_block.c();
      t14 = space();
      div5 = element("div");
      div5.innerHTML = `<img src="./img/onboarding-welcome.svg" style="width: 90%;height: 90%;"/>`;
      attr(div1, "class", "fs-4 mb-4");
      set_style(div1, "line-height", "2");
      attr(div2, "class", "fs-4");
      attr(div3, "class", "mb-4");
      attr(div4, "class", "col-7 d-flex flex-col justify-content-center align-items-center");
      attr(div5, "class", "col-5 d-flex justify-content-center");
      attr(div6, "class", "row mb-3");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div4);
      append(div4, div3);
      append(div3, div1);
      append(div1, t0);
      append(div1, br0);
      append(div1, t1);
      append(div1, t2);
      append(div1, br1);
      append(div1, t3);
      append(div1, t4);
      append(div1, br2);
      append(div1, t5);
      append(div1, div0);
      append(div3, t7);
      append(div3, div2);
      append(div2, t8);
      append(div2, br3);
      append(div2, t9);
      append(div2, t10);
      append(div2, br4);
      append(div2, t11);
      append(div2, t12);
      append(div4, t13);
      if (if_block)
        if_block.m(div4, null);
      append(div6, t14);
      append(div6, div5);
    },
    p(ctx2, dirty) {
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(div6);
      if (if_block)
        if_block.d();
    }
  };
}
function create_fragment$e(ctx) {
  let onboardingpagelayout;
  let current;
  onboardingpagelayout = new OnboardingPageLayout({
    props: {
      class: "fs-3 pt-4",
      $$slots: {
        default: [create_default_slot$7],
        title: [create_title_slot$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(onboardingpagelayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(onboardingpagelayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const onboardingpagelayout_changes = {};
      if (dirty & 2) {
        onboardingpagelayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      onboardingpagelayout.$set(onboardingpagelayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(onboardingpagelayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(onboardingpagelayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(onboardingpagelayout, detaching);
    }
  };
}
function instance$d($$self) {
  const user = getContext("user");
  return [user];
}
class Welcome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$e, safe_not_equal, {});
  }
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  return child_ctx;
}
function create_if_block_4(ctx) {
  let div2;
  let h5;
  let b;
  let t1;
  let div1;
  let div0;
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  return {
    c() {
      div2 = element("div");
      h5 = element("h5");
      b = element("b");
      b.textContent = `${TXT("l_extension")}`;
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "class", "d-flex flex-nowrap");
      attr(div1, "class", "my-4");
      attr(div2, "class", "mb-4");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h5);
      append(h5, b);
      append(div2, t1);
      append(div2, div1);
      append(div1, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & 4) {
        each_value = ctx2[2];
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div0, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block(ctx) {
  let div;
  let span;
  let span_data_browser_value;
  let t0;
  let h6;
  let a;
  let t1_value = ctx[17].label + "";
  let t1;
  let a_href_value;
  let t2;
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = space();
      h6 = element("h6");
      a = element("a");
      t1 = text(t1_value);
      t2 = space();
      attr(span, "class", "browser-icon");
      attr(span, "data-browser", span_data_browser_value = ctx[17].icon);
      attr(span, "style", iconStyle);
      attr(a, "target", "_blank");
      attr(a, "href", a_href_value = ctx[17].href);
      attr(a, "class", "browser-name");
      toggle_class(a, "text-success", ctx[17].installed);
      attr(h6, "class", "mt-1");
      attr(div, "class", "text-center");
      set_style(div, "width", "120px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t0);
      append(div, h6);
      append(h6, a);
      append(a, t1);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && span_data_browser_value !== (span_data_browser_value = ctx2[17].icon)) {
        attr(span, "data-browser", span_data_browser_value);
      }
      if (dirty & 4 && t1_value !== (t1_value = ctx2[17].label + ""))
        set_data(t1, t1_value);
      if (dirty & 4 && a_href_value !== (a_href_value = ctx2[17].href)) {
        attr(a, "href", a_href_value);
      }
      if (dirty & 4) {
        toggle_class(a, "text-success", ctx2[17].installed);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$5(ctx) {
  let div2;
  let h5;
  let b;
  let t1;
  let div1;
  let div0;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_1$4;
    return create_else_block$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      h5 = element("h5");
      b = element("b");
      b.textContent = `${TXT("l_desktop")}`;
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      attr(div0, "class", "d-flex flex-nowrap");
      attr(div1, "class", "mt-4");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h5);
      append(h5, b);
      append(div2, t1);
      append(div2, div1);
      append(div1, div0);
      if_block.m(div0, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if_block.d();
    }
  };
}
function create_else_block$2(ctx) {
  let t;
  let if_block1_anchor;
  let if_block0 = (!ctx[1] || ctx[1] === ctx[6].WINDOWS) && create_if_block_3$2();
  let if_block1 = (!ctx[1] || ctx[1] === ctx[6].MAC) && create_if_block_2$3();
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (!ctx2[1] || ctx2[1] === ctx2[6].WINDOWS) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$2();
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!ctx2[1] || ctx2[1] === ctx2[6].MAC) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2$3();
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_if_block_1$4(ctx) {
  let div;
  let i2;
  let t0;
  let h6;
  return {
    c() {
      div = element("div");
      i2 = element("i");
      t0 = space();
      h6 = element("h6");
      h6.textContent = `${TXT("l_installed")}`;
      attr(i2, "class", "fa fa-desktop fa-2x");
      set_style(i2, "width", "120px");
      attr(h6, "class", "mt-1 text-success");
      attr(div, "class", "text-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, i2);
      append(div, t0);
      append(div, h6);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_3$2(ctx) {
  let div;
  let span;
  let t0;
  let h6;
  let a;
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = space();
      h6 = element("h6");
      a = element("a");
      a.textContent = `${TXT("a_download")}`;
      attr(span, "class", "browser-icon");
      attr(span, "data-browser", "windows");
      attr(span, "style", iconStyle);
      attr(a, "class", "mr-l-20 nowrap");
      attr(a, "href", "https://utils.distill.io/electron/download/alpha/win32/x64/latest");
      attr(h6, "class", "mt-1");
      attr(div, "class", "text-center");
      set_style(div, "width", "120px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t0);
      append(div, h6);
      append(h6, a);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$3(ctx) {
  let div;
  let span;
  let t0;
  let h6;
  let a;
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = space();
      h6 = element("h6");
      a = element("a");
      a.textContent = `${TXT("a_download")}`;
      attr(span, "class", "browser-icon");
      attr(span, "data-browser", "mac");
      attr(span, "style", iconStyle);
      attr(a, "class", "mr-l-20 nowrap");
      attr(a, "href", "https://utils.distill.io/electron/download/alpha/darwin/arm64/latest");
      attr(h6, "class", "mt-1");
      attr(div, "class", "text-center");
      set_style(div, "width", "120px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t0);
      append(div, h6);
      append(h6, a);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$6(ctx) {
  let div3;
  let div1;
  let div0;
  let strong;
  let br;
  let t1;
  let ul;
  let li0;
  let t3;
  let li1;
  let t5;
  let li2;
  let t7;
  let li3;
  let t9;
  let div2;
  let t10;
  let if_block0 = ctx[0] !== ctx[5].EXTENSION && ctx[2].length && create_if_block_4(ctx);
  let if_block1 = ctx[0] !== ctx[5].ELECTRON && create_if_block$5(ctx);
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      strong = element("strong");
      strong.textContent = `${TXT("m_onboarding_platforms_benefits")}`;
      br = element("br");
      t1 = space();
      ul = element("ul");
      li0 = element("li");
      li0.textContent = `${TXT("m_onboarding_platforms_benefits_1")}`;
      t3 = space();
      li1 = element("li");
      li1.textContent = `${TXT("m_onboarding_platforms_benefits_2")}`;
      t5 = space();
      li2 = element("li");
      li2.textContent = `${TXT("m_onboarding_platforms_benefits_3")}`;
      t7 = space();
      li3 = element("li");
      li3.textContent = `${TXT("m_onboarding_platforms_benefits_4")}`;
      t9 = space();
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t10 = space();
      if (if_block1)
        if_block1.c();
      attr(div1, "class", "col-sm-5 d-flex align-items-center");
      attr(div2, "class", "col-sm-3");
      attr(div3, "class", "row fs-4 mt-4 justify-content-evenly");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      append(div0, strong);
      append(div0, br);
      append(div0, t1);
      append(div0, ul);
      append(ul, li0);
      append(ul, t3);
      append(ul, li1);
      append(ul, t5);
      append(ul, li2);
      append(ul, t7);
      append(ul, li3);
      append(div3, t9);
      append(div3, div2);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t10);
      if (if_block1)
        if_block1.m(div2, null);
    },
    p(ctx2, dirty) {
      if (ctx2[0] !== ctx2[5].EXTENSION && ctx2[2].length) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          if_block0.m(div2, t10);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0] !== ctx2[5].ELECTRON) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$5(ctx2);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_title_slot$3(ctx) {
  let t_value = TXT("l_onboarding_platforms_title") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$d(ctx) {
  let onboardingpagelayout;
  let current;
  onboardingpagelayout = new OnboardingPageLayout({
    props: {
      $$slots: {
        title: [create_title_slot$3],
        default: [create_default_slot$6]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(onboardingpagelayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(onboardingpagelayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const onboardingpagelayout_changes = {};
      if (dirty & 1048591) {
        onboardingpagelayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      onboardingpagelayout.$set(onboardingpagelayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(onboardingpagelayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(onboardingpagelayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(onboardingpagelayout, detaching);
    }
  };
}
const iconStyle = "width:2.8rem; height: 2.8rem;background-size: contain;";
function instance$c($$self, $$props, $$invalidate) {
  let $user;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(9, $user = value));
  const clientId = getContext("clientId");
  let currentClientType;
  let currentBrowser;
  let currentOS;
  let displayExtensions;
  let installedDesktopApp;
  let installedExtensions = {};
  const CLIENT_TYPE = {
    WEB: "web",
    ELECTRON: "electron",
    EXTENSION: "extension"
  };
  const OS = { WINDOWS: "windows", MAC: "mac" };
  const extensions = {
    [C$1.CLIENT_CR]: {
      icon: "chrome",
      href: "https://chrome.google.com/webstore/detail/distill-web-monitor/inlikjemeeknofckkjolnjbpehgadgge?hl=en&utm_source=webApp&utm_campaign=onboarding",
      label: SPRINTF("a_add_to", "l_chrome")
    },
    [C$1.CLIENT_FF]: {
      icon: "firefox",
      href: "https://addons.mozilla.org/en-US/firefox/addon/distill-web-monitor-ff",
      label: SPRINTF("a_add_to", "l_firefox")
    },
    [C$1.CLIENT_OP]: {
      icon: "opera",
      href: "https://addons.opera.com/en/extensions/details/distill-web-monitor",
      label: SPRINTF("a_add_to", "l_opera")
    },
    [C$1.CLIENT_MSE]: {
      icon: "edge",
      href: "https://microsoftedge.microsoft.com/addons/detail/distill-web-monitor/hldhhgncaohjmpcjjhggekonocabhceg",
      label: SPRINTF("a_add_to", "l_edge")
    }
  };
  init2();
  function init2() {
    for (let client of $user.clients) {
      if (clientId === client.id) {
        $$invalidate(0, currentClientType = getPlatformType(client));
      }
      if (installedExtensions[client.type]) {
        continue;
      }
      if (isExtension(client)) {
        installedExtensions[client.type] = true;
      } else if (client.type === C$1.CLIENT_ELECTRON) {
        $$invalidate(3, installedDesktopApp = true);
      }
    }
    currentBrowser = detectBrowser2();
    if (!installedDesktopApp) {
      $$invalidate(1, currentOS = detectOS());
    }
    $$invalidate(2, displayExtensions = []);
    const installedExtensionList = Object.keys(installedExtensions);
    installedExtensionList.forEach((key) => {
      displayExtensions.push({
        ...extensions[key],
        label: TXT("l_installed"),
        installed: true
      });
    });
    if (!installedExtensionList.includes(currentBrowser) && extensions[currentBrowser]) {
      displayExtensions.push(extensions[currentBrowser]);
    }
  }
  function isExtension(client) {
    return [C$1.CLIENT_CR, C$1.CLIENT_FF, C$1.CLIENT_OP, C$1.CLIENT_MSE].includes(client.type);
  }
  function getPlatformType(client) {
    const type = client.type;
    if (type === C$1.CLIENT_WEB) {
      return CLIENT_TYPE.WEB;
    } else if (type === C$1.CLIENT_ELECTRON) {
      return CLIENT_TYPE.DESKTOP;
    } else {
      return CLIENT_TYPE.EXTENSION;
    }
  }
  function detectBrowser2() {
    let userAgent = navigator.userAgent;
    if ((userAgent.indexOf("Opera") || userAgent.indexOf("OPR")) != -1) {
      return C$1.CLIENT_OP;
    } else if (userAgent.indexOf("Edg") != -1) {
      return C$1.CLIENT_MSE;
    } else if (userAgent.indexOf("Chrome") != -1) {
      return C$1.CLIENT_CR;
    } else if (userAgent.indexOf("Firefox") != -1) {
      return C$1.CLIENT_FF;
    } else {
      return null;
    }
  }
  function detectOS() {
    var userAgent = navigator.userAgent;
    if (userAgent.indexOf("Win") != -1)
      return OS.WINDOWS;
    if (userAgent.indexOf("Mac") != -1)
      return OS.MAC;
  }
  return [
    currentClientType,
    currentOS,
    displayExtensions,
    installedDesktopApp,
    user,
    CLIENT_TYPE,
    OS
  ];
}
class Links extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$d, safe_not_equal, {});
  }
}
var CreateFirstMonitor_svelte_svelte_type_style_lang = "";
function create_title_slot$2(ctx) {
  let t_value = TXT("m_onboarding_create_monitor_title") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_catch_block$3(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$3(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  let if_block0 = ctx[2] && create_if_block_2$2(ctx);
  let if_block1 = ctx[7] && create_if_block_1$3(ctx);
  let if_block2 = ctx[4] && create_if_block$4(ctx);
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      set_style(div, "margin-bottom", !ctx[4] ? "200px" : "20px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[7]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$3(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[4]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$4(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (dirty & 16) {
        set_style(div, "margin-bottom", !ctx2[4] ? "200px" : "20px");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_2$2(ctx) {
  let selectorurledit;
  let t0;
  let div;
  let small;
  let t2;
  let if_block_anchor;
  let current;
  selectorurledit = new SelectorUrlEdit({
    props: {
      uri: ctx[3],
      disableGo: ctx[7],
      showProxySelector: false,
      showSessionSelector: false
    }
  });
  selectorurledit.$on("go", ctx[11]);
  let if_block = ctx[6] && create_if_block_3$1();
  return {
    c() {
      create_component(selectorurledit.$$.fragment);
      t0 = space();
      div = element("div");
      small = element("small");
      small.textContent = `${TXT("m_onboarding_create_monitor_info_2")}`;
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div, "class", "text-body-tertiary fs-6 ms-1");
    },
    m(target, anchor) {
      mount_component(selectorurledit, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      append(div, small);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const selectorurledit_changes = {};
      if (dirty & 8)
        selectorurledit_changes.uri = ctx2[3];
      if (dirty & 128)
        selectorurledit_changes.disableGo = ctx2[7];
      selectorurledit.$set(selectorurledit_changes);
      if (ctx2[6]) {
        if (if_block) {
          if (dirty & 64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$1();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(selectorurledit.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(selectorurledit.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(selectorurledit, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3$1(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_if_block_1$3(ctx) {
  let div3;
  let span;
  let t1;
  let div2;
  let div0;
  let t2_value = ctx[8].name + "";
  let t2;
  let t3;
  let div1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      span = element("span");
      span.textContent = `${TXT("m_onboarding_create_monitor_exists")}`;
      t1 = space();
      div2 = element("div");
      div0 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div1 = element("div");
      button = element("button");
      button.innerHTML = `<i class="fa fa-trash-o"></i>`;
      attr(span, "class", "fs-6");
      attr(div0, "class", "col-sm-11");
      attr(button, "class", "btn btn-danger");
      attr(div1, "class", "col-sm-1 d-flex justify-content-end");
      attr(div2, "class", "row p-1 justify-content-space-between align-items-center rounded border border-1 text-black mt-2 xfade svelte-1jz8j44");
      attr(div3, "class", "py-3");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, span);
      append(div3, t1);
      append(div3, div2);
      append(div2, div0);
      append(div0, t2);
      append(div2, t3);
      append(div2, div1);
      append(div1, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[12]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 256 && t2_value !== (t2_value = ctx2[8].name + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$4(ctx) {
  let sievedata;
  let current;
  sievedata = new SieveData({
    props: {
      data: ctx[5],
      oldData: ctx[5],
      sieve: ctx[1],
      showDiffStats: false,
      showDiffOptions: false,
      iframeStyle: "max-height: 1000px;"
    }
  });
  return {
    c() {
      create_component(sievedata.$$.fragment);
    },
    m(target, anchor) {
      mount_component(sievedata, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const sievedata_changes = {};
      if (dirty & 32)
        sievedata_changes.data = ctx2[5];
      if (dirty & 32)
        sievedata_changes.oldData = ctx2[5];
      if (dirty & 2)
        sievedata_changes.sieve = ctx2[1];
      sievedata.$set(sievedata_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(sievedata.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievedata.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(sievedata, detaching);
    }
  };
}
function create_pending_block$3(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.innerHTML = `<span class="placeholder placeholder-lg col-11"></span> 
        <span class="placeholder placeholder-lg col-1"></span>`;
      attr(p, "class", "d-flex gap-1 placeholder-glow block");
      attr(p, "aria-hidden", "true");
      set_style(p, "height", "30px");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(p);
    }
  };
}
function create_default_slot$5(ctx) {
  let div;
  let p;
  let t1;
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$3,
    then: create_then_block$3,
    catch: create_catch_block$3,
    blocks: [, , ,]
  };
  handle_promise(ctx[10], info);
  return {
    c() {
      div = element("div");
      p = element("p");
      p.textContent = `${TXT("m_onboarding_create_monitor_info_1")}`;
      t1 = space();
      await_block_anchor = empty();
      info.block.c();
      attr(div, "class", "fs-5 mb-3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      insert(target, t1, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$c(ctx) {
  let onboardingpagelayout;
  let current;
  onboardingpagelayout = new OnboardingPageLayout({
    props: {
      $$slots: {
        default: [create_default_slot$5],
        title: [create_title_slot$2]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(onboardingpagelayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(onboardingpagelayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const onboardingpagelayout_changes = {};
      if (dirty & 268435966) {
        onboardingpagelayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      onboardingpagelayout.$set(onboardingpagelayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(onboardingpagelayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(onboardingpagelayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(onboardingpagelayout, detaching);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let $uri, $$unsubscribe_uri = noop$1, $$subscribe_uri = () => ($$unsubscribe_uri(), $$unsubscribe_uri = subscribe(uri, ($$value) => $$invalidate(16, $uri = $$value)), uri);
  let $user;
  let $buttonStore, $$unsubscribe_buttonStore = noop$1, $$subscribe_buttonStore = () => ($$unsubscribe_buttonStore(), $$unsubscribe_buttonStore = subscribe(buttonStore, ($$value) => $$invalidate(18, $buttonStore = $$value)), buttonStore);
  let $onboardingSieve, $$unsubscribe_onboardingSieve = noop$1, $$subscribe_onboardingSieve = () => ($$unsubscribe_onboardingSieve(), $$unsubscribe_onboardingSieve = subscribe(onboardingSieve, ($$value) => $$invalidate(8, $onboardingSieve = $$value)), onboardingSieve);
  $$self.$$.on_destroy.push(() => $$unsubscribe_uri());
  $$self.$$.on_destroy.push(() => $$unsubscribe_buttonStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_onboardingSieve());
  let { buttonStore } = $$props;
  $$subscribe_buttonStore();
  const nextPlugin = async () => {
    if (dataFetched) {
      const savePromise = save();
      set_store_value(buttonStore, $buttonStore.nextPromise = savePromise, $buttonStore);
      await savePromise;
    }
  };
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(17, $user = value));
  const clientId = getContext("clientId");
  let model;
  let formModel;
  let uri;
  let content_type;
  let sieveData;
  let loading2;
  let saved;
  let dataFetched;
  let onboardingSieve;
  let initPromise = init2();
  set_store_value(buttonStore, $buttonStore.nextPromise = initPromise, $buttonStore);
  async function init2() {
    createNewSieve();
    await fetchOnboardingSieve();
  }
  async function fetchOnboardingSieve() {
    const res = await new Model$2.Sieve().fetch({
      data: {
        state: C$1.STATE_READY,
        "meta:->>'onboarding'.eq": true
      }
    });
    let data;
    data = res[1].data[0];
    if (data) {
      $$subscribe_onboardingSieve($$invalidate(7, onboardingSieve = new Model$2.Sieve(data, { parse: true })));
    }
  }
  function createNewSieve() {
    $$invalidate(1, model = new Model$2.Sieve({ uri: "https://timeanddate.com" }));
    $$invalidate(2, formModel = new SieveFormModel(model));
    $$subscribe_uri($$invalidate(3, { uri } = formModel.fields, uri));
  }
  async function fetchData() {
    trackEvent(PHEvents.ONBOARDING_GO);
    $$invalidate(6, loading2 = true);
    saved = false;
    await getData();
    $$invalidate(6, loading2 = false);
    dataFetched = true;
  }
  async function getData() {
    var _a;
    try {
      Msg.reset();
      $$invalidate(4, content_type = void 0);
      const response = await fetchResource();
      $$invalidate(4, content_type = getSieveContentType(response.headers["content-type"]));
      $$invalidate(5, sieveData = {
        data_type: content_type,
        data: response.text,
        text: response.text
      });
      model.set("content_type", content_type);
      set_store_value(buttonStore, $buttonStore.nextLabel = "a_save_and_next", $buttonStore);
    } catch (e) {
      console.error(e);
      Msg.error((_a = e.error) == null ? void 0 : _a.message);
    }
  }
  function showSaveMessage() {
    Msg.info("Sieve saved successfully, check it out later from the watchlist");
    setTimeout(
      () => {
        Msg.reset();
      },
      4e3
    );
  }
  async function fetchResource() {
    const response = await Api.utils(`/datasources/${C$1.DS_ID_TEXT}/fetch`, "POST", {
      name: $uri.host,
      uri: $uri.toJSON(),
      config: { request: { method: "GET" } }
    });
    if (response.headers) {
      return response;
    }
    return { text: response, headers: Api.headers };
  }
  function getSieveContentType(type_header) {
    if (type_header.includes("json")) {
      return C$1.TYPE_JSON;
    } else if (type_header.includes("xml")) {
      return C$1.TYPE_XML;
    } else if (type_header.includes("html")) {
      return C$1.TYPE_HTML;
    } else if (type_header.includes("pdf")) {
      return C$1.TYPE_PDF_HTML;
    } else {
      return C$1.TYPE_HTML;
    }
  }
  async function save() {
    try {
      const clientType = $user.clients.find((client) => clientId === client.id).type;
      Msg.start("sieve:save", { info: "saving" });
      const saveModel = new Model$2.Sieve(
        {
          uri: uri.toJSON(),
          content_type,
          name: `First Monitor - ${$uri.hostname}`,
          state: C$1.STATE_READY,
          version: 1,
          datasource_id: content_type === C$1.TYPE_JSON ? C$1.DS_ID_JSON : null,
          meta: { source: { clientType }, onboarding: true }
        },
        { parse: true }
      );
      saveModel.applyConfigDefaults();
      await saveModel.save();
      Msg.stop("sieve:save");
      showSaveMessage();
      saved = true;
    } catch (e) {
      Msg.stop("sieve:save", {
        error: "Some error occurred: Failed to save monitor"
      });
      console.error(e);
    }
  }
  async function deleteOnboardingSieve() {
    onboardingSieve.destroy({
      success: () => {
        $$subscribe_onboardingSieve($$invalidate(7, onboardingSieve = void 0));
      }
    });
  }
  $$self.$$set = ($$props2) => {
    if ("buttonStore" in $$props2)
      $$subscribe_buttonStore($$invalidate(0, buttonStore = $$props2.buttonStore));
  };
  return [
    buttonStore,
    model,
    formModel,
    uri,
    content_type,
    sieveData,
    loading2,
    onboardingSieve,
    $onboardingSieve,
    user,
    initPromise,
    fetchData,
    deleteOnboardingSieve,
    nextPlugin
  ];
}
class CreateFirstMonitor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$c, safe_not_equal, { buttonStore: 0, nextPlugin: 13 });
  }
  get nextPlugin() {
    return this.$$.ctx[13];
  }
}
function create_header_slot(ctx) {
  let t_value = TXT("m_continue_without_trial") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$4(ctx) {
  let t_value = TXT("m_without_trial_warning") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_buttons_slot(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${TXT("l_continue_with_free_plan")}`;
      attr(button, "class", "btn btn-primary text-center");
      toggle_class(button, "disabled", ctx[0]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        toggle_class(button, "disabled", ctx2[0]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$b(ctx) {
  let modal;
  let current;
  modal = new Modal$2({
    props: {
      isDialog: false,
      $$slots: {
        buttons: [create_buttons_slot],
        default: [create_default_slot$4],
        header: [create_header_slot]
      },
      $$scope: { ctx }
    }
  });
  modal.$on("close", ctx[3]);
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const modal_changes = {};
      if (dirty & 17) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let { showLoader } = $$props;
  const dispatch = createEventDispatcher();
  const click_handler = () => dispatch("continue");
  function close_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("showLoader" in $$props2)
      $$invalidate(0, showLoader = $$props2.showLoader);
  };
  return [showLoader, dispatch, click_handler, close_handler];
}
class WarningModal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$b, safe_not_equal, { showLoader: 0 });
  }
}
async function showStripeAddCardModal(opts) {
  let {
    email,
    name = "Distill",
    image = "/favicon.ico",
    label = TXT("a_add"),
    description = "Add Payment Method"
  } = opts;
  let calledBack = false;
  Msg.info("l_loading");
  return new Promise((resolve) => {
    StripeCheckout.open({
      email,
      key: STRIPE_KEY,
      name,
      image,
      description,
      panelLabel: label,
      closed: function() {
        if (!calledBack) {
          resolve(null);
        }
      },
      opened: function() {
        Msg.reset();
      },
      token: async function(token) {
        calledBack = true;
        resolve(token || null);
      }
    });
  });
}
function create_title_slot$1(ctx) {
  let t_value = TXT("m_onborading_free_trial_title") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    var _a;
    if (((_a = ctx2[5].subscription) == null ? void 0 : _a.is_free_trial) || false)
      return create_if_block_2$1;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_else_block$1(ctx) {
  let buttton;
  let mounted;
  let dispose;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block_3;
    return create_else_block_1;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      buttton = element("buttton");
      if_block.c();
      attr(buttton, "class", "btn btn-lg btn-primary");
      set_style(buttton, "min-width", "200px");
      attr(buttton, "act-action", "subscribe");
    },
    m(target, anchor) {
      insert(target, buttton, anchor);
      if_block.m(buttton, null);
      if (!mounted) {
        dispose = listen(buttton, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(buttton, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(buttton);
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$1(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = `${TXT("l_subscribed_to_free_trial")}`;
      attr(div, "class", "d-flex align-items-center fs-5 bg-success text-white rounded px-4 py-2");
      set_style(div, "cursor", "default");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_else_block_1(ctx) {
  let t_value = TXT("l_start_free_trial") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "spinner-border text-light");
      attr(div, "role", "status");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_default_slot$3(ctx) {
  let div0;
  let raw0_value = TXT("m_onboarding_free_trial") + "";
  let t0;
  let div5;
  let div2;
  let div1;
  let strong;
  let t2;
  let ul;
  let li0;
  let t4;
  let li1;
  let t6;
  let li2;
  let t8;
  let li3;
  let t10;
  let div3;
  let t11;
  let div4;
  let table;
  let tbody;
  let tr0;
  let td0;
  let t13;
  let td1;
  let t15;
  let tr1;
  let td2;
  let t17;
  let td3;
  let t19;
  let tr2;
  let td4;
  let t21;
  let td5;
  let t23;
  let tr3;
  let td6;
  let t25;
  let td7;
  let t28;
  let div6;
  let show_if = ctx[6].isLoggedIn();
  let t29;
  let div7;
  let small;
  let t30_value = TXT("m_onboarding_free_trial_cond_1") + "";
  let t30;
  let br;
  let t31;
  let html_tag;
  let raw1_value = TXT("m_onboarding_free_trial_cond_2") + "";
  let if_block = show_if && create_if_block_1$2(ctx);
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div5 = element("div");
      div2 = element("div");
      div1 = element("div");
      strong = element("strong");
      strong.textContent = `${TXT("m_onboarding_free_trial_info")}`;
      t2 = space();
      ul = element("ul");
      li0 = element("li");
      li0.textContent = `${TXT("m_onboarding_free_trial_info_1")}`;
      t4 = space();
      li1 = element("li");
      li1.textContent = `${TXT("m_onboarding_free_trial_info_2")}`;
      t6 = space();
      li2 = element("li");
      li2.textContent = `${TXT("m_onboarding_free_trial_info_3")}`;
      t8 = space();
      li3 = element("li");
      li3.textContent = `${TXT("m_onboarding_free_trial_info_4")}`;
      t10 = space();
      div3 = element("div");
      t11 = space();
      div4 = element("div");
      table = element("table");
      tbody = element("tbody");
      tr0 = element("tr");
      td0 = element("td");
      td0.textContent = `${TXT("l_monitors")}`;
      t13 = space();
      td1 = element("td");
      td1.textContent = "20";
      t15 = space();
      tr1 = element("tr");
      td2 = element("td");
      td2.textContent = `${TXT("l_push")}`;
      t17 = space();
      td3 = element("td");
      td3.textContent = `${TXT("l_unlimited")}`;
      t19 = space();
      tr2 = element("tr");
      td4 = element("td");
      td4.textContent = `${TXT("l_macros")}`;
      t21 = space();
      td5 = element("td");
      td5.textContent = "2";
      t23 = space();
      tr3 = element("tr");
      td6 = element("td");
      td6.textContent = `${TXT("l_min_cloud_interval")}`;
      t25 = space();
      td7 = element("td");
      td7.textContent = `10 ${TXT("l_minutes")}`;
      t28 = space();
      div6 = element("div");
      if (if_block)
        if_block.c();
      t29 = space();
      div7 = element("div");
      small = element("small");
      t30 = text(t30_value);
      br = element("br");
      t31 = space();
      html_tag = new HtmlTag(false);
      attr(div0, "class", "fs-5 mb-5");
      attr(div1, "class", "fs-5");
      attr(div2, "class", "col-sm-6");
      attr(div3, "class", "col-sm-1");
      attr(table, "class", "table table-striped");
      attr(div4, "class", "col-sm-4");
      attr(div5, "class", "row mb-4");
      attr(div6, "class", "flex justify-content-center");
      html_tag.a = null;
      attr(div7, "class", "text-body-tertiary");
      set_style(div7, "margin-top", "7rem");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      div0.innerHTML = raw0_value;
      insert(target, t0, anchor);
      insert(target, div5, anchor);
      append(div5, div2);
      append(div2, div1);
      append(div1, strong);
      append(div1, t2);
      append(div1, ul);
      append(ul, li0);
      append(ul, t4);
      append(ul, li1);
      append(ul, t6);
      append(ul, li2);
      append(ul, t8);
      append(ul, li3);
      append(div5, t10);
      append(div5, div3);
      append(div5, t11);
      append(div5, div4);
      append(div4, table);
      append(table, tbody);
      append(tbody, tr0);
      append(tr0, td0);
      append(tr0, t13);
      append(tr0, td1);
      append(tbody, t15);
      append(tbody, tr1);
      append(tr1, td2);
      append(tr1, t17);
      append(tr1, td3);
      append(tbody, t19);
      append(tbody, tr2);
      append(tr2, td4);
      append(tr2, t21);
      append(tr2, td5);
      append(tbody, t23);
      append(tbody, tr3);
      append(tr3, td6);
      append(tr3, t25);
      append(tr3, td7);
      insert(target, t28, anchor);
      insert(target, div6, anchor);
      if (if_block)
        if_block.m(div6, null);
      insert(target, t29, anchor);
      insert(target, div7, anchor);
      append(div7, small);
      append(small, t30);
      append(small, br);
      append(small, t31);
      html_tag.m(raw1_value, small);
    },
    p(ctx2, dirty) {
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div5);
      if (detaching)
        detach(t28);
      if (detaching)
        detach(div6);
      if (if_block)
        if_block.d();
      if (detaching)
        detach(t29);
      if (detaching)
        detach(div7);
    }
  };
}
function create_if_block$3(ctx) {
  let warningmodal;
  let current;
  warningmodal = new WarningModal({ props: { showLoader: ctx[1] } });
  warningmodal.$on("continue", ctx[10]);
  warningmodal.$on("close", ctx[11]);
  return {
    c() {
      create_component(warningmodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(warningmodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const warningmodal_changes = {};
      if (dirty & 2)
        warningmodal_changes.showLoader = ctx2[1];
      warningmodal.$set(warningmodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(warningmodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(warningmodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(warningmodal, detaching);
    }
  };
}
function create_fragment$a(ctx) {
  let onboardingpagelayout;
  let t;
  let if_block_anchor;
  let current;
  onboardingpagelayout = new OnboardingPageLayout({
    props: {
      $$slots: {
        default: [create_default_slot$3],
        title: [create_title_slot$1]
      },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[3] && create_if_block$3(ctx);
  return {
    c() {
      create_component(onboardingpagelayout.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(onboardingpagelayout, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const onboardingpagelayout_changes = {};
      if (dirty & 1048610) {
        onboardingpagelayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      onboardingpagelayout.$set(onboardingpagelayout_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(onboardingpagelayout.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(onboardingpagelayout.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(onboardingpagelayout, detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let $user;
  let $buttonStore, $$unsubscribe_buttonStore = noop$1, $$subscribe_buttonStore = () => ($$unsubscribe_buttonStore(), $$unsubscribe_buttonStore = subscribe(buttonStore, ($$value) => $$invalidate(13, $buttonStore = $$value)), buttonStore);
  let $onboardingSieve, $$unsubscribe_onboardingSieve = noop$1, $$subscribe_onboardingSieve = () => ($$unsubscribe_onboardingSieve(), $$unsubscribe_onboardingSieve = subscribe(onboardingSieve, ($$value) => $$invalidate(14, $onboardingSieve = $$value)), onboardingSieve);
  $$self.$$.on_destroy.push(() => $$unsubscribe_buttonStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_onboardingSieve());
  let { buttonStore } = $$props;
  $$subscribe_buttonStore();
  const nextPlugin = async () => {
    if (!onboardingSievePromise) {
      return false;
    }
    await onboardingSievePromise;
    if (!onboardingSieve || $user.subscription.is_free_trial) {
      return;
    }
    if (continueWithoutSubscribing) {
      onboardingSieve.destroy();
      return;
    }
    if (premiumContentTypes.includes($onboardingSieve.content_type)) {
      $$invalidate(3, showWarningModal = true);
    } else {
      return;
    }
    return false;
  };
  const premiumContentTypes = [C$1.TYPE_JSON, C$1.TYPE_XML, C$1.TYPE_FEED, C$1.TYPE_PDF_HTML];
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(5, $user = value));
  const dispatch = createEventDispatcher();
  let saving;
  let onboardingSieve;
  let showWarningModal;
  let continueWithoutSubscribing = false;
  let onboardingSievePromise;
  set_store_value(buttonStore, $buttonStore.nextPromise = init2(), $buttonStore);
  async function init2() {
    onboardingSievePromise = fetchOnboardingSieve();
    await onboardingSievePromise;
  }
  async function subscribeToFreeTrial() {
    $$invalidate(1, saving = true);
    try {
      await Api.api("/subscriptions/freetrial", "POST");
      await updateUser();
    } catch (e) {
      if (e.code === "ERR_AUTH_FAILED") {
        await handleAddCard();
        await updateUser();
      } else if (e.code === "ERR_USER_NOT_ELIGIBLE") {
        Msg.error(e.msg);
        setTimeout(() => Msg.reset(), 5e3);
      }
    }
    $$invalidate(1, saving = false);
  }
  async function fetchOnboardingSieve() {
    const res = await new Model$2.Sieve().fetch({
      data: {
        state: C$1.STATE_READY,
        "meta:->>'onboarding'.eq": true
      }
    });
    let data;
    data = res[1].data[0];
    if (data) {
      $$subscribe_onboardingSieve($$invalidate(2, onboardingSieve = new Model$2.Sieve(data, { parse: true })));
    }
  }
  async function updateUser() {
    await user.fetch({ reset: true });
  }
  async function handleAddCard() {
    const token = await showStripeAddCardModal({ email: $user.email });
    if (token) {
      try {
        await Api.api("/users/cards", "POST", { stripe_token: token.id });
        Msg.info("Card added successfully");
        await Api.api("/subscriptions/freetrial", "POST");
      } catch (err) {
        console.log("Error ", err);
        Msg.error(err.msg);
      }
    }
  }
  const continue_handler = () => {
    $$invalidate(4, continueWithoutSubscribing = true);
    dispatch("next");
  };
  const close_handler = () => {
    $$invalidate(3, showWarningModal = false);
  };
  $$self.$$set = ($$props2) => {
    if ("buttonStore" in $$props2)
      $$subscribe_buttonStore($$invalidate(0, buttonStore = $$props2.buttonStore));
  };
  return [
    buttonStore,
    saving,
    onboardingSieve,
    showWarningModal,
    continueWithoutSubscribing,
    $user,
    user,
    dispatch,
    subscribeToFreeTrial,
    nextPlugin,
    continue_handler,
    close_handler
  ];
}
class FreeTrial extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$a, safe_not_equal, { buttonStore: 0, nextPlugin: 9 });
  }
  get nextPlugin() {
    return this.$$.ctx[9];
  }
}
function create_fragment$9(ctx) {
  let svg;
  let g;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      path = svg_element("path");
      set_style(path, "fill", ctx[0]);
      attr(path, "d", "M510.868,327.816c-0.61-4.281-1.471-8.474-2.528-12.572l0.733-0.095c0,0-42.276-112.08-51.077-151.655\n		c-7.37-29.951-28.899-53.445-56.26-64.216c-0.697-2.495-1.275-4.744-1.706-6.664c-5.963-24.275-29.473-40.554-54.752-36.975\n		c-25.276,3.58-43.345,25.75-42.336,50.727c0.203,3.229,0.466,7.382,0.765,12.102c-18.842,17.961-29.939,43.56-28.831,70.96\n		c0.047,0.765,0.096,1.546,0.143,2.359h-38.042c0.047-0.813,0.095-1.594,0.148-2.359c1.104-27.401-9.986-52.999-28.836-70.96\n		c0.299-4.719,0.563-8.873,0.766-12.102c1.008-24.977-17.057-47.147-42.337-50.727c-25.276-3.58-48.789,12.7-54.752,36.975\n		c-0.43,1.921-1.008,4.169-1.706,6.664c-27.36,10.77-48.889,34.265-56.26,64.216C45.199,203.069,2.923,315.149,2.923,315.149\n		l0.733,0.095c-1.056,4.098-1.917,8.291-2.523,12.572c-8.765,61.872,34.296,119.143,96.168,127.905\n		c61.872,8.761,119.14-34.296,127.901-96.168c0.606-4.289,0.94-8.546,1.064-12.779l0.733,0.112c0,0,0.195-3.029,0.538-8.267h56.922\n		c0.343,5.238,0.538,8.267,0.538,8.267l0.734-0.112c0.124,4.233,0.458,8.49,1.064,12.779\n		c8.762,61.872,66.029,104.929,127.901,96.168C476.576,446.96,519.629,389.688,510.868,327.816z M187.861,354.268\n		c-5.848,41.24-44.022,69.955-85.274,64.112c-41.248-5.844-69.952-44.031-64.108-85.27c5.84-41.248,44.018-69.956,85.266-64.113\n		C164.996,274.842,193.7,313.012,187.861,354.268z M409.41,418.38c-41.252,5.843-79.426-22.872-85.274-64.112\n		c-5.839-41.256,22.864-79.426,64.116-85.271c41.252-5.843,79.426,22.864,85.267,64.113\n		C479.362,374.35,450.658,412.537,409.41,418.38z");
      attr(svg, "height", ctx[2]);
      attr(svg, "width", ctx[1]);
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      attr(svg, "viewBox", "0 0 512 512");
      attr(svg, "xml:space", "preserve");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        set_style(path, "fill", ctx2[0]);
      }
      if (dirty & 4) {
        attr(svg, "height", ctx2[2]);
      }
      if (dirty & 2) {
        attr(svg, "width", ctx2[1]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let { stroke = "#000000" } = $$props;
  let { width = "100px" } = $$props;
  let { height = "100px" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("stroke" in $$props2)
      $$invalidate(0, stroke = $$props2.stroke);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
  };
  return [stroke, width, height];
}
class Binoculars extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$9, safe_not_equal, { stroke: 0, width: 1, height: 2 });
  }
}
function create_fragment$8(ctx) {
  let svg;
  let g2;
  let path0;
  let g1;
  let path1;
  let path2;
  let g0;
  let path3;
  let path4;
  return {
    c() {
      svg = svg_element("svg");
      g2 = svg_element("g");
      path0 = svg_element("path");
      g1 = svg_element("g");
      path1 = svg_element("path");
      path2 = svg_element("path");
      g0 = svg_element("g");
      path3 = svg_element("path");
      path4 = svg_element("path");
      attr(path0, "fill", ctx[1]);
      attr(path0, "d", "M39.2137929,26 C43.4929916,26 46.7023907,26 48.84199,26 C49.54377,26 50.59644,26 52,26 C54.209139,26 56,27.790861 56,30 L56,52 C56,54.209139 54.209139,56 52,56 L4,56 C1.790861,56 2.705415e-16,54.209139 0,52 L0,30 C-2.705415e-16,27.790861 1.790861,26 4,26 L16.8281579,26");
      attr(path1, "d", "M0,2.57571742e-14 L12,12");
      attr(path1, "transform", "rotate(-90 6 6)");
      attr(path2, "d", "M12,2 L12,40");
      attr(path3, "d", "M0,2.57571742e-14 L12,12");
      attr(path3, "transform", "rotate(-90 6 6)");
      attr(path4, "d", "M12,2 L12,40");
      attr(g0, "transform", "rotate(180 16 24)");
      attr(g1, "transform", "translate(12)");
      attr(g2, "fill", "none");
      attr(g2, "stroke", ctx[0]);
      attr(g2, "stroke-linecap", "round");
      attr(g2, "stroke-linejoin", "round");
      attr(g2, "stroke-width", ctx[4]);
      attr(g2, "transform", "translate(20 12)");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", ctx[2]);
      attr(svg, "height", ctx[3]);
      attr(svg, "viewBox", "0 0 96 80");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g2);
      append(g2, path0);
      append(g2, g1);
      append(g1, path1);
      append(g1, path2);
      append(g1, g0);
      append(g0, path3);
      append(g0, path4);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        attr(path0, "fill", ctx2[1]);
      }
      if (dirty & 1) {
        attr(g2, "stroke", ctx2[0]);
      }
      if (dirty & 16) {
        attr(g2, "stroke-width", ctx2[4]);
      }
      if (dirty & 4) {
        attr(svg, "width", ctx2[2]);
      }
      if (dirty & 8) {
        attr(svg, "height", ctx2[3]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let { stroke = "#000" } = $$props;
  let { fill = "#FFF" } = $$props;
  let { width = "96px" } = $$props;
  let { height = "80px" } = $$props;
  let { strokeWidth = "4" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("stroke" in $$props2)
      $$invalidate(0, stroke = $$props2.stroke);
    if ("fill" in $$props2)
      $$invalidate(1, fill = $$props2.fill);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(3, height = $$props2.height);
    if ("strokeWidth" in $$props2)
      $$invalidate(4, strokeWidth = $$props2.strokeWidth);
  };
  return [stroke, fill, width, height, strokeWidth];
}
class ImportExport extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$8, safe_not_equal, {
      stroke: 0,
      fill: 1,
      width: 2,
      height: 3,
      strokeWidth: 4
    });
  }
}
function create_fragment$7(ctx) {
  let svg;
  let path;
  let rect;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      rect = svg_element("rect");
      attr(path, "d", "M30,12V4H22V7H18a2.0023,2.0023,0,0,0-2,2v6H10V12H2v8h8V17h6v6a2.0023,2.0023,0,0,0,2,2h4v3h8V20H22v3H18V9h4v3ZM8,18H4V14H8Zm16,4h4v4H24ZM24,6h4v4H24Z");
      attr(rect, "id", "_Transparent_Rectangle_");
      attr(rect, "data-name", "<Transparent Rectangle>");
      attr(rect, "fill", "none");
      attr(rect, "width", "32");
      attr(rect, "height", "32");
      attr(svg, "fill", ctx[0]);
      attr(svg, "width", ctx[1]);
      attr(svg, "height", ctx[2]);
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(svg, rect);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        attr(svg, "fill", ctx2[0]);
      }
      if (dirty & 2) {
        attr(svg, "width", ctx2[1]);
      }
      if (dirty & 4) {
        attr(svg, "height", ctx2[2]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { fill = "#000000" } = $$props;
  let { width = "800px" } = $$props;
  let { height = "800px" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("fill" in $$props2)
      $$invalidate(0, fill = $$props2.fill);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
  };
  return [fill, width, height];
}
class DecisionTree extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$7, safe_not_equal, { fill: 0, width: 1, height: 2 });
  }
}
function create_fragment$6(ctx) {
  let svg;
  let g;
  let rect0;
  let rect1;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      g = svg_element("g");
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      path = svg_element("path");
      attr(rect0, "width", "60");
      attr(rect0, "height", "21.145");
      attr(rect0, "rx", "3.333");
      attr(rect1, "width", "46.667");
      attr(rect1, "height", "21.145");
      attr(rect1, "rx", "3.333");
      attr(rect1, "transform", "translate(0 27.912)");
      attr(path, "d", "M47.0109651,32.0672615 L52.7955713,45.8466089 L44.8044967,49.201283 L38.7674853,34.8206881 L30.8333333,42.765209 L30.8333333,3.48621462 L58.4256192,32.0672615 L47.0109651,32.0672615 Z");
      attr(g, "fill", ctx[1]);
      attr(g, "stroke", ctx[0]);
      attr(g, "stroke-linecap", "square");
      attr(g, "stroke-linejoin", "round");
      attr(g, "stroke-width", ctx[4]);
      attr(g, "transform", "translate(18 15)");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", ctx[2]);
      attr(svg, "height", ctx[3]);
      attr(svg, "viewBox", "0 0 96 80");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g);
      append(g, rect0);
      append(g, rect1);
      append(g, path);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        attr(g, "fill", ctx2[1]);
      }
      if (dirty & 1) {
        attr(g, "stroke", ctx2[0]);
      }
      if (dirty & 16) {
        attr(g, "stroke-width", ctx2[4]);
      }
      if (dirty & 4) {
        attr(svg, "width", ctx2[2]);
      }
      if (dirty & 8) {
        attr(svg, "height", ctx2[3]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let { stroke = "#000" } = $$props;
  let { fill = "#FFF" } = $$props;
  let { width = "96px" } = $$props;
  let { height = "80px" } = $$props;
  let { strokeWidth = "3.33px" } = $$props;
  $$self.$$set = ($$props2) => {
    if ("stroke" in $$props2)
      $$invalidate(0, stroke = $$props2.stroke);
    if ("fill" in $$props2)
      $$invalidate(1, fill = $$props2.fill);
    if ("width" in $$props2)
      $$invalidate(2, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(3, height = $$props2.height);
    if ("strokeWidth" in $$props2)
      $$invalidate(4, strokeWidth = $$props2.strokeWidth);
  };
  return [stroke, fill, width, height, strokeWidth];
}
class Macros extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$6, safe_not_equal, {
      stroke: 0,
      fill: 1,
      width: 2,
      height: 3,
      strokeWidth: 4
    });
  }
}
function create_title_slot(ctx) {
  let t_value = TXT("m_onboarding_whats_next_title") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$2(ctx) {
  let div2;
  let div0;
  let raw_value = TXT("m_onboarding_whats_next_info_1") + "";
  let t0;
  let div1;
  let t2;
  let div12;
  let t3_value = TXT("m_onboarding_whats_next_info_2") + "";
  let t3;
  let t4;
  let div11;
  let div4;
  let a2;
  let importexport;
  let t5;
  let div3;
  let h50;
  let t7;
  let span0;
  let t9;
  let div6;
  let a3;
  let decisiontree;
  let t10;
  let div5;
  let h51;
  let t12;
  let span1;
  let t14;
  let div8;
  let a4;
  let macros;
  let t15;
  let div7;
  let h52;
  let t17;
  let span2;
  let t19;
  let div10;
  let a5;
  let binoculars;
  let t20;
  let div9;
  let h53;
  let t22;
  let span3;
  let current;
  importexport = new ImportExport({
    props: {
      width: "64px",
      height: "60px",
      stroke: color,
      strokeWidth: "4.5px"
    }
  });
  decisiontree = new DecisionTree({
    props: {
      width: "64px",
      height: "60px",
      fill: color
    }
  });
  macros = new Macros({
    props: {
      width: "64px",
      height: "60px",
      stroke: color,
      strokeWidth: "4px"
    }
  });
  binoculars = new Binoculars({
    props: {
      width: "64px",
      height: "60px",
      stroke: color
    }
  });
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<a target="_blank" href="https://apps.apple.com/us/app/distill-web-monitor/id1118660791?ls=1"><img src="./img/icon-ios.svg"/></a> 

        <a target="_blank" href="https://play.google.com/store/apps/details?id=com.neemb.distill&amp;utm_source=webApp&amp;utm_campaign=onboarding"><img src="./img/icon-playstore.svg"/></a>`;
      t2 = space();
      div12 = element("div");
      t3 = text(t3_value);
      t4 = space();
      div11 = element("div");
      div4 = element("div");
      a2 = element("a");
      create_component(importexport.$$.fragment);
      t5 = space();
      div3 = element("div");
      h50 = element("h5");
      h50.textContent = `${TXT("l_import_export")}`;
      t7 = space();
      span0 = element("span");
      span0.textContent = `${TXT("m_import_export_info")}`;
      t9 = space();
      div6 = element("div");
      a3 = element("a");
      create_component(decisiontree.$$.fragment);
      t10 = space();
      div5 = element("div");
      h51 = element("h5");
      h51.textContent = `${TXT("l_conditions")}`;
      t12 = space();
      span1 = element("span");
      span1.textContent = `${TXT("m_conditions_info")}`;
      t14 = space();
      div8 = element("div");
      a4 = element("a");
      create_component(macros.$$.fragment);
      t15 = space();
      div7 = element("div");
      h52 = element("h5");
      h52.textContent = `${TXT("l_macros")}`;
      t17 = space();
      span2 = element("span");
      span2.textContent = `${TXT("m_macros_info")}`;
      t19 = space();
      div10 = element("div");
      a5 = element("a");
      create_component(binoculars.$$.fragment);
      t20 = space();
      div9 = element("div");
      h53 = element("h5");
      h53.textContent = `${TXT("l_watchlist")}`;
      t22 = space();
      span3 = element("span");
      span3.textContent = `${TXT("m_watchlist_info")}`;
      attr(div1, "class", "d-flex pt-4 pb-2 justify-content-center gap-10");
      attr(div2, "class", "fs-5");
      attr(span0, "class", "text-center");
      attr(div3, "class", "d-flex flex-col align-items-center");
      attr(a2, "href", "https://distill.io/docs/web-monitor/how-export-and-import-monitors/");
      attr(a2, "target", "_blank");
      attr(a2, "class", "d-flex flex-col align-items-center text-decoration-none text-black");
      attr(div4, "class", "flex-fill");
      attr(span1, "class", "text-center");
      attr(div5, "class", "d-flex flex-col align-items-center");
      attr(a3, "href", "https://distill.io/docs/web-monitor/using-conditions-to-get-alert-on-important-changes/");
      attr(a3, "target", "_blank");
      attr(a3, "class", "d-flex flex-col align-items-center text-decoration-none text-black");
      attr(div6, "class", "flex-fill");
      attr(span2, "class", "text-center");
      attr(div7, "class", "d-flex flex-col align-items-center");
      attr(a4, "href", "https://distill.io/docs/web-monitor/macro-to-record-replay-actions/");
      attr(a4, "target", "_blank");
      attr(a4, "class", "d-flex flex-col align-items-center text-decoration-none text-black");
      attr(div8, "class", "flex-fill");
      attr(span3, "class", "text-center");
      attr(div9, "class", "d-flex flex-col align-items-center");
      attr(a5, "href", "https://distill.io/docs/web-monitor/what-is-watchlist/");
      attr(a5, "target", "_blank");
      attr(a5, "class", "d-flex flex-col align-items-center text-decoration-none text-black");
      attr(div10, "class", "flex-fill");
      attr(div11, "class", "d-flex gap-8 mt-4 mb-10");
      set_style(div11, "--bs-gutter-y", "10px");
      attr(div12, "class", "fs-5");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      div0.innerHTML = raw_value;
      append(div2, t0);
      append(div2, div1);
      insert(target, t2, anchor);
      insert(target, div12, anchor);
      append(div12, t3);
      append(div12, t4);
      append(div12, div11);
      append(div11, div4);
      append(div4, a2);
      mount_component(importexport, a2, null);
      append(a2, t5);
      append(a2, div3);
      append(div3, h50);
      append(div3, t7);
      append(div3, span0);
      append(div11, t9);
      append(div11, div6);
      append(div6, a3);
      mount_component(decisiontree, a3, null);
      append(a3, t10);
      append(a3, div5);
      append(div5, h51);
      append(div5, t12);
      append(div5, span1);
      append(div11, t14);
      append(div11, div8);
      append(div8, a4);
      mount_component(macros, a4, null);
      append(a4, t15);
      append(a4, div7);
      append(div7, h52);
      append(div7, t17);
      append(div7, span2);
      append(div11, t19);
      append(div11, div10);
      append(div10, a5);
      mount_component(binoculars, a5, null);
      append(a5, t20);
      append(a5, div9);
      append(div9, h53);
      append(div9, t22);
      append(div9, span3);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(importexport.$$.fragment, local);
      transition_in(decisiontree.$$.fragment, local);
      transition_in(macros.$$.fragment, local);
      transition_in(binoculars.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(importexport.$$.fragment, local);
      transition_out(decisiontree.$$.fragment, local);
      transition_out(macros.$$.fragment, local);
      transition_out(binoculars.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div12);
      destroy_component(importexport);
      destroy_component(decisiontree);
      destroy_component(macros);
      destroy_component(binoculars);
    }
  };
}
function create_fragment$5(ctx) {
  let onboardingpagelayout;
  let current;
  onboardingpagelayout = new OnboardingPageLayout({
    props: {
      class: "d-flex flex-col",
      style: "gap:4rem;",
      $$slots: {
        default: [create_default_slot$2],
        title: [create_title_slot]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(onboardingpagelayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(onboardingpagelayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const onboardingpagelayout_changes = {};
      if (dirty & 1) {
        onboardingpagelayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      onboardingpagelayout.$set(onboardingpagelayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(onboardingpagelayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(onboardingpagelayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(onboardingpagelayout, detaching);
    }
  };
}
let color = "#495057";
class WhatsNext extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$5, safe_not_equal, {});
  }
}
const STAGE_IDS = {
  LOGIN_STAGE_ID: "0",
  WELCOME_STAGE_ID: "1",
  LINKS_STAGE_ID: "2",
  CREATE_MONITOR_STAGE_ID: "3",
  FREE_TRIAL_STAGE_ID: "4",
  WHATS_NEXT_STAGE_ID: "5"
};
let hideFreeTrialStage;
let stages;
async function checkEligibility() {
  try {
    await Api.api("/subscriptions/freetrial/eligibility");
  } catch (e) {
    hideFreeTrialStage = true;
  }
}
async function setStages() {
  await checkEligibility();
  stages = {
    [STAGE_IDS.LOGIN_STAGE_ID]: {
      path: "login",
      component: Login,
      next: () => STAGE_IDS.WELCOME_STAGE_ID
    },
    [STAGE_IDS.WELCOME_STAGE_ID]: {
      path: "",
      component: Welcome,
      next: ({ local }) => {
        if (local) {
          return STAGE_IDS.CREATE_MONITOR_STAGE_ID;
        } else {
          return STAGE_IDS.LINKS_STAGE_ID;
        }
      }
    },
    [STAGE_IDS.LINKS_STAGE_ID]: {
      path: "links",
      component: Links,
      next: ({ local }) => {
        if (local) {
          return STAGE_IDS.FREE_TRIAL_STAGE_ID;
        } else {
          return STAGE_IDS.CREATE_MONITOR_STAGE_ID;
        }
      }
    },
    [STAGE_IDS.CREATE_MONITOR_STAGE_ID]: {
      path: "create-monitor",
      component: CreateFirstMonitor,
      next: ({ local }) => {
        if (local) {
          return STAGE_IDS.LINKS_STAGE_ID;
        } else {
          return STAGE_IDS.FREE_TRIAL_STAGE_ID;
        }
      }
    },
    [STAGE_IDS.FREE_TRIAL_STAGE_ID]: {
      path: "free-trial",
      component: FreeTrial,
      next: () => STAGE_IDS.WHATS_NEXT_STAGE_ID,
      skip: hideFreeTrialStage
    },
    [STAGE_IDS.WHATS_NEXT_STAGE_ID]: {
      path: "whats-next",
      component: WhatsNext,
      nextLabel: "l_done",
      next: () => {
        return;
      },
      finalStage: true,
      hideSkip: true
    }
  };
}
class PageController {
  constructor({ user: userModel, initPageId, context = {} }) {
    var _a, _b, _c, _d, _e;
    this.userModel = userModel;
    this.user = get_store_value(this.userModel);
    this.initPageId = initPageId || this.getFirstStage();
    this.stages = stages;
    this.currentStageId = this.initPageId;
    this.context = context;
    this.skipped = (_b = (_a = this.user.meta) == null ? void 0 : _a.onboarding) == null ? void 0 : _b.skipped;
    this.createStore();
    if ((_c = this.user.meta) == null ? void 0 : _c.onboarding) {
      this.goToStage((_e = (_d = this.user) == null ? void 0 : _d.meta) == null ? void 0 : _e.onboarding.currentStageId);
    }
  }
  createStore() {
    const store2 = writable({ currentStageId: this.currentStageId, prevStages: [] });
    Object.assign(this, store2);
  }
  getFirstStage() {
    if (this.userModel.isLoggedIn()) {
      this.currentStageId = STAGE_IDS.WELCOME_STAGE_ID;
    } else {
      this.currentStageId = STAGE_IDS.LOGIN_STAGE_ID;
    }
    return this.currentStageId;
  }
  goToStage(stageId) {
    while (this.currentStageId < stageId) {
      this.next();
    }
  }
  next(additionalOpts) {
    var _a;
    let nextStageId;
    do {
      this.pushStage();
      nextStageId = this.stages[this.currentStageId].next({ ...this.context, ...additionalOpts });
      this.setStage(nextStageId);
    } while ((_a = this.stages[nextStageId]) == null ? void 0 : _a.skip);
    return nextStageId;
  }
  prev() {
    var _a;
    let prevStage;
    do {
      prevStage = this.popStage();
    } while ((_a = this.stages[this.currentStageId]) == null ? void 0 : _a.skip);
    return prevStage;
  }
  setStage(stageId) {
    this.update((state) => {
      this.currentStageId = stageId;
      return { ...state, currentStageId: stageId };
    });
  }
  pushStage(stageId = this.currentStageId) {
    this.update((state) => {
      return { ...state, prevStages: [...state.prevStages, stageId] };
    });
  }
  popStage() {
    const { prevStages } = get_store_value(this);
    let lastStage = prevStages.pop();
    this.currentStageId = lastStage;
    this.update(() => ({ currentStageId: lastStage, prevStages }));
    return lastStage;
  }
  addToContext(ctx) {
    this.context = { ...this.context, ...ctx };
  }
}
const get_next_slot_changes = (dirty) => ({});
const get_next_slot_context = (ctx) => ({});
const get_additional_slot_changes = (dirty) => ({});
const get_additional_slot_context = (ctx) => ({});
const get_postPrev_slot_changes = (dirty) => ({});
const get_postPrev_slot_context = (ctx) => ({});
const get_prev_slot_changes = (dirty) => ({});
const get_prev_slot_context = (ctx) => ({});
function create_if_block_2(ctx) {
  let div;
  let t;
  let current;
  const prev_slot_template = ctx[9].prev;
  const prev_slot = create_slot(prev_slot_template, ctx, ctx[8], get_prev_slot_context);
  const prev_slot_or_fallback = prev_slot || fallback_block_1(ctx);
  const postPrev_slot_template = ctx[9].postPrev;
  const postPrev_slot = create_slot(postPrev_slot_template, ctx, ctx[8], get_postPrev_slot_context);
  return {
    c() {
      div = element("div");
      if (prev_slot_or_fallback)
        prev_slot_or_fallback.c();
      t = space();
      if (postPrev_slot)
        postPrev_slot.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (prev_slot_or_fallback) {
        prev_slot_or_fallback.m(div, null);
      }
      append(div, t);
      if (postPrev_slot) {
        postPrev_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (prev_slot) {
        if (prev_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            prev_slot,
            prev_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(prev_slot_template, ctx2[8], dirty, get_prev_slot_changes),
            get_prev_slot_context
          );
        }
      }
      if (postPrev_slot) {
        if (postPrev_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            postPrev_slot,
            postPrev_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(postPrev_slot_template, ctx2[8], dirty, get_postPrev_slot_changes),
            get_postPrev_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(prev_slot_or_fallback, local);
      transition_in(postPrev_slot, local);
      current = true;
    },
    o(local) {
      transition_out(prev_slot_or_fallback, local);
      transition_out(postPrev_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (prev_slot_or_fallback)
        prev_slot_or_fallback.d(detaching);
      if (postPrev_slot)
        postPrev_slot.d(detaching);
    }
  };
}
function fallback_block_1(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${TXT("a_back")}`;
      attr(button, "class", "btn btn-secondary");
      set_style(button, "min-width", "100px");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[10]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$2(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  const additional_slot_template = ctx[9].additional;
  const additional_slot = create_slot(additional_slot_template, ctx, ctx[8], get_additional_slot_context);
  let if_block = !ctx[2] && create_if_block_1$1(ctx);
  const next_slot_template = ctx[9].next;
  const next_slot = create_slot(next_slot_template, ctx, ctx[8], get_next_slot_context);
  const next_slot_or_fallback = next_slot || fallback_block(ctx);
  return {
    c() {
      div = element("div");
      if (additional_slot)
        additional_slot.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      if (next_slot_or_fallback)
        next_slot_or_fallback.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (additional_slot) {
        additional_slot.m(div, null);
      }
      append(div, t0);
      if (if_block)
        if_block.m(div, null);
      append(div, t1);
      if (next_slot_or_fallback) {
        next_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (additional_slot) {
        if (additional_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            additional_slot,
            additional_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(additional_slot_template, ctx2[8], dirty, get_additional_slot_changes),
            get_additional_slot_context
          );
        }
      }
      if (!ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1(ctx2);
          if_block.c();
          if_block.m(div, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (next_slot) {
        if (next_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            next_slot,
            next_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(next_slot_template, ctx2[8], dirty, get_next_slot_changes),
            get_next_slot_context
          );
        }
      } else {
        if (next_slot_or_fallback && next_slot_or_fallback.p && (!current || dirty & 48)) {
          next_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(additional_slot, local);
      transition_in(next_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(additional_slot, local);
      transition_out(next_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (additional_slot)
        additional_slot.d(detaching);
      if (if_block)
        if_block.d();
      if (next_slot_or_fallback)
        next_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.textContent = `${TXT("a_skip")}`;
      attr(button, "class", "btn btn-secondary");
      set_style(button, "min-width", "100px");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", ctx[11]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_catch_block$2(ctx) {
  return { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };
}
function create_then_block$2(ctx) {
  let t_value = TXT(ctx[4].nextLabel || "a_next") + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t_value !== (t_value = TXT(ctx2[4].nextLabel || "a_next") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_pending_block$2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "spinner-border spinner-border-sm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function fallback_block(ctx) {
  let button;
  let promise;
  let mounted;
  let dispose;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$2,
    then: create_then_block$2,
    catch: create_catch_block$2
  };
  handle_promise(promise = ctx[4].nextPromise, info);
  return {
    c() {
      button = element("button");
      info.block.c();
      attr(button, "class", "nowrap btn btn-primary");
      set_style(button, "min-width", "100px");
      attr(button, "act-action", "next");
      button.disabled = ctx[5];
    },
    m(target, anchor) {
      insert(target, button, anchor);
      info.block.m(button, info.anchor = null);
      info.mount = () => button;
      info.anchor = null;
      if (!mounted) {
        dispose = listen(button, "click", ctx[12]);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 16 && promise !== (promise = ctx[4].nextPromise) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
      if (dirty & 32) {
        button.disabled = ctx[5];
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      info.block.d();
      info.token = null;
      info = null;
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$4(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let current;
  let if_block0 = !ctx[1] && create_if_block_2(ctx);
  let if_block1 = !ctx[0] && create_if_block$2(ctx);
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "flex-1");
      attr(div1, "class", "d-flex");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let $buttonStore, $$unsubscribe_buttonStore = noop$1, $$subscribe_buttonStore = () => ($$unsubscribe_buttonStore(), $$unsubscribe_buttonStore = subscribe(buttonStore, ($$value) => $$invalidate(4, $buttonStore = $$value)), buttonStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_buttonStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  let { hideNext } = $$props;
  let { hidePrev } = $$props;
  let { hideSkip } = $$props;
  let { buttonStore } = $$props;
  $$subscribe_buttonStore();
  const dispatch = createEventDispatcher();
  let disableNext;
  function clearPromise() {
    set_store_value(buttonStore, $buttonStore.nextPromise = Promise.resolve(), $buttonStore);
  }
  const click_handler = () => {
    clearPromise();
    dispatch("prev");
  };
  const click_handler_1 = () => dispatch("skip");
  const click_handler_2 = () => dispatch("next");
  $$self.$$set = ($$props2) => {
    if ("hideNext" in $$props2)
      $$invalidate(0, hideNext = $$props2.hideNext);
    if ("hidePrev" in $$props2)
      $$invalidate(1, hidePrev = $$props2.hidePrev);
    if ("hideSkip" in $$props2)
      $$invalidate(2, hideSkip = $$props2.hideSkip);
    if ("buttonStore" in $$props2)
      $$subscribe_buttonStore($$invalidate(3, buttonStore = $$props2.buttonStore));
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      if ($buttonStore.nextPromise) {
        $$invalidate(5, disableNext = true);
        $buttonStore.nextPromise.then(() => $$invalidate(5, disableNext = false));
      }
    }
  };
  return [
    hideNext,
    hidePrev,
    hideSkip,
    buttonStore,
    $buttonStore,
    disableNext,
    dispatch,
    clearPromise,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class ButtonBar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, {
      hideNext: 0,
      hidePrev: 1,
      hideSkip: 2,
      buttonStore: 3
    });
  }
}
var index_svelte_svelte_type_style_lang = "";
function create_action_slot(ctx) {
  let a;
  let i2;
  let t0;
  let t1_value = (ctx[4].locale ? langs.find(ctx[12]).label : "English (US)") + "";
  let t1;
  let mounted;
  let dispose;
  return {
    c() {
      a = element("a");
      i2 = element("i");
      t0 = space();
      t1 = text(t1_value);
      attr(i2, "class", "fa fa-language");
      attr(i2, "aria-hidden", "true");
      attr(a, "href", "#");
      attr(a, "class", "fs-6 dropdown-toggle");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, i2);
      append(a, t0);
      append(a, t1);
      if (!mounted) {
        dispose = listen(a, "click", prevent_default(function() {
          if (is_function(ctx[21]))
            ctx[21].apply(this, arguments);
        }));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 16 && t1_value !== (t1_value = (ctx[4].locale ? langs.find(ctx[12]).label : "English (US)") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(a);
      mounted = false;
      dispose();
    }
  };
}
function create_catch_block$1(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$1(ctx) {
  let div5;
  let div4;
  let div3;
  let div2;
  let div0;
  let switch_instance;
  let updating_nextPlugin;
  let t;
  let div1;
  let buttonbar;
  let current;
  function switch_instance_nextPlugin_binding(value) {
    ctx[13](value);
  }
  var switch_value = ctx[1].component;
  function switch_props(ctx2) {
    let switch_instance_props = { buttonStore: ctx2[6] };
    if (ctx2[2] !== void 0) {
      switch_instance_props.nextPlugin = ctx2[2];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    binding_callbacks.push(() => bind$1(switch_instance, "nextPlugin", switch_instance_nextPlugin_binding));
    switch_instance.$on("next", ctx[8]);
  }
  buttonbar = new ButtonBar({
    props: {
      buttonStore: ctx[6],
      hidePrev: !ctx[3].prevStages.length,
      hideSkip: ctx[1].hideSkip
    }
  });
  buttonbar.$on("next", ctx[8]);
  buttonbar.$on("prev", ctx[9]);
  buttonbar.$on("skip", ctx[10]);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      div1 = element("div");
      create_component(buttonbar.$$.fragment);
      attr(div0, "class", "flex-1");
      attr(div1, "class", "m-3");
      attr(div2, "class", "d-flex flex-col p-0 card justify-content-space-between");
      set_style(div2, "min-height", ctx[1].minHeight || "500px");
      attr(div3, "class", "col-sm-10 col-xxl-8");
      attr(div4, "class", "row mx-0 h-100 justify-content-center overflow-auto");
      set_style(div4, "margin", "100px 0");
      attr(div5, "class", "onboarding");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div3);
      append(div3, div2);
      append(div2, div0);
      if (switch_instance)
        mount_component(switch_instance, div0, null);
      append(div2, t);
      append(div2, div1);
      mount_component(buttonbar, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (!updating_nextPlugin && dirty & 4) {
        updating_nextPlugin = true;
        switch_instance_changes.nextPlugin = ctx2[2];
        add_flush_callback(() => updating_nextPlugin = false);
      }
      if (dirty & 2 && switch_value !== (switch_value = ctx2[1].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          binding_callbacks.push(() => bind$1(switch_instance, "nextPlugin", switch_instance_nextPlugin_binding));
          switch_instance.$on("next", ctx2[8]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div0, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      const buttonbar_changes = {};
      if (dirty & 8)
        buttonbar_changes.hidePrev = !ctx2[3].prevStages.length;
      if (dirty & 2)
        buttonbar_changes.hideSkip = ctx2[1].hideSkip;
      buttonbar.$set(buttonbar_changes);
      if (!current || dirty & 2) {
        set_style(div2, "min-height", ctx2[1].minHeight || "500px");
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(buttonbar.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(buttonbar.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (switch_instance)
        destroy_component(switch_instance);
      destroy_component(buttonbar);
    }
  };
}
function create_pending_block$1(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_fragment$3(ctx) {
  let t0;
  let div4;
  let div3;
  let div0;
  let t1;
  let div2;
  let localeselector;
  let t2;
  let div1;
  let a0;
  let i2;
  let t3;
  let t4_value = ctx[4].name + "";
  let t4;
  let t5;
  let ul;
  let li;
  let a1;
  let t6;
  let t7;
  let await_block_anchor;
  let current;
  localeselector = new LocaleSelector({
    props: {
      label: "Select Language",
      placement: "bottom-end",
      class: "btn btn-default",
      $$slots: {
        action: [
          create_action_slot,
          ({ onClick }) => ({ 21: onClick }),
          ({ onClick }) => onClick ? 2097152 : 0
        ]
      },
      $$scope: { ctx }
    }
  });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$1,
    then: create_then_block$1,
    catch: create_catch_block$1,
    value: 20,
    blocks: [, , ,]
  };
  handle_promise(ctx[7], info);
  return {
    c() {
      t0 = space();
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<img alt="distill-logo" src="./img/distill_logo.png" style="height:40px;"/>`;
      t1 = space();
      div2 = element("div");
      create_component(localeselector.$$.fragment);
      t2 = space();
      div1 = element("div");
      a0 = element("a");
      i2 = element("i");
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      ul = element("ul");
      li = element("li");
      a1 = element("a");
      t6 = text("Sign Out");
      t7 = space();
      await_block_anchor = empty();
      info.block.c();
      document.title = "Welcome | Distill.io";
      attr(i2, "class", "fa fa-user");
      attr(a0, "href", "#");
      attr(a0, "data-bs-toggle", "dropdown");
      attr(a0, "class", "text-decoration-none dropdown-toggle");
      attr(a1, "class", "dropdown-item");
      attr(a1, "role", "menuitem");
      attr(a1, "href", urlCfg.logout);
      attr(ul, "class", "dropdown-menu");
      attr(div1, "class", "dropdown d-flex align-items-center");
      attr(div2, "class", "d-flex gap-4");
      attr(div3, "class", "d-flex justify-content-between align-items-center mt-2 px-4 pt-2");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, div0);
      append(div3, t1);
      append(div3, div2);
      mount_component(localeselector, div2, null);
      append(div2, t2);
      append(div2, div1);
      append(div1, a0);
      append(a0, i2);
      append(a0, t3);
      append(a0, t4);
      append(div1, t5);
      append(div1, ul);
      append(ul, li);
      append(li, a1);
      append(a1, t6);
      insert(target, t7, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const localeselector_changes = {};
      if (dirty & 6291472) {
        localeselector_changes.$$scope = { dirty, ctx };
      }
      localeselector.$set(localeselector_changes);
      if ((!current || dirty & 16) && t4_value !== (t4_value = ctx[4].name + ""))
        set_data(t4, t4_value);
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(localeselector.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(localeselector.$$.fragment, local);
      for (let i3 = 0; i3 < 3; i3 += 1) {
        const block = info.blocks[i3];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div4);
      destroy_component(localeselector);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
const homeLink = "/#/w/0/list/all/";
function instance$3($$self, $$props, $$invalidate) {
  let $buttonStore;
  let $pageController, $$unsubscribe_pageController = noop$1, $$subscribe_pageController = () => ($$unsubscribe_pageController(), $$unsubscribe_pageController = subscribe(pageController, ($$value) => $$invalidate(3, $pageController = $$value)), pageController);
  let $user;
  $$self.$$.on_destroy.push(() => $$unsubscribe_pageController());
  let { params: params2 } = $$props;
  const user = getContext("user");
  component_subscribe($$self, user, (value) => $$invalidate(4, $user = value));
  const clientId = getContext("clientId");
  let pageController;
  let stage;
  let nextPlugin;
  let buttonStore = writable({ nextLabel: "a_next", nextPromise: null });
  component_subscribe($$self, buttonStore, (value) => $$invalidate(14, $buttonStore = value));
  let initPromise = set_store_value(buttonStore, $buttonStore.nextPromise = init2(), $buttonStore);
  async function init2() {
    await setStages();
    $$subscribe_pageController($$invalidate(0, pageController = new PageController({
      user,
      context: { local: Supports.agents.local }
    })));
    push$1(`/u/welcome/${stages[$pageController.currentStageId].path}`);
    set_store_value(buttonStore, $buttonStore.nextPromise = initMeta(), $buttonStore);
  }
  async function initMeta() {
    if (!$user.meta.onboarding) {
      await updateUserMeta({
        skipped: false,
        completed: false,
        initClientId: clientId,
        currentClientId: clientId,
        tsStart: new Date(),
        tsEnd: null
      });
    } else if ($user.meta.onboarding.currentClientId !== clientId) {
      updateUserMeta({ currentClientId: clientId });
    }
  }
  async function onNext() {
    if (nextPlugin && await nextPlugin() === false) {
      return;
    }
    $$invalidate(2, nextPlugin = null);
    pageController.next();
    const currentStageId = $pageController.currentStageId;
    if (currentStageId) {
      updateUserMeta({ currentStageId });
      push$1(`/u/welcome/${stages[currentStageId].path}`);
    } else {
      trackEvent(PHEvents.ONBOARDING_COMPLETED);
      updateUserMeta({ completed: true, tsEnd: new Date() });
      location.href = homeLink;
    }
  }
  async function onPrev() {
    pageController.prev();
    push$1(`/u/welcome/${stages[$pageController.currentStageId].path}`);
    updateUserMeta({
      currentStageId: $pageController.currentStageId
    });
  }
  async function onSkip() {
    trackEvent(PHEvents.ONBOARDING_SKIP);
    updateUserMeta({ skipped: true });
    location.href = homeLink;
  }
  async function updateUserMeta(data) {
    await Api.api("/users/meta/onboarding", "PUT", data);
  }
  function updateStage() {
    let nextStage = stages[$pageController.currentStageId];
    if (nextStage) {
      $$invalidate(1, stage = nextStage);
      set_store_value(buttonStore, $buttonStore.nextLabel = stage.nextLabel, $buttonStore);
    }
  }
  const func2 = (lang) => lang.locale === $user.locale;
  function switch_instance_nextPlugin_binding(value) {
    nextPlugin = value;
    $$invalidate(2, nextPlugin);
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(11, params2 = $$props2.params);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2048) {
      params2 == null ? void 0 : params2.stage, (async () => {
        await initPromise;
        updateStage();
      })();
    }
  };
  return [
    pageController,
    stage,
    nextPlugin,
    $pageController,
    $user,
    user,
    buttonStore,
    initPromise,
    onNext,
    onPrev,
    onSkip,
    params2,
    func2,
    switch_instance_nextPlugin_binding
  ];
}
class Onboarding extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, { params: 11 });
  }
}
function create_if_block$1(ctx) {
  let await_block_anchor;
  let promise;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 4,
    blocks: [, , ,]
  };
  handle_promise(promise = ctx[0], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 1 && promise !== (promise = ctx[0]) && handle_promise(promise, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < 3; i2 += 1) {
        const block = info.blocks[i2];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block(ctx) {
  let a;
  let h3;
  let t2;
  let sievedatalist;
  let current;
  sievedatalist = new SieveDataList({ props: { sieve: ctx[1] } });
  return {
    c() {
      a = element("a");
      h3 = element("h3");
      h3.textContent = `${ctx[1].get("name")} | Monitor`;
      t2 = space();
      create_component(sievedatalist.$$.fragment);
      attr(h3, "class", "ph3");
      attr(a, "href", urlCfg.sievePage(ctx[1].id));
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, h3);
      insert(target, t2, anchor);
      mount_component(sievedatalist, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(sievedatalist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(sievedatalist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a);
      if (detaching)
        detach(t2);
      destroy_component(sievedatalist, detaching);
    }
  };
}
function create_pending_block(ctx) {
  let loader;
  let current;
  loader = new Loader({});
  return {
    c() {
      create_component(loader.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loader, detaching);
    }
  };
}
function create_default_slot$1(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block$1(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$2(ctx) {
  let watchlistlayout;
  let current;
  watchlistlayout = new WatchListLayout({
    props: {
      renderDefaultToolbar: true,
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(watchlistlayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(watchlistlayout, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const watchlistlayout_changes = {};
      if (dirty & 33) {
        watchlistlayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      watchlistlayout.$set(watchlistlayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(watchlistlayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(watchlistlayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(watchlistlayout, detaching);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let { params: params2 } = $$props;
  let { sieveId = params2 == null ? void 0 : params2.id } = $$props;
  let sieve = new Model$2.Sieve({ id: sieveId });
  let sieveFetchPromise = null;
  if (sieveId) {
    sieveFetchPromise = sieve.fetch();
  }
  $$self.$$set = ($$props2) => {
    if ("params" in $$props2)
      $$invalidate(2, params2 = $$props2.params);
    if ("sieveId" in $$props2)
      $$invalidate(3, sieveId = $$props2.sieveId);
  };
  return [sieveFetchPromise, sieve, params2, sieveId];
}
class SieveDetail extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, { params: 2, sieveId: 3 });
  }
}
function prepareRoutes(overrides) {
  return {
    "/admin/:module/": Admin,
    "/teams/": Teams,
    "/teams/:id": Team,
    "/u/:team/usage/:module/": Usage_1,
    "/u/welcome/:stage?": Onboarding,
    "/u/:team/sieve/:sieveId/data/:dataId/diff": Explore_diff,
    "/u/:team/crawlers/": Crawlers_1,
    "/u/:team/crawlers/:id": Crawler_detail,
    "/u/:team/crawlers/:id/edit": Crawler_editor,
    "/u/:team/crawlers/:id/:jobId": Job_detail,
    "/u/:team/sieve/:id/detail": SieveDetail,
    "/checks/:team/:sieveID": Works,
    "/w/:team/:module/": Watchlist,
    "/w/:team/:module/:prefix/*": Watchlist,
    "/u/:team/form/:formId": Forms,
    ...overrides,
    "*": Error404
  };
}
function prepareRedirects(overrides = {}) {
  const redirects = {
    "": () => {
      return `#/w/0/list/all/`;
    },
    "inbox": () => {
      return `#/w/0/list/all/`;
    },
    "/w/:team/sieve/detail/:sieveId.id": ({ team, sieveId }) => {
      return `#/u/${team}/sieve/${sieveId}/detail`;
    },
    ...overrides
  };
  const handlers = {};
  const rp = Object.keys(redirects).map((u) => {
    const rp2 = parse$2(u);
    handlers[rp2.pattern.source] = redirects[u];
    return rp2;
  });
  return ({ location: location2 }) => {
    let hash = (location2.hash || "").replace("#", "");
    if (!hash.startsWith("/")) {
      hash = "/" + hash;
    }
    for (let i2 = 0; i2 < rp.length; i2++) {
      if (rp[i2].pattern.test(hash)) {
        const paramsKV = exec(hash, rp[i2]);
        return handlers[rp[i2].pattern.source](paramsKV);
      }
    }
    return null;
  };
}
function exec(path, result2) {
  let i2 = 0, out = {};
  let matches = result2.pattern.exec(path);
  while (i2 < result2.keys.length) {
    out[result2.keys[i2]] = matches[++i2] || null;
  }
  return out;
}
function create_else_block(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1(ctx) {
  let router;
  let current;
  router = new Router({ props: { routes: ctx[1] } });
  router.$on("routeLoaded", ctx[5]);
  return {
    c() {
      create_component(router.$$.fragment);
    },
    m(target, anchor) {
      mount_component(router, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const router_changes = {};
      if (dirty & 2)
        router_changes.routes = ctx2[1];
      router.$set(router_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(router.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(router.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(router, detaching);
    }
  };
}
function create_if_block(ctx) {
  let savemodal;
  let current;
  savemodal = new SaveModal({
    props: {
      title: TXT("l_feedback_form"),
      onSave: ctx[7],
      saveLabel: "Submit",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  savemodal.$on("close", ctx[8]);
  return {
    c() {
      create_component(savemodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(savemodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const savemodal_changes = {};
      if (dirty & 28)
        savemodal_changes.onSave = ctx2[7];
      if (dirty & 1032) {
        savemodal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      savemodal.$set(savemodal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(savemodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(savemodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(savemodal, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let formgroup;
  let updating_model;
  let current;
  function formgroup_model_binding(value) {
    ctx[6](value);
  }
  let formgroup_props = { id: C$1.FORM_APP_FEEDBACK };
  if (ctx[3] !== void 0) {
    formgroup_props.model = ctx[3];
  }
  formgroup = new FormGroup({ props: formgroup_props });
  binding_callbacks.push(() => bind$1(formgroup, "model", formgroup_model_binding));
  return {
    c() {
      create_component(formgroup.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formgroup, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formgroup_changes = {};
      if (!updating_model && dirty & 8) {
        updating_model = true;
        formgroup_changes.model = ctx2[3];
        add_flush_callback(() => updating_model = false);
      }
      formgroup.$set(formgroup_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formgroup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formgroup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formgroup, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let message;
  let t0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let t2;
  let button;
  let current;
  let mounted;
  let dispose;
  message = new Message({});
  const if_block_creators = [create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[2] && create_if_block(ctx);
  return {
    c() {
      create_component(message.$$.fragment);
      t0 = space();
      if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      button = element("button");
      button.textContent = "Give Feedback";
      attr(button, "class", "btn btn-default xbtn-feedback xbtn-default");
    },
    m(target, anchor) {
      mount_component(message, target, anchor);
      insert(target, t0, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t2, anchor);
      insert(target, button, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t1.parentNode, t1);
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(message.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(message.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(message, detaching);
      if (detaching)
        detach(t0);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t1);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function preventDefault(e) {
  if (e.target.tagName == "A" && e.target.getAttribute("href") == "#") {
    let url = new URL(e.target.href);
    if (url.hash === "") {
      e.preventDefault();
    }
  }
}
function instance$1($$self, $$props, $$invalidate) {
  let $location;
  component_subscribe($$self, location$1, ($$value) => $$invalidate(4, $location = $$value));
  let { loaded } = $$props;
  let { routes } = $$props;
  let showFeedbackModal = false;
  let feedbackModel;
  function routeLoaded(event) {
    var _a, _b, _c, _d;
    const team = (_c = (_b = (_a = event.detail) == null ? void 0 : _a.params) == null ? void 0 : _b.team) != null ? _c : "0";
    const routeName = (_d = event.detail) == null ? void 0 : _d.route;
    updateTeam(team);
    updateRoute(routeName);
    Msg.reset();
  }
  document.addEventListener("click", (e) => {
    preventDefault(e);
    const element2 = e.target.closest("[ph-event]");
    if (element2 && element2.hasAttribute("ph-event")) {
      let eventName = element2.getAttribute("ph-event");
      let eventCategory = element2.getAttribute("ph-event-category");
      let properties = {};
      for (let i2 = 0; i2 < element2.attributes.length; i2++) {
        let attr2 = element2.attributes[i2];
        if (attr2.name.startsWith("data-ph-")) {
          let key = attr2.name.replace("data-ph-", "");
          if (!key) {
            continue;
          }
          properties[key] = attr2.value;
        }
      }
      trackEvent(eventName, properties, eventCategory);
    }
  });
  function formgroup_model_binding(value) {
    feedbackModel = value;
    $$invalidate(3, feedbackModel);
  }
  const func2 = () => {
    let doc = { location: $location };
    feedbackModel.submit(doc);
    $$invalidate(2, showFeedbackModal = false);
  };
  const close_handler = () => {
    $$invalidate(2, showFeedbackModal = false);
  };
  const click_handler = () => {
    $$invalidate(2, showFeedbackModal = true);
  };
  $$self.$$set = ($$props2) => {
    if ("loaded" in $$props2)
      $$invalidate(0, loaded = $$props2.loaded);
    if ("routes" in $$props2)
      $$invalidate(1, routes = $$props2.routes);
  };
  return [
    loaded,
    routes,
    showFeedbackModal,
    feedbackModel,
    $location,
    routeLoaded,
    formgroup_model_binding,
    func2,
    close_handler,
    click_handler
  ];
}
class AppCommon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { loaded: 0, routes: 1 });
  }
}
function create_fragment(ctx) {
  let appcommon;
  let current;
  appcommon = new AppCommon({
    props: {
      loaded: ctx[1],
      routes: ctx[2]
    }
  });
  return {
    c() {
      create_component(appcommon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(appcommon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const appcommon_changes = {};
      if (dirty & 2)
        appcommon_changes.loaded = ctx2[1];
      appcommon.$set(appcommon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(appcommon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(appcommon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(appcommon, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $user, $$unsubscribe_user = noop$1, $$subscribe_user = () => ($$unsubscribe_user(), $$unsubscribe_user = subscribe(user, ($$value) => $$invalidate(5, $user = $$value)), user);
  $$self.$$.on_destroy.push(() => $$unsubscribe_user());
  let { labels: labels_1, user: user_1, root: root_1 } = appCommon({ setContext, clientId: serviceProxy.clientId });
  let { labels = labels_1, user = user_1, root: root2 = root_1 } = $$props;
  $$subscribe_user();
  let loaded = false;
  const routes = prepareRoutes({ "/settings/:module/": Index_ext });
  instance$5s.on("users", syncUser);
  onMount(async () => {
    try {
      window.USER = $user;
      await isReady();
      await Promise.all([syncUser()]);
      $$invalidate(1, loaded = true);
    } catch (e) {
      console.error("error while Service init", e);
      Msg.error(`Error while loading the app. ${e.message}. Please try again later or contact support if problem persists`, void 0, e);
    }
  });
  onDestroy(() => {
    instance$5s.off("users", syncUser);
  });
  async function isReady() {
    return new Promise(async (resolve, reject2) => {
      if (await serviceProxy.service.isReady()) {
        if (await serviceProxy.auth.isReady()) {
          resolve(void 0);
        } else {
          location.href = serviceProxy.CFG.URL.LOGIN;
        }
      } else {
        const serviceInfo = await serviceProxy.service.getInfo();
        if (serviceInfo.initError) {
          return reject2(serviceInfo.initError);
        }
        serviceProxy.serviceEvents.on("init", resolve);
        serviceProxy.serviceEvents.on("init:error", reject2);
      }
    });
  }
  async function syncUser() {
    if (await serviceProxy.auth.isLoggedIn()) {
      try {
        await user.fetch();
      } catch (e) {
        let tUser = await serviceProxy.store.UserStore.findOne({ id: await serviceProxy.auth.getId() });
        tUser && user.set(tUser);
      }
    } else {
      user.trigger("sync");
    }
    let locale = $user.locale || await serviceProxy.store.Prefs.get("locale");
    await loadLang(locale || "en-US");
  }
  $$self.$$set = ($$props2) => {
    if ("labels" in $$props2)
      $$invalidate(3, labels = $$props2.labels);
    if ("user" in $$props2)
      $$subscribe_user($$invalidate(0, user = $$props2.user));
    if ("root" in $$props2)
      $$invalidate(4, root2 = $$props2.root);
  };
  return [user, loaded, routes, labels, root2];
}
class AppLocal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { labels: 3, user: 0, root: 4 });
  }
  get labels() {
    return this.$$.ctx[3];
  }
  set labels(labels) {
    this.$$set({ labels });
    flush();
  }
  get user() {
    return this.$$.ctx[0];
  }
  set user(user) {
    this.$$set({ user });
    flush();
  }
  get root() {
    return this.$$.ctx[4];
  }
  set root(root2) {
    this.$$set({ root: root2 });
    flush();
  }
  get navBack() {
    return navBack;
  }
}
var AppLocal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": AppLocal
}, Symbol.toStringTag, { value: "Module" }));
export { AppLocal$1 as A, ConfirmBtn as C, DIFF_TYPE as D, Checkbox as a, generateTree as b, getChanges as c, ChangeType as d, diffTree as e, getDiffObj as g, types as t };
